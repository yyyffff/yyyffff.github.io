

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">

  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/128.png">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="yyf">
  <meta name="keywords" content="">
  
    <meta name="description" content="内存分区模型 代码区：存放二进制代码，由操作系统管理 全局区：存放全局变量、静态变量、全局常量 栈区：编译器自动分配释放，存放函数参数值、局部变量等 堆区：由程序员分配、释放，若不释放，结束时由操作系统回收  意义：赋予不同的生命周期，灵活编程 程序运行前未执行.exe文件前，分为两个区域  代码区：  存放cpu执行的机器指令 特点：共享（频繁被执行的程序只要在内存中有一份代码即可），只读（防止">
<meta property="og:type" content="article">
<meta property="og:title" content="c++语法学习">
<meta property="og:url" content="http://yyyffff.github.io/2025/03/19/c++%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0/index.html">
<meta property="og:site_name" content="yyyffff">
<meta property="og:description" content="内存分区模型 代码区：存放二进制代码，由操作系统管理 全局区：存放全局变量、静态变量、全局常量 栈区：编译器自动分配释放，存放函数参数值、局部变量等 堆区：由程序员分配、释放，若不释放，结束时由操作系统回收  意义：赋予不同的生命周期，灵活编程 程序运行前未执行.exe文件前，分为两个区域  代码区：  存放cpu执行的机器指令 特点：共享（频繁被执行的程序只要在内存中有一份代码即可），只读（防止">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://yyyffff.github.io/2025/01/18/%E5%A4%87%E6%B3%A8/%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0/1744274250663.png">
<meta property="og:image" content="http://yyyffff.github.io/2025/01/18/%E5%A4%87%E6%B3%A8/%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0/1744274955782.png">
<meta property="og:image" content="http://yyyffff.github.io/2025/01/18/%E5%A4%87%E6%B3%A8/%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0/1744607846230.png">
<meta property="og:image" content="http://yyyffff.github.io/2025/01/18/%E5%A4%87%E6%B3%A8/%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0/1745213483114.png">
<meta property="og:image" content="http://yyyffff.github.io/2025/01/18/%E5%A4%87%E6%B3%A8/%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0/1745298210863.png">
<meta property="og:image" content="http://yyyffff.github.io/2025/01/18/%E5%A4%87%E6%B3%A8/%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0/1745412561491.png">
<meta property="og:image" content="http://yyyffff.github.io/2025/01/18/%E5%A4%87%E6%B3%A8/%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0/1745412627477.png">
<meta property="article:published_time" content="2025-03-19T08:22:26.000Z">
<meta property="article:modified_time" content="2025-05-09T07:29:33.901Z">
<meta property="article:author" content="yyf">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://yyyffff.github.io/2025/01/18/%E5%A4%87%E6%B3%A8/%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0/1744274250663.png">
  
  
  
  <title>c++语法学习 - yyyffff</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"yyyffff.github.io","root":"/","version":"1.9.8","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"leancloud":{"app_id":"2bkS2AvQTqNk4TIsyxh4ew9q-gzGzoHsz","app_key":"GfRH0zMaM1USTNT6w25DTqu8","server_url":"https://2bks2avq.lc-cn-n1-shared.com","path":"window.location.pathname","ignore_local":false},"umami":{"src":null,"website_id":null,"domains":null,"start_time":"2024-01-01T00:00:00.000Z","token":null,"api_server":null}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  

  

  

  

  

  
    
  



  
<meta name="generator" content="Hexo 7.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>yyyffff</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="c++语法学习"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2025-03-19 16:22" pubdate>
          2025年3月19日 下午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          10k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          87 分钟
        
      </span>
    

    
    
      
        <span id="leancloud-page-views-container" class="post-meta" style="display: none">
          <i class="iconfont icon-eye" aria-hidden="true"></i>
          <span id="leancloud-page-views"></span> 次
        </span>
        
      
      
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">c++语法学习</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="内存分区模型"><a href="#内存分区模型" class="headerlink" title="内存分区模型"></a>内存分区模型</h1><ul>
<li>代码区：存放二进制代码，由操作系统管理</li>
<li>全局区：存放全局变量、静态变量、全局常量</li>
<li>栈区：<strong>编译器</strong>自动分配释放，存放函数参数值、局部变量等</li>
<li>堆区：由<strong>程序员</strong>分配、释放，若不释放，结束时由操作系统回收</li>
</ul>
<p>意义：赋予不同的生命周期，灵活编程</p>
<h2 id="程序运行前"><a href="#程序运行前" class="headerlink" title="程序运行前"></a>程序运行前</h2><p>未执行.exe文件前，分为两个区域</p>
<ul>
<li><p>代码区：</p>
<ul>
<li>存放cpu执行的机器指令</li>
<li>特点：共享（频繁被执行的程序只要在内存中有一份代码即可），只读（防止程序意外修改了指令）</li>
</ul>
</li>
<li><p>全局区：</p>
<ul>
<li><p>全局变量和静态变量在此</p>
</li>
<li><p>包含常量区，字符串常量和其他常量也存放在此</p>
</li>
<li><p>该区域数据在程序结束后由<strong>操作系统</strong>释放</p>
</li>
<li><p>静态变量：在前面加<code>static</code>，比如<code>static int a=10</code></p>
<p>常量：分为全局的和局部的，但只有全局的常量在常量区，<code>const int a=10</code></p>
</li>
</ul>
</li>
</ul>
<h2 id="程序运行后"><a href="#程序运行后" class="headerlink" title="程序运行后"></a>程序运行后</h2><ul>
<li>栈区<ul>
<li>存放函数的局部变量及参数，编译器自动开辟与free</li>
</ul>
</li>
<li>堆区<ul>
<li>由程序员手动分配与释放，如果程序员不释放的话就由操作系统释放</li>
<li>在c++中用<code>new</code>来分配内存</li>
</ul>
</li>
</ul>
<h2 id="new操作符语法"><a href="#new操作符语法" class="headerlink" title="new操作符语法"></a>new操作符语法</h2><p>分配：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span>* <span class="hljs-title">func</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-type">int</span>* p=<span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">10</span>);<span class="hljs-comment">//在堆中开辟了一块int大小的数据，其中的数据是10，并且new会返回分配的地址</span><br>	<span class="hljs-keyword">return</span> p;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>释放：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-type">int</span> *p=<span class="hljs-built_in">func</span>();<br>	cout&lt;&lt;*p&lt;&lt;endl;<br>	<span class="hljs-keyword">delete</span> p;<br>	cout&lt;&lt;*p&lt;&lt;endl;<span class="hljs-comment">//这句会报错，因为用delete释放了</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>开辟一段连续的数组空间：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span>* <span class="hljs-title">func2</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-type">int</span>* p=<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">10</span>];<span class="hljs-comment">//开辟了int类型的10个空间</span><br>     <span class="hljs-comment">//赋值</span><br>     <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">10</span>;i++)<br>          p[i]=i;<br>     <span class="hljs-comment">//打印</span><br>     <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">10</span>;i++)<br>          cout&lt;&lt;p[i]&lt;&lt;endl;<br>	reuturn p;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>释放数组：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-type">int</span> *p=<span class="hljs-built_in">func2</span>();<br>	<span class="hljs-keyword">delete</span>[] p;<span class="hljs-comment">//记得加中括号</span><br>	reuturn <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><h2 id="基本语法使用"><a href="#基本语法使用" class="headerlink" title="基本语法使用"></a>基本语法使用</h2><ul>
<li><p>作用</p>
<ul>
<li>给变量起别名</li>
</ul>
</li>
<li><p>语法</p>
<ul>
<li><p>数据类型 &amp;别名&#x3D;原名</p>
</li>
<li><p>比如原来有<code>int a=10</code></p>
<p>创建引用<code>int &amp;b=a;</code></p>
</li>
</ul>
</li>
</ul>
<p>操作的是同一块内存</p>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ul>
<li><p>必须初始化</p>
<p><code>int &amp;b</code>错误的</p>
</li>
<li><p>初始化后不可改变引用的对象</p>
</li>
</ul>
<h2 id="引用作为函数参数"><a href="#引用作为函数参数" class="headerlink" title="引用作为函数参数"></a>引用作为函数参数</h2><ul>
<li>作用：<ul>
<li>可以用引用让形式参数修饰实参</li>
<li>可以不用指针，简化思考</li>
</ul>
</li>
</ul>
<p>这里举一个交换两个数的例子</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-type">int</span> &amp;a,<span class="hljs-type">int</span> &amp;b)</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-type">int</span> temp=a;<br>	a=b;<br>	b=temp;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>     <span class="hljs-type">int</span> a=<span class="hljs-number">10</span>,b=<span class="hljs-number">20</span>;<br>     cout&lt;&lt;<span class="hljs-string">&quot;交换前：a=&quot;</span>&lt;&lt;a;<br>     cout&lt;&lt;<span class="hljs-string">&quot; b=&quot;</span>&lt;&lt;b&lt;&lt;endl;<br>     <span class="hljs-built_in">swap</span>(a,b);<br>     cout&lt;&lt;<span class="hljs-string">&quot;交换后：a=&quot;</span>&lt;&lt;a;<br>     cout&lt;&lt;<span class="hljs-string">&quot; b=&quot;</span>&lt;&lt;b&lt;&lt;endl;<br>     <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="引用做函数返回值"><a href="#引用做函数返回值" class="headerlink" title="引用做函数返回值"></a>引用做函数返回值</h2><ul>
<li>注意：<ul>
<li>不能返回局部变量的引用</li>
</ul>
</li>
</ul>
<p>函数调用可以作为等号左边的值</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> &amp;<span class="hljs-title">test1</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-type">static</span> <span class="hljs-type">int</span> a=<span class="hljs-number">10</span>;<br>	<span class="hljs-keyword">return</span> a;<span class="hljs-comment">//这里返回的是a的引用</span><br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-type">int</span> &amp;b=<span class="hljs-built_in">test1</span>();<br>	cout&lt;&lt;<span class="hljs-string">&quot;b=&quot;</span>&lt;&lt;b&lt;&lt;endl;<br>	<span class="hljs-built_in">test1</span>()=<span class="hljs-number">1000</span>;<span class="hljs-comment">//这里是对a的引用进行了修改，相当于a=1000</span><br>	cout&lt;&lt;<span class="hljs-string">&quot;b=&quot;</span>&lt;&lt;b&lt;&lt;endl;<span class="hljs-comment">//再用b（别名）进行访问</span><br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="本质"><a href="#本质" class="headerlink" title="本质"></a>本质</h2><ul>
<li>本质：<ul>
<li>在C++内部就是一个<strong>指针常量</strong>，指向我引用的对象</li>
</ul>
</li>
</ul>
<h2 id="常量引用"><a href="#常量引用" class="headerlink" title="常量引用"></a>常量引用</h2><ul>
<li>作用：<ul>
<li>用于修饰形参，防止误操作，保护参数</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test1</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;a)</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-comment">//a=100，这里就会发生错误</span><br>	<span class="hljs-comment">//这里就可以防止这个变量的值发生改变，保护数据</span><br>	cout&lt;&lt;a&lt;&lt;endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;a=<span class="hljs-number">10</span>;<span class="hljs-comment">//自己创建了一个值为10的空间，不可修改</span><br>	<span class="hljs-type">int</span> aa=<span class="hljs-number">10</span>;<br>	<span class="hljs-built_in">test1</span>(a);<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h1 id="函数提高"><a href="#函数提高" class="headerlink" title="函数提高"></a>函数提高</h1><h2 id="函数默认参数"><a href="#函数默认参数" class="headerlink" title="函数默认参数"></a>函数默认参数</h2><p>C++中，函数的形参列表中可以有默认值</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test</span> <span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b=<span class="hljs-number">10</span>,<span class="hljs-type">int</span> c=<span class="hljs-number">20</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>	...<br>&#125;<br></code></pre></td></tr></table></figure>

<p>如果我没有传参就用默认，如果我们有传参，就用我们传的参数</p>
<p>注意：</p>
<ul>
<li>如果某个位置有了默认参数，那么往后都必须要有默认值</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test</span> <span class="hljs-params">(<span class="hljs-type">int</span> a=<span class="hljs-number">10</span>,<span class="hljs-type">int</span> b,<span class="hljs-type">int</span> c)</span></span><br><span class="hljs-function"></span>&#123;<br>...<br>&#125;<span class="hljs-comment">//错误的</span><br></code></pre></td></tr></table></figure>

<ul>
<li>函数的声明和实现只能一边有默认参数</li>
</ul>
<h2 id="函数占位参数"><a href="#函数占位参数" class="headerlink" title="函数占位参数"></a>函数占位参数</h2><p>C++中可以有占位参数，用来占位，但在函数调用时必须填补该位置</p>
<p>比如</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span>)</span><span class="hljs-comment">//第二个int就是来占位的</span></span><br><span class="hljs-function"></span>&#123;<br>	...<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-built_in">test</span>(<span class="hljs-number">10</span>,<span class="hljs-number">10</span>);<span class="hljs-comment">//必须填补那个占位的</span><br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>占位参数还可以有默认参数，比如</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> = <span class="hljs-number">10</span>)</span><span class="hljs-comment">//第二个int就是来占位的</span></span><br><span class="hljs-function"></span>&#123;<br>...<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">test</span>(<span class="hljs-number">10</span>,<span class="hljs-number">10</span>);<span class="hljs-comment">//必须填补那个占位的</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><ul>
<li>作用：<ul>
<li>函数名可以相同，提高重用性</li>
</ul>
</li>
<li>条件：<ul>
<li>同一个作用域（比如都是全局）</li>
<li>函数名相同</li>
<li>函数参数<strong>类型不同</strong>或<strong>个数不同</strong>或<strong>顺序不同</strong></li>
</ul>
</li>
<li>注意：<ul>
<li><strong>函数返回值不可作为函数重载的条件</strong></li>
</ul>
</li>
</ul>
<p>举个例子</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span><span class="hljs-comment">//参数个数不同</span></span><br><span class="hljs-function"></span>&#123;<br>	cout&lt;&lt;<span class="hljs-string">&quot;func(int a)被调用&quot;</span>&lt;&lt;endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	cout&lt;&lt;<span class="hljs-string">&quot;func()被调用&quot;</span>&lt;&lt;endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-built_in">func</span>(<span class="hljs-number">10</span>);<br>	<span class="hljs-built_in">func</span>();<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h3><ul>
<li>引用作为函数重载的条件</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">int</span> &amp;a)</span></span><br><span class="hljs-function"></span>&#123;<br>	cout&lt;&lt;<span class="hljs-string">&quot;func(int &amp;a)被调用&quot;</span>&lt;&lt;endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;a)</span></span><br><span class="hljs-function"></span>&#123;<br>	cout&lt;&lt;<span class="hljs-string">&quot;func(const int &amp;a)被调用&quot;</span>&lt;&lt;endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-type">int</span> a=<span class="hljs-number">10</span>;<br>	<span class="hljs-built_in">func</span>(a);<span class="hljs-comment">//调用了第一个</span><br>	<span class="hljs-built_in">func</span>(<span class="hljs-number">10</span>);<span class="hljs-comment">//调用了第二个</span><br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>函数重载碰到默认参数</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span></span><br><span class="hljs-function"></span>&#123;<br>	cout&lt;&lt;<span class="hljs-string">&quot;func(int a)被调用&quot;</span>&lt;&lt;endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b=<span class="hljs-number">10</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>	cout&lt;&lt;<span class="hljs-string">&quot;func(int a,int b=10)被调用&quot;</span>&lt;&lt;endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-comment">//func(10);//错误的</span><br>	<span class="hljs-built_in">func</span>(<span class="hljs-number">10</span>,<span class="hljs-number">20</span>);<span class="hljs-comment">//正确的</span><br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h1 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h1><p>C++面向对象三大特性：封装、继承、多态</p>
<h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><h3 id="意义"><a href="#意义" class="headerlink" title="意义"></a>意义</h3><ul>
<li>将属性和行为封装在一起，表现事物</li>
<li>将属性和行为加以权限控制</li>
</ul>
<p><strong>意义1：</strong></p>
<ul>
<li>语法：<code>class 类名&#123; 属性、行为 &#125;</code></li>
</ul>
<p>比如设计一个圆类，求圆周长</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Circle</span><br>&#123;<br>	<span class="hljs-comment">//访问权限</span><br><span class="hljs-keyword">public</span>:<br>	<span class="hljs-comment">//属性</span><br>	<span class="hljs-type">int</span> r;<br>	<span class="hljs-comment">//行为</span><br>	<span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">c</span><span class="hljs-params">()</span></span><br><span class="hljs-function">	</span>&#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-number">2</span>*<span class="hljs-number">3.14</span>*r;<br>	&#125;<br>&#125;;<span class="hljs-comment">//注意这里有一个分号</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>     <span class="hljs-comment">//通过圆类创建一个对象</span><br>     Circle c1;<br>     <span class="hljs-comment">//赋予属性</span><br>     c<span class="hljs-number">1.</span>r=<span class="hljs-number">10</span>;<br>     cout&lt;&lt;<span class="hljs-string">&quot;圆周长为&quot;</span>&lt;&lt;c<span class="hljs-number">1.</span><span class="hljs-built_in">c</span>()&lt;&lt;endl;<br>     <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>类中的属性行为统一称为成员</p>
<p>属性：成员属性，成员变量</p>
<p>行为：成员函数，成员方法</p>
<p><strong>意义2：</strong></p>
<p>访问权限分为3种</p>
<ul>
<li>public 公共权限<ul>
<li>类内类外均可访问</li>
</ul>
</li>
<li>protected 保护权限<ul>
<li>类内可访问</li>
<li>类外不可访问</li>
<li>子可访问父</li>
</ul>
</li>
<li>private 私有权限<ul>
<li>类内可访问</li>
<li>类外不可访问</li>
<li>子不可访问父亲</li>
</ul>
</li>
</ul>
<h3 id="struct-class区别"><a href="#struct-class区别" class="headerlink" title="struct class区别"></a>struct class区别</h3><p>唯一区别：默认访问权限不同</p>
<p>struct：公共</p>
<p>class：私有</p>
<h3 id="将成员属性设置为私有"><a href="#将成员属性设置为私有" class="headerlink" title="将成员属性设置为私有"></a>将成员属性设置为私有</h3><p>优点1：将所有成员属性设置为私有，可以自己控制读写权限</p>
<p>优点2：对于写权限，我们可以检查数据有效性（就是在写的时候加if来判断即可）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">person</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>	<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setname</span><span class="hljs-params">(string n)</span></span><br><span class="hljs-function">	</span>&#123;<br>		name=n;<br>	&#125;<span class="hljs-comment">//这样就是可读可写</span><br>	<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">getage</span><span class="hljs-params">()</span></span><br><span class="hljs-function">	</span>&#123;<br>		cout&lt;&lt;<span class="hljs-string">&quot;年龄为：&quot;</span>&lt;&lt;age&lt;&lt;endl;<br>	&#125;这样就是只读了<br>	<span class="hljs-function">string <span class="hljs-title">setidol</span><span class="hljs-params">(string i)</span></span><br><span class="hljs-function">	</span>&#123;<br>		idol=i;<br>	&#125;<span class="hljs-comment">//这样就是只写了</span><br><span class="hljs-keyword">private</span>:<br>	string name;<span class="hljs-comment">//姓名，可读可写</span><br>	<span class="hljs-type">int</span> age=<span class="hljs-number">18</span>;<span class="hljs-comment">//年龄 只读</span><br>	srring idol;<span class="hljs-comment">//偶像 只写</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="对象的初始化和清理"><a href="#对象的初始化和清理" class="headerlink" title="对象的初始化和清理"></a>对象的初始化和清理</h2><h3 id="构造函数和析构函数"><a href="#构造函数和析构函数" class="headerlink" title="构造函数和析构函数"></a>构造函数和析构函数</h3><p><strong>初始化</strong>和<strong>清理</strong>是非常重要的安全问题</p>
<ul>
<li>没有初始化，对象使用后果是位置的</li>
<li>使用完对象或变量没有及时清理，也会造成安全问题</li>
</ul>
<p>构造和析构就是来解决初始化和清理的，由编译器自动调用，<strong>如果我们不提供构造和析构，编译器会提供，但编译器提供的是空的</strong></p>
<ul>
<li>构造：主要作用在创建对象时为成员属性赋值，由编译器自动调用，无须手动</li>
<li>析构：主要作用在于对象销毁前自动调用，执行一些清理</li>
</ul>
<p>构造函数语法：<code>类名 ()&#123;&#125;</code></p>
<ul>
<li>没有返回值也不写void</li>
<li>函数名称和类名相同</li>
<li>可以有参数，因此可以发生重载</li>
<li>程序在调用对象的时候会自动调用构造，无须手动调用，而且只会调用一次</li>
</ul>
<p>析构函数语法：<code>~类名 ()&#123;&#125;</code></p>
<ul>
<li>没有返回值但也不写void</li>
<li>函数名称和类名相同，在名称前面加~</li>
<li><strong>不可以</strong>有参数，因此<strong>不可以</strong>发生重载</li>
<li>程序在对象销毁前会自动调用析构，无须手动调用且只会调用一次</li>
</ul>
<p>举例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">person</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>	<span class="hljs-built_in">person</span>()<span class="hljs-comment">//构造函数</span><br>	&#123;<br>		cout&lt;&lt;<span class="hljs-string">&quot;Person构造函数被调用&quot;</span>&lt;&lt;endl;<br>	&#125;<br>	~<span class="hljs-built_in">person</span>()<span class="hljs-comment">//析构函数</span><br>	&#123;<br>		cout&lt;&lt;<span class="hljs-string">&quot;person析构函数被调用&quot;</span>&lt;&lt;endl;<br>	&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>     person p;<span class="hljs-comment">//栈上的数据，执行完毕后会释放这个对象，也就会执行析构函数</span><br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-built_in">test1</span>();<br>     <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="构造函数的分类及调用"><a href="#构造函数的分类及调用" class="headerlink" title="构造函数的分类及调用"></a>构造函数的分类及调用</h3><p>分类：</p>
<ul>
<li>按参数<ul>
<li>有参构造和无参构造</li>
</ul>
</li>
<li>按类型<ul>
<li>普通构造和拷贝构造</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">person</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>	<span class="hljs-built_in">person</span>()<span class="hljs-comment">//无参构造函数</span><br>	&#123;<br>		cout&lt;&lt;<span class="hljs-string">&quot;Person无参构造函数被调用&quot;</span>&lt;&lt;endl;<br>	&#125;<br>	<span class="hljs-built_in">person</span>(<span class="hljs-type">int</span> a)<span class="hljs-comment">//有参构造函数</span><br>	&#123;<br>		cout&lt;&lt;<span class="hljs-string">&quot;Person有参构造函数被调用&quot;</span>&lt;&lt;endl;<br>	&#125;<br>     <span class="hljs-comment">//拷贝构造函数</span><br>     <span class="hljs-comment">//将传入的对象身上的属性拷贝到我当前的对象上</span><br>     <span class="hljs-built_in">person</span>(<span class="hljs-type">const</span> person &amp;p)<br>     &#123;<br>          cout&lt;&lt;<span class="hljs-string">&quot;Person拷贝&quot;</span>&lt;&lt;endl;<br>          age=p.age<br>     &#125;<br>	~<span class="hljs-built_in">person</span>()<span class="hljs-comment">//析构函数</span><br>	&#123;<br>		cout&lt;&lt;<span class="hljs-string">&quot;person析构函数被调用&quot;</span>&lt;&lt;endl;<br>	&#125;<br>	<span class="hljs-type">int</span> a;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>调用方式：</p>
<ul>
<li>括号法<ul>
<li>注意事项<ul>
<li>调用默认构造函数时不要加()，<code>person p1()</code>会被当做是一个函数的声明</li>
</ul>
</li>
</ul>
</li>
<li>显示法<ul>
<li>不要利用拷贝构造函数初始化匿名对象</li>
</ul>
</li>
<li>隐式转换法</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>     <span class="hljs-comment">//括号法</span><br>     person p;<span class="hljs-comment">//默认构造函数调用</span><br>     <span class="hljs-function">person <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>;<span class="hljs-comment">//括号法调用有参</span><br>     <span class="hljs-function">person <span class="hljs-title">p2</span><span class="hljs-params">(p1)</span></span>;<span class="hljs-comment">//括号法调用拷贝</span><br>     <span class="hljs-comment">//显示法</span><br>     person p3=<span class="hljs-built_in">person</span>(<span class="hljs-number">10</span>);<span class="hljs-comment">//显示法调用有参构造</span><br>     person p4=<span class="hljs-built_in">person</span>(p1);<span class="hljs-comment">//显示法调用拷贝构造</span><br>     <span class="hljs-built_in">person</span>(<span class="hljs-number">10</span>);<span class="hljs-comment">//匿名对象，当前执行结束后会立即释放掉</span><br>     <span class="hljs-comment">//隐式转换法</span><br>     person p5=<span class="hljs-number">10</span>;<span class="hljs-comment">//相当于person p5=person(10)</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="拷贝构造函数调用时机"><a href="#拷贝构造函数调用时机" class="headerlink" title="拷贝构造函数调用时机"></a>拷贝构造函数调用时机</h3><p>调用的三种情况</p>
<ul>
<li>调用一个已经创建完毕的对象来初始化新对象</li>
<li>值传递方式给函数参数传值</li>
<li>以值传递方式返回局部对象</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">person</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>	<span class="hljs-built_in">person</span>()<br>	&#123;<br>		cout&lt;&lt;<span class="hljs-string">&quot;默认构造函数被调用&quot;</span>&lt;&lt;endl;<br>	&#125;<br>	<span class="hljs-built_in">person</span>(<span class="hljs-type">int</span> a)<br>	&#123;<br>		age=a;<br>		cout&lt;&lt;<span class="hljs-string">&quot;有参构造被调用&quot;</span>&lt;&lt;endl;<br>	&#125;<br>	~<span class="hljs-built_in">person</span>()<br>	&#123;<br>		cout&lt;&lt;<span class="hljs-string">&quot;析构函数被调用&quot;</span>&lt;&lt;endl;<br>	&#125;<br>	<span class="hljs-built_in">person</span>(<span class="hljs-type">const</span> person &amp;p)<br>	&#123;<br>		age=p.age;<br>		cout&lt;&lt;<span class="hljs-string">&quot;拷贝构造被调用&quot;</span>&lt;&lt;endl<br>	&#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">work1</span><span class="hljs-params">(person p)</span></span><br><span class="hljs-function"></span>&#123;<br>     <br>&#125;<br><span class="hljs-function">person <span class="hljs-title">work2</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>     person p1;<br>     <span class="hljs-keyword">return</span> p1;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>     <span class="hljs-function">person <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-number">20</span>)</span></span>;<br>     <span class="hljs-function">person <span class="hljs-title">p2</span><span class="hljs-params">(p1)</span></span>;<span class="hljs-comment">//第一种调用情况</span><br>     <span class="hljs-built_in">work1</span>(p1);<span class="hljs-comment">//第二种调用情况，拷贝出临时的副本给函数用</span><br>     person p=<span class="hljs-built_in">work2</span>();<span class="hljs-comment">//第三种调用情况，return时会拷贝一个新对象给p</span><br>     <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="构造函数调用规则"><a href="#构造函数调用规则" class="headerlink" title="构造函数调用规则"></a>构造函数调用规则</h3><p>默认情况下，c++编译器至少给一个类添加三个函数</p>
<ul>
<li>默认构造函数（无参，函数体为空）</li>
<li>默认析构函数（无参，函数体为空）</li>
<li>默认拷贝函数，对属性进行值拷贝</li>
</ul>
<p>构造函数调用规则：</p>
<ul>
<li>用户自定义<strong>有参构造</strong>函数，C++不在提供默认无参构造，但是会提供默认拷贝函数</li>
<li>用户自定义<strong>拷贝构造</strong>函数，C++不再提供其他的构造函数</li>
</ul>
<h3 id="深拷贝和浅拷贝"><a href="#深拷贝和浅拷贝" class="headerlink" title="深拷贝和浅拷贝"></a>深拷贝和浅拷贝</h3><p>浅拷贝：简单赋值操作</p>
<p>深拷贝：在堆区重新申请空间，进行拷贝操作</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">person</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>	<span class="hljs-built_in">person</span>()<br>	&#123;<br>		cout&lt;&lt;<span class="hljs-string">&quot;默认构造函数被调用&quot;</span>&lt;&lt;endl;<br>	&#125;<br>	<span class="hljs-built_in">person</span>(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> h)<br>	&#123;<br>		age=a;<br>          high=<span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(h);<br>		cout&lt;&lt;<span class="hljs-string">&quot;有参构造被调用&quot;</span>&lt;&lt;endl;<br>	&#125;<br>	~<span class="hljs-built_in">person</span>()<br>	&#123;<br>          <span class="hljs-comment">//析构函数，将堆区开辟的数据释放掉</span><br>          <span class="hljs-keyword">if</span> (high!=<span class="hljs-literal">NULL</span>)<br>               <span class="hljs-keyword">delete</span> high;<br>		cout&lt;&lt;<span class="hljs-string">&quot;析构函数被调用&quot;</span>&lt;&lt;endl;<br>	&#125;<br><span class="hljs-keyword">private</span>:<br>     <span class="hljs-type">int</span> age;<br>     <span class="hljs-type">int</span>* high=<span class="hljs-literal">NULL</span>;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>浅拷贝会导致一块内存重复被释放</p>
<ul>
<li><pre><code class="c++">int main()
&#123;
    person p1(18,120);
    person p2(p1);//系统提供的拷贝函数，是浅拷贝
    return 0;
&#125;//此时p1p2中的age存储的是同一块堆中的地址，当p2结束后会执行一次析构函数，此时high已经被释放掉，而p1结束后还会再来一次析构函数，而此时已经释放掉的内存就会再一次被释放，导致程序出错
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><br>此时就需要深拷贝，需要重新申请一块内存<br><br>```c++<br><span class="hljs-keyword">class</span> person<br>&#123;<br><span class="hljs-keyword">public</span>:<br>	person()<br>	&#123;<br>		cout&lt;&lt;<span class="hljs-string">&quot;默认构造函数被调用&quot;</span>&lt;&lt;endl;<br>	&#125;<br>	person(<span class="hljs-keyword">int</span> a,<span class="hljs-keyword">int</span> h)<br>	&#123;<br>		age=a;<br>          high=<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>(h);<br>		cout&lt;&lt;<span class="hljs-string">&quot;有参构造被调用&quot;</span>&lt;&lt;endl;<br>	&#125;<br>	~person()<br>	&#123;<br>          <span class="hljs-comment">//析构函数，将堆区开辟的数据释放掉</span><br>          <span class="hljs-keyword">if</span> (high!=<span class="hljs-keyword">NULL</span>)<br>               <span class="hljs-keyword">delete</span> high;<br>		cout&lt;&lt;<span class="hljs-string">&quot;析构函数被调用&quot;</span>&lt;&lt;endl;<br>	&#125;<br>     <span class="hljs-comment">//深拷贝</span><br>     person(const person &amp;p)<br>     &#123;<br>          cout&lt;&lt;<span class="hljs-string">&quot;深拷贝函数被调用&quot;</span>&lt;&lt;endl;<br>          age=p.age;<br>          <span class="hljs-comment">//high=p.high;  编译器默认提供的拷贝函数就是这句代码</span><br>          high=<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>(*p.high);<br>     &#125;<br><span class="hljs-keyword">private</span>:<br>     <span class="hljs-keyword">int</span> age;<br>     <span class="hljs-keyword">int</span>* high=<span class="hljs-keyword">NULL</span>;<br>&#125;;<br></code></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
<h3 id="初始化列表"><a href="#初始化列表" class="headerlink" title="初始化列表"></a>初始化列表</h3><p><strong>作用</strong>：</p>
<p>C++提供初始化列表语法，用于初始化属性</p>
<p>语法：<code>构造函数():属性1(值1),属性2(值2)....&#123;&#125;</code></p>
<p>参数非常数时：<code>person(int a,int b,int c):m_A(a),m_B(b),m_C(c)&#123;&#125;</code></p>
<h3 id="类对象作为类成员"><a href="#类对象作为类成员" class="headerlink" title="类对象作为类成员"></a>类对象作为类成员</h3><p>C++中类中的成员可以是另一个类的对象，我们称该成员为：<strong>对象成员</strong></p>
<p>比如</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>&#123;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span><br>&#123;<br>	A a;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>B中有对象A作为成员，A是对象成员</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">phone</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>	<span class="hljs-built_in">phone</span>(string p)<br>	&#123;<br>		pname=p;<br>	&#125;<br>	string pname;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">person</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>	<span class="hljs-built_in">person</span>(string n,string pn)<br>	&#123;<br>		name=n;<br>		m_phone.pname=pn;<br>	&#125;<br>	srring name;<br>	phone m_phone;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-function">person <span class="hljs-title">p</span><span class="hljs-params">(<span class="hljs-string">&quot;pp&quot;</span>,<span class="hljs-string">&quot;apple&quot;</span>)</span></span>;<br>	<br>&#125;<br></code></pre></td></tr></table></figure>

<p>结论：当其他类对象作为本类对象，<strong>其他类的构造函数先被调用，然后自身的构造函数再来，析构则是反过来</strong></p>
<h3 id="静态成员"><a href="#静态成员" class="headerlink" title="静态成员"></a>静态成员</h3><p>在成员变量和成员函数前加static，称为静态成员</p>
<p>静态成员分为</p>
<h4 id="静态成员变量"><a href="#静态成员变量" class="headerlink" title="静态成员变量"></a>静态成员变量</h4><ul>
<li>所有对象共用一份数据</li>
<li>编译阶段分配内存</li>
<li>类内声明，类外初始化</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">person</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>	<span class="hljs-type">static</span> <span class="hljs-type">int</span> a;<br>&#125;;<br><span class="hljs-type">int</span> person::a=<span class="hljs-number">100</span>;<span class="hljs-comment">//类外初始化</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>     person p;<br>     cout&lt;&lt;p.a&lt;&lt;endl;<br>     person p1;<br>     p<span class="hljs-number">1.</span>a=<span class="hljs-number">200</span>;<br>     cout&lt;&lt;p.a&lt;&lt;endl;<br>&#125;<br><span class="hljs-comment">//输出：</span><br><span class="hljs-comment">//100</span><br><span class="hljs-comment">//200</span><br></code></pre></td></tr></table></figure>

<p>静态成员变量不属于某个对象上，所有对象共享同一份数据</p>
<p>因此有两种访问方式</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test02</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	person p;<br>	<span class="hljs-comment">//通过对象访问</span><br>	cout&lt;&lt;p.a&lt;&lt;endl;<br>	<span class="hljs-comment">//通过类名访问</span><br>	cout&lt;&lt;person::a&lt;&lt;endl;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>静态成员变量同样存在访问权限</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">person</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>	<span class="hljs-type">static</span> <span class="hljs-type">int</span> a;<br><span class="hljs-keyword">private</span>:<br>	<span class="hljs-type">static</span> <span class="hljs-type">int</span> b;<br>&#125;;<br><span class="hljs-type">int</span> person::a=<span class="hljs-number">100</span>;<span class="hljs-comment">//类外初始化</span><br><span class="hljs-type">int</span> person::b=<span class="hljs-number">101</span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>     person p;<br>     cout&lt;&lt;p.a&lt;&lt;endl;<br>     person p1;<br>     p<span class="hljs-number">1.</span>a=<span class="hljs-number">200</span>;<br>     cout&lt;&lt;p.a&lt;&lt;endl;<br>&#125;<br><span class="hljs-comment">//输出：</span><br><span class="hljs-comment">//100</span><br><span class="hljs-comment">//200</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test02</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	cout&lt;&lt;person::b&lt;&lt;endl;<span class="hljs-comment">//会报错，由于private权限，类外不可访问</span><br>&#125;<br></code></pre></td></tr></table></figure>



<h4 id="静态成员函数"><a href="#静态成员函数" class="headerlink" title="静态成员函数"></a>静态成员函数</h4><ul>
<li>所有对象共享同一个函数</li>
<li>静态成员函数只能访问静态成员变量（因为无法区分这个变量是谁的）</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">person</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>	<span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span><br><span class="hljs-function">	</span>&#123;<br>		cout&lt;&lt;<span class="hljs-string">&quot;静态成员函数被调用&quot;</span>&lt;&lt;endl;<br>	&#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>访问方式：</p>
<ul>
<li>通过对象访问</li>
<li>通过类名访问</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	person p;<br>	<span class="hljs-comment">//通过对象访问</span><br>	p.<span class="hljs-built_in">func</span>();<br>	<span class="hljs-comment">//通过类名访问</span><br>	person::<span class="hljs-built_in">func</span>();<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="c-对象模型和this指针"><a href="#c-对象模型和this指针" class="headerlink" title="c++对象模型和this指针"></a>c++对象模型和this指针</h2><h3 id="成员变量和成员函数分开存储"><a href="#成员变量和成员函数分开存储" class="headerlink" title="成员变量和成员函数分开存储"></a>成员变量和成员函数分开存储</h3><p>C++中，类内的成员变量和成员函数分开存储</p>
<p>只有<strong>非静态成员变量</strong>才属于类的对象上。静态成员变量、非静态成员函数、静态成员函数都不属于类的对象上</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">person</span><br>&#123;<br><br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">person1</span><br>&#123;<br>     <span class="hljs-type">int</span> a;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">person2</span><br>&#123;<br>     <span class="hljs-type">int</span> a;<br>     <span class="hljs-type">static</span> <span class="hljs-type">int</span> b;<br>&#125;;<br><span class="hljs-type">int</span> person2::b=<span class="hljs-number">100</span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	person p;<br>	cout&lt;&lt;<span class="hljs-string">&quot;size of p = &quot;</span>&lt;&lt;<span class="hljs-built_in">sizeof</span>(p)&lt;&lt;endl;<span class="hljs-comment">//输出结果是1，所以空对象占用内存是1</span><br>     <span class="hljs-comment">//c++会给每个空对象也分配一个字节，为了区别空对象占内存的位置，空对象也有独一无二的内存地址</span><br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test02</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>     person1 p;<br>	cout&lt;&lt;<span class="hljs-string">&quot;size of p = &quot;</span>&lt;&lt;<span class="hljs-built_in">sizeof</span>(p)&lt;&lt;endl;<span class="hljs-comment">//结果是4</span><br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test03</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>     person2 p;<br>	cout&lt;&lt;<span class="hljs-string">&quot;size of p = &quot;</span>&lt;&lt;<span class="hljs-built_in">sizeof</span>(p)&lt;&lt;endl;<span class="hljs-comment">//结果是还是4，它没有存储在类中</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="this指针"><a href="#this指针" class="headerlink" title="this指针"></a>this指针</h3><p>C++通过提供特殊的对象指针，this指针，来区分是哪个对象调用的。<strong>this指针指向被调用的成员函数所属的对象</strong></p>
<ul>
<li>this指针隐含在每一个非静态成员函数内的一种指针</li>
<li>this指针不需要定义，可以直接使用</li>
</ul>
<p>用途</p>
<ul>
<li>当形参和成员函数重名时，用this指针来区分</li>
<li>在非静态成员函数中返回对象本身，可以使用<code>return *this</code></li>
</ul>
<p>实例</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">person</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>	<span class="hljs-built_in">person</span>(<span class="hljs-type">int</span> age)<br>	&#123;<br>		<span class="hljs-keyword">this</span>-&gt;age=age;<br>		<span class="hljs-comment">//不能直接age=age，会报错</span><br>	&#125;<br>     <span class="hljs-function">person&amp; <span class="hljs-title">addage</span><span class="hljs-params">(person&amp; p)</span><span class="hljs-comment">//要是引用，如果是person，返回的话就是浅拷贝创建了一个新对象，不再是原本的那个</span></span><br><span class="hljs-function">     </span>&#123;<br>          <span class="hljs-keyword">this</span>-&gt;age+=p.age;<br>          <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<span class="hljs-comment">//这样就可以重复调用</span><br>     &#125;<br>	<span class="hljs-type">int</span> age;<br>&#125;<br><span class="hljs-comment">//解决名称冲突</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>     <span class="hljs-function">person <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-number">18</span>)</span></span>;<br>     cout&lt;&lt;<span class="hljs-string">&quot;p1年龄：&quot;</span>&lt;&lt;endl;<span class="hljs-comment">//此时this指向p1;</span><br>&#125;<br><span class="hljs-comment">//返回对象本身用*this</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test02</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>     <span class="hljs-function">person <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>;<br>     <span class="hljs-function">person <span class="hljs-title">p2</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>;<br>     p<span class="hljs-number">2.</span><span class="hljs-built_in">addage</span>(p1).<span class="hljs-built_in">addage</span>(p1),<span class="hljs-built_in">addage</span>(p1);<span class="hljs-comment">//如果没有return *this就会报错</span><br>     <span class="hljs-comment">//链式编程思想</span><br>     cout&lt;&lt;<span class="hljs-string">&quot;p2年龄为：&quot;</span>&lt;&lt;p<span class="hljs-number">2.</span>age&lt;&lt;endl;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="空指针访问成员函数"><a href="#空指针访问成员函数" class="headerlink" title="空指针访问成员函数"></a>空指针访问成员函数</h3><p>C++中空指针也可以调用成员函数的，但要注意有没有用到this指针</p>
<p>如果遇到this指针要加以判断保证代码健壮性</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">person</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>	<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">showtype</span><span class="hljs-params">()</span></span><br><span class="hljs-function">	</span>&#123;<br>		cout&lt;&lt;<span class="hljs-string">&quot;This is person class&quot;</span>&lt;&lt;endl;<br>	&#125;<br>	<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">showage</span><span class="hljs-params">()</span></span><br><span class="hljs-function">	</span>&#123;<br>          <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>==<span class="hljs-literal">NULL</span>)<br>               <span class="hljs-keyword">return</span>;<span class="hljs-comment">//检查保证程序不会崩溃</span><br>		cout&lt;&lt;age&lt;&lt;endl;<br>	&#125;<br><span class="hljs-keyword">private</span>:<br>	<span class="hljs-type">int</span> age;<br>&#125;；<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	preson *p=<span class="hljs-literal">NULL</span>;<br>	p-&gt;<span class="hljs-built_in">showtype</span>();<span class="hljs-comment">//这句不会</span><br>	p-&gt;<span class="hljs-built_in">showage</span>();<span class="hljs-comment">//这句会出错，报错原因在于传入指针为空，age相当于this-&gt;age，而this指针是空</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="const修饰成员函数"><a href="#const修饰成员函数" class="headerlink" title="const修饰成员函数"></a>const修饰成员函数</h3><ul>
<li>常函数<ul>
<li>加const后称为常函数</li>
<li>常函数内不可修改成员属性</li>
<li><strong>成员属性后加mutable后，在常函数内可以修改</strong></li>
</ul>
</li>
<li>常对象<ul>
<li>声明对象前加const后称为常函数</li>
<li>常对象只能调用常函数</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">person</span><br>&#123;<br><span class="hljs-keyword">private</span>:<br>	<span class="hljs-type">int</span> a;<br><span class="hljs-keyword">public</span>:<br>	<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">showperson</span> <span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function">	</span>&#123;<br>		a = <span class="hljs-number">100</span>;<span class="hljs-comment">//会报错，因为这个const将this指针变成const person * const this这样左值就不可修改了</span><br>          <span class="hljs-comment">//在成员函数后加const，修饰的是this指针，让指针指向的值也不可被修改</span><br>	&#125;<br>     <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span></span><br><span class="hljs-function">     </span>&#123;<br>          <br>     &#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	person p;<br>	p.<span class="hljs-built_in">showperson</span>();<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test02</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>     <span class="hljs-type">const</span> person p;<br>     p.a=<span class="hljs-number">100</span>;<span class="hljs-comment">//报错，也不可修改属性，但加mutable就可以修改了</span><br>     p.<span class="hljs-built_in">showperson</span>();<br>     p.<span class="hljs-built_in">show</span>();<span class="hljs-comment">//会报错，不可调用普通成员函数，因为普通成员函数可以修改属性，与常对象矛盾</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="调用规则"><a href="#调用规则" class="headerlink" title="调用规则"></a>调用规则</h4><ul>
<li><strong><code>const</code> 成员函数</strong> 可以被 <code>const</code> 对象调用，也可以被非 <code>const</code> 对象调用（但优先调用非 <code>const</code> 版本）。<br>  <strong>非</strong></li>
<li>** <code>const</code> 成员函数** 只能被非 <code>const</code> 对象调用。</li>
<li><strong><code>const</code> 可以用来区分重载函数</strong>，只要它们的参数列表相同，但 <code>const</code> 属性不同。</li>
</ul>
<h2 id="友元"><a href="#友元" class="headerlink" title="友元"></a>友元</h2><p>在程序里，有些私有属性，也想让类外的一些特殊的函数或类进行访问，需要用到友元</p>
<p>关键字：<strong>friend</strong></p>
<ul>
<li>三种实现<ul>
<li>全局函数做友元</li>
<li>类做友元</li>
<li>成员函数做友元</li>
</ul>
</li>
</ul>
<h3 id="全局函数做友元"><a href="#全局函数做友元" class="headerlink" title="全局函数做友元"></a>全局函数做友元</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">room</span><br>&#123;<br>	<span class="hljs-function"><span class="hljs-keyword">friend</span> <span class="hljs-type">void</span> <span class="hljs-title">gfriend</span><span class="hljs-params">(room* r)</span></span>;<span class="hljs-comment">//实现友元，这样公有和私有都可以访问了</span><br><span class="hljs-keyword">public</span>:<br>	<span class="hljs-built_in">room</span>()<br>	&#123;<br>		sroom = <span class="hljs-string">&quot;a&quot;</span>;<br>		bedroom = <span class="hljs-string">&quot;b&quot;</span>;<br>	&#125;<br><span class="hljs-keyword">public</span>:<br>	string sroom;<br><span class="hljs-keyword">private</span>:<br>	string bedroom;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">gfriend</span><span class="hljs-params">(room* r)</span></span><br><span class="hljs-function"></span>&#123;<br>	cout &lt;&lt; <span class="hljs-string">&quot;全局函数访问：&quot;</span> &lt;&lt; r-&gt;sroom &lt;&lt; endl;<br>	cout &lt;&lt; <span class="hljs-string">&quot;全局函数访问：&quot;</span> &lt;&lt; r-&gt;bedroom &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	room rr;<br>	<span class="hljs-built_in">gfriend</span>(&amp;rr);<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="类做友元"><a href="#类做友元" class="headerlink" title="类做友元"></a>类做友元</h3><p>让一个类可以访问另一个类的私有成员</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">room</span><br>&#123;<br>	<span class="hljs-keyword">friend</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">gfriend</span>;<span class="hljs-comment">//实现类做友元</span><br><span class="hljs-keyword">public</span>:<br>	<span class="hljs-built_in">room</span>();<br><span class="hljs-keyword">public</span>:<br>	string sroom;<br><span class="hljs-keyword">private</span>:<br>	string bedroom;<br>&#125;;<br>room::<span class="hljs-built_in">room</span>()<span class="hljs-comment">//类外实现构造函数</span><br>&#123;<br>	sroom = <span class="hljs-string">&quot;a&quot;</span>;<br>	bedroom = <span class="hljs-string">&quot;b&quot;</span>;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">gfriend</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>	room* r;<br>	<span class="hljs-built_in">gfriend</span>()<br>	&#123;<br>		r = <span class="hljs-keyword">new</span> room;<br>	&#125;<br>	<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">visit</span><span class="hljs-params">()</span></span><br><span class="hljs-function">	</span>&#123;<br>		cout &lt;&lt; <span class="hljs-string">&quot;gfriend正在访问：&quot;</span> &lt;&lt; r-&gt;sroom &lt;&lt; endl;<br>		cout &lt;&lt; <span class="hljs-string">&quot;gfriend正在访问：&quot;</span> &lt;&lt; r-&gt;bedroom &lt;&lt; endl;<br>	&#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	gfriend gg;<br>	gg.<span class="hljs-built_in">visit</span>();<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="成员函数做友元"><a href="#成员函数做友元" class="headerlink" title="成员函数做友元"></a>成员函数做友元</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">room</span>; <span class="hljs-comment">// 前向声明</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">gfriend</span> <br>&#123;<br><span class="hljs-keyword">public</span>:<br>    room* r;<br>    <span class="hljs-built_in">gfriend</span>();<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">visit</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">// 先声明成员函数</span><br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">room</span> <br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">friend</span> <span class="hljs-type">void</span> <span class="hljs-title">gfriend::visit</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">// 此时 gfriend 类已定义，实现友元</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">room</span>();<br>    string sroom;<br><span class="hljs-keyword">private</span>:<br>    string bedroom;<br>&#125;;<br><br><span class="hljs-comment">// 类成员函数的实现</span><br>room::<span class="hljs-built_in">room</span>() <br>&#123;<br>    sroom = <span class="hljs-string">&quot;a&quot;</span>;<br>    bedroom = <span class="hljs-string">&quot;b&quot;</span>;<br>&#125;<br><br>gfriend::<span class="hljs-built_in">gfriend</span>() <br>&#123;<br>    r = <span class="hljs-keyword">new</span> room;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">gfriend::visit</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"></span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;gfriend正在访问：&quot;</span> &lt;&lt; r-&gt;sroom &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;gfriend正在访问：&quot;</span> &lt;&lt; r-&gt;bedroom &lt;&lt; endl; <span class="hljs-comment">// 现在可以访问私有成员</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"></span>&#123;<br>    gfriend gg;<br>    gg.<span class="hljs-built_in">visit</span>();<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h2><p>对运算符重新进行定义，赋予其另一种功能，以适应不同的数据类型</p>
<h3 id="加号运算符重载"><a href="#加号运算符重载" class="headerlink" title="加号运算符重载"></a>加号运算符重载</h3><p>作用：实现自定义数据类型的运算</p>
<h4 id="成员函数重载加号"><a href="#成员函数重载加号" class="headerlink" title="成员函数重载加号"></a>成员函数重载加号</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">person</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>	<span class="hljs-type">int</span> a;<br>	<span class="hljs-type">int</span> b;<br>	person <span class="hljs-keyword">operator</span>+(person&amp; p)<br>	&#123;<br>		person temp;<br>		temp.a = a + p.a;<br>		temp.b = b + p.b;<br>		<span class="hljs-keyword">return</span> temp;<br>	&#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	person p1;<br>	p<span class="hljs-number">1.</span>a = <span class="hljs-number">10</span>;<br>	p<span class="hljs-number">1.</span>b = <span class="hljs-number">10</span>;<br>	person p2;<br>	p<span class="hljs-number">2.</span>a = <span class="hljs-number">10</span>;<br>	p<span class="hljs-number">2.</span>b = <span class="hljs-number">10</span>;<br>	person p3 = p1 + p2;<br>     <span class="hljs-comment">//本质p3=p1.operator+(p2);简化为上面的写法</span><br>	cout &lt;&lt; <span class="hljs-string">&quot;p3.a=&quot;</span> &lt;&lt; p<span class="hljs-number">3.</span>a &lt;&lt; endl;<br>	cout &lt;&lt; <span class="hljs-string">&quot;p3.b=&quot;</span> &lt;&lt; p<span class="hljs-number">3.</span>b &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="全局函数重载加号"><a href="#全局函数重载加号" class="headerlink" title="全局函数重载加号"></a>全局函数重载加号</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">person</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>	<span class="hljs-type">int</span> a;<br>	<span class="hljs-type">int</span> b;<br>&#125;;<br>person <span class="hljs-keyword">operator</span>+(person&amp; p1, person&amp; p2)<br>&#123;<br>	person temp;<br>	temp.a = p<span class="hljs-number">1.</span>a + p<span class="hljs-number">2.</span>a;<br>	temp.b = p<span class="hljs-number">2.</span>b + p<span class="hljs-number">2.</span>b;<br>	<span class="hljs-keyword">return</span> temp;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	person p1;<br>	p<span class="hljs-number">1.</span>a = <span class="hljs-number">10</span>;<br>	p<span class="hljs-number">1.</span>b = <span class="hljs-number">10</span>;<br>	person p2;<br>	p<span class="hljs-number">2.</span>a = <span class="hljs-number">10</span>;<br>	p<span class="hljs-number">2.</span>b = <span class="hljs-number">10</span>;<br>	person p3 = p1 + p2;<br>	<span class="hljs-comment">//本质p3=operatoe(p1,p2)简化为上面的写法</span><br>	cout &lt;&lt; <span class="hljs-string">&quot;p3.a=&quot;</span> &lt;&lt; p<span class="hljs-number">3.</span>a &lt;&lt; endl;<br>	cout &lt;&lt; <span class="hljs-string">&quot;p3.b=&quot;</span> &lt;&lt; p<span class="hljs-number">3.</span>b &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="运算符重载发生函数重载"><a href="#运算符重载发生函数重载" class="headerlink" title="运算符重载发生函数重载"></a>运算符重载发生函数重载</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">person</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>	<span class="hljs-type">int</span> a;<br>	<span class="hljs-type">int</span> b;<br>&#125;;<br>person <span class="hljs-keyword">operator</span>+(person&amp; p1, person&amp; p2)<br>&#123;<br>	person temp;<br>	temp.a = p<span class="hljs-number">1.</span>a + p<span class="hljs-number">2.</span>a;<br>	temp.b = p<span class="hljs-number">2.</span>b + p<span class="hljs-number">2.</span>b;<br>	<span class="hljs-keyword">return</span> temp;<br>&#125;<br>person <span class="hljs-keyword">operator</span>+(person&amp; p1, <span class="hljs-type">int</span> n)<br>&#123;<br>	person temp;<br>	temp.a = p<span class="hljs-number">1.</span>a + n;<br>	temp.b = p<span class="hljs-number">1.</span>b + n;<br>	<span class="hljs-keyword">return</span> temp;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	person p1;<br>	p<span class="hljs-number">1.</span>a = <span class="hljs-number">10</span>;<br>	p<span class="hljs-number">1.</span>b = <span class="hljs-number">10</span>;<br>	person p2;<br>	p<span class="hljs-number">2.</span>a = <span class="hljs-number">10</span>;<br>	p<span class="hljs-number">2.</span>b = <span class="hljs-number">10</span>;<br>	person p3 = p1 + p2;<br>	person p4 = p1 + <span class="hljs-number">20</span>;<br>	<span class="hljs-comment">//本质p3=operatoe(p1,p2)简化为上面的写法</span><br>	cout &lt;&lt; <span class="hljs-string">&quot;p3.a=&quot;</span> &lt;&lt; p<span class="hljs-number">3.</span>a &lt;&lt; endl;<br>	cout &lt;&lt; <span class="hljs-string">&quot;p3.b=&quot;</span> &lt;&lt; p<span class="hljs-number">3.</span>b &lt;&lt; endl;<br>	cout &lt;&lt; endl;<br>	cout &lt;&lt; <span class="hljs-string">&quot;p4.a=&quot;</span> &lt;&lt; p<span class="hljs-number">4.</span>a &lt;&lt; endl;<br>	cout &lt;&lt; <span class="hljs-string">&quot;p4.b=&quot;</span> &lt;&lt; p<span class="hljs-number">4.</span>b &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>总结1：对于内置的数据类型的表达式的运算符不能重载</p>
<p>总结2：不要滥用运算符重载（把加法写成减法等等）</p>
</blockquote>
<h3 id="左移运算符重载"><a href="#左移运算符重载" class="headerlink" title="左移运算符重载"></a>左移运算符重载</h3><p>作用：输出自定义数据类型<code>&lt;&lt;</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">person</span><br>&#123;<br>     <span class="hljs-keyword">friend</span> ostream&amp; <span class="hljs-keyword">operator</span>&lt;&lt;(ostream&amp; cout, person&amp; p);<br>     <span class="hljs-function"><span class="hljs-keyword">friend</span> <span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-comment">//成员函数重载</span><br>    <span class="hljs-comment">//void operator&lt;&lt;(cout)</span><br>    <span class="hljs-comment">//&#123;   </span><br>    <span class="hljs-comment">//&#125;</span><br>    <span class="hljs-comment">//一般不会用成员函数重载&lt;&lt;，应为无法实现cout在左侧</span><br><span class="hljs-keyword">private</span>:<span class="hljs-comment">//一般设置为私有，所以要设置友元</span><br>    <span class="hljs-type">int</span> a;<br>    <span class="hljs-type">int</span> b;<br>&#125;;<br><span class="hljs-comment">//只能利用全局函数重载左移运算符</span><br>ostream&amp; <span class="hljs-keyword">operator</span>&lt;&lt;(ostream&amp; cout, person&amp; p)<span class="hljs-comment">//本质 operator&lt;&lt;(cout,p)，简化后cout&lt;&lt;p</span><br>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;a=&quot;</span> &lt;&lt; p.a &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;b=&quot;</span> &lt;&lt; p.b &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> cout;<span class="hljs-comment">//这样就能继续输出endl，否则只能cout&lt;&lt;p;</span><br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    person p;<br>    p.a = <span class="hljs-number">10</span>;<br>    p.b = <span class="hljs-number">10</span>;<br>    cout &lt;&lt; p &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="递增运算符重载"><a href="#递增运算符重载" class="headerlink" title="递增运算符重载"></a>递增运算符重载</h3><p>实现前置递增和后置递增</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">person</span><br>&#123;<br>    <span class="hljs-keyword">friend</span> ostream&amp; <span class="hljs-keyword">operator</span>&lt;&lt;(ostream&amp; cout,<span class="hljs-type">const</span> person&amp; p);<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">person</span>()<br>    &#123;<br>        a = <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-comment">//重载前置++</span><br>    person&amp; <span class="hljs-keyword">operator</span>++()<br>    &#123;<br>        a++;<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<span class="hljs-comment">//不能返回值，否则是拷贝，两次++不会更改原本的值，返回引用是为了一直对一个数据做递增</span><br>    &#125;<br>    <span class="hljs-comment">//重载后置++</span><br>    person <span class="hljs-keyword">operator</span>++(<span class="hljs-type">int</span>)<span class="hljs-comment">//int是占位参数，用来区分前置和后置</span><br>    &#123;<br>        person temp = *<span class="hljs-keyword">this</span>;<br>        a++;<br>        <span class="hljs-keyword">return</span> temp;<span class="hljs-comment">//这时返回的是值而不是引用，因为这是对局部变量的引用，会报错</span><br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> a;<br>&#125;;<br>ostream&amp; <span class="hljs-keyword">operator</span>&lt;&lt;(ostream&amp; cout,<span class="hljs-type">const</span> person&amp; p)<span class="hljs-comment">//要加const，否则不能接收临时对象，也就是p+</span><br>&#123;<br>    cout &lt;&lt; p.a;<br>    <span class="hljs-keyword">return</span> cout;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    person p;<br>    cout &lt;&lt; p &lt;&lt; endl;<br>    cout &lt;&lt; ++p &lt;&lt; endl;<br>    cout &lt;&lt; p &lt;&lt; endl;<br>    cout &lt;&lt; p++ &lt;&lt; endl;<br>    cout &lt;&lt; p;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>总结：<strong>前置递增返回的是引用，后置递增返回的是值</strong></p>
<h3 id="赋值运算符重载"><a href="#赋值运算符重载" class="headerlink" title="赋值运算符重载"></a>赋值运算符重载</h3><p>C++至少给一个类添加4个函数</p>
<ul>
<li>默认构造函数</li>
<li>默认析构函数</li>
<li>默认拷贝函数</li>
<li>赋值运算符<code>operator=</code>，对属性进行值拷贝</li>
</ul>
<p>如果有属性指向堆区，也会出现深浅拷贝的问题</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">person</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">person</span>(<span class="hljs-type">int</span> ag)<br>    &#123;<br>        age = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(ag);<br>    &#125;<br>    ~<span class="hljs-built_in">person</span>()<br>    &#123;<br>        <span class="hljs-keyword">if</span> (age != <span class="hljs-literal">NULL</span>)<br>        &#123;<br>            <span class="hljs-keyword">delete</span> age;<br>            age = <span class="hljs-literal">NULL</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//重载赋值运算符</span><br>    person&amp; <span class="hljs-keyword">operator</span>=(person&amp; p)<br>    &#123;<br>        <span class="hljs-comment">//编译器提供的是浅拷贝，我们要写的是深拷贝</span><br>        <span class="hljs-comment">//先判断是否有属性在堆上，如果有的话先释放干净</span><br>        &#123;<br>            <span class="hljs-keyword">if</span> (age != <span class="hljs-literal">NULL</span>)<br>            &#123;<br>                <span class="hljs-keyword">delete</span> age;<br>                age = <span class="hljs-literal">NULL</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//深拷贝</span><br>        age = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(*p.age);<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<span class="hljs-comment">//可以进行连等，p3=p2=p1;</span><br>    &#125;<br>    <span class="hljs-type">int</span>* age;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">person <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-number">18</span>)</span></span>;<br>    <span class="hljs-function">person <span class="hljs-title">p2</span><span class="hljs-params">(<span class="hljs-number">20</span>)</span></span>;<br>    <span class="hljs-function">person <span class="hljs-title">p3</span><span class="hljs-params">(<span class="hljs-number">22</span>)</span></span>;<br>    p3 = p2 = p1;<br>    cout &lt;&lt; <span class="hljs-string">&quot;p1=&quot;</span> &lt;&lt; *p<span class="hljs-number">1.</span>age &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;p2=&quot;</span> &lt;&lt; *p<span class="hljs-number">2.</span>age &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;p3=&quot;</span> &lt;&lt; *p<span class="hljs-number">3.</span>age &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="关系运算符重载"><a href="#关系运算符重载" class="headerlink" title="关系运算符重载"></a>关系运算符重载</h3><p>作用：可以让两个自定义数据类型可以进行比较</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">person</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>	<span class="hljs-built_in">person</span>(<span class="hljs-type">int</span> a)<br>	&#123;<br>		age=a;<br>	&#125;<br>	<span class="hljs-type">int</span> age;<br>	<span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>==(person&amp; p)<br>	&#123;<br>		<span class="hljs-keyword">if</span> (age==p.age)<br>			<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>		<span class="hljs-keyword">else</span><br>			<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>	&#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-function">person <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-number">18</span>)</span></span>;<br>	<span class="hljs-function">person <span class="hljs-title">p2</span><span class="hljs-params">(<span class="hljs-number">18</span>)</span></span>;<br>	<span class="hljs-keyword">if</span> (p1==p2)<br>		cout&lt;&lt;<span class="hljs-string">&quot;p1与p2相等&quot;</span>&lt;&lt;endl;<br>     <span class="hljs-keyword">else</span><br>          cout&lt;&lt;<span class="hljs-string">&quot;p1与p2不相等&quot;</span>&lt;&lt;endl;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>其他符号都与上面这个类似，只要改几个符号即可，这里只写了<code>==</code></p>
<h3 id="函数调用运算符的重载"><a href="#函数调用运算符的重载" class="headerlink" title="函数调用运算符的重载"></a>函数调用运算符的重载</h3><ul>
<li>函数运算符()也可以重载</li>
<li>重载后使用方式和函数非常像，因此称为仿函数</li>
<li>仿函数没有固定写法，非常灵活</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">mprint</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">//重载函数调用运算符</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(string test)</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout &lt;&lt; test &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">madd</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">int</span> n1, <span class="hljs-type">int</span> n2)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> n1 + n2;<br>    &#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    mprint mp;<br>    <span class="hljs-built_in">mp</span>(<span class="hljs-string">&quot;Hello World!&quot;</span>);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test02</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    madd md;<br>    cout &lt;&lt; <span class="hljs-built_in">md</span>(<span class="hljs-number">100</span>, <span class="hljs-number">10</span>) &lt;&lt; endl;<br>    <span class="hljs-comment">//匿名函数对象（执行完立即被释放）</span><br>    cout &lt;&lt; <span class="hljs-built_in">madd</span>()(<span class="hljs-number">100</span>, <span class="hljs-number">20</span>) &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">test01</span>();<br>    <span class="hljs-built_in">test02</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p><strong>面向对象的三大特性之一</strong></p>
<p><img src="/2025/01/18/%E5%A4%87%E6%B3%A8/%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0/1744274250663.png" srcset="/img/loading.gif" lazyload alt="继承"></p>
<p>我们发现在定义这些类时，下级别除了拥有上一级的共性，还有自己的特性</p>
<p>这里我们就可以利用继承来减少代码量</p>
<h3 id="继承基本语法"><a href="#继承基本语法" class="headerlink" title="继承基本语法"></a>继承基本语法</h3><ul>
<li><p>语法：<code>class 子类 : 继承方式 父类</code></p>
</li>
<li><p>子类也称派生类</p>
</li>
<li><p>父类也称基类</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//继承实现</span><br><span class="hljs-comment">//公共页面类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">basepage</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">header</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;登陆          注册&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><span class="hljs-comment">//Java页面</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Java</span> : <span class="hljs-keyword">public</span> basepage<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">content</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Java&quot;</span> &lt;&lt; endl;<br>        cout &lt;&lt; <span class="hljs-string">&quot;-----------------&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">python</span> : <span class="hljs-keyword">public</span> basepage<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">content</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;python&quot;</span> &lt;&lt; endl;<br>        cout &lt;&lt; <span class="hljs-string">&quot;-----------------&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">cpp</span> : <span class="hljs-keyword">public</span> basepage<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">content</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;C++&quot;</span> &lt;&lt; endl;<br>        cout &lt;&lt; <span class="hljs-string">&quot;-----------------&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    Java ja;<br>    ja.<span class="hljs-built_in">header</span>();<br>    ja.<span class="hljs-built_in">content</span>();<br>    python py;<br>    py.<span class="hljs-built_in">header</span>();<br>    py.<span class="hljs-built_in">content</span>();<br>    cpp cjj;<br>    cjj.<span class="hljs-built_in">header</span>();<br>    cjj.<span class="hljs-built_in">content</span>();<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="/2025/01/18/%E5%A4%87%E6%B3%A8/%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0/1744274955782.png" srcset="/img/loading.gif" lazyload alt="效果"></p>
<p><strong>总结：继承减少重复的代码</strong></p>
<h3 id="继承方式"><a href="#继承方式" class="headerlink" title="继承方式"></a>继承方式</h3><ul>
<li>公共继承</li>
<li>保护继承</li>
<li>私有继承</li>
</ul>
<p><img src="/2025/01/18/%E5%A4%87%E6%B3%A8/%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0/1744607846230.png" srcset="/img/loading.gif" lazyload alt="继承方式"></p>
<p><strong>父类私有成员子类访问不到</strong></p>
<ul>
<li>公共继承<ul>
<li>继承父类中的各种属性的权限</li>
</ul>
</li>
<li>保护继承<ul>
<li>将公共权限变为保护，其它不变，<strong>类内可访问类外不可访问</strong></li>
</ul>
</li>
<li>私有继承<ul>
<li>全部变成private，<strong>类外全部不能访问</strong></li>
<li>此时如果又有一个类（子子类）来继承这个子类，那么也无法访问这个子类的属性，因为子类继承父类时变成私有的了，子子类无法访问</li>
</ul>
</li>
</ul>
<h3 id="继承中的对象模型"><a href="#继承中的对象模型" class="headerlink" title="继承中的对象模型"></a>继承中的对象模型</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">base</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>	<span class="hljs-type">int</span> a;<br><span class="hljs-keyword">protected</span>:<br>	<span class="hljs-type">int</span> b;<br><span class="hljs-keyword">private</span>:<br>	<span class="hljs-type">int</span> c<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">son</span>:puiblic base<br>&#123;<br><span class="hljs-keyword">public</span>:<br>	<span class="hljs-type">int</span> d;<br>&#125;;<br><span class="hljs-built_in">test01</span>()<br>&#123;<br>     cout&lt;&lt;<span class="hljs-string">&quot;size: &quot;</span>&lt;&lt;<span class="hljs-built_in">sizeof</span>(son)&lt;&lt;endl;<br>&#125;<br><span class="hljs-comment">//结果是16</span><br></code></pre></td></tr></table></figure>

<p>结论：</p>
<ul>
<li>父类中所有非静态成员都会被子类继承</li>
<li>私有属性也有被继承只不过被隐藏了无法访问而已</li>
</ul>
<h3 id="继承中构造和析构函数"><a href="#继承中构造和析构函数" class="headerlink" title="继承中构造和析构函数"></a>继承中构造和析构函数</h3><p>结论：</p>
<ul>
<li>父类构造</li>
<li>子类构造</li>
<li>子类析构</li>
<li>父类析构</li>
</ul>
<h3 id="继承同名成员的处理方式"><a href="#继承同名成员的处理方式" class="headerlink" title="继承同名成员的处理方式"></a>继承同名成员的处理方式</h3><p>当子类与父类出现同名成员时，如何通过子类访问子类或父类中的同名成员</p>
<ul>
<li>子类中的直接访问</li>
<li>父类通过作用域访问</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">base</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>	<span class="hljs-type">int</span> a;<br>	<span class="hljs-built_in">base</span>()<br>	&#123;<br>		a = <span class="hljs-number">100</span>;<br>	&#125;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">son</span> :<span class="hljs-keyword">public</span> base<br>&#123;<br><span class="hljs-keyword">public</span>:<br>	<span class="hljs-type">int</span> a;<br>	<span class="hljs-built_in">son</span>()<br>	&#123;<br>		a = <span class="hljs-number">200</span>;<br>	&#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	son s;<br>	<span class="hljs-comment">//访问son下的a</span><br>	cout &lt;&lt; <span class="hljs-string">&quot;son下的a=&quot;</span> &lt;&lt; s.a &lt;&lt; endl;<br>	<span class="hljs-comment">//访问base的a</span><br>	cout &lt;&lt; <span class="hljs-string">&quot;base下的a=&quot;</span> &lt;&lt; s.base::a &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>函数同理</p>
<h1 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h1><p>C++面向对象三大特性之一</p>
<h2 id="多态基本概念"><a href="#多态基本概念" class="headerlink" title="多态基本概念"></a>多态基本概念</h2><p>分为两类</p>
<ul>
<li>静态多态：函数重载 运算符重载属于静态多态，复用函数名</li>
<li>动态多态：派生类和虚函数实现运行时的多态</li>
</ul>
<p>区别：</p>
<ul>
<li>静态多态的函数地址早绑定，编译阶段确定函数地址</li>
<li>动态多态的函数地址晚绑定，允许阶段确定函数地址</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">animal</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>	<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">speak</span><span class="hljs-params">()</span></span><br><span class="hljs-function">	</span>&#123;<br>		cout&lt;&lt;<span class="hljs-string">&quot;animal说话&quot;</span>&lt;&lt;endl;<br>	&#125;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">cat</span>:<span class="hljs-keyword">public</span> animal<br>&#123;<br><span class="hljs-keyword">public</span>:<br>	<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">speak</span><span class="hljs-params">()</span></span><br><span class="hljs-function">	</span>&#123;<br>		cout&lt;&lt;<span class="hljs-string">&quot;cat说话&quot;</span>&lt;&lt;endl;<br>	&#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dospeak</span><span class="hljs-params">(animal&amp; ani)</span></span><br><span class="hljs-function"></span>&#123;<br>	ani.<span class="hljs-built_in">speak</span>();<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	cat c;<br>	<span class="hljs-built_in">dospeak</span>(c);<span class="hljs-comment">//父子之间不用强制类型转换，父类能直接用子类的引用或者指针</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>结果：</p>
<p><img src="/2025/01/18/%E5%A4%87%E6%B3%A8/%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0/1745213483114.png" srcset="/img/loading.gif" lazyload></p>
<p>地址早绑定，编译阶段就确定了函数的地址，无论穿什么参数，都会执行<code>ani.speak()</code>，</p>
<p>如果要执行cat说话，地址就<strong>不能早绑定</strong>，需要在<strong>运行阶段绑定</strong>，也就是<strong>晚绑定</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">animal</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>     <span class="hljs-comment">//虚函数，实现地址晚绑定</span><br>	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">speak</span><span class="hljs-params">()</span></span><br><span class="hljs-function">	</span>&#123;<br>		cout&lt;&lt;<span class="hljs-string">&quot;animal说话&quot;</span>&lt;&lt;endl;<br>	&#125;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">cat</span>:<span class="hljs-keyword">public</span> animal<br>&#123;<br><span class="hljs-keyword">public</span>:<br>	<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">speak</span><span class="hljs-params">()</span></span><br><span class="hljs-function">	</span>&#123;<br>		cout&lt;&lt;<span class="hljs-string">&quot;cat说话&quot;</span>&lt;&lt;endl;<br>	&#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dospeak</span><span class="hljs-params">(animal&amp; ani)</span></span><br><span class="hljs-function"></span>&#123;<br>	ani.<span class="hljs-built_in">speak</span>();<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	cat c;<br>	<span class="hljs-built_in">dospeak</span>(c);<span class="hljs-comment">//父子之间不用强制类型转换，父类能直接用子类的引用或者指针</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>结果：</p>
<p><img src="/2025/01/18/%E5%A4%87%E6%B3%A8/%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0/1745298210863.png" srcset="/img/loading.gif" lazyload></p>
<p>动态多态的条件：</p>
<ul>
<li>有继承关系</li>
<li>子类重写父类的虚函数<ul>
<li>重写：函数返回值类型 函数名 参数列表完全相同</li>
</ul>
</li>
</ul>
<p>动态多态的使用：</p>
<ul>
<li>父类的指针或者引用指向子类的对象</li>
</ul>
<h2 id="多态的本质"><a href="#多态的本质" class="headerlink" title="多态的本质"></a>多态的本质</h2><ul>
<li>当父类使用virtual关键字创建虚函数的时候，其内部会有一个vfptr(virtual function prt)指针父类的虚函数表，这个时候父类的虚函数表中会有一个地址：&amp;animal::speak</li>
</ul>
<p><img src="/2025/01/18/%E5%A4%87%E6%B3%A8/%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0/1745412561491.png" srcset="/img/loading.gif" lazyload></p>
<ul>
<li>当子类继承父类的时候会继承父类的vfptr指针，指向子类的虚函数表，但是当子类重写父类的虚函数的时候，会将自身的虚函数表中的地址给替换掉，替换成：&amp;cat::speak，这样就可以调用指向cat::speak的指针</li>
</ul>
<p><img src="/2025/01/18/%E5%A4%87%E6%B3%A8/%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0/1745412627477.png" srcset="/img/loading.gif" lazyload></p>
<h2 id="案例1：计算器类"><a href="#案例1：计算器类" class="headerlink" title="案例1：计算器类"></a>案例1：计算器类</h2><p>案例描述：分别利用普通写法和多态技术，实现两个操作数进行运算的计算机类</p>
<p>多态优点：</p>
<ul>
<li>代码组织结构清晰</li>
<li>可读性强</li>
<li>利于前期和后期的扩展和维护</li>
</ul>
<p>普通：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">cac</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>	<span class="hljs-type">int</span> n1;<br>	<span class="hljs-type">int</span> n2;<br>	<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getresult</span><span class="hljs-params">(string oper)</span></span><br><span class="hljs-function">	</span>&#123;<br><br>		<span class="hljs-keyword">if</span> (oper == <span class="hljs-string">&quot;+&quot;</span>)<br>			<span class="hljs-keyword">return</span> n1 + n2;<br>		<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (oper == <span class="hljs-string">&quot;-&quot;</span>)<br>			<span class="hljs-keyword">return</span> n1 - n2;<br>		<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (oper == <span class="hljs-string">&quot;*&quot;</span>)<br>			<span class="hljs-keyword">return</span> n1 * n2;<br>		<span class="hljs-comment">//如果要扩展新功能，需要修改源码</span><br>		<span class="hljs-comment">//在真实开发中，提倡开闭原则：对扩展进行开放，对修改进行关闭</span><br>	&#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	cac c;<br>	c.n1 = <span class="hljs-number">10</span>;<br>	c.n2 = <span class="hljs-number">10</span>;<br>	cout &lt;&lt; c.<span class="hljs-built_in">getresult</span>(<span class="hljs-string">&quot;+&quot;</span>) &lt;&lt; endl;<br>	cout &lt;&lt; c.<span class="hljs-built_in">getresult</span>(<span class="hljs-string">&quot;-&quot;</span>) &lt;&lt; endl;<br>	cout &lt;&lt; c.<span class="hljs-built_in">getresult</span>(<span class="hljs-string">&quot;*&quot;</span>) &lt;&lt; endl;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>多态：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">basecac</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">int</span> <span class="hljs-title">getresult</span><span class="hljs-params">()</span></span><br><span class="hljs-function">	</span>&#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>	&#125;<br>	<span class="hljs-type">int</span> n1;<br>	<span class="hljs-type">int</span> n2;<br>&#125;;<br><span class="hljs-comment">//加法类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">addcac</span>:<span class="hljs-keyword">public</span> basecac<br>&#123;<br><span class="hljs-keyword">public</span>:<br>     <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getresult</span><span class="hljs-params">()</span></span><br><span class="hljs-function">     </span>&#123;<br>          <span class="hljs-keyword">return</span> n1+n2;<br>     &#125;<br>&#125;;<br><span class="hljs-comment">//减法类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">jfcac</span>:<span class="hljs-keyword">public</span> basecac<br>&#123;<br><span class="hljs-keyword">public</span>:<br>     <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getresult</span><span class="hljs-params">()</span></span><br><span class="hljs-function">     </span>&#123;<br>          <span class="hljs-keyword">return</span> n1-n2;<br>     &#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>     basecac *a=<span class="hljs-keyword">new</span> addcac;<span class="hljs-comment">//用父类指针指向子类对象，发生多态</span><br>     basecac *b=<span class="hljs-keyword">new</span> jfcac;<br>     a-&gt;n1=<span class="hljs-number">10</span>;<br>     a-&gt;n2=<span class="hljs-number">10</span>;<br>     b-&gt;n1=<span class="hljs-number">20</span>;<br>     b-&gt;n2=<span class="hljs-number">10</span>;<br>     cout&lt;&lt;a-&gt;<span class="hljs-built_in">getresult</span>()&lt;&lt;endl;<br>     cout&lt;&lt;b-&gt;<span class="hljs-built_in">getresult</span>()&lt;&lt;endl;<br>     <span class="hljs-comment">//用完后堆区记得销毁</span><br>     <span class="hljs-keyword">delete</span> a;<br>     <span class="hljs-keyword">delete</span> b;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>可见优点：</p>
<ul>
<li>组织结构清晰</li>
<li>可读性强</li>
<li>便于前期和后期的扩展的修改</li>
</ul>
<blockquote>
<p>总结：C++开发中提倡利用多态设计程序架构，其优点很多</p>
</blockquote>
<h2 id="纯虚函数和抽象类"><a href="#纯虚函数和抽象类" class="headerlink" title="纯虚函数和抽象类"></a>纯虚函数和抽象类</h2><p>在多态中，通常父类中的虚函数的实现是毫无意义的，主要都是在调用子类重写的内容</p>
<p>因此可以将虚函数改成纯虚函数</p>
<p>语法：<code>virtual 返回值类型 函数名 (参数列表)=0</code></p>
<p>当类中有一个纯虚函数，这个类也就称为<strong>抽象类</strong></p>
<p>抽象类特点：</p>
<ul>
<li><strong>无法实例化对象</strong></li>
<li><strong>子类必须要重写抽象类的纯虚函数，否则这个子类也属于抽象类</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">base</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span>=<span class="hljs-number">0</span>;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">son</span>:<span class="hljs-keyword">public</span> base<br>&#123;<br><span class="hljs-keyword">public</span>:<br>	<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span>&#123;&#125;<span class="hljs-comment">//子类必须要重写父类中的纯虚函数</span><br>&#125;;<br></code></pre></td></tr></table></figure>

<h2 id="虚析构和纯虚析构"><a href="#虚析构和纯虚析构" class="headerlink" title="虚析构和纯虚析构"></a>虚析构和纯虚析构</h2><p>多态使用时，如果子类中有属性开辟到堆区，那么父类指针在释放时无法调用到子类的析构代码</p>
<p>解决：将父类中析构函数改为<strong>虚析构或纯虚析构</strong></p>
<p>虚析构和纯虚析构共性</p>
<ul>
<li>可以解决父类指针释放子类对象</li>
<li>都需要有具体的函数实现</li>
</ul>
<p>区别：</p>
<ul>
<li>如果是纯虚析构函数，该类属于抽象类，无法实例化对象</li>
</ul>
<p>虚析构：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">animal</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>	<span class="hljs-built_in">animal</span>()<br>	&#123;<br>		cout&lt;&lt;<span class="hljs-string">&quot;动物活了&quot;</span>&lt;&lt;endl;<br>	&#125;<br>	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">speak</span><span class="hljs-params">()</span></span><br><span class="hljs-function">	</span>&#123;<br>	&#125;<br>	<span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">animal</span>()<span class="hljs-comment">//改成虚析构后在销毁父类指针后才会执行子类析构</span><br>	&#123;<br>		cout&lt;&lt;<span class="hljs-string">&quot;动物死了&quot;</span>&lt;&lt;endl;<br>	&#125;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">cat</span>:<span class="hljs-keyword">public</span> animal<br>&#123;<br><span class="hljs-keyword">public</span>:<br>	string *name=<span class="hljs-literal">NULL</span>;<br>	<span class="hljs-built_in">cat</span>(string n)<br>	&#123;<br>		cout&lt;&lt;<span class="hljs-string">&quot;猫活了&quot;</span>&lt;&lt;endl;<br>		name=<span class="hljs-keyword">new</span> <span class="hljs-built_in">string</span>(n);<br>	&#125;<br>	<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">speak</span><span class="hljs-params">()</span></span><br><span class="hljs-function">	</span>&#123;<br>		cout&lt;&lt;<span class="hljs-string">&quot;1&quot;</span>&lt;&lt;endl;<br>	&#125;<br>	~<span class="hljs-built_in">cat</span>()<br>	&#123;<br>		<span class="hljs-keyword">if</span> (name!=<span class="hljs-literal">NULL</span>)<br>		&#123;<br>			cout&lt;&lt;<span class="hljs-string">&quot;猫死了&quot;</span>&lt;&lt;endl;<br>			<span class="hljs-keyword">delete</span> name;<br>			name=<span class="hljs-literal">NULL</span>;<br>		&#125;<br>	&#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	animal* a=<span class="hljs-keyword">new</span> <span class="hljs-built_in">cat</span>(<span class="hljs-string">&quot;aa&quot;</span>);<br>	a-&gt;speak;<br>	<span class="hljs-comment">//父类指针在析构的时候不会调用子类的析构函数</span><br>	<span class="hljs-keyword">delete</span> a;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>纯虚析构：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">animal</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>	<span class="hljs-built_in">animal</span>()<br>	&#123;<br>		cout&lt;&lt;<span class="hljs-string">&quot;动物活了&quot;</span>&lt;&lt;endl;<br>	&#125;<br>	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">speak</span><span class="hljs-params">()</span></span><br><span class="hljs-function">	</span>&#123;<br>	&#125;<br><span class="hljs-comment">//	virtual ~animal()//改成虚析构后在销毁父类指针后才会执行子类析构</span><br><span class="hljs-comment">//	&#123;</span><br><span class="hljs-comment">//		cout&lt;&lt;&quot;动物死了&quot;&lt;&lt;endl;</span><br><span class="hljs-comment">//	&#125;</span><br>     <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">animal</span>()=<span class="hljs-number">0</span>;<span class="hljs-comment">//注意纯虚析构必须要有函数实现</span><br>&#125;;<br>animal::~<span class="hljs-built_in">animal</span>()<span class="hljs-comment">//这个是必须的</span><br>&#123;<br>     cout&lt;&lt;<span class="hljs-string">&quot;纯虚析构&quot;</span>&lt;&lt;endl;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">cat</span>:<span class="hljs-keyword">public</span> animal<br>&#123;<br><span class="hljs-keyword">public</span>:<br>	string *name=<span class="hljs-literal">NULL</span>;<br>	<span class="hljs-built_in">cat</span>(string n)<br>	&#123;<br>		cout&lt;&lt;<span class="hljs-string">&quot;猫活了&quot;</span>&lt;&lt;endl;<br>		name=<span class="hljs-keyword">new</span> <span class="hljs-built_in">string</span>(n);<br>	&#125;<br>	<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">speak</span><span class="hljs-params">()</span></span><br><span class="hljs-function">	</span>&#123;<br>		cout&lt;&lt;<span class="hljs-string">&quot;1&quot;</span>&lt;&lt;endl;<br>	&#125;<br>	~<span class="hljs-built_in">cat</span>()<br>	&#123;<br>		<span class="hljs-keyword">if</span> (name!=<span class="hljs-literal">NULL</span>)<br>		&#123;<br>			cout&lt;&lt;<span class="hljs-string">&quot;猫死了&quot;</span>&lt;&lt;endl;<br>			<span class="hljs-keyword">delete</span> name;<br>			name=<span class="hljs-literal">NULL</span>;<br>		&#125;<br>	&#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	animal* a=<span class="hljs-keyword">new</span> <span class="hljs-built_in">cat</span>(<span class="hljs-string">&quot;aa&quot;</span>);<br>	a-&gt;speak;<br>	<span class="hljs-comment">//父类指针在析构的时候不会调用子类的析构函数</span><br>	<span class="hljs-keyword">delete</span> a;<br>&#125;<br></code></pre></td></tr></table></figure>

<h1 id="PTA错题回顾"><a href="#PTA错题回顾" class="headerlink" title="PTA错题回顾"></a>PTA错题回顾</h1><h2 id="判断"><a href="#判断" class="headerlink" title="判断"></a>判断</h2><h3 id="0x001"><a href="#0x001" class="headerlink" title="0x001"></a>0x001</h3><p>对于已正确定义的二维数组a,  *(a[i]+j)与a[i][j]的含义相同。  </p>
<p>T    F</p>
<ul>
<li>答案为T</li>
</ul>
<h3 id="0x002"><a href="#0x002" class="headerlink" title="0x002"></a>0x002</h3><p>不允许把一个数值或字符赋予指针变量。  </p>
<p>T     F</p>
<ul>
<li>答案为T</li>
</ul>
<h3 id="0x003"><a href="#0x003" class="headerlink" title="0x003"></a>0x003</h3><p>若重载为友元函数，函数定义格式如下：</p>
<p>&lt;类型&gt;operator&lt;运算符&gt;（&lt;参数列表&gt;）</p>
<p>{</p>
<p>&lt;函数体&gt;</p>
<p>}  </p>
<p>T    F</p>
<ul>
<li>答案为F</li>
</ul>
<h3 id="0x004"><a href="#0x004" class="headerlink" title="0x004"></a>0x004</h3><p>对每个可重载的运算符来讲，它既可以重载为友元函数，又可以重载为成员函数，还可以重载为非成员函数。  </p>
<p>T     F</p>
<ul>
<li>答案为F，有些运算符必须要用全局函数来重载，比如说左移（&lt;&lt;）</li>
</ul>
<h3 id="0x005"><a href="#0x005" class="headerlink" title="0x005"></a>0x005</h3><p>重定义虚函数的派生类必须是公有继承的。  </p>
<p>T     F</p>
<ul>
<li>T</li>
</ul>
<h3 id="0x006"><a href="#0x006" class="headerlink" title="0x006"></a>0x006</h3><p>如果一个类的函数全部都是纯虚函数，则这个类不能有自己类的实现（包括引用和指针），只能通过派生类继承实现。</p>
<p>T     F</p>
<ul>
<li>F</li>
</ul>
<h3 id="0x007"><a href="#0x007" class="headerlink" title="0x007"></a>0x007</h3><p>虚函数既可以在函数说明时定义，也可以在函数实现时定义。</p>
<p>T    F</p>
<ul>
<li>F</li>
</ul>
<h3 id="0x008"><a href="#0x008" class="headerlink" title="0x008"></a>0x008</h3><p>含有纯虚函数的类是不可以用来创建对象的，因为它是虚基类。 </p>
<p>T    F</p>
<ul>
<li>F，是抽象类</li>
</ul>
<h2 id="选择"><a href="#选择" class="headerlink" title="选择"></a>选择</h2><h3 id="0x001-1"><a href="#0x001-1" class="headerlink" title="0x001"></a>0x001</h3><p>执行以下的程序片段，将输出几个数字？</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">3</span>;i++);<br><br>       <span class="hljs-built_in">cout</span>&lt;&lt;i;<br></code></pre></td></tr></table></figure>

<p>A.0B.3C.2D.1</p>
<ul>
<li>答案为D<ul>
<li>for循环后有分号，cout不在循环体内</li>
</ul>
</li>
</ul>
<h3 id="0x002-1"><a href="#0x002-1" class="headerlink" title="0x002"></a>0x002</h3><p>以下数组定义中错误的是（ ）。</p>
<p>A.<br><code>int x[2][3]=&#123;&#123;1,2&#125;,&#123;3,4&#125;,&#123;5,6)&#125;;</code></p>
<p>B.<br><code>int x[][3]=&#123;&#123;1,2,3&#125;,(4,5,6)&#125;;</code></p>
<p>C.<br><code>int x[][3]=&#123;0&#125;;</code></p>
<p>D.<br><code>int x[2][3]=&#123;1,2,3,4,5,6&#125;;</code></p>
<ul>
<li>答案为A，定义的数组是两行三列的，而给出的数据是三行两列的</li>
</ul>
<h3 id="0x003-1"><a href="#0x003-1" class="headerlink" title="0x003"></a>0x003</h3><p>设变量定义为 <code>int a[2]=&#123;1,3&#125;, *p=&amp;a[0]+1;</code>，则<code>*p</code>的值是(       )。</p>
<p>A.&amp;a[0]+1B.2C.4D.3</p>
<ul>
<li>答案为D，*p代表地址上的值</li>
</ul>
<h3 id="0x004-1"><a href="#0x004-1" class="headerlink" title="0x004"></a>0x004</h3><p>对类的构造函数和析构函数描述正确的是( )。</p>
<p>A.构造函数不能重载，析构函数也不能重裁</p>
<p>B.构造函数不能重载，析构函数可以重载</p>
<p>C.构造函数可以重载，析构函数不能重载</p>
<p>D.构造函数可以重载，析构函数也可以重载</p>
<ul>
<li>答案为C</li>
</ul>
<h3 id="0x005-1"><a href="#0x005-1" class="headerlink" title="0x005"></a>0x005</h3><p>下列程序的运行结果是（）。</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs elixir">int i;<br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">3</span>;i++)<br>   switch(i)<br>   &#123;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">1</span><span class="hljs-symbol">:cout&lt;&lt;i</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">2</span><span class="hljs-symbol">:cout&lt;&lt;i</span>;<br>        <span class="hljs-symbol">default:</span>cout&lt;&lt;i;<br>   &#125;<br></code></pre></td></tr></table></figure>

<p>A.012</p>
<p>B.011122</p>
<p>C.012020</p>
<p>D.120</p>
<ul>
<li>答案为B，因为case里面没有break</li>
</ul>
<h3 id="0x006-1"><a href="#0x006-1" class="headerlink" title="0x006"></a>0x006</h3><p>一个函数为<code>void f(int x, char y = &#39;a&#39;)</code>，另一个函数为<code>void f(int)</code>，则它们_</p>
<p>A.不能在同一程序块中定义</p>
<p>B.可以在同一个程序块中定义，但不可以重载</p>
<p>C.以上说法均不正确</p>
<p>D.可以在同一个程序块中定义并可重载</p>
<ul>
<li>答案为D</li>
</ul>
<h3 id="0x007-1"><a href="#0x007-1" class="headerlink" title="0x007"></a>0x007</h3><p>关于类模板，描述错误的是。</p>
<p>A.一个普通基类不能派生类模板</p>
<p>B.类模板可以从普通类派生，也可以从类模板派生</p>
<p>C.根据建立对象时的实际数据类型，编译器把类模板实例化为模板类</p>
<p>D.函数的类模板参数需生成模板类并通过构造函数实例化</p>
<ul>
<li>答案A</li>
</ul>
<h3 id="0x008-1"><a href="#0x008-1" class="headerlink" title="0x008"></a>0x008</h3><p>类模板的参数错误的说法是：</p>
<p>A.可以有多个</p>
<p>B.可以有0个</p>
<p>C.参数不能给初值</p>
<p>D.不能有基本数据类型</p>
<ul>
<li>答案</li>
</ul>
<h3 id="0x009"><a href="#0x009" class="headerlink" title="0x009"></a>0x009</h3><p>若需要为xv类重载乘法运算符,运算结果为xv类型,在将其声明为类的成员函数时,下列原型声明正确的是_________。</p>
<p>A.<code>xv operator*(xv);</code></p>
<p>B.<code>operator*(xv);</code></p>
<p>C.<code>xv*(xv);*</code></p>
<p>D.<code>xv operator*(xv,xv);</code></p>
<ul>
<li>答案为A</li>
</ul>
<h3 id="0x00A"><a href="#0x00A" class="headerlink" title="0x00A"></a>0x00A</h3><p>继承机制的作用是</p>
<p>A.数据封装B.数据抽象C.信息隐藏D.定义新类</p>
<ul>
<li>答案为D</li>
</ul>
<h3 id="0x00B"><a href="#0x00B" class="headerlink" title="0x00B"></a>0x00B</h3><p>一个类的私有成员</p>
<p>A.只能被该类的成员函数和友元函数访问</p>
<p>B.以上答案都不对</p>
<p>C.只能被该类的成员函数访问</p>
<p>D.只能被该类的成员函数、友元函数和派生类访问</p>
<ul>
<li>答案为A</li>
</ul>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h2 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h2><h3 id="0x1"><a href="#0x1" class="headerlink" title="0x1"></a>0x1</h3><p><strong>R7-1 定义类模板实现2个数的算术运算</strong></p>
<p>分数 20</p>
<p>全屏浏览切换布局</p>
<p>作者 孙杰</p>
<p>单位 青岛大学</p>
<p>本题目要求定义类模板实现2个数的最大值、最小值、加、减、乘、除等算术运算，在main（）函数中使用该类模板分别实例化为int型和double型的类，定义相关的对象，读入2个整数和2个浮点数，然后分别输出它们的最大值、最小值、加、减、乘、除的结果。</p>
<p><strong>输入格式:</strong></p>
<p>分别输入2组数字，第一行为2个整数，以空格分隔；第二行为2个浮点数，以空格分隔。</p>
<p><strong>输出格式:</strong></p>
<p>分2行分别输出整数和浮点数的运算结果，每行依次输出2个数的最大值、最小值、加、减、乘、除等算术运算。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br>using namespace <span class="hljs-built_in">std</span>;<br>template &lt;typename T&gt;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Arithmetic</span> </span><br><span class="hljs-class">&#123;</span><br>private:<br>    T num1;<br>    T num2;<br>public:<br>    Arithmetic(T a, T b)<br>    &#123;<br>        num1=a;<br>        num2=b;<br>    &#125;<br>    T <span class="hljs-title function_">getMax</span><span class="hljs-params">()</span> <br>    &#123;<br>        <span class="hljs-keyword">if</span> (num1&gt;num2)<br>            <span class="hljs-keyword">return</span> num1;<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-keyword">return</span> num2;<br>    &#125;<br>    T <span class="hljs-title function_">getMin</span><span class="hljs-params">()</span> <br>    &#123;<br>        <span class="hljs-keyword">if</span> (num1&lt;num2)<br>            <span class="hljs-keyword">return</span> num1;<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-keyword">return</span> num2;<br>    &#125;<br>    T <span class="hljs-title function_">add</span><span class="hljs-params">()</span> <br>    &#123;<br>        <span class="hljs-keyword">return</span> num1 + num2;<br>    &#125;<br>    T <span class="hljs-title function_">subtract</span><span class="hljs-params">()</span> <br>    &#123;<br>        <span class="hljs-keyword">return</span> num1 - num2;<br>    &#125;<br>    T <span class="hljs-title function_">multiply</span><span class="hljs-params">()</span> <br>    &#123;<br>        <span class="hljs-keyword">return</span> num1 * num2;<br>    &#125;<br>    T <span class="hljs-title function_">divide</span><span class="hljs-params">()</span> <br>    &#123;<br>        <span class="hljs-keyword">return</span> num1 / num2;<br>    &#125;<br>    <span class="hljs-type">void</span> <span class="hljs-title function_">pprint</span><span class="hljs-params">()</span> <br>    &#123;<br>        <span class="hljs-built_in">cout</span> &lt;&lt; getMax() &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; getMin() &lt;&lt; <span class="hljs-string">&quot; &quot;</span> <br>             &lt;&lt; add() &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; subtract() &lt;&lt; <span class="hljs-string">&quot; &quot;</span> <br>             &lt;&lt; multiply() &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; divide();<br>    &#125;<br>&#125;;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> int1, int2;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; int1 &gt;&gt; int2;<br>    Arithmetic&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title function_">intArith</span><span class="hljs-params">(int1, int2)</span>;<br>    <span class="hljs-type">double</span> double1, double2;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; double1 &gt;&gt; double2;<br>    Arithmetic&lt;<span class="hljs-type">double</span>&gt; <span class="hljs-title function_">doubleArith</span><span class="hljs-params">(double1, double2)</span>;<br>    intArith.pprint();<br>    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    doubleArith.pprint();<br>    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><h3 id="模板的语法及使用"><a href="#模板的语法及使用" class="headerlink" title="模板的语法及使用"></a>模板的语法及使用</h3><h4 id="函数模板"><a href="#函数模板" class="headerlink" title="函数模板"></a>函数模板</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std; <br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function">T <span class="hljs-title">maxx</span><span class="hljs-params">(T a,T b)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (a&gt;b)<br>        <span class="hljs-keyword">return</span> a;<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> b;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-type">int</span> a1=<span class="hljs-built_in">maxx</span>(<span class="hljs-number">3</span>,<span class="hljs-number">5</span>);<br>	<span class="hljs-type">double</span> a2=<span class="hljs-built_in">maxx</span>(<span class="hljs-number">2.5</span>,<span class="hljs-number">3.1</span>);<br>    cout&lt;&lt;a1&lt;&lt;endl;<br>    cout&lt;&lt;a2&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="类模板"><a href="#类模板" class="headerlink" title="类模板"></a>类模板</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std; <br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Box</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    T content;<br>    <span class="hljs-built_in">Box</span>(T c) : <span class="hljs-built_in">content</span>(c) &#123;&#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">speak</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>    	cout&lt;&lt;content&lt;&lt;endl;<br>	&#125;<br>&#125;;<br><br><span class="hljs-comment">// 使用</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-function">Box&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">intBox</span><span class="hljs-params">(<span class="hljs-number">42</span>)</span></span>;<br>	<span class="hljs-function">Box&lt;std::string&gt; <span class="hljs-title">strBox</span><span class="hljs-params">(<span class="hljs-string">&quot;Hello&quot;</span>)</span></span>;<span class="hljs-comment">//需要显示说明类型</span><br>	intBox.<span class="hljs-built_in">speak</span>();<br>	strBox.<span class="hljs-built_in">speak</span>();<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="单向链表的创建及删除"><a href="#单向链表的创建及删除" class="headerlink" title="单向链表的创建及删除"></a>单向链表的创建及删除</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">struct</span> ListNode *<span class="hljs-title function_">readlist</span><span class="hljs-params">()</span><span class="hljs-comment">//按输入顺序创建链表</span><br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span>* <span class="hljs-title">head</span>=</span><span class="hljs-literal">NULL</span>;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span>* <span class="hljs-title">tail</span>=</span><span class="hljs-literal">NULL</span>;<br>    <span class="hljs-type">int</span> a;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>    &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;a);<br>        <span class="hljs-keyword">if</span> (a==<span class="hljs-number">-1</span>)<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span>* <span class="hljs-title">new</span>=</span>(<span class="hljs-keyword">struct</span> LiseNode*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> ListNode));<br>        new-&gt;data=a;<br>        new-&gt;next=<span class="hljs-literal">NULL</span>;<br>        <span class="hljs-keyword">if</span> (head==<span class="hljs-literal">NULL</span>)<br>            head=new;<br>        <span class="hljs-keyword">else</span><br>            tail-&gt;next=new;<br>        tail=new;<br>    &#125;<br>    <span class="hljs-keyword">return</span> head;<br>&#125;<br><span class="hljs-keyword">struct</span> ListNode *<span class="hljs-title function_">deletem</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> ListNode *L, <span class="hljs-type">int</span> m)</span> <span class="hljs-comment">//删除链表中值=m的节点</span><br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span> <span class="hljs-title">dummy</span>;</span> <span class="hljs-comment">// 创建一个哑节点</span><br>    dummy.next = L;       <span class="hljs-comment">// 哑节点的 next 指向链表头</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span> *<span class="hljs-title">prev</span> =</span> &amp;dummy; <span class="hljs-comment">// prev 指向哑节点</span><br><br>    <span class="hljs-keyword">while</span> (prev-&gt;next != <span class="hljs-literal">NULL</span>) <br>    &#123;<br>        <span class="hljs-keyword">if</span> (prev-&gt;next-&gt;data == m) <br>        &#123;<br>            <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span> *<span class="hljs-title">temp</span> =</span> prev-&gt;next;<br>            prev-&gt;next = temp-&gt;next;<br>            <span class="hljs-built_in">free</span>(temp);<br>        &#125; <br>        <span class="hljs-keyword">else</span> <br>            prev = prev-&gt;next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dummy.next;<br>&#125;<br></code></pre></td></tr></table></figure>


                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/%E8%AF%BE%E5%86%85/" class="category-chain-item">课内</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>c++语法学习</div>
      <div>http://yyyffff.github.io/2025/03/19/c++语法学习/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>yyf</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2025年3月19日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-cc-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2025/03/19/%E5%A0%86%E7%9A%84%E6%94%BB%E5%87%BB/" title="堆的攻击">
                        <span class="hidden-mobile">堆的攻击</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
  
  
    <article id="comments" lazyload>
      
  <div id="valine"></div>
  <script type="text/javascript">
    Fluid.utils.loadComments('#valine', function() {
      Fluid.utils.createScript('https://lib.baomitu.com/valine/1.5.1/Valine.min.js', function() {
        var options = Object.assign(
          {"appId":"2bkS2AvQTqNk4TIsyxh4ew9q-gzGzoHsz","appKey":"GfRH0zMaM1USTNT6w25DTqu8","path":"window.location.pathname","placeholder":"说点什么","avatar":"retro","meta":["nick","mail","link"],"requiredFields":[],"pageSize":10,"lang":"zh-CN","highlight":false,"recordIP":false,"serverURLs":"","emojiCDN":null,"emojiMaps":null,"enableQQ":false},
          {
            el: "#valine",
            path: window.location.pathname
          }
        )
        new Valine(options);
        Fluid.utils.waitElementVisible('#valine .vcontent', () => {
          var imgSelector = '#valine .vcontent img:not(.vemoji)';
          Fluid.plugins.imageCaption(imgSelector);
          Fluid.plugins.fancyBox(imgSelector);
        })
      });
    });
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


    </article>
  


          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
    <div class="statistics">
  
  

  
    
      <span id="leancloud-site-pv-container" style="display: none">
        总访问量 
        <span id="leancloud-site-pv"></span>
         次
      </span>
    
    
      <span id="leancloud-site-uv-container" style="display: none">
        总访客数 
        <span id="leancloud-site-uv"></span>
         人
      </span>
    
    

  

</div>

  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/5.0.0/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script defer src="/js/leancloud.js" ></script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
